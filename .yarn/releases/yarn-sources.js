#!/usr/bin/env node
/* eslint-disable */
module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(270);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(313);




(0,_main__WEBPACK_IMPORTED_MODULE_1__.main)({
  binaryVersion: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.YarnVersion || `<unknown>`,
  pluginConfiguration: (0,_tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_2__.getPluginConfiguration)()
});

/***/ }),
/* 1 */
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony import */ var fromentries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var fromentries__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fromentries__WEBPACK_IMPORTED_MODULE_0__);
// @ts-ignore: missing declaration
 // Remove when dropping Node 10 (~April 2021)

if (!Object.fromEntries) Object.fromEntries = (fromentries__WEBPACK_IMPORTED_MODULE_0___default());

/***/ }),
/* 2 */
/***/ ((module) => {

module.exports = function fromEntries (iterable) {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val
    return obj
  }, {})
}


/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "main": () => /* binding */ main
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(272);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(206);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _pluginCommands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _tools_WelcomeCommand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);








function runBinary(path) {
  const physicalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(path);
  process.on(`SIGINT`, () => {// We don't want SIGINT to kill our process; we want it to kill the
    // innermost process, whose end will cause our own to exit.
  });

  if (physicalPath) {
    (0,child_process__WEBPACK_IMPORTED_MODULE_0__.execFileSync)(process.execPath, [physicalPath, ...process.argv.slice(2)], {
      stdio: `inherit`,
      env: { ...process.env,
        YARN_IGNORE_PATH: `1`,
        YARN_IGNORE_CWD: `1`
      }
    });
  } else {
    (0,child_process__WEBPACK_IMPORTED_MODULE_0__.execFileSync)(physicalPath, process.argv.slice(2), {
      stdio: `inherit`,
      env: { ...process.env,
        YARN_IGNORE_PATH: `1`,
        YARN_IGNORE_CWD: `1`
      }
    });
  }
}

async function main({
  binaryVersion,
  pluginConfiguration
}) {
  async function run() {
    const cli = new clipanion__WEBPACK_IMPORTED_MODULE_1__.Cli({
      binaryLabel: `Yarn Package Manager`,
      binaryName: `yarn`,
      binaryVersion
    });
    cli.register(_tools_WelcomeCommand__WEBPACK_IMPORTED_MODULE_4__.WelcomeCommand);

    try {
      await exec(cli);
    } catch (error) {
      process.stdout.write(cli.error(error));
      process.exitCode = 1;
    }
  }

  async function exec(cli) {
    // Non-exhaustive known requirements:
    // - 10.16+ for Brotli support on `plugin-compat`
    // - 10.17+ to silence `got` warning on `dns.promises`
    var _a, _b, _c, _d, _e;

    const version = process.versions.node;
    const range = `>=10.17`;
    if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.semverUtils.satisfiesWithPrereleases(version, range) && process.env.YARN_IGNORE_NODE !== `1`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`This tool requires a Node version compatible with ${range} (got ${version}). Upgrade Node, or set \`YARN_IGNORE_NODE=1\` in your environment.`); // Since we only care about a few very specific settings (yarn-path and ignore-path) we tolerate extra configuration key.
    // If we didn't, we wouldn't even be able to run `yarn config` (which is recommended in the invalid config error message)

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.find(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(process.cwd()), pluginConfiguration, {
      usePath: true,
      strict: false
    });
    const yarnPath = configuration.get(`yarnPath`);
    const ignorePath = configuration.get(`ignorePath`);
    const ignoreCwd = configuration.get(`ignoreCwd`);

    if (yarnPath !== null && !ignorePath) {
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.existsSync(yarnPath)) {
        process.stdout.write(cli.error(new Error(`The "yarn-path" option has been set (in ${configuration.sources.get(`yarnPath`)}), but the specified location doesn't exist (${yarnPath}).`)));
        process.exitCode = 1;
      } else {
        try {
          runBinary(yarnPath);
        } catch (error) {
          process.exitCode = error.code || 1;
        }
      }
    } else {
      if (ignorePath) delete process.env.YARN_IGNORE_PATH;
      const isTelemetryEnabled = configuration.get(`enableTelemetry`);
      if (isTelemetryEnabled) _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.telemetry = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.TelemetryManager(configuration, `puba9cdc10ec5790a2cf4969dd413a47270`);
      (_a = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportVersion(binaryVersion);

      for (const [name, plugin] of configuration.plugins.entries()) {
        if (_pluginCommands__WEBPACK_IMPORTED_MODULE_3__.pluginCommands.has((_c = (_b = name.match(/^@yarnpkg\/plugin-(.*)$/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : ``)) (_d = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.telemetry) === null || _d === void 0 ? void 0 : _d.reportPluginName(name);

        for (const command of plugin.commands || []) {
          cli.register(command);
        }
      }

      const command = cli.process(process.argv.slice(2));
      if (!command.help) (_e = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.telemetry) === null || _e === void 0 ? void 0 : _e.reportCommandName(command.path.join(` `)); // @ts-ignore: The cwd is a global option defined by BaseCommand

      const cwd = command.cwd;

      if (typeof cwd !== `undefined` && !ignoreCwd) {
        const iAmHere = (0,fs__WEBPACK_IMPORTED_MODULE_2__.realpathSync)(process.cwd());
        const iShouldBeHere = (0,fs__WEBPACK_IMPORTED_MODULE_2__.realpathSync)(cwd);

        if (iAmHere !== iShouldBeHere) {
          process.chdir(cwd);
          await run();
          return;
        }
      }

      cli.runExit(command, {
        cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(process.cwd()),
        plugins: pluginConfiguration,
        quiet: false,
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr
      });
    }
  }

  return run().catch(error => {
    process.stdout.write(error.stack || error.message);
    process.exitCode = 1;
  });
}

/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cli": () => /* binding */ Cli,
/* harmony export */   "Command": () => /* binding */ Command,
/* harmony export */   "UsageError": () => /* binding */ UsageError
/* harmony export */ });
class Command {
    constructor() {
        /**
         * Predefined that will be set to true if `-h,--help` has been used, in which case `Command#execute` shouldn't be called.
         */
        this.help = false;
    }
    static getMeta(prototype) {
        const base = prototype.constructor;
        return base.meta = Object.prototype.hasOwnProperty.call(base, `meta`) ? base.meta : {
            definitions: [],
            transformers: [
                (state, command) => {
                    for (const { name, value } of state.options) {
                        if (name === `-h` || name === `--help`) {
                            // @ts-ignore: The property is meant to have been defined by the child class
                            command.help = value;
                        }
                    }
                },
            ],
        };
    }
    static resolveMeta(prototype) {
        const definitions = [];
        const transformers = [];
        for (let proto = prototype; proto instanceof Command; proto = proto.__proto__) {
            const meta = this.getMeta(proto);
            for (const definition of meta.definitions)
                definitions.push(definition);
            for (const transformer of meta.transformers) {
                transformers.push(transformer);
            }
        }
        return {
            definitions,
            transformers,
        };
    }
    static registerDefinition(prototype, definition) {
        this.getMeta(prototype).definitions.push(definition);
    }
    static registerTransformer(prototype, transformer) {
        this.getMeta(prototype).transformers.push(transformer);
    }
    static addPath(...path) {
        this.Path(...path)(this.prototype, `execute`);
    }
    static addOption(name, builder) {
        builder(this.prototype, name);
    }
    /**
     * Wrap the specified command to be attached to the given path on the command line.
     * The first path thus attached will be considered the "main" one, and all others will be aliases.
     * @param path The command path.
     */
    static Path(...path) {
        return (prototype, propertyName) => {
            this.registerDefinition(prototype, command => {
                command.addPath(path);
            });
        };
    }
    /**
     * Register a boolean listener for the given option names. When Clipanion detects that this argument is present, the value will be set to false. The value won't be set unless the option is found, so you must remember to set it to an appropriate default value.
     * @param descriptor the option names.
     */
    static Boolean(descriptor, { hidden = false } = {}) {
        return (prototype, propertyName) => {
            const optNames = descriptor.split(`,`);
            this.registerDefinition(prototype, command => {
                command.addOption({ names: optNames, arity: 0, hidden, allowBinding: false });
            });
            this.registerTransformer(prototype, (state, command) => {
                for (const { name, value } of state.options) {
                    if (optNames.includes(name)) {
                        // @ts-ignore: The property is meant to have been defined by the child class
                        command[propertyName] = value;
                    }
                }
            });
        };
    }
    static String(descriptor = { required: true }, { tolerateBoolean = false, hidden = false } = {}) {
        return (prototype, propertyName) => {
            if (typeof descriptor === `string`) {
                const optNames = descriptor.split(`,`);
                this.registerDefinition(prototype, command => {
                    // If tolerateBoolean is specified, the command will only accept a string value
                    // using the bind syntax and will otherwise act like a boolean option
                    command.addOption({ names: optNames, arity: tolerateBoolean ? 0 : 1, hidden });
                });
                this.registerTransformer(prototype, (state, command) => {
                    for (const { name, value } of state.options) {
                        if (optNames.includes(name)) {
                            // @ts-ignore: The property is meant to have been defined by the child class
                            command[propertyName] = value;
                        }
                    }
                });
            }
            else {
                this.registerDefinition(prototype, command => {
                    command.addPositional({ name: propertyName, required: descriptor.required });
                });
                this.registerTransformer(prototype, (state, command) => {
                    if (state.positionals.length > 0) {
                        // @ts-ignore: The property is meant to have been defined by the child class
                        command[propertyName] = state.positionals.shift().value;
                    }
                });
            }
        };
    }
    /**
     * Register a listener that looks for an option and its followup argument. When Clipanion detects that this argument is present, the value will be pushed into the array represented in the property.
     */
    static Array(descriptor, { hidden = false } = {}) {
        return (prototype, propertyName) => {
            const optNames = descriptor.split(`,`);
            this.registerDefinition(prototype, command => {
                command.addOption({ names: optNames, arity: 1, hidden });
            });
            this.registerTransformer(prototype, (state, command) => {
                for (const { name, value } of state.options) {
                    if (optNames.includes(name)) {
                        // @ts-ignore: The property is meant to have been defined by the child class
                        command[propertyName] = command[propertyName] || [];
                        // @ts-ignore: The property is meant to have been defined by the child class
                        command[propertyName].push(value);
                    }
                }
            });
        };
    }
    static Rest({ required = 0 } = {}) {
        return (prototype, propertyName) => {
            this.registerDefinition(prototype, command => {
                command.addRest({ name: propertyName, required });
            });
            this.registerTransformer(prototype, (state, command) => {
                // @ts-ignore: The property is meant to have been defined by the child class
                command[propertyName] = state.positionals.map(({ value }) => value);
            });
        };
    }
    /**
     * Register a listener that takes all the arguments remaining (including options and such) and store them into the selected property.
     * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).
     */
    static Proxy({ required = 0 } = {}) {
        return (prototype, propertyName) => {
            this.registerDefinition(prototype, command => {
                command.addProxy({ required });
            });
            this.registerTransformer(prototype, (state, command) => {
                // @ts-ignore: The property is meant to have been defined by the child class
                command[propertyName] = state.positionals.map(({ value }) => value);
            });
        };
    }
    /**
     * Defines the usage information for the given command.
     * @param usage
     */
    static Usage(usage) {
        return usage;
    }
    /**
     * Defines the schema for the given command.
     * @param schema
     */
    static Schema(schema) {
        return schema;
    }
    async validateAndExecute() {
        const commandClass = this.constructor;
        const schema = commandClass.schema;
        if (typeof schema !== `undefined`) {
            try {
                await schema.validate(this);
            }
            catch (error) {
                if (error.name === `ValidationError`)
                    error.clipanion = { type: `usage` };
                throw error;
            }
        }
        const exitCode = await this.execute();
        if (typeof exitCode !== `undefined`) {
            return exitCode;
        }
        else {
            return 0;
        }
    }
}
/**
 * A list of useful semi-opinionated command entries that have to be registered manually.
 *
 * They cover the basic needs of most CLIs (e.g. help command, version command).
 *
 * @example
 * cli.register(Command.Entries.Help);
 * cli.register(Command.Entries.Version);
 */
Command.Entries = {};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

class HelpCommand extends Command {
    async execute() {
        this.context.stdout.write(this.cli.usage(null));
    }
}
__decorate([
    Command.Path(`--help`),
    Command.Path(`-h`)
], HelpCommand.prototype, "execute", null);

class VersionCommand extends Command {
    async execute() {
        var _a;
        this.context.stdout.write(`${(_a = this.cli.binaryVersion) !== null && _a !== void 0 ? _a : `<unknown>`}\n`);
    }
}
__decorate([
    Command.Path(`--version`),
    Command.Path(`-v`)
], VersionCommand.prototype, "execute", null);

const NODE_INITIAL = 0;
const NODE_SUCCESS = 1;
const NODE_ERRORED = 2;
const START_OF_INPUT = `\u0001`;
const END_OF_INPUT = `\u0000`;
const HELP_COMMAND_INDEX = -1;
const HELP_REGEX = /^(-h|--help)(?:=([0-9]+))?$/;
const OPTION_REGEX = /^(--[a-z]+(?:-[a-z]+)*|-[a-zA-Z]+)$/;
const BATCH_REGEX = /^-[a-zA-Z]{2,}$/;
const BINDING_REGEX = /^([^=]+)=([\s\S]*)$/;
const DEBUG = process.env.DEBUG_CLI === `1`;

/**
 * A generic usage error with the name `UsageError`.
 *
 * It should be used over `Error` only when it's the user's fault.
 */
class UsageError extends Error {
    constructor(message) {
        super(message);
        this.clipanion = { type: `usage` };
        this.name = `UsageError`;
    }
}
class UnknownSyntaxError extends Error {
    constructor(input, candidates) {
        super();
        this.input = input;
        this.candidates = candidates;
        this.clipanion = { type: `none` };
        this.name = `UnknownSyntaxError`;
        if (this.candidates.length === 0) {
            this.message = `Command not found, but we're not sure what's the alternative.`;
        }
        else if (this.candidates.length === 1 && this.candidates[0].reason !== null) {
            const [{ usage, reason }] = this.candidates;
            this.message = `${reason}\n\n$ ${usage}`;
        }
        else if (this.candidates.length === 1) {
            const [{ usage }] = this.candidates;
            this.message = `Command not found; did you mean:\n\n$ ${usage}\n${whileRunning(input)}`;
        }
        else {
            this.message = `Command not found; did you mean one of:\n\n${this.candidates.map(({ usage }, index) => {
                return `${`${index}.`.padStart(4)} ${usage}`;
            }).join(`\n`)}\n\n${whileRunning(input)}`;
        }
    }
}
class AmbiguousSyntaxError extends Error {
    constructor(input, usages) {
        super();
        this.input = input;
        this.usages = usages;
        this.clipanion = { type: `none` };
        this.name = `AmbiguousSyntaxError`;
        this.message = `Cannot find who to pick amongst the following alternatives:\n\n${this.usages.map((usage, index) => {
            return `${`${index}.`.padStart(4)} ${usage}`;
        }).join(`\n`)}\n\n${whileRunning(input)}`;
    }
}
const whileRunning = (input) => `While running ${input.filter(token => {
    return token !== END_OF_INPUT;
}).map(token => {
    const json = JSON.stringify(token);
    if (token.match(/\s/) || token.length === 0 || json !== `"${token}"`) {
        return json;
    }
    else {
        return token;
    }
}).join(` `)}`;

// ------------------------------------------------------------------------
function debug(str) {
    if (DEBUG) {
        console.log(str);
    }
}
function makeStateMachine() {
    return {
        nodes: [makeNode(), makeNode(), makeNode()],
    };
}
function makeAnyOfMachine(inputs) {
    const output = makeStateMachine();
    const heads = [];
    let offset = output.nodes.length;
    for (const input of inputs) {
        heads.push(offset);
        for (let t = 0; t < input.nodes.length; ++t)
            if (!isTerminalNode(t))
                output.nodes.push(cloneNode(input.nodes[t], offset));
        offset += input.nodes.length - 2;
    }
    for (const head of heads)
        registerShortcut(output, NODE_INITIAL, head);
    return output;
}
function injectNode(machine, node) {
    machine.nodes.push(node);
    return machine.nodes.length - 1;
}
function simplifyMachine(input) {
    const visited = new Set();
    const process = (node) => {
        if (visited.has(node))
            return;
        visited.add(node);
        const nodeDef = input.nodes[node];
        for (const transitions of Object.values(nodeDef.statics))
            for (const { to } of transitions)
                process(to);
        for (const [, { to }] of nodeDef.dynamics)
            process(to);
        for (const { to } of nodeDef.shortcuts)
            process(to);
        const shortcuts = new Set(nodeDef.shortcuts.map(({ to }) => to));
        while (nodeDef.shortcuts.length > 0) {
            const { to } = nodeDef.shortcuts.shift();
            const toDef = input.nodes[to];
            for (const [segment, transitions] of Object.entries(toDef.statics)) {
                let store = !Object.prototype.hasOwnProperty.call(nodeDef.statics, segment)
                    ? nodeDef.statics[segment] = []
                    : nodeDef.statics[segment];
                for (const transition of transitions) {
                    if (!store.some(({ to }) => transition.to === to)) {
                        store.push(transition);
                    }
                }
            }
            for (const [test, transition] of toDef.dynamics)
                if (!nodeDef.dynamics.some(([otherTest, { to }]) => test === otherTest && transition.to === to))
                    nodeDef.dynamics.push([test, transition]);
            for (const transition of toDef.shortcuts) {
                if (!shortcuts.has(transition.to)) {
                    nodeDef.shortcuts.push(transition);
                    shortcuts.add(transition.to);
                }
            }
        }
    };
    process(NODE_INITIAL);
}
function debugMachine(machine, { prefix = `` } = {}) {
    debug(`${prefix}Nodes are:`);
    for (let t = 0; t < machine.nodes.length; ++t) {
        debug(`${prefix}  ${t}: ${JSON.stringify(machine.nodes[t])}`);
    }
}
function runMachineInternal(machine, input, partial = false) {
    debug(`Running a vm on ${JSON.stringify(input)}`);
    let branches = [{ node: NODE_INITIAL, state: {
                candidateUsage: null,
                errorMessage: null,
                ignoreOptions: false,
                options: [],
                path: [],
                positionals: [],
                remainder: null,
                selectedIndex: null,
            } }];
    debugMachine(machine, { prefix: `  ` });
    const tokens = [START_OF_INPUT, ...input];
    for (let t = 0; t < tokens.length; ++t) {
        const segment = tokens[t];
        debug(`  Processing ${JSON.stringify(segment)}`);
        const nextBranches = [];
        for (const { node, state } of branches) {
            debug(`    Current node is ${node}`);
            const nodeDef = machine.nodes[node];
            if (node === NODE_ERRORED) {
                nextBranches.push({ node, state });
                continue;
            }
            console.assert(nodeDef.shortcuts.length === 0, `Shortcuts should have been eliminated by now`);
            const hasExactMatch = Object.prototype.hasOwnProperty.call(nodeDef.statics, segment);
            if (!partial || t < tokens.length - 1 || hasExactMatch) {
                if (hasExactMatch) {
                    const transitions = nodeDef.statics[segment];
                    for (const { to, reducer } of transitions) {
                        nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });
                        debug(`      Static transition to ${to} found`);
                    }
                }
                else {
                    debug(`      No static transition found`);
                }
            }
            else {
                let hasMatches = false;
                for (const candidate of Object.keys(nodeDef.statics)) {
                    if (!candidate.startsWith(segment))
                        continue;
                    if (segment === candidate) {
                        for (const { to, reducer } of nodeDef.statics[candidate]) {
                            nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });
                            debug(`      Static transition to ${to} found`);
                        }
                    }
                    else {
                        for (const { to, reducer } of nodeDef.statics[candidate]) {
                            nextBranches.push({ node: to, state: Object.assign(Object.assign({}, state), { remainder: candidate.slice(segment.length) }) });
                            debug(`      Static transition to ${to} found (partial match)`);
                        }
                    }
                    hasMatches = true;
                }
                if (!hasMatches) {
                    debug(`      No partial static transition found`);
                }
            }
            if (segment !== END_OF_INPUT) {
                for (const [test, { to, reducer }] of nodeDef.dynamics) {
                    if (execute(tests, test, state, segment)) {
                        nextBranches.push({ node: to, state: typeof reducer !== `undefined` ? execute(reducers, reducer, state, segment) : state });
                        debug(`      Dynamic transition to ${to} found (via ${test})`);
                    }
                }
            }
        }
        if (nextBranches.length === 0) {
            throw new UnknownSyntaxError(input, branches.filter(({ node }) => {
                return node !== NODE_ERRORED;
            }).map(({ state }) => {
                return { usage: state.candidateUsage, reason: null };
            }));
        }
        if (nextBranches.every(({ node }) => node === NODE_ERRORED)) {
            throw new UnknownSyntaxError(input, nextBranches.map(({ state }) => {
                return { usage: state.candidateUsage, reason: state.errorMessage };
            }));
        }
        branches = trimSmallerBranches(nextBranches);
    }
    if (branches.length > 0) {
        debug(`  Results:`);
        for (const branch of branches) {
            debug(`    - ${branch.node} -> ${JSON.stringify(branch.state)}`);
        }
    }
    else {
        debug(`  No results`);
    }
    return branches;
}
function checkIfNodeIsFinished(node, state) {
    if (state.selectedIndex !== null)
        return true;
    if (Object.prototype.hasOwnProperty.call(node.statics, END_OF_INPUT))
        for (const { to } of node.statics[END_OF_INPUT])
            if (to === NODE_SUCCESS)
                return true;
    return false;
}
function suggestMachine(machine, input, partial) {
    // If we're accepting partial matches, then exact matches need to be
    // prefixed with an extra space.
    const prefix = partial && input.length > 0 ? [``] : [];
    const branches = runMachineInternal(machine, input, partial);
    const suggestions = [];
    const suggestionsJson = new Set();
    const traverseSuggestion = (suggestion, node, skipFirst = true) => {
        let nextNodes = [node];
        while (nextNodes.length > 0) {
            const currentNodes = nextNodes;
            nextNodes = [];
            for (const node of currentNodes) {
                const nodeDef = machine.nodes[node];
                const keys = Object.keys(nodeDef.statics);
                for (const key of Object.keys(nodeDef.statics)) {
                    const segment = keys[0];
                    for (const { to, reducer } of nodeDef.statics[segment]) {
                        if (reducer !== `pushPath`)
                            continue;
                        if (!skipFirst)
                            suggestion.push(segment);
                        nextNodes.push(to);
                    }
                }
            }
            skipFirst = false;
        }
        const json = JSON.stringify(suggestion);
        if (suggestionsJson.has(json))
            return;
        suggestions.push(suggestion);
        suggestionsJson.add(json);
    };
    for (const { node, state } of branches) {
        if (state.remainder !== null) {
            traverseSuggestion([state.remainder], node);
            continue;
        }
        const nodeDef = machine.nodes[node];
        const isFinished = checkIfNodeIsFinished(nodeDef, state);
        for (const [candidate, transitions] of Object.entries(nodeDef.statics))
            if ((isFinished && candidate !== END_OF_INPUT) || (!candidate.startsWith(`-`) && transitions.some(({ reducer }) => reducer === `pushPath`)))
                traverseSuggestion([...prefix, candidate], node);
        if (!isFinished)
            continue;
        for (const [test, { to }] of nodeDef.dynamics) {
            if (to === NODE_ERRORED)
                continue;
            const tokens = suggest(test, state);
            if (tokens === null)
                continue;
            for (const token of tokens) {
                traverseSuggestion([...prefix, token], node);
            }
        }
    }
    return [...suggestions].sort();
}
function runMachine(machine, input) {
    const branches = runMachineInternal(machine, [...input, END_OF_INPUT]);
    return selectBestState(input, branches.map(({ state }) => {
        return state;
    }));
}
function trimSmallerBranches(branches) {
    let maxPathSize = 0;
    for (const { state } of branches)
        if (state.path.length > maxPathSize)
            maxPathSize = state.path.length;
    return branches.filter(({ state }) => {
        return state.path.length === maxPathSize;
    });
}
function selectBestState(input, states) {
    const terminalStates = states.filter(state => {
        return state.selectedIndex !== null;
    });
    if (terminalStates.length === 0)
        throw new Error();
    let maxPathSize = 0;
    for (const state of terminalStates)
        if (state.path.length > maxPathSize)
            maxPathSize = state.path.length;
    const bestPathBranches = terminalStates.filter(state => {
        return state.path.length === maxPathSize;
    });
    const getPositionalCount = (state) => state.positionals.filter(({ extra }) => {
        return !extra;
    }).length + state.options.length;
    const statesWithPositionalCount = bestPathBranches.map(state => {
        return { state, positionalCount: getPositionalCount(state) };
    });
    let maxPositionalCount = 0;
    for (const { positionalCount } of statesWithPositionalCount)
        if (positionalCount > maxPositionalCount)
            maxPositionalCount = positionalCount;
    const bestPositionalStates = statesWithPositionalCount.filter(({ positionalCount }) => {
        return positionalCount === maxPositionalCount;
    }).map(({ state }) => {
        return state;
    });
    const fixedStates = aggregateHelpStates(bestPositionalStates);
    if (fixedStates.length > 1)
        throw new AmbiguousSyntaxError(input, fixedStates.map(state => state.candidateUsage));
    return fixedStates[0];
}
function aggregateHelpStates(states) {
    const notHelps = [];
    const helps = [];
    for (const state of states) {
        if (state.selectedIndex === HELP_COMMAND_INDEX) {
            helps.push(state);
        }
        else {
            notHelps.push(state);
        }
    }
    if (helps.length > 0) {
        notHelps.push({
            candidateUsage: null,
            errorMessage: null,
            ignoreOptions: false,
            path: findCommonPrefix(...helps.map(state => state.path)),
            positionals: [],
            options: helps.reduce((options, state) => options.concat(state.options), []),
            remainder: null,
            selectedIndex: HELP_COMMAND_INDEX,
        });
    }
    return notHelps;
}
function findCommonPrefix(firstPath, secondPath, ...rest) {
    if (secondPath === undefined)
        return Array.from(firstPath);
    return findCommonPrefix(firstPath.filter((segment, i) => segment === secondPath[i]), ...rest);
}
function makeNode() {
    return {
        dynamics: [],
        shortcuts: [],
        statics: {},
    };
}
function isTerminalNode(node) {
    return node === NODE_SUCCESS || node === NODE_ERRORED;
}
function cloneTransition(input, offset = 0) {
    return {
        to: !isTerminalNode(input.to) ? input.to > 2 ? input.to + offset - 2 : input.to + offset : input.to,
        reducer: input.reducer,
    };
}
function cloneNode(input, offset = 0) {
    const output = makeNode();
    for (const [test, transition] of input.dynamics)
        output.dynamics.push([test, cloneTransition(transition, offset)]);
    for (const transition of input.shortcuts)
        output.shortcuts.push(cloneTransition(transition, offset));
    for (const [segment, transitions] of Object.entries(input.statics))
        output.statics[segment] = transitions.map(transition => cloneTransition(transition, offset));
    return output;
}
function registerDynamic(machine, from, test, to, reducer) {
    machine.nodes[from].dynamics.push([test, { to, reducer }]);
}
function registerShortcut(machine, from, to, reducer) {
    machine.nodes[from].shortcuts.push({ to, reducer });
}
function registerStatic(machine, from, test, to, reducer) {
    let store = !Object.prototype.hasOwnProperty.call(machine.nodes[from].statics, test)
        ? machine.nodes[from].statics[test] = []
        : machine.nodes[from].statics[test];
    store.push({ to, reducer });
}
function execute(store, callback, state, segment) {
    if (Array.isArray(callback)) {
        const [name, ...args] = callback;
        return store[name](state, segment, ...args);
    }
    else {
        return store[callback](state, segment);
    }
}
function suggest(callback, state) {
    const fn = Array.isArray(callback)
        ? tests[callback[0]]
        : tests[callback];
    // @ts-ignore
    if (typeof fn.suggest === `undefined`)
        return null;
    const args = Array.isArray(callback)
        ? callback.slice(1)
        : [];
    // @ts-ignore
    return fn.suggest(state, ...args);
}
const tests = {
    always: () => {
        return true;
    },
    isNotOptionLike: (state, segment) => {
        return state.ignoreOptions || !segment.startsWith(`-`);
    },
    isOption: (state, segment, name, hidden) => {
        return !state.ignoreOptions && segment === name;
    },
    isBatchOption: (state, segment, names) => {
        return !state.ignoreOptions && BATCH_REGEX.test(segment) && [...segment.slice(1)].every(name => names.includes(`-${name}`));
    },
    isBoundOption: (state, segment, names, options) => {
        const optionParsing = segment.match(BINDING_REGEX);
        return !state.ignoreOptions && !!optionParsing && OPTION_REGEX.test(optionParsing[1]) && names.includes(optionParsing[1])
            // Disallow bound options with no arguments (i.e. booleans)
            && options.filter(opt => opt.names.includes(optionParsing[1])).every(opt => opt.allowBinding);
    },
    isNegatedOption: (state, segment, name) => {
        return !state.ignoreOptions && segment === `--no-${name.slice(2)}`;
    },
    isHelp: (state, segment) => {
        return !state.ignoreOptions && HELP_REGEX.test(segment);
    },
    isUnsupportedOption: (state, segment, names) => {
        return !state.ignoreOptions && segment.startsWith(`-`) && OPTION_REGEX.test(segment) && !names.includes(segment);
    },
    isInvalidOption: (state, segment) => {
        return !state.ignoreOptions && segment.startsWith(`-`) && !OPTION_REGEX.test(segment);
    },
};
// @ts-ignore
tests.isOption.suggest = (state, name, hidden = true) => {
    return !hidden ? [name] : null;
};
const reducers = {
    setCandidateUsage: (state, segment, usage) => {
        return Object.assign(Object.assign({}, state), { candidateUsage: usage });
    },
    setSelectedIndex: (state, segment, index) => {
        return Object.assign(Object.assign({}, state), { selectedIndex: index });
    },
    pushBatch: (state, segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.concat([...segment.slice(1)].map(name => ({ name: `-${name}`, value: true }))) });
    },
    pushBound: (state, segment) => {
        const [, name, value] = segment.match(BINDING_REGEX);
        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name, value }) });
    },
    pushPath: (state, segment) => {
        return Object.assign(Object.assign({}, state), { path: state.path.concat(segment) });
    },
    pushPositional: (state, segment) => {
        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: false }) });
    },
    pushExtra: (state, segment) => {
        return Object.assign(Object.assign({}, state), { positionals: state.positionals.concat({ value: segment, extra: true }) });
    },
    pushTrue: (state, segment, name = segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name: segment, value: true }) });
    },
    pushFalse: (state, segment, name = segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name, value: false }) });
    },
    pushUndefined: (state, segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.concat({ name: segment, value: undefined }) });
    },
    setStringValue: (state, segment) => {
        return Object.assign(Object.assign({}, state), { options: state.options.slice(0, -1).concat(Object.assign(Object.assign({}, state.options[state.options.length - 1]), { value: segment })) });
    },
    inhibateOptions: (state) => {
        return Object.assign(Object.assign({}, state), { ignoreOptions: true });
    },
    useHelp: (state, segment, command) => {
        const [, name, index] = segment.match(HELP_REGEX);
        if (typeof index !== `undefined`) {
            return Object.assign(Object.assign({}, state), { options: [{ name: `-c`, value: String(command) }, { name: `-i`, value: index }] });
        }
        else {
            return Object.assign(Object.assign({}, state), { options: [{ name: `-c`, value: String(command) }] });
        }
    },
    setError: (state, segment, errorMessage) => {
        if (segment === END_OF_INPUT) {
            return Object.assign(Object.assign({}, state), { errorMessage: `${errorMessage}.` });
        }
        else {
            return Object.assign(Object.assign({}, state), { errorMessage: `${errorMessage} ("${segment}").` });
        }
    },
};
// ------------------------------------------------------------------------
const NoLimits = Symbol();
class CommandBuilder {
    constructor(cliIndex, cliOpts) {
        this.allOptionNames = [];
        this.arity = { leading: [], trailing: [], extra: [], proxy: false };
        this.options = [];
        this.paths = [];
        this.cliIndex = cliIndex;
        this.cliOpts = cliOpts;
    }
    addPath(path) {
        this.paths.push(path);
    }
    setArity({ leading = this.arity.leading, trailing = this.arity.trailing, extra = this.arity.extra, proxy = this.arity.proxy }) {
        Object.assign(this.arity, { leading, trailing, extra, proxy });
    }
    addPositional({ name = 'arg', required = true } = {}) {
        if (!required && this.arity.extra === NoLimits)
            throw new Error(`Optional parameters cannot be declared when using .rest() or .proxy()`);
        if (!required && this.arity.trailing.length > 0)
            throw new Error(`Optional parameters cannot be declared after the required trailing positional arguments`);
        if (!required && this.arity.extra !== NoLimits) {
            this.arity.extra.push(name);
        }
        else if (this.arity.extra !== NoLimits && this.arity.extra.length === 0) {
            this.arity.leading.push(name);
        }
        else {
            this.arity.trailing.push(name);
        }
    }
    addRest({ name = 'arg', required = 0 } = {}) {
        if (this.arity.extra === NoLimits)
            throw new Error(`Infinite lists cannot be declared multiple times in the same command`);
        if (this.arity.trailing.length > 0)
            throw new Error(`Infinite lists cannot be declared after the required trailing positional arguments`);
        for (let t = 0; t < required; ++t)
            this.addPositional({ name });
        this.arity.extra = NoLimits;
    }
    addProxy({ required = 0 } = {}) {
        this.addRest({ required });
        this.arity.proxy = true;
    }
    addOption({ names, arity = 0, hidden = false, allowBinding = true }) {
        this.allOptionNames.push(...names);
        this.options.push({ names, arity, hidden, allowBinding });
    }
    setContext(context) {
        this.context = context;
    }
    usage({ detailed = true } = {}) {
        const segments = [this.cliOpts.binaryName];
        if (this.paths.length > 0)
            segments.push(...this.paths[0]);
        if (detailed) {
            for (const { names, arity, hidden } of this.options) {
                if (hidden)
                    continue;
                const args = [];
                for (let t = 0; t < arity; ++t)
                    args.push(` #${t}`);
                segments.push(`[${names.join(`,`)}${args.join(``)}]`);
            }
            segments.push(...this.arity.leading.map(name => `<${name}>`));
            if (this.arity.extra === NoLimits)
                segments.push(`...`);
            else
                segments.push(...this.arity.extra.map(name => `[${name}]`));
            segments.push(...this.arity.trailing.map(name => `<${name}>`));
        }
        return segments.join(` `);
    }
    compile() {
        if (typeof this.context === `undefined`)
            throw new Error(`Assertion failed: No context attached`);
        const machine = makeStateMachine();
        let firstNode = NODE_INITIAL;
        firstNode = injectNode(machine, makeNode());
        registerStatic(machine, NODE_INITIAL, START_OF_INPUT, firstNode, [`setCandidateUsage`, this.usage()]);
        const positionalArgument = this.arity.proxy
            ? `always`
            : `isNotOptionLike`;
        const paths = this.paths.length > 0
            ? this.paths
            : [[]];
        for (const path of paths) {
            let lastPathNode = firstNode;
            // We allow options to be specified before the path. Note that we
            // only do this when there is a path, otherwise there would be
            // some redundancy with the options attached later.
            if (path.length > 0) {
                const optionPathNode = injectNode(machine, makeNode());
                registerShortcut(machine, lastPathNode, optionPathNode);
                this.registerOptions(machine, optionPathNode);
                lastPathNode = optionPathNode;
            }
            for (let t = 0; t < path.length; ++t) {
                const nextPathNode = injectNode(machine, makeNode());
                registerStatic(machine, lastPathNode, path[t], nextPathNode, `pushPath`);
                lastPathNode = nextPathNode;
            }
            if (this.arity.leading.length > 0 || !this.arity.proxy) {
                const helpNode = injectNode(machine, makeNode());
                registerDynamic(machine, lastPathNode, `isHelp`, helpNode, [`useHelp`, this.cliIndex]);
                registerStatic(machine, helpNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, HELP_COMMAND_INDEX]);
                this.registerOptions(machine, lastPathNode);
            }
            if (this.arity.leading.length > 0)
                registerStatic(machine, lastPathNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
            let lastLeadingNode = lastPathNode;
            for (let t = 0; t < this.arity.leading.length; ++t) {
                const nextLeadingNode = injectNode(machine, makeNode());
                if (!this.arity.proxy)
                    this.registerOptions(machine, nextLeadingNode);
                if (this.arity.trailing.length > 0 || t + 1 !== this.arity.leading.length)
                    registerStatic(machine, nextLeadingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
                registerDynamic(machine, lastLeadingNode, `isNotOptionLike`, nextLeadingNode, `pushPositional`);
                lastLeadingNode = nextLeadingNode;
            }
            let lastExtraNode = lastLeadingNode;
            if (this.arity.extra === NoLimits || this.arity.extra.length > 0) {
                const extraShortcutNode = injectNode(machine, makeNode());
                registerShortcut(machine, lastLeadingNode, extraShortcutNode);
                if (this.arity.extra === NoLimits) {
                    const extraNode = injectNode(machine, makeNode());
                    if (!this.arity.proxy)
                        this.registerOptions(machine, extraNode);
                    registerDynamic(machine, lastLeadingNode, positionalArgument, extraNode, `pushExtra`);
                    registerDynamic(machine, extraNode, positionalArgument, extraNode, `pushExtra`);
                    registerShortcut(machine, extraNode, extraShortcutNode);
                }
                else {
                    for (let t = 0; t < this.arity.extra.length; ++t) {
                        const nextExtraNode = injectNode(machine, makeNode());
                        if (!this.arity.proxy)
                            this.registerOptions(machine, nextExtraNode);
                        registerDynamic(machine, lastExtraNode, positionalArgument, nextExtraNode, `pushExtra`);
                        registerShortcut(machine, nextExtraNode, extraShortcutNode);
                        lastExtraNode = nextExtraNode;
                    }
                }
                lastExtraNode = extraShortcutNode;
            }
            if (this.arity.trailing.length > 0)
                registerStatic(machine, lastExtraNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
            let lastTrailingNode = lastExtraNode;
            for (let t = 0; t < this.arity.trailing.length; ++t) {
                const nextTrailingNode = injectNode(machine, makeNode());
                if (!this.arity.proxy)
                    this.registerOptions(machine, nextTrailingNode);
                if (t + 1 < this.arity.trailing.length)
                    registerStatic(machine, nextTrailingNode, END_OF_INPUT, NODE_ERRORED, [`setError`, `Not enough positional arguments`]);
                registerDynamic(machine, lastTrailingNode, `isNotOptionLike`, nextTrailingNode, `pushPositional`);
                lastTrailingNode = nextTrailingNode;
            }
            registerDynamic(machine, lastTrailingNode, positionalArgument, NODE_ERRORED, [`setError`, `Extraneous positional argument`]);
            registerStatic(machine, lastTrailingNode, END_OF_INPUT, NODE_SUCCESS, [`setSelectedIndex`, this.cliIndex]);
        }
        return {
            machine,
            context: this.context,
        };
    }
    registerOptions(machine, node) {
        registerDynamic(machine, node, [`isOption`, `--`], node, `inhibateOptions`);
        registerDynamic(machine, node, [`isBatchOption`, this.allOptionNames], node, `pushBatch`);
        registerDynamic(machine, node, [`isBoundOption`, this.allOptionNames, this.options], node, `pushBound`);
        registerDynamic(machine, node, [`isUnsupportedOption`, this.allOptionNames], NODE_ERRORED, [`setError`, `Unsupported option name`]);
        registerDynamic(machine, node, [`isInvalidOption`], NODE_ERRORED, [`setError`, `Invalid option name`]);
        for (const option of this.options) {
            const longestName = option.names.reduce((longestName, name) => {
                return name.length > longestName.length ? name : longestName;
            }, ``);
            if (option.arity === 0) {
                for (const name of option.names) {
                    registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], node, `pushTrue`);
                    if (name.startsWith(`--`)) {
                        registerDynamic(machine, node, [`isNegatedOption`, name, option.hidden || name !== longestName], node, [`pushFalse`, name]);
                    }
                }
            }
            else if (option.arity === 1) {
                const argNode = injectNode(machine, makeNode());
                registerDynamic(machine, argNode, `isNotOptionLike`, node, `setStringValue`);
                for (const name of option.names) {
                    registerDynamic(machine, node, [`isOption`, name, option.hidden || name !== longestName], argNode, `pushUndefined`);
                }
            }
            else {
                throw new Error(`Unsupported option arity (${option.arity})`);
            }
        }
    }
}
class CliBuilder {
    constructor({ binaryName = `...` } = {}) {
        this.builders = [];
        this.opts = { binaryName };
    }
    static build(cbs, opts = {}) {
        return new CliBuilder(opts).commands(cbs).compile();
    }
    getBuilderByIndex(n) {
        if (!(n >= 0 && n < this.builders.length))
            throw new Error(`Assertion failed: Out-of-bound command index (${n})`);
        return this.builders[n];
    }
    commands(cbs) {
        for (const cb of cbs)
            cb(this.command());
        return this;
    }
    command() {
        const builder = new CommandBuilder(this.builders.length, this.opts);
        this.builders.push(builder);
        return builder;
    }
    compile() {
        const machines = [];
        const contexts = [];
        for (const builder of this.builders) {
            const { machine, context } = builder.compile();
            machines.push(machine);
            contexts.push(context);
        }
        const machine = makeAnyOfMachine(machines);
        simplifyMachine(machine);
        return {
            machine,
            contexts,
            process: (input) => {
                return runMachine(machine, input);
            },
            suggest: (input, partial) => {
                return suggestMachine(machine, input, partial);
            },
        };
    }
}

const richFormat = {
    bold: str => `\x1b[1m${str}\x1b[22m`,
    error: str => `\x1b[31m\x1b[1m${str}\x1b[22m\x1b[39m`,
    code: str => `\x1b[36m${str}\x1b[39m`,
};
const textFormat = {
    bold: str => str,
    error: str => str,
    code: str => str,
};
function formatMarkdownish(text, { format, paragraphs }) {
    // Enforce \n as newline character
    text = text.replace(/\r\n?/g, `\n`);
    // Remove the indentation, since it got messed up with the JS indentation
    text = text.replace(/^[\t ]+|[\t ]+$/gm, ``);
    // Remove surrounding newlines, since they got added for JS formatting
    text = text.replace(/^\n+|\n+$/g, ``);
    // List items always end with at least two newlines (in order to not be collapsed)
    text = text.replace(/^-([^\n]*?)\n+/gm, `-$1\n\n`);
    // Single newlines are removed; larger than that are collapsed into one
    text = text.replace(/\n(\n)?\n*/g, `$1`);
    if (paragraphs) {
        text = text.split(/\n/).map(function (paragraph) {
            // Does the paragraph starts with a list?
            let bulletMatch = paragraph.match(/^[*-][\t ]+(.*)/);
            if (!bulletMatch)
                // No, cut the paragraphs into segments of 80 characters
                return paragraph.match(/(.{1,80})(?: |$)/g).join('\n');
            // Yes, cut the paragraphs into segments of 78 characters (to account for the prefix)
            return bulletMatch[1].match(/(.{1,78})(?: |$)/g).map((line, index) => {
                return (index === 0 ? `- ` : `  `) + line;
            }).join(`\n`);
        }).join(`\n\n`);
    }
    // Highlight the code segments
    text = text.replace(/(`+)((?:.|[\n])*?)\1/g, function ($0, $1, $2) {
        return format.code($1 + $2 + $1);
    });
    return text ? text + `\n` : ``;
}

class HelpCommand$1 extends Command {
    constructor(realCli, contexts) {
        super();
        this.realCli = realCli;
        this.contexts = contexts;
        this.commands = [];
    }
    static from(state, realCli, contexts) {
        const command = new HelpCommand$1(realCli, contexts);
        command.path = state.path;
        for (const opt of state.options) {
            switch (opt.name) {
                case `-c`:
                    {
                        command.commands.push(Number(opt.value));
                    }
                    break;
                case `-i`:
                    {
                        command.index = Number(opt.value);
                    }
                    break;
            }
        }
        return command;
    }
    async execute() {
        let commands = this.commands;
        if (typeof this.index !== `undefined` && this.index >= 0 && this.index < commands.length)
            commands = [commands[this.index]];
        if (commands.length === 1) {
            this.context.stdout.write(this.realCli.usage(this.contexts[commands[0]].commandClass, { detailed: true }));
        }
        else if (commands.length > 1) {
            this.context.stdout.write(`Multiple commands match your selection:\n`);
            this.context.stdout.write(`\n`);
            let index = 0;
            for (const command of this.commands)
                this.context.stdout.write(this.realCli.usage(this.contexts[command].commandClass, { prefix: `${index++}. `.padStart(5) }));
            this.context.stdout.write(`\n`);
            this.context.stdout.write(`Run again with -h=<index> to see the longer details of any of those commands.\n`);
        }
    }
}

function getDefaultColorSettings() {
    if (process.env.FORCE_COLOR === `0`)
        return false;
    if (process.env.FORCE_COLOR === `1`)
        return true;
    if (typeof process.stdout !== `undefined` && process.stdout.isTTY)
        return true;
    return false;
}
/**
 * @template Context The context shared by all commands. Contexts are a set of values, defined when calling the `run`/`runExit` functions from the CLI instance, that will be made available to the commands via `this.context`.
 */
class Cli {
    constructor({ binaryLabel, binaryName: binaryNameOpt = `...`, binaryVersion, enableColors = getDefaultColorSettings() } = {}) {
        this.registrations = new Map();
        this.builder = new CliBuilder({ binaryName: binaryNameOpt });
        this.binaryLabel = binaryLabel;
        this.binaryName = binaryNameOpt;
        this.binaryVersion = binaryVersion;
        this.enableColors = enableColors;
    }
    /**
     * Creates a new Cli and registers all commands passed as parameters.
     *
     * @param commandClasses The Commands to register
     * @returns The created `Cli` instance
     */
    static from(commandClasses, options = {}) {
        const cli = new Cli(options);
        for (const commandClass of commandClasses)
            cli.register(commandClass);
        return cli;
    }
    /**
     * Registers a command inside the CLI.
     */
    register(commandClass) {
        const commandBuilder = this.builder.command();
        this.registrations.set(commandClass, commandBuilder.cliIndex);
        const { definitions } = commandClass.resolveMeta(commandClass.prototype);
        for (const definition of definitions)
            definition(commandBuilder);
        commandBuilder.setContext({
            commandClass,
        });
    }
    process(input) {
        const { contexts, process } = this.builder.compile();
        const state = process(input);
        switch (state.selectedIndex) {
            case HELP_COMMAND_INDEX:
                {
                    return HelpCommand$1.from(state, this, contexts);
                }
            default:
                {
                    const { commandClass } = contexts[state.selectedIndex];
                    const command = new commandClass();
                    command.path = state.path;
                    const { transformers } = commandClass.resolveMeta(commandClass.prototype);
                    for (const transformer of transformers)
                        transformer(state, command);
                    return command;
                }
        }
    }
    async run(input, context) {
        let command;
        if (!Array.isArray(input)) {
            command = input;
        }
        else {
            try {
                command = this.process(input);
            }
            catch (error) {
                context.stdout.write(this.error(error));
                return 1;
            }
        }
        if (command.help) {
            context.stdout.write(this.usage(command, { detailed: true }));
            return 0;
        }
        command.context = context;
        command.cli = {
            binaryLabel: this.binaryLabel,
            binaryName: this.binaryName,
            binaryVersion: this.binaryVersion,
            enableColors: this.enableColors,
            definitions: () => this.definitions(),
            error: (error, opts) => this.error(error, opts),
            process: input => this.process(input),
            run: (input, subContext) => this.run(input, Object.assign(Object.assign({}, context), subContext)),
            usage: (command, opts) => this.usage(command, opts),
        };
        let exitCode;
        try {
            exitCode = await command.validateAndExecute();
        }
        catch (error) {
            context.stdout.write(this.error(error, { command }));
            return 1;
        }
        return exitCode;
    }
    /**
     * Runs a command and exits the current `process` with the exit code returned by the command.
     *
     * @param input An array containing the name of the command and its arguments.
     *
     * @example
     * cli.runExit(process.argv.slice(2), Cli.defaultContext)
     */
    async runExit(input, context) {
        process.exitCode = await this.run(input, context);
    }
    suggest(input, partial) {
        const { contexts, process, suggest } = this.builder.compile();
        return suggest(input, partial);
    }
    definitions({ colored = false } = {}) {
        const data = [];
        for (const [commandClass, number] of this.registrations) {
            if (typeof commandClass.usage === `undefined`)
                continue;
            const path = this.getUsageByIndex(number, { detailed: false });
            const usage = this.getUsageByIndex(number, { detailed: true });
            const category = typeof commandClass.usage.category !== `undefined`
                ? formatMarkdownish(commandClass.usage.category, { format: this.format(colored), paragraphs: false })
                : undefined;
            const description = typeof commandClass.usage.description !== `undefined`
                ? formatMarkdownish(commandClass.usage.description, { format: this.format(colored), paragraphs: false })
                : undefined;
            const details = typeof commandClass.usage.details !== `undefined`
                ? formatMarkdownish(commandClass.usage.details, { format: this.format(colored), paragraphs: true })
                : undefined;
            const examples = typeof commandClass.usage.examples !== `undefined`
                ? commandClass.usage.examples.map(([label, cli]) => [formatMarkdownish(label, { format: this.format(colored), paragraphs: false }), cli.replace(/\$0/g, this.binaryName)])
                : undefined;
            data.push({ path, usage, category, description, details, examples });
        }
        return data;
    }
    usage(command = null, { colored, detailed = false, prefix = `$ ` } = {}) {
        // @ts-ignore
        const commandClass = command !== null && typeof command.getMeta === `undefined`
            ? command.constructor
            : command;
        let result = ``;
        if (!commandClass) {
            const commandsByCategories = new Map();
            for (const [commandClass, number] of this.registrations.entries()) {
                if (typeof commandClass.usage === `undefined`)
                    continue;
                const category = typeof commandClass.usage.category !== `undefined`
                    ? formatMarkdownish(commandClass.usage.category, { format: this.format(colored), paragraphs: false })
                    : null;
                let categoryCommands = commandsByCategories.get(category);
                if (typeof categoryCommands === `undefined`)
                    commandsByCategories.set(category, categoryCommands = []);
                const usage = this.getUsageByIndex(number);
                categoryCommands.push({ commandClass, usage });
            }
            const categoryNames = Array.from(commandsByCategories.keys()).sort((a, b) => {
                if (a === null)
                    return -1;
                if (b === null)
                    return +1;
                return a.localeCompare(b, `en`, { usage: `sort`, caseFirst: `upper` });
            });
            const hasLabel = typeof this.binaryLabel !== `undefined`;
            const hasVersion = typeof this.binaryVersion !== `undefined`;
            if (hasLabel || hasVersion) {
                if (hasLabel && hasVersion)
                    result += `${this.format(colored).bold(`${this.binaryLabel} - ${this.binaryVersion}`)}\n\n`;
                else if (hasLabel)
                    result += `${this.format(colored).bold(`${this.binaryLabel}`)}\n`;
                else
                    result += `${this.format(colored).bold(`${this.binaryVersion}`)}\n`;
                result += `  ${this.format(colored).bold(prefix)}${this.binaryName} <command>\n`;
            }
            else {
                result += `${this.format(colored).bold(prefix)}${this.binaryName} <command>\n`;
            }
            for (let categoryName of categoryNames) {
                const commands = commandsByCategories.get(categoryName).slice().sort((a, b) => {
                    return a.usage.localeCompare(b.usage, `en`, { usage: `sort`, caseFirst: `upper` });
                });
                const header = categoryName !== null
                    ? categoryName.trim()
                    : `Where <command> is one of`;
                result += `\n`;
                result += `${this.format(colored).bold(`${header}:`)}\n`;
                for (let { commandClass, usage } of commands) {
                    const doc = commandClass.usage.description || `undocumented`;
                    result += `\n`;
                    result += `  ${this.format(colored).bold(usage)}\n`;
                    result += `    ${formatMarkdownish(doc, { format: this.format(colored), paragraphs: false })}`;
                }
            }
            result += `\n`;
            result += formatMarkdownish(`You can also print more details about any of these commands by calling them after adding the \`-h,--help\` flag right after the command name.`, { format: this.format(colored), paragraphs: true });
        }
        else {
            if (!detailed) {
                result += `${this.format(colored).bold(prefix)}${this.getUsageByRegistration(commandClass)}\n`;
            }
            else {
                const { description = ``, details = ``, examples = [], } = commandClass.usage || {};
                if (description !== ``) {
                    result += formatMarkdownish(description, { format: this.format(colored), paragraphs: false }).replace(/^./, $0 => $0.toUpperCase());
                    result += `\n`;
                }
                if (details !== `` || examples.length > 0) {
                    result += `${this.format(colored).bold(`Usage:`)}\n`;
                    result += `\n`;
                }
                result += `${this.format(colored).bold(prefix)}${this.getUsageByRegistration(commandClass)}\n`;
                if (details !== ``) {
                    result += `\n`;
                    result += `${this.format(colored).bold(`Details:`)}\n`;
                    result += `\n`;
                    result += formatMarkdownish(details, { format: this.format(colored), paragraphs: true });
                }
                if (examples.length > 0) {
                    result += `\n`;
                    result += `${this.format(colored).bold(`Examples:`)}\n`;
                    for (let [description, example] of examples) {
                        result += `\n`;
                        result += formatMarkdownish(description, { format: this.format(colored), paragraphs: false });
                        result += example
                            .replace(/^/m, `  ${this.format(colored).bold(prefix)}`)
                            .replace(/\$0/g, this.binaryName)
                            + `\n`;
                    }
                }
            }
        }
        return result;
    }
    error(error, { colored, command = null } = {}) {
        if (!(error instanceof Error))
            error = new Error(`Execution failed with a non-error rejection (rejected value: ${JSON.stringify(error)})`);
        let result = ``;
        let name = error.name.replace(/([a-z])([A-Z])/g, `$1 $2`);
        if (name === `Error`)
            name = `Internal Error`;
        result += `${this.format(colored).error(name)}: ${error.message}\n`;
        // @ts-ignore
        const meta = error.clipanion;
        if (typeof meta !== `undefined`) {
            if (meta.type === `usage`) {
                result += `\n`;
                result += this.usage(command);
            }
        }
        else {
            if (error.stack) {
                result += `${error.stack.replace(/^.*\n/, ``)}\n`;
            }
        }
        return result;
    }
    getUsageByRegistration(klass, opts) {
        const index = this.registrations.get(klass);
        if (typeof index === `undefined`)
            throw new Error(`Assertion failed: Unregistered command`);
        return this.getUsageByIndex(index, opts);
    }
    getUsageByIndex(n, opts) {
        return this.builder.getBuilderByIndex(n).usage(opts);
    }
    format(colored = this.enableColors) {
        return colored ? richFormat : textFormat;
    }
}
/**
 * The default context of the CLI.
 *
 * Contains the stdio of the current `process`.
 */
Cli.defaultContext = {
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr,
};

Command.Entries.Help = HelpCommand;
Command.Entries.Version = VersionCommand;




/***/ }),
/* 6 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pluginCommands": () => /* binding */ pluginCommands
/* harmony export */ });
// Don't modify this script directly! Instead, run:
// yarn build:plugin-commands
const pluginCommands = new Map([[`constraints`, [[`constraints`, `query`], [`constraints`, `source`], [`constraints`]]], [`exec`, []], [`interactive-tools`, [[`search`], [`upgrade-interactive`]]], [`stage`, [[`stage`]]], [`typescript`, []], [`version`, [[`version`, `apply`], [`version`, `check`], [`version`]]], [`workspace-tools`, [[`workspaces`, `focus`], [`workspaces`, `foreach`]]]]);

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WelcomeCommand": () => /* binding */ WelcomeCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _BaseCommand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);





const getMessage = configuration => `
${configuration.format(`Welcome on Yarn 2!`, `bold`)}  Thanks for helping us shape our vision of how projects
should be managed going forward.

Being still in RC, Yarn 2 isn't completely stable yet. Some features might be
missing, and some behaviors may have received major overhaul. In case of doubt,
use the following URLs to get some insight:

  - The changelog:
    ${configuration.format(`https://github.com/yarnpkg/berry/tree/CHANGELOG.md`, `cyan`)}

  - Our issue tracker:
    ${configuration.format(`https://github.com/yarnpkg/berry`, `cyan`)}

  - Our Discord server:
    ${configuration.format(`https://discord.gg/yarnpkg`, `cyan`)}

We're hoping you will enjoy the experience. For now, a good start is to run
the two following commands:

  ${configuration.format(`find . -name node_modules -prune -exec rm -r {} \\;`, `magenta`)}
  ${configuration.format(`yarn install`, `magenta`)}

One last trick! If you need at some point to upgrade Yarn to a nightly build,
the following command will install the CLI straight from master:

  ${configuration.format(`yarn set version from sources`, `magenta`)}

See you later 
`;

class WelcomeCommand extends _BaseCommand__WEBPACK_IMPORTED_MODULE_1__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    this.context.stdout.write(`${getMessage(configuration).trim()}\n`);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--welcome`)], WelcomeCommand.prototype, "execute", null);

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseCommand": () => /* binding */ BaseCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);


class BaseCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {}

(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.String(`--cwd`, {
  hidden: true
})], BaseCommand.prototype, "cwd", void 0);

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__decorate": () => /* binding */ __decorate
/* harmony export */ });
/* unused harmony exports __extends, __assign, __rest, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_RC_FILENAME": () => /* binding */ DEFAULT_RC_FILENAME,
/* harmony export */   "DEFAULT_LOCK_FILENAME": () => /* binding */ DEFAULT_LOCK_FILENAME,
/* harmony export */   "SettingsType": () => /* binding */ SettingsType,
/* harmony export */   "FormatType": () => /* binding */ FormatType,
/* harmony export */   "ProjectLookup": () => /* binding */ ProjectLookup,
/* harmony export */   "Configuration": () => /* binding */ Configuration
/* harmony export */ });
/* unused harmony exports ENVIRONMENT_PREFIX, SECRET, formatColors, coreDefinitions */
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(114);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50);
/* harmony import */ var camelcase__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(camelcase__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51);
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(chalk__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);
/* harmony import */ var ci_info__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ci_info__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(65);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(p_limit__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(110);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _CorePlugin__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(216);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(230);
/* harmony import */ var _MultiFetcher__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(225);
/* harmony import */ var _MultiResolver__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(220);
/* harmony import */ var _ProtocolResolver__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(224);
/* harmony import */ var _VirtualFetcher__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(228);
/* harmony import */ var _VirtualResolver__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(221);
/* harmony import */ var _WorkspaceFetcher__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(229);
/* harmony import */ var _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(222);
/* harmony import */ var _folderUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(111);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(121);
/* harmony import */ var _nodeUtils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(218);
/* harmony import */ var _semverUtils__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(231);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(140);
























const chalkOptions = process.env.GITHUB_ACTIONS ? {
  level: 2
} : (chalk__WEBPACK_IMPORTED_MODULE_2___default().supportsColor) ? {
  level: (chalk__WEBPACK_IMPORTED_MODULE_2___default().supportsColor.level)
} : {
  level: 0
};
const supportsColor = chalkOptions.level !== 0;
const supportsHyperlinks = supportsColor && !process.env.GITHUB_ACTIONS;
const chalkInstance = new (chalk__WEBPACK_IMPORTED_MODULE_2___default().Instance)(chalkOptions);
const IGNORED_ENV_VARIABLES = new Set([// "binFolder" is the magic location where the parent process stored the
// current binaries; not an actual configuration settings
`binFolder`, // "version" is set by Docker:
// https://github.com/nodejs/docker-node/blob/5a6a5e91999358c5b04fddd6c22a9a4eb0bf3fbf/10/alpine/Dockerfile#L51
`version`, // "flags" is set by Netlify; they use it to specify the flags to send to the
// CLI when running the automatic `yarn install`
`flags`, // "gpg" and "profile" are used by the install.sh script:
// https://classic.yarnpkg.com/install.sh
`profile`, `gpg`, // "ignoreNode" is used to disable the Node version check
`ignoreNode`, // "wrapOutput" was a variable used to indicate nested "yarn run" processes
// back in Yarn 1.
`wrapOutput`]);
const ENVIRONMENT_PREFIX = `yarn_`;
const DEFAULT_RC_FILENAME = `.yarnrc.yml`;
const DEFAULT_LOCK_FILENAME = `yarn.lock`;
const SECRET = `********`;
var SettingsType;

(function (SettingsType) {
  SettingsType["ANY"] = "ANY";
  SettingsType["BOOLEAN"] = "BOOLEAN";
  SettingsType["ABSOLUTE_PATH"] = "ABSOLUTE_PATH";
  SettingsType["LOCATOR"] = "LOCATOR";
  SettingsType["LOCATOR_LOOSE"] = "LOCATOR_LOOSE";
  SettingsType["NUMBER"] = "NUMBER";
  SettingsType["STRING"] = "STRING";
  SettingsType["SECRET"] = "SECRET";
  SettingsType["SHAPE"] = "SHAPE";
  SettingsType["MAP"] = "MAP";
})(SettingsType || (SettingsType = {}));

var FormatType;

(function (FormatType) {
  FormatType["NAME"] = "NAME";
  FormatType["NUMBER"] = "NUMBER";
  FormatType["PATH"] = "PATH";
  FormatType["RANGE"] = "RANGE";
  FormatType["REFERENCE"] = "REFERENCE";
  FormatType["SCOPE"] = "SCOPE";
  FormatType["ADDED"] = "ADDED";
  FormatType["REMOVED"] = "REMOVED";
  FormatType["CODE"] = "CODE";
})(FormatType || (FormatType = {}));

const formatColors = chalkOptions.level >= 3 ? new Map([[FormatType.NAME, `#d7875f`], [FormatType.RANGE, `#00afaf`], [FormatType.REFERENCE, `#87afff`], [FormatType.NUMBER, `#ffd700`], [FormatType.PATH, `#d75fd7`], [FormatType.SCOPE, `#d75f00`], [FormatType.ADDED, `#5faf00`], [FormatType.REMOVED, `#d70000`], [FormatType.CODE, `#87afff`]]) : new Map([[FormatType.NAME, 173], [FormatType.RANGE, 37], [FormatType.REFERENCE, 111], [FormatType.NUMBER, 220], [FormatType.PATH, 170], [FormatType.SCOPE, 166], [FormatType.ADDED, 70], [FormatType.REMOVED, 160], [FormatType.CODE, 111]]); // General rules:
//
// - filenames that don't accept actual paths must end with the "Filename" suffix
//   prefer to use absolute paths instead, since they are automatically resolved
//   ex: lockfileFilename
//
// - folders must end with the "Folder" suffix
//   ex: cacheFolder, pnpVirtualFolder
//
// - actual paths to a file must end with the "Path" suffix
//   ex: pnpPath
//
// - options that tweaks the strictness must begin with the "allow" prefix
//   ex: allowInvalidChecksums
//
// - options that enable a feature must begin with the "enable" prefix
//   ex: enableEmojis, enableColors

const coreDefinitions = {
  // Not implemented for now, but since it's part of all Yarn installs we want to declare it in order to improve drop-in compatibility
  lastUpdateCheck: {
    description: `Last timestamp we checked whether new Yarn versions were available`,
    type: SettingsType.STRING,
    default: null
  },
  // Settings related to proxying all Yarn calls to a specific executable
  yarnPath: {
    description: `Path to the local executable that must be used over the global one`,
    type: SettingsType.ABSOLUTE_PATH,
    default: null
  },
  ignorePath: {
    description: `If true, the local executable will be ignored when using the global one`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  ignoreCwd: {
    description: `If true, the \`--cwd\` flag will be ignored`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  // Settings related to the package manager internal names
  cacheKeyOverride: {
    description: `A global cache key override; used only for test purposes`,
    type: SettingsType.STRING,
    default: null
  },
  globalFolder: {
    description: `Folder where are stored the system-wide settings`,
    type: SettingsType.ABSOLUTE_PATH,
    default: _folderUtils__WEBPACK_IMPORTED_MODULE_8__.getDefaultGlobalFolder()
  },
  cacheFolder: {
    description: `Folder where the cache files must be written`,
    type: SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/cache`
  },
  compressionLevel: {
    description: `Zip files compression level, from 0 to 9 or mixed (a variant of 9, which stores some files uncompressed, when compression doesn't yield good results)`,
    type: SettingsType.NUMBER,
    values: [`mixed`, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    default: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.DEFAULT_COMPRESSION_LEVEL
  },
  virtualFolder: {
    description: `Folder where the virtual packages (cf doc) will be mapped on the disk (must be named $$virtual)`,
    type: SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/$$virtual`
  },
  bstatePath: {
    description: `Path of the file where the current state of the built packages must be stored`,
    type: SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/build-state.yml`
  },
  lockfileFilename: {
    description: `Name of the files where the Yarn dependency tree entries must be stored`,
    type: SettingsType.STRING,
    default: DEFAULT_LOCK_FILENAME
  },
  installStatePath: {
    description: `Path of the file where the install state will be persisted`,
    type: SettingsType.ABSOLUTE_PATH,
    default: `./.yarn/install-state.gz`
  },
  immutablePatterns: {
    description: `Array of glob patterns; files matching them won't be allowed to change during immutable installs`,
    type: SettingsType.STRING,
    default: [],
    isArray: true
  },
  rcFilename: {
    description: `Name of the files where the configuration can be found`,
    type: SettingsType.STRING,
    default: getRcFilename()
  },
  enableGlobalCache: {
    description: `If true, the system-wide cache folder will be used regardless of \`cache-folder\``,
    type: SettingsType.BOOLEAN,
    default: false
  },
  enableAbsoluteVirtuals: {
    description: `If true, the virtual symlinks will use absolute paths if required [non portable!!]`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  // Settings related to the output style
  enableColors: {
    description: `If true, the CLI is allowed to use colors in its output`,
    type: SettingsType.BOOLEAN,
    default: supportsColor,
    defaultText: `<dynamic>`
  },
  enableHyperlinks: {
    description: `If true, the CLI is allowed to use hyperlinks in its output`,
    type: SettingsType.BOOLEAN,
    default: supportsHyperlinks,
    defaultText: `<dynamic>`
  },
  enableInlineBuilds: {
    description: `If true, the CLI will print the build output on the command line`,
    type: SettingsType.BOOLEAN,
    default: ci_info__WEBPACK_IMPORTED_MODULE_3__.isCI,
    defaultText: `<dynamic>`
  },
  enableProgressBars: {
    description: `If true, the CLI is allowed to show a progress bar for long-running events`,
    type: SettingsType.BOOLEAN,
    default: !ci_info__WEBPACK_IMPORTED_MODULE_3__.isCI && process.stdout.isTTY && process.stdout.columns > 22,
    defaultText: `<dynamic>`
  },
  enableTimers: {
    description: `If true, the CLI is allowed to print the time spent executing commands`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  preferAggregateCacheInfo: {
    description: `If true, the CLI will only print a one-line report of any cache changes`,
    type: SettingsType.BOOLEAN,
    default: ci_info__WEBPACK_IMPORTED_MODULE_3__.isCI
  },
  preferInteractive: {
    description: `If true, the CLI will automatically use the interactive mode when called from a TTY`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  preferTruncatedLines: {
    description: `If true, the CLI will truncate lines that would go beyond the size of the terminal`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  progressBarStyle: {
    description: `Which style of progress bar should be used (only when progress bars are enabled)`,
    type: SettingsType.STRING,
    default: undefined,
    defaultText: `<dynamic>`
  },
  // Settings related to how packages are interpreted by default
  defaultLanguageName: {
    description: `Default language mode that should be used when a package doesn't offer any insight`,
    type: SettingsType.STRING,
    default: `node`
  },
  defaultProtocol: {
    description: `Default resolution protocol used when resolving pure semver and tag ranges`,
    type: SettingsType.STRING,
    default: `npm:`
  },
  enableTransparentWorkspaces: {
    description: `If false, Yarn won't automatically resolve workspace dependencies unless they use the \`workspace:\` protocol`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  // Settings related to network access
  enableMirror: {
    description: `If true, the downloaded packages will be retrieved and stored in both the local and global folders`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  enableNetwork: {
    description: `If false, the package manager will refuse to use the network if required to`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  httpProxy: {
    description: `URL of the http proxy that must be used for outgoing http requests`,
    type: SettingsType.STRING,
    default: null
  },
  httpsProxy: {
    description: `URL of the http proxy that must be used for outgoing https requests`,
    type: SettingsType.STRING,
    default: null
  },
  unsafeHttpWhitelist: {
    description: `List of the hostnames for which http queries are allowed (glob patterns are supported)`,
    type: SettingsType.STRING,
    default: [],
    isArray: true
  },
  httpTimeout: {
    description: `Timeout of each http request in milliseconds`,
    type: SettingsType.NUMBER,
    default: 60000
  },
  httpRetry: {
    description: `Retry times on http failure`,
    type: SettingsType.NUMBER,
    default: 3
  },
  networkConcurrency: {
    description: `Maximal number of concurrent requests`,
    type: SettingsType.NUMBER,
    default: Infinity
  },
  // Settings related to telemetry
  enableTelemetry: {
    description: `If true, telemetry will be periodically sent, following the rules in https://yarnpkg.com/advanced/telemetry`,
    type: SettingsType.BOOLEAN,
    default: !ci_info__WEBPACK_IMPORTED_MODULE_3__.isCI
  },
  telemetryInterval: {
    description: `Minimal amount of time between two telemetry uploads, in days`,
    type: SettingsType.NUMBER,
    default: 7
  },
  telemetryUserId: {
    description: `If you desire to tell us which project you are, you can set this field. Completely optional and opt-in.`,
    type: SettingsType.STRING,
    default: null
  },
  // Settings related to security
  enableScripts: {
    description: `If true, packages are allowed to have install scripts by default`,
    type: SettingsType.BOOLEAN,
    default: true
  },
  enableImmutableCache: {
    description: `If true, the cache is reputed immutable and actions that would modify it will throw`,
    type: SettingsType.BOOLEAN,
    default: false
  },
  checksumBehavior: {
    description: `Enumeration defining what to do when a checksum doesn't match expectations`,
    type: SettingsType.STRING,
    default: `throw`
  },
  // Package patching - to fix incorrect definitions
  packageExtensions: {
    description: `Map of package corrections to apply on the dependency tree`,
    type: SettingsType.MAP,
    valueDefinition: {
      description: ``,
      type: SettingsType.ANY
    }
  }
};

function parseBoolean(value) {
  switch (value) {
    case `true`:
    case `1`:
    case 1:
    case true:
      {
        return true;
      }
      break;

    case `false`:
    case `0`:
    case 0:
    case false:
      {
        return false;
      }
      break;

    default:
      {
        throw new Error(`Couldn't parse "${value}" as a boolean`);
      }
      break;
  }
}

function parseValue(configuration, path, value, definition, folder) {
  if (definition.isArray) {
    if (!Array.isArray(value)) {
      return String(value).split(/,/).map(segment => {
        return parseSingleValue(configuration, path, segment, definition, folder);
      });
    } else {
      return value.map((sub, i) => parseSingleValue(configuration, `${path}[${i}]`, sub, definition, folder));
    }
  } else {
    if (Array.isArray(value)) {
      throw new Error(`Non-array configuration settings "${path}" cannot be an array`);
    } else {
      return parseSingleValue(configuration, path, value, definition, folder);
    }
  }
}

function parseSingleValue(configuration, path, value, definition, folder) {
  var _a;

  switch (definition.type) {
    case SettingsType.ANY:
      return value;

    case SettingsType.SHAPE:
      return parseShape(configuration, path, value, definition, folder);

    case SettingsType.MAP:
      return parseMap(configuration, path, value, definition, folder);
  }

  if (value === null && !definition.isNullable && definition.default !== null) throw new Error(`Non-nullable configuration settings "${path}" cannot be set to null`);
  if ((_a = definition.values) === null || _a === void 0 ? void 0 : _a.includes(value)) return value;

  const interpretValue = () => {
    if (definition.type === SettingsType.BOOLEAN) return parseBoolean(value);
    if (typeof value !== `string`) throw new Error(`Expected value (${value}) to be a string`);
    const valueWithReplacedVariables = _miscUtils__WEBPACK_IMPORTED_MODULE_10__.replaceEnvVariables(value, {
      env: process.env
    });

    switch (definition.type) {
      case SettingsType.ABSOLUTE_PATH:
        return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(folder, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.toPortablePath(valueWithReplacedVariables));

      case SettingsType.LOCATOR_LOOSE:
        return _structUtils__WEBPACK_IMPORTED_MODULE_12__.parseLocator(valueWithReplacedVariables, false);

      case SettingsType.NUMBER:
        return parseInt(valueWithReplacedVariables);

      case SettingsType.LOCATOR:
        return _structUtils__WEBPACK_IMPORTED_MODULE_12__.parseLocator(valueWithReplacedVariables);

      default:
        return valueWithReplacedVariables;
    }
  };

  const interpreted = interpretValue();
  if (definition.values && !definition.values.includes(interpreted)) throw new Error(`Invalid value, expected one of ${definition.values.join(`, `)}`);
  return interpreted;
}

function parseShape(configuration, path, value, definition, folder) {
  if (typeof value !== `object` || Array.isArray(value)) throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`Object configuration settings "${path}" must be an object`);
  const result = getDefaultValue(configuration, definition);
  if (value === null) return result;

  for (const [propKey, propValue] of Object.entries(value)) {
    const subPath = `${path}.${propKey}`;
    const subDefinition = definition.properties[propKey];
    if (!subDefinition) throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`Unrecognized configuration settings found: ${path}.${propKey} - run "yarn config -v" to see the list of settings supported in Yarn`);
    result.set(propKey, parseValue(configuration, subPath, propValue, definition.properties[propKey], folder));
  }

  return result;
}

function parseMap(configuration, path, value, definition, folder) {
  const result = new Map();
  if (typeof value !== `object` || Array.isArray(value)) throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`Map configuration settings "${path}" must be an object`);
  if (value === null) return result;

  for (const [propKey, propValue] of Object.entries(value)) {
    const normalizedKey = definition.normalizeKeys ? definition.normalizeKeys(propKey) : propKey;
    const subPath = `${path}['${normalizedKey}']`; // @ts-ignore: SettingsDefinitionNoDefault has ... no default ... but
    // that's fine because we're guaranteed it's not undefined.

    const valueDefinition = definition.valueDefinition;
    result.set(normalizedKey, parseValue(configuration, subPath, propValue, valueDefinition, folder));
  }

  return result;
}

function getDefaultValue(configuration, definition) {
  switch (definition.type) {
    case SettingsType.SHAPE:
      {
        const result = new Map();

        for (const [propKey, propDefinition] of Object.entries(definition.properties)) result.set(propKey, getDefaultValue(configuration, propDefinition));

        return result;
      }
      break;

    case SettingsType.MAP:
      {
        return new Map();
      }
      break;

    case SettingsType.ABSOLUTE_PATH:
      {
        if (definition.default === null) return null;

        if (configuration.projectCwd === null) {
          if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.isAbsolute(definition.default)) {
            return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.normalize(definition.default);
          } else if (definition.isNullable) {
            return null;
          } else {
            // Reached when a relative path is the default but the current
            // context is evaluated outside of a Yarn project
            return undefined;
          }
        } else {
          if (Array.isArray(definition.default)) {
            return definition.default.map(entry => _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(configuration.projectCwd, entry));
          } else {
            return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(configuration.projectCwd, definition.default);
          }
        }
      }
      break;

    default:
      {
        return definition.default;
      }
      break;
  }
}

function transformConfiguration(rawValue, definition, transforms) {
  if (definition.type === SettingsType.SECRET && typeof rawValue === `string` && transforms.hideSecrets) return SECRET;
  if (definition.type === SettingsType.ABSOLUTE_PATH && typeof rawValue === `string` && transforms.getNativePaths) return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.fromPortablePath(rawValue);

  if (definition.isArray && Array.isArray(rawValue)) {
    const newValue = [];

    for (const value of rawValue) newValue.push(transformConfiguration(value, definition, transforms));

    return newValue;
  }

  if (definition.type === SettingsType.MAP && rawValue instanceof Map) {
    const newValue = new Map();

    for (const [key, value] of rawValue.entries()) newValue.set(key, transformConfiguration(value, definition.valueDefinition, transforms));

    return newValue;
  }

  if (definition.type === SettingsType.SHAPE && rawValue instanceof Map) {
    const newValue = new Map();

    for (const [key, value] of rawValue.entries()) {
      const propertyDefinition = definition.properties[key];
      newValue.set(key, transformConfiguration(value, propertyDefinition, transforms));
    }

    return newValue;
  }

  return rawValue;
}

function getEnvironmentSettings() {
  const environmentSettings = {};

  for (let [key, value] of Object.entries(process.env)) {
    key = key.toLowerCase();
    if (!key.startsWith(ENVIRONMENT_PREFIX)) continue;
    key = camelcase__WEBPACK_IMPORTED_MODULE_1___default()(key.slice(ENVIRONMENT_PREFIX.length));
    environmentSettings[key] = value;
  }

  return environmentSettings;
}

function getRcFilename() {
  const rcKey = `${ENVIRONMENT_PREFIX}rc_filename`;

  for (const [key, value] of Object.entries(process.env)) if (key.toLowerCase() === rcKey && typeof value === `string`) return value;

  return DEFAULT_RC_FILENAME;
}

var ProjectLookup;

(function (ProjectLookup) {
  ProjectLookup[ProjectLookup["LOCKFILE"] = 0] = "LOCKFILE";
  ProjectLookup[ProjectLookup["MANIFEST"] = 1] = "MANIFEST";
  ProjectLookup[ProjectLookup["NONE"] = 2] = "NONE";
})(ProjectLookup || (ProjectLookup = {}));

class Configuration {
  constructor(startingCwd) {
    this.projectCwd = null;
    this.plugins = new Map();
    this.settings = new Map();
    this.values = new Map();
    this.sources = new Map();
    this.invalid = new Map();
    this.packageExtensions = new Map();
    this.limits = new Map();
    this.startingCwd = startingCwd;
  }

  static create(startingCwd, projectCwdOrPlugins, maybePlugins) {
    const configuration = new Configuration(startingCwd);
    if (typeof projectCwdOrPlugins !== `undefined` && !(projectCwdOrPlugins instanceof Map)) configuration.projectCwd = projectCwdOrPlugins;
    configuration.importSettings(coreDefinitions);
    const plugins = typeof maybePlugins !== `undefined` ? maybePlugins : projectCwdOrPlugins instanceof Map ? projectCwdOrPlugins : new Map();

    for (const [name, plugin] of plugins) configuration.activatePlugin(name, plugin);

    return configuration;
  }
  /**
   * Instantiate a new configuration object exposing the configuration obtained
   * from reading the various rc files and the environment settings.
   *
   * The `pluginConfiguration` parameter is expected to indicate:
   *
   * 1. which modules should be made available to plugins when they require a
   *    package (this is the dynamic linking part - for example we want all the
   *    plugins to use the exact same version of @yarnpkg/core, which also is the
   *    version used by the running Yarn instance).
   *
   * 2. which of those modules are actually plugins that need to be injected
   *    within the configuration.
   *
   * Note that some extra plugins will be automatically added based on the
   * content of the rc files - with the rc plugins taking precedence over
   * the other ones.
   *
   * One particularity: the plugin initialization order is quite strict, with
   * plugins listed in /foo/bar/.yarnrc.yml taking precedence over plugins
   * listed in /foo/.yarnrc.yml and /.yarnrc.yml. Additionally, while plugins
   * can depend on one another, they can only depend on plugins that have been
   * instantiated before them (so a plugin listed in /foo/.yarnrc.yml can
   * depend on another one listed on /foo/bar/.yarnrc.yml, but not the other
   * way around).
   */


  static async find(startingCwd, pluginConfiguration, {
    lookup = ProjectLookup.LOCKFILE,
    strict = true,
    usePath = false,
    useRc = true
  } = {}) {
    const environmentSettings = getEnvironmentSettings();
    delete environmentSettings.rcFilename;
    const rcFiles = await Configuration.findRcFiles(startingCwd);
    const homeRcFile = await Configuration.findHomeRcFile();

    const pickCoreFields = ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename
    }) => ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename
    });

    const excludeCoreFields = ({
      ignoreCwd,
      yarnPath,
      ignorePath,
      lockfileFilename,
      ...rest
    }) => rest;

    const configuration = new Configuration(startingCwd);
    configuration.importSettings(pickCoreFields(coreDefinitions));
    configuration.useWithSource(`<environment>`, pickCoreFields(environmentSettings), startingCwd, {
      strict: false
    });

    for (const {
      path,
      cwd,
      data
    } of rcFiles) configuration.useWithSource(path, pickCoreFields(data), cwd, {
      strict: false
    });

    if (homeRcFile) configuration.useWithSource(homeRcFile.path, pickCoreFields(homeRcFile.data), homeRcFile.cwd, {
      strict: false
    });

    if (usePath) {
      const yarnPath = configuration.get(`yarnPath`);
      const ignorePath = configuration.get(`ignorePath`);

      if (yarnPath !== null && !ignorePath) {
        return configuration;
      }
    } // We need to know the project root before being able to truly instantiate
    // our configuration, and to know that we need to know the lockfile name


    const lockfileFilename = configuration.get(`lockfileFilename`);
    let projectCwd;

    switch (lookup) {
      case ProjectLookup.LOCKFILE:
        {
          projectCwd = await Configuration.findProjectCwd(startingCwd, lockfileFilename);
        }
        break;

      case ProjectLookup.MANIFEST:
        {
          projectCwd = await Configuration.findProjectCwd(startingCwd, null);
        }
        break;

      case ProjectLookup.NONE:
        {
          if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(startingCwd, `package.json`))) {
            projectCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(startingCwd);
          } else {
            projectCwd = null;
          }
        }
        break;
    } // Great! We now have enough information to really start to setup the
    // core configuration object.


    configuration.startingCwd = startingCwd;
    configuration.projectCwd = projectCwd;
    configuration.importSettings(excludeCoreFields(coreDefinitions)); // Now that the configuration object is almost ready, we need to load all
    // the configured plugins

    const plugins = new Map([[`@@core`, _CorePlugin__WEBPACK_IMPORTED_MODULE_14__.CorePlugin]]);

    const interop = obj => obj.__esModule ? obj.default : obj;

    if (pluginConfiguration !== null) {
      for (const request of pluginConfiguration.plugins.keys()) plugins.set(request, interop(pluginConfiguration.modules.get(request)));

      const requireEntries = new Map();

      for (const request of _nodeUtils__WEBPACK_IMPORTED_MODULE_15__.builtinModules()) requireEntries.set(request, () => _nodeUtils__WEBPACK_IMPORTED_MODULE_15__.dynamicRequire(request));

      for (const [request, embedModule] of pluginConfiguration.modules) requireEntries.set(request, () => embedModule);

      const dynamicPlugins = new Set();

      const getDefault = object => {
        return object.default || object;
      };

      const importPlugin = (pluginPath, source) => {
        const {
          factory,
          name
        } = _nodeUtils__WEBPACK_IMPORTED_MODULE_15__.dynamicRequire(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.fromPortablePath(pluginPath)); // Prevent plugin redefinition so that the ones declared deeper in the
        // filesystem always have precedence over the ones below.

        if (dynamicPlugins.has(name)) return;
        const pluginRequireEntries = new Map(requireEntries);

        const pluginRequire = request => {
          if (pluginRequireEntries.has(request)) {
            return pluginRequireEntries.get(request)();
          } else {
            throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`This plugin cannot access the package referenced via ${request} which is neither a builtin, nor an exposed entry`);
          }
        };

        const plugin = _miscUtils__WEBPACK_IMPORTED_MODULE_10__.prettifySyncErrors(() => {
          return getDefault(factory(pluginRequire));
        }, message => {
          return `${message} (when initializing ${name}, defined in ${source})`;
        });
        requireEntries.set(name, () => plugin);
        dynamicPlugins.add(name);
        plugins.set(name, plugin);
      };

      if (environmentSettings.plugins) {
        for (const userProvidedPath of environmentSettings.plugins.split(`;`)) {
          const pluginPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(startingCwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.toPortablePath(userProvidedPath));
          importPlugin(pluginPath, `<environment>`);
        }
      }

      for (const {
        path,
        cwd,
        data
      } of rcFiles) {
        if (!useRc) continue;
        if (!Array.isArray(data.plugins)) continue;

        for (const userPluginEntry of data.plugins) {
          const userProvidedPath = typeof userPluginEntry !== `string` ? userPluginEntry.path : userPluginEntry;
          const pluginPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.toPortablePath(userProvidedPath));
          importPlugin(pluginPath, path);
        }
      }
    }

    for (const [name, plugin] of plugins) configuration.activatePlugin(name, plugin);

    configuration.useWithSource(`<environment>`, excludeCoreFields(environmentSettings), startingCwd, {
      strict
    });

    for (const {
      path,
      cwd,
      data
    } of rcFiles) configuration.useWithSource(path, excludeCoreFields(data), cwd, {
      strict
    }); // The home configuration is never strict because it improves support for
    // multiple projects using different Yarn versions on the same machine


    if (homeRcFile) configuration.useWithSource(homeRcFile.path, excludeCoreFields(homeRcFile.data), homeRcFile.cwd, {
      strict: false
    });

    if (configuration.get(`enableGlobalCache`)) {
      configuration.values.set(`cacheFolder`, `${configuration.get(`globalFolder`)}/cache`);
      configuration.sources.set(`cacheFolder`, `<internal>`);
    }

    await configuration.refreshPackageExtensions();
    return configuration;
  }

  static async findRcFiles(startingCwd) {
    const rcFilename = getRcFilename();
    const rcFiles = [];
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (nextCwd !== currentCwd) {
      currentCwd = nextCwd;
      const rcPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(currentCwd, rcFilename);

      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(rcPath)) {
        const content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.readFilePromise(rcPath, `utf8`);
        let data;

        try {
          data = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(content);
        } catch (error) {
          let tip = ``;
          if (content.match(/^\s+(?!-)[^:]+\s+\S+/m)) tip = ` (in particular, make sure you list the colons after each key name)`;
          throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`Parse error when loading ${rcPath}; please check it's proper Yaml${tip}`);
        }

        rcFiles.push({
          path: rcPath,
          cwd: currentCwd,
          data
        });
      }

      nextCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(currentCwd);
    }

    return rcFiles;
  }

  static async findHomeRcFile() {
    const rcFilename = getRcFilename();
    const homeFolder = _folderUtils__WEBPACK_IMPORTED_MODULE_8__.getHomeFolder();
    const homeRcFilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(homeFolder, rcFilename);

    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(homeRcFilePath)) {
      const content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.readFilePromise(homeRcFilePath, `utf8`);
      const data = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(content);
      return {
        path: homeRcFilePath,
        cwd: homeFolder,
        data
      };
    }

    return null;
  }

  static async findProjectCwd(startingCwd, lockfileFilename) {
    let projectCwd = null;
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (nextCwd !== currentCwd) {
      currentCwd = nextCwd;
      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(currentCwd, `package.json`))) projectCwd = currentCwd;

      if (lockfileFilename !== null) {
        if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(currentCwd, lockfileFilename))) {
          projectCwd = currentCwd;
          break;
        }
      } else {
        if (projectCwd !== null) {
          break;
        }
      }

      nextCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(currentCwd);
    }

    return projectCwd;
  }

  static async updateConfiguration(cwd, patch) {
    const rcFilename = getRcFilename();
    const configurationPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(cwd, rcFilename);
    const current = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.existsSync(configurationPath) ? (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.readFilePromise(configurationPath, `utf8`)) : {};
    let patched = false;
    if (typeof patch === `function`) patch = patch(current);
    if (typeof patch === `function`) throw new Error(`Assertion failed: Invalid configuration type`);

    for (const key of Object.keys(patch)) {
      const currentValue = current[key];
      const nextValue = typeof patch[key] === `function` ? patch[key](currentValue) : patch[key];
      if (currentValue === nextValue) continue;
      current[key] = nextValue;
      patched = true;
    }

    if (!patched) return;
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.changeFilePromise(configurationPath, (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.stringifySyml)(current), {
      automaticNewlines: true
    });
  }

  static async updateHomeConfiguration(patch) {
    const homeFolder = _folderUtils__WEBPACK_IMPORTED_MODULE_8__.getHomeFolder();
    return await Configuration.updateConfiguration(homeFolder, patch);
  }

  activatePlugin(name, plugin) {
    this.plugins.set(name, plugin);

    if (typeof plugin.configuration !== `undefined`) {
      this.importSettings(plugin.configuration);
    }
  }

  importSettings(definitions) {
    for (const [name, definition] of Object.entries(definitions)) {
      if (this.settings.has(name)) throw new Error(`Cannot redefine settings "${name}"`);
      this.settings.set(name, definition);
      this.values.set(name, getDefaultValue(this, definition));
    }
  }

  useWithSource(source, data, folder, {
    strict = true,
    overwrite = false
  }) {
    try {
      this.use(source, data, folder, {
        strict,
        overwrite
      });
    } catch (error) {
      error.message += ` (in ${source})`;
      throw error;
    }
  }

  use(source, data, folder, {
    strict = true,
    overwrite = false
  }) {
    for (const key of Object.keys(data)) {
      const value = data[key];
      if (typeof value === `undefined`) continue; // The plugins have already been loaded at this point

      if (key === `plugins`) continue; // Some environment variables should be ignored when applying the configuration

      if (source === `<environment>` && IGNORED_ENV_VARIABLES.has(key)) continue; // It wouldn't make much sense, would it?

      if (key === `rcFilename`) throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`The rcFilename settings can only be set via ${`${ENVIRONMENT_PREFIX}RC_FILENAME`.toUpperCase()}, not via a rc file`);
      const definition = this.settings.get(key);

      if (!definition) {
        if (strict) {
          throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`Unrecognized or legacy configuration settings found: ${key} - run "yarn config -v" to see the list of settings supported in Yarn`);
        } else {
          this.invalid.set(key, source);
          continue;
        }
      }

      if (this.sources.has(key) && !overwrite) continue;
      let parsed;

      try {
        parsed = parseValue(this, key, data[key], definition, folder);
      } catch (error) {
        error.message += ` in ${source}`;
        throw error;
      }

      this.values.set(key, parsed);
      this.sources.set(key, source);
    }
  }

  get(key) {
    if (!this.values.has(key)) throw new Error(`Invalid configuration key "${key}"`);
    return this.values.get(key);
  }

  getSpecial(key, {
    hideSecrets = false,
    getNativePaths = false
  }) {
    const rawValue = this.get(key);
    const definition = this.settings.get(key);
    if (typeof definition === `undefined`) throw new clipanion__WEBPACK_IMPORTED_MODULE_4__.UsageError(`Couldn't find a configuration settings named "${key}"`);
    return transformConfiguration(rawValue, definition, {
      hideSecrets,
      getNativePaths
    });
  }

  getSubprocessStreams(logFile, {
    header,
    prefix,
    report
  }) {
    let stdout;
    let stderr;
    const logStream = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.createWriteStream(logFile);

    if (this.get(`enableInlineBuilds`)) {
      const stdoutLineReporter = report.createStreamReporter(`${prefix} ${this.format(`STDOUT`, `green`)}`);
      const stderrLineReporter = report.createStreamReporter(`${prefix} ${this.format(`STDERR`, `red`)}`);
      stdout = new stream__WEBPACK_IMPORTED_MODULE_7__.PassThrough();
      stdout.pipe(stdoutLineReporter);
      stdout.pipe(logStream);
      stderr = new stream__WEBPACK_IMPORTED_MODULE_7__.PassThrough();
      stderr.pipe(stderrLineReporter);
      stderr.pipe(logStream);
    } else {
      stdout = logStream;
      stderr = logStream;

      if (typeof header !== `undefined`) {
        stdout.write(`${header}\n`);
      }
    }

    return {
      stdout,
      stderr
    };
  }

  makeResolver() {
    const pluginResolvers = [];

    for (const plugin of this.plugins.values()) for (const resolver of plugin.resolvers || []) pluginResolvers.push(new resolver());

    return new _MultiResolver__WEBPACK_IMPORTED_MODULE_16__.MultiResolver([new _VirtualResolver__WEBPACK_IMPORTED_MODULE_17__.VirtualResolver(), new _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_18__.WorkspaceResolver(), new _ProtocolResolver__WEBPACK_IMPORTED_MODULE_19__.ProtocolResolver(), ...pluginResolvers]);
  }

  makeFetcher() {
    const pluginFetchers = [];

    for (const plugin of this.plugins.values()) for (const fetcher of plugin.fetchers || []) pluginFetchers.push(new fetcher());

    return new _MultiFetcher__WEBPACK_IMPORTED_MODULE_20__.MultiFetcher([new _VirtualFetcher__WEBPACK_IMPORTED_MODULE_21__.VirtualFetcher(), new _WorkspaceFetcher__WEBPACK_IMPORTED_MODULE_22__.WorkspaceFetcher(), ...pluginFetchers]);
  }

  getLinkers() {
    const linkers = [];

    for (const plugin of this.plugins.values()) for (const linker of plugin.linkers || []) linkers.push(new linker());

    return linkers;
  }

  async refreshPackageExtensions() {
    this.packageExtensions = new Map();
    const packageExtensions = this.packageExtensions;

    const registerPackageExtension = (descriptor, extensionData) => {
      if (!semver__WEBPACK_IMPORTED_MODULE_6___default().validRange(descriptor.range)) throw new Error(`Only semver ranges are allowed as keys for the lockfileExtensions setting`);
      const extension = new _Manifest__WEBPACK_IMPORTED_MODULE_23__.Manifest();
      extension.load(extensionData);
      _miscUtils__WEBPACK_IMPORTED_MODULE_10__.getArrayWithDefault(packageExtensions, descriptor.identHash).push({
        descriptor,
        changes: new Set([...[...extension.dependencies.values(), ...extension.peerDependencies.values()].map(descriptor => {
          return _structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyIdent(descriptor);
        }), ...extension.dependenciesMeta.keys(), ...extension.peerDependenciesMeta.keys()]),
        patch: pkg => {
          pkg.dependencies = new Map([...pkg.dependencies, ...extension.dependencies]);
          pkg.peerDependencies = new Map([...pkg.peerDependencies, ...extension.peerDependencies]);
          pkg.dependenciesMeta = new Map([...pkg.dependenciesMeta, ...extension.dependenciesMeta]);
          pkg.peerDependenciesMeta = new Map([...pkg.peerDependenciesMeta, ...extension.peerDependenciesMeta]);
        }
      });
    };

    for (const [descriptorString, extensionData] of this.get(`packageExtensions`)) registerPackageExtension(_structUtils__WEBPACK_IMPORTED_MODULE_12__.parseDescriptor(descriptorString, true), extensionData);

    await this.triggerHook(hooks => {
      return hooks.registerPackageExtensions;
    }, this, registerPackageExtension);
  }

  normalizePackage(original) {
    const pkg = _structUtils__WEBPACK_IMPORTED_MODULE_12__.copyPackage(original); // We use the extensions to define additional dependencies that weren't
    // properly listed in the original package definition

    if (this.packageExtensions == null) throw new Error(`refreshPackageExtensions has to be called before normalizing packages`);
    const extensionList = this.packageExtensions.get(original.identHash);

    if (typeof extensionList !== `undefined`) {
      const version = original.version;

      if (version !== null) {
        const extensionEntry = extensionList.find(({
          descriptor
        }) => {
          return _semverUtils__WEBPACK_IMPORTED_MODULE_24__.satisfiesWithPrereleases(version, descriptor.range);
        });

        if (typeof extensionEntry !== `undefined`) {
          extensionEntry.patch(pkg);
        }
      }
    } // We also add implicit optional @types peer dependencies for each peer
    // dependency. This is for compatibility reason, as many existing packages
    // forget to define their @types/react optional peer dependency when they
    // peer-depend on react.


    const getTypesName = descriptor => {
      return descriptor.scope ? `${descriptor.scope}__${descriptor.name}` : `${descriptor.name}`;
    };

    for (const descriptor of pkg.peerDependencies.values()) {
      if (descriptor.scope === `@types`) continue;
      const typesName = getTypesName(descriptor);
      const typesIdent = _structUtils__WEBPACK_IMPORTED_MODULE_12__.makeIdent(`types`, typesName);
      if (pkg.peerDependencies.has(typesIdent.identHash) || pkg.peerDependenciesMeta.has(typesIdent.identHash)) continue;
      pkg.peerDependenciesMeta.set(_structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyIdent(typesIdent), {
        optional: true
      });
    } // I don't like implicit dependencies, but package authors are reluctant to
    // use optional peer dependencies because they would print warnings in older
    // npm releases.


    for (const identString of pkg.peerDependenciesMeta.keys()) {
      const ident = _structUtils__WEBPACK_IMPORTED_MODULE_12__.parseIdent(identString);

      if (!pkg.peerDependencies.has(ident.identHash)) {
        pkg.peerDependencies.set(ident.identHash, _structUtils__WEBPACK_IMPORTED_MODULE_12__.makeDescriptor(ident, `*`));
      }
    } // We sort the dependencies so that further iterations always occur in the
    // same order, regardless how the various registries formatted their output


    pkg.dependencies = new Map(_miscUtils__WEBPACK_IMPORTED_MODULE_10__.sortMap(pkg.dependencies, ([, descriptor]) => _structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyDescriptor(descriptor)));
    pkg.peerDependencies = new Map(_miscUtils__WEBPACK_IMPORTED_MODULE_10__.sortMap(pkg.peerDependencies, ([, descriptor]) => _structUtils__WEBPACK_IMPORTED_MODULE_12__.stringifyDescriptor(descriptor)));
    return pkg;
  }

  getLimit(key) {
    return _miscUtils__WEBPACK_IMPORTED_MODULE_10__.getFactoryWithDefault(this.limits, key, () => {
      return p_limit__WEBPACK_IMPORTED_MODULE_5___default()(this.get(key));
    });
  }

  async triggerHook(get, ...args) {
    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      await hook(...args);
    }
  }

  async triggerMultipleHooks(get, argsList) {
    for (const args of argsList) {
      await this.triggerHook(get, ...args);
    }
  }

  async reduceHook(get, initialValue, ...args) {
    let value = initialValue;

    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      value = await hook(value, ...args);
    }

    return value;
  }

  async firstHook(get, ...args) {
    for (const plugin of this.plugins.values()) {
      const hooks = plugin.hooks;
      if (!hooks) continue;
      const hook = get(hooks);
      if (!hook) continue;
      const ret = await hook(...args);

      if (typeof ret !== `undefined`) {
        // @ts-ignore
        return ret;
      }
    }

    return null;
  }

  format(text, colorRequest) {
    if (colorRequest === FormatType.PATH) text = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.npath.fromPortablePath(text);
    if (!this.get(`enableColors`)) return text;
    let color = formatColors.get(colorRequest);
    if (typeof color === `undefined`) color = colorRequest;
    const fn = typeof color === `number` ? chalkInstance.ansi256(color) : color.startsWith(`#`) ? chalkInstance.hex(color) : chalkInstance[color];
    return fn(text);
  }

}
Configuration.telemetry = null;

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseShell": () => /* reexport safe */ _shell__WEBPACK_IMPORTED_MODULE_0__.parseShell,
/* harmony export */   "parseResolution": () => /* reexport safe */ _resolution__WEBPACK_IMPORTED_MODULE_1__.parseResolution,
/* harmony export */   "stringifyResolution": () => /* reexport safe */ _resolution__WEBPACK_IMPORTED_MODULE_1__.stringifyResolution,
/* harmony export */   "parseSyml": () => /* reexport safe */ _syml__WEBPACK_IMPORTED_MODULE_2__.parseSyml,
/* harmony export */   "stringifySyml": () => /* reexport safe */ _syml__WEBPACK_IMPORTED_MODULE_2__.stringifySyml
/* harmony export */ });
/* harmony import */ var _shell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _resolution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _syml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);




/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseShell": () => /* binding */ parseShell
/* harmony export */ });
/* harmony import */ var _grammars_shell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _grammars_shell__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_grammars_shell__WEBPACK_IMPORTED_MODULE_0__);

function parseShell(source, options = {
  isGlobPattern: () => false
}) {
  try {
    return (0,_grammars_shell__WEBPACK_IMPORTED_MODULE_0__.parse)(source, options);
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}

/***/ }),
/* 14 */
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { Start: peg$parseStart },
      peg$startRuleFunction  = peg$parseStart,

      peg$c0 = function(line) { return line ? line : [] },
      peg$c1 = function(main, then) { return [ main ].concat(then || []) },
      peg$c2 = ";",
      peg$c3 = peg$literalExpectation(";", false),
      peg$c4 = function(then) { return then },
      peg$c5 = function(chain, then) { return then ? { chain, then } : { chain } },
      peg$c6 = function(type, then) { return { type, line: then } },
      peg$c7 = "&&",
      peg$c8 = peg$literalExpectation("&&", false),
      peg$c9 = "||",
      peg$c10 = peg$literalExpectation("||", false),
      peg$c11 = function(main, then) { return then ? { ...main, then } : main },
      peg$c12 = function(type, then) { return { type, chain: then } },
      peg$c13 = "|&",
      peg$c14 = peg$literalExpectation("|&", false),
      peg$c15 = "|",
      peg$c16 = peg$literalExpectation("|", false),
      peg$c17 = "=",
      peg$c18 = peg$literalExpectation("=", false),
      peg$c19 = function(name, arg) { return { name, args: [arg] } },
      peg$c20 = function(name) { return { name, args: [] } },
      peg$c21 = "(",
      peg$c22 = peg$literalExpectation("(", false),
      peg$c23 = ")",
      peg$c24 = peg$literalExpectation(")", false),
      peg$c25 = function(subshell, args) { return { type: `subshell`, subshell, args } },
      peg$c26 = function(envs, args) { return { type: `command`, args, envs } },
      peg$c27 = function(envs) { return { type: `envs`, envs } },
      peg$c28 = function(args) { return args },
      peg$c29 = function(arg) { return arg },
      peg$c30 = ">>",
      peg$c31 = peg$literalExpectation(">>", false),
      peg$c32 = ">",
      peg$c33 = peg$literalExpectation(">", false),
      peg$c34 = "<<<",
      peg$c35 = peg$literalExpectation("<<<", false),
      peg$c36 = "<",
      peg$c37 = peg$literalExpectation("<", false),
      peg$c38 = function(redirect, arg) { return { type: `redirection`, subtype: redirect, args: [arg] } },
      peg$c39 = function(segments) { return { type: `argument`, segments: [].concat(... segments) } },
      peg$c40 = function(string) { return string },
      peg$c41 = "'",
      peg$c42 = peg$literalExpectation("'", false),
      peg$c43 = function(text) { return [ { type: `text`, text } ] },
      peg$c44 = "\"",
      peg$c45 = peg$literalExpectation("\"", false),
      peg$c46 = function(segments) { return segments },
      peg$c47 = function(arithmetic) { return { type: `arithmetic`, arithmetic, quoted: true} },
      peg$c48 = function(shell) { return { type: `shell`, shell, quoted: true } },
      peg$c49 = function(variable) { return { type: `variable`, ...variable, quoted: true } },
      peg$c50 = function(text) { return { type: `text`, text } },
      peg$c51 = function(arithmetic) { return { type: `arithmetic`, arithmetic, quoted: false} },
      peg$c52 = function(shell) { return { type: `shell`, shell, quoted: false } },
      peg$c53 = function(variable) { return { type: `variable`, ...variable, quoted: false } },
      peg$c54 = function(pattern) { return { type: `glob`, pattern } },
      peg$c55 = "\\",
      peg$c56 = peg$literalExpectation("\\", false),
      peg$c57 = peg$anyExpectation(),
      peg$c58 = function(c) { return c },
      peg$c59 = /^[^']/,
      peg$c60 = peg$classExpectation(["'"], true, false),
      peg$c61 = function(chars) { return chars.join(``) },
      peg$c62 = /^[^$"]/,
      peg$c63 = peg$classExpectation(["$", "\""], true, false),
      peg$c64 = "-",
      peg$c65 = peg$literalExpectation("-", false),
      peg$c66 = "+",
      peg$c67 = peg$literalExpectation("+", false),
      peg$c68 = /^[0-9]/,
      peg$c69 = peg$classExpectation([["0", "9"]], false, false),
      peg$c70 = ".",
      peg$c71 = peg$literalExpectation(".", false),
      peg$c72 = function(sign, left, right) { return { type: `number`, value: (sign === '-' ? -1 : 1) * parseFloat(left.join(``) + `.` + right.join(``)) } },
      peg$c73 = function(sign, value) { return { type: `number`, value: (sign === '-' ? -1 : 1) *  parseInt(value.join(``)) } },
      peg$c74 = function(variable) { return { type: `variable`, ...variable } },
      peg$c75 = function(name) { return { type: `variable`, name } },
      peg$c76 = function(value) { return value },
      peg$c77 = "*",
      peg$c78 = peg$literalExpectation("*", false),
      peg$c79 = function(left, right) { return { type: `multiplication`, left, right } },
      peg$c80 = "/",
      peg$c81 = peg$literalExpectation("/", false),
      peg$c82 = function(left, right) { return { type: `division`, left, right } },
      peg$c83 = function(left, right) { return { type: `addition`, left, right } },
      peg$c84 = function(left, right) { return { type: `subtraction`, left, right } },
      peg$c85 = "$((",
      peg$c86 = peg$literalExpectation("$((", false),
      peg$c87 = "))",
      peg$c88 = peg$literalExpectation("))", false),
      peg$c89 = function(arithmetic) { return arithmetic },
      peg$c90 = "$(",
      peg$c91 = peg$literalExpectation("$(", false),
      peg$c92 = function(command) { return command },
      peg$c93 = "${",
      peg$c94 = peg$literalExpectation("${", false),
      peg$c95 = ":-",
      peg$c96 = peg$literalExpectation(":-", false),
      peg$c97 = "}",
      peg$c98 = peg$literalExpectation("}", false),
      peg$c99 = function(name, arg) { return { name, defaultValue: arg } },
      peg$c100 = ":-}",
      peg$c101 = peg$literalExpectation(":-}", false),
      peg$c102 = function(name) { return { name, defaultValue: [] } },
      peg$c103 = function(name) { return { name } },
      peg$c104 = "$",
      peg$c105 = peg$literalExpectation("$", false),
      peg$c106 = function(pattern) { return options.isGlobPattern(pattern) },
      peg$c107 = function(pattern) { return pattern },
      peg$c108 = /^[a-zA-Z0-9_]/,
      peg$c109 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false),
      peg$c110 = function() { return text() },
      peg$c111 = /^[@*?#a-zA-Z0-9_\-]/,
      peg$c112 = peg$classExpectation(["@", "*", "?", "#", ["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
      peg$c113 = /^[(){}<>$|&; \t"']/,
      peg$c114 = peg$classExpectation(["(", ")", "{", "}", "<", ">", "$", "|", "&", ";", " ", "\t", "\"", "'"], false, false),
      peg$c115 = /^[<>&; \t"']/,
      peg$c116 = peg$classExpectation(["<", ">", "&", ";", " ", "\t", "\"", "'"], false, false),
      peg$c117 = /^[ \t]/,
      peg$c118 = peg$classExpectation([" ", "\t"], false, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseStart() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseShellLine();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseShellLine() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseCommandLine();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseShellLineThen();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c1(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseShellLineThen() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 59) {
        s2 = peg$c2;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseShellLine();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c4(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandLine() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseCommandChain();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandLineThen();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c5(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandLineThen() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandLineType();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandLine();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandLineType() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c7) {
      s0 = peg$c7;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c8); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c9) {
        s0 = peg$c9;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
    }

    return s0;
  }

  function peg$parseCommandChain() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseCommand();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandChainThen();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c11(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandChainThen() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseCommandChainType();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandChain();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c12(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCommandChainType() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c13) {
      s0 = peg$c13;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c14); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 124) {
        s0 = peg$c15;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
    }

    return s0;
  }

  function peg$parseVariableAssignment() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseEnvVariable();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 61) {
        s2 = peg$c17;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseStrictValueArgument();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c19(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseEnvVariable();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c17;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c18); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c20(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseCommand() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c21;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseShellLine();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseS();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseS();
            }
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c23;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c24); }
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parseS();
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$parseS();
                }
                if (s7 !== peg$FAILED) {
                  s8 = [];
                  s9 = peg$parseRedirectArgument();
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parseRedirectArgument();
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = [];
                    s10 = peg$parseS();
                    while (s10 !== peg$FAILED) {
                      s9.push(s10);
                      s10 = peg$parseS();
                    }
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c25(s4, s8);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseVariableAssignment();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseVariableAssignment();
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseS();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseS();
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseArgument();
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseArgument();
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseS();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseS();
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseS();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseS();
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseVariableAssignment();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseVariableAssignment();
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseS();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c27(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseCommandString() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseValueArgument();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseValueArgument();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseS();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseS();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c28(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseArgument() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseRedirectArgument();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseS();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseValueArgument();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c29(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseRedirectArgument() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 2) === peg$c30) {
        s2 = peg$c30;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c31); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s2 = peg$c32;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c33); }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c34) {
            s2 = peg$c34;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c35); }
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 60) {
              s2 = peg$c36;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c37); }
            }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseValueArgument();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c38(s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseValueArgument() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseS();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseS();
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseStrictValueArgument();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseStrictValueArgument() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseArgumentSegment();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseArgumentSegment();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c39(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseArgumentSegment() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseSglQuoteString();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c40(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseDblQuoteString();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c40(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsePlainString();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s1);
        }
        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parseSglQuoteString() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c41;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c42); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseSglQuoteStringText();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c41;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c42); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c43(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDblQuoteString() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c44;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c45); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseDblQuoteStringSegment();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseDblQuoteStringSegment();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c44;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c45); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePlainString() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsePlainStringSegment();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsePlainStringSegment();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c46(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseDblQuoteStringSegment() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseArithmetic();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c47(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSubshell();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c48(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c49(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDblQuoteStringText();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c50(s1);
          }
          s0 = s1;
        }
      }
    }

    return s0;
  }

  function peg$parsePlainStringSegment() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseArithmetic();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c51(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSubshell();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseGlob();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c54(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePlainStringText();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c50(s1);
            }
            s0 = s1;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseSglQuoteStringText() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c55;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c56); }
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c57); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c58(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      if (peg$c59.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c60); }
      }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s3 = peg$c55;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c57); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c58(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        if (peg$c59.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c60); }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c61(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseDblQuoteStringText() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c55;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c56); }
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c57); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c58(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      if (peg$c62.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c63); }
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c55;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c56); }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c57); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c58(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          if (peg$c62.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c63); }
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c61(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsePlainStringText() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s3 = peg$c55;
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c56); }
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c57); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c58(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 === peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parseSpecialShellChars();
      peg$silentFails--;
      if (s4 === peg$FAILED) {
        s3 = void 0;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c57); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c58(s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c55;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c56); }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c57); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c58(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseSpecialShellChars();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c57); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c58(s4);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c61(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseArithmeticPrimary() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c64;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c65); }
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c66;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c68.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c69); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c68.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c69); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s3 = peg$c70;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c71); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c68.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c69); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c68.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c72(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c64;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c66;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c68.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c69); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c68.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c69); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c73(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c74(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c75(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
              s1 = peg$c21;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c22); }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseArithmeticExpression();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                      s5 = peg$c23;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c24); }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c76(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseArithmeticTimesExpression() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseArithmeticPrimary();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 42) {
          s3 = peg$c77;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c78); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseArithmeticTimesExpression();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c79(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseArithmeticPrimary();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 47) {
            s3 = peg$c80;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c81); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseArithmeticTimesExpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c82(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseArithmeticPrimary();
      }
    }

    return s0;
  }

  function peg$parseArithmeticExpression() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseArithmeticTimesExpression();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s3 = peg$c66;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseArithmeticExpression();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c83(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseArithmeticTimesExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseS();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseS();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s3 = peg$c64;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c65); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseS();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseS();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseArithmeticExpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c84(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseArithmeticTimesExpression();
      }
    }

    return s0;
  }

  function peg$parseArithmetic() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c85) {
      s1 = peg$c85;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c86); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseS();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseS();
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseArithmeticExpression();
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseS();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseS();
          }
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c87) {
              s5 = peg$c87;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c88); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c89(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSubshell() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c90) {
      s1 = peg$c90;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c91); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseShellLine();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 41) {
          s3 = peg$c23;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c24); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c92(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVariable() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c93) {
      s1 = peg$c93;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c94); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseIdentifier();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c95) {
          s3 = peg$c95;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c96); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseCommandString();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c97;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c98); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c99(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c93) {
        s1 = peg$c93;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c94); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIdentifier();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c100) {
            s3 = peg$c100;
            peg$currPos += 3;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c101); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c102(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c93) {
          s1 = peg$c93;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c94); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s3 = peg$c97;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c98); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c103(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 36) {
            s1 = peg$c104;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c105); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c103(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseGlob() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseGlobText();
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c106(s1);
      if (s2) {
        s2 = void 0;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c107(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGlobText() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$currPos;
    peg$silentFails++;
    s4 = peg$parseGlobSpecialShellChars();
    peg$silentFails--;
    if (s4 === peg$FAILED) {
      s3 = void 0;
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c57); }
      }
      if (s4 !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c58(s4);
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseGlobSpecialShellChars();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c57); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c58(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c61(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseEnvVariable() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c108.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c109); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c108.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c109); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c110();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseIdentifier() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c111.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c112); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c111.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c112); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c110();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseSpecialShellChars() {
    var s0;

    if (peg$c113.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c114); }
    }

    return s0;
  }

  function peg$parseGlobSpecialShellChars() {
    var s0;

    if (peg$c115.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c116); }
    }

    return s0;
  }

  function peg$parseS() {
    var s0, s1;

    s0 = [];
    if (peg$c117.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c118); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c117.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c118); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};


/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseResolution": () => /* binding */ parseResolution,
/* harmony export */   "stringifyResolution": () => /* binding */ stringifyResolution
/* harmony export */ });
/* harmony import */ var _grammars_resolution__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _grammars_resolution__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_grammars_resolution__WEBPACK_IMPORTED_MODULE_0__);

function parseResolution(source) {
  const legacyResolution = source.match(/^\*{1,2}\/(.*)/);
  if (legacyResolution) throw new Error(`The override for '${source}' includes a glob pattern. Glob patterns have been removed since their behaviours don't match what you'd expect. Set the override to '${legacyResolution[1]}' instead.`);

  try {
    return (0,_grammars_resolution__WEBPACK_IMPORTED_MODULE_0__.parse)(source);
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}
function stringifyResolution(resolution) {
  let str = ``;

  if (resolution.from) {
    str += resolution.from.fullName;
    if (resolution.from.description) str += `@${resolution.from.description}`;
    str += `/`;
  }

  str += resolution.descriptor.fullName;
  if (resolution.descriptor.description) str += `@${resolution.descriptor.description}`;
  return str;
}

/***/ }),
/* 16 */
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return `"${literalEscape(expectation.text)}"`;
    },

    "class": function(expectation) {
      var escapedParts = "",
        i;

      for (i = 0; i < expectation.parts.length; i++)
        escapedParts += expectation.parts[i] instanceof Array
          ? `${classEscape(expectation.parts[i][0])}-${classEscape(expectation.parts[i][1])}`
          : classEscape(expectation.parts[i]);


      return `[${expectation.inverted ? "^" : ""}${escapedParts}]`;
    },

    any: function(expectation) {
      return "any character";
    },

    end: function(expectation) {
      return "end of input";
    },

    other: function(expectation) {
      return expectation.description;
    },
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return `\\x0${hex(ch)}`; })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return `\\x${hex(ch)}`; });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return `\\x0${hex(ch)}`; })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return `\\x${hex(ch)}`; });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
      i, j;

    for (i = 0; i < expected.length; i++)
      descriptions[i] = describeExpectation(expected[i]);


    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return `${descriptions[0]} or ${descriptions[1]}`;

      default:
        return `${descriptions.slice(0, -1).join(", ")
        }, or ${
          descriptions[descriptions.length - 1]}`;
    }
  }

  function describeFound(found) {
    return found ? `"${literalEscape(found)}"` : "end of input";
  }

  return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

    peg$startRuleFunctions = {resolution: peg$parseresolution},
    peg$startRuleFunction  = peg$parseresolution,

    peg$c0 = "/",
    peg$c1 = peg$literalExpectation("/", false),
    peg$c2 = function(from, descriptor) { return {from, descriptor}; },
    peg$c3 = function(descriptor) { return {descriptor}; },
    peg$c4 = "@",
    peg$c5 = peg$literalExpectation("@", false),
    peg$c6 = function(fullName, description) { return {fullName, description}; },
    peg$c7 = function(fullName) { return {fullName}; },
    peg$c8 = function() { return text(); },
    peg$c9 = /^[^\/@]/,
    peg$c10 = peg$classExpectation(["/", "@"], true, false),
    peg$c11 = /^[^\/]/,
    peg$c12 = peg$classExpectation(["/"], true, false),

    peg$currPos          = 0,
    peg$savedPos         = 0,
    peg$posDetailsCache  = [{line: 1, column: 1}],
    peg$maxFailPos       = 0,
    peg$maxFailExpected  = [],
    peg$silentFails      = 0,

    peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions))
      throw new Error(`Can't start parsing from rule "${options.startRule}".`);


    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return {type: "literal", text: text, ignoreCase: ignoreCase};
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase};
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function peg$anyExpectation() {
    return {type: "any"};
  }

  function peg$endExpectation() {
    return {type: "end"};
  }

  function peg$otherExpectation(description) {
    return {type: "other", description: description};
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p])
        p--;


      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column,
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
      endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column,
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column,
      },
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos)  return;

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseresolution() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsespecifier();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 47) {
        s2 = peg$c0;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsespecifier();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsespecifier();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c3(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsespecifier() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsefullName();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 64) {
        s2 = peg$c4;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c5); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsedescription();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c6(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsefullName();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c7(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsefullName() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 64) {
      s1 = peg$c4;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c5); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseident();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s3 = peg$c0;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseident();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c8();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseident();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c8();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseident() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c9.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c10); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c9.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c8();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsedescription() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c11.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c12); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c11.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c8();
    }
    s0 = s1;

    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length)
      peg$fail(peg$endExpectation());


    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse,
};


/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stringifySyml": () => /* binding */ stringifySyml,
/* harmony export */   "parseSyml": () => /* binding */ parseSyml
/* harmony export */ });
/* unused harmony export PreserveOrdering */
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_yaml__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _grammars_syml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _grammars_syml__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_grammars_syml__WEBPACK_IMPORTED_MODULE_1__);
// @ts-ignore


const simpleStringPattern = /^(?![-?:,\][{}#&*!|>'"%@` \t\r\n]).([ \t]*(?![,\][{}:# \t\r\n]).)*$/; // The following keys will always be stored at the top of the object, in the
// specified order. It's not fair but life isn't fair either.

const specialObjectKeys = [`__metadata`, `version`, `resolution`, `dependencies`, `peerDependencies`, `dependenciesMeta`, `peerDependenciesMeta`, `binaries`];
class PreserveOrdering {
  constructor(data) {
    this.data = data;
  }

}

function stringifyString(value) {
  if (value.match(simpleStringPattern)) {
    return value;
  } else {
    return JSON.stringify(value);
  }
}

function stringifyValue(value, indentLevel, newLineIfObject) {
  if (value === null) return `null\n`;
  if (typeof value === `number` || typeof value === `boolean`) return `${value.toString()}\n`;
  if (typeof value === `string`) return `${stringifyString(value)}\n`;

  if (Array.isArray(value)) {
    if (value.length === 0) return `[]\n`;
    const indent = `  `.repeat(indentLevel);
    const serialized = value.map(sub => {
      return `${indent}- ${stringifyValue(sub, indentLevel + 1, false)}`;
    }).join(``);
    return `\n${serialized}`;
  }

  if (typeof value === `object` && value) {
    let data;
    let sort;

    if (value instanceof PreserveOrdering) {
      data = value.data;
      sort = false;
    } else {
      data = value;
      sort = true;
    }

    const indent = `  `.repeat(indentLevel);
    const keys = Object.keys(data);

    if (sort) {
      keys.sort((a, b) => {
        const aIndex = specialObjectKeys.indexOf(a);
        const bIndex = specialObjectKeys.indexOf(b);
        if (aIndex === -1 && bIndex === -1) return a < b ? -1 : a > b ? +1 : 0;
        if (aIndex !== -1 && bIndex === -1) return -1;
        if (aIndex === -1 && bIndex !== -1) return +1;
        return aIndex - bIndex;
      });
    }

    const fields = keys.filter(key => {
      return data[key] !== undefined;
    }).map((key, index) => {
      const value = data[key];
      const stringifiedKey = stringifyString(key);
      const stringifiedValue = stringifyValue(value, indentLevel + 1, true);
      const recordIndentation = index > 0 || newLineIfObject ? indent : ``;

      if (stringifiedValue.startsWith(`\n`)) {
        return `${recordIndentation}${stringifiedKey}:${stringifiedValue}`;
      } else {
        return `${recordIndentation}${stringifiedKey}: ${stringifiedValue}`;
      }
    }).join(indentLevel === 0 ? `\n` : ``) || `\n`;

    if (!newLineIfObject) {
      return `${fields}`;
    } else {
      return `\n${fields}`;
    }
  }

  throw new Error(`Unsupported value type (${value})`);
}

function stringifySyml(value) {
  try {
    return stringifyValue(value, 0, false);
  } catch (error) {
    if (error.location) error.message = error.message.replace(/(\.)?$/, ` (line ${error.location.start.line}, column ${error.location.start.column})$1`);
    throw error;
  }
}
stringifySyml.PreserveOrdering = PreserveOrdering;

function parseViaPeg(source) {
  if (!source.endsWith(`\n`)) source += `\n`;
  return (0,_grammars_syml__WEBPACK_IMPORTED_MODULE_1__.parse)(source);
}

const LEGACY_REGEXP = /^(#.*(\r?\n))*?#\s+yarn\s+lockfile\s+v1\r?\n/i;

function parseViaJsYaml(source) {
  if (LEGACY_REGEXP.test(source)) return parseViaPeg(source);
  const value = (0,js_yaml__WEBPACK_IMPORTED_MODULE_0__.safeLoad)(source, {
    schema: js_yaml__WEBPACK_IMPORTED_MODULE_0__.FAILSAFE_SCHEMA
  }); // Empty files are parsed as `undefined` instead of an empty object
  // Empty files with 2 newlines or more are `null` instead

  if (value === undefined || value === null) return {};
  if (typeof value !== `object`) throw new Error(`Expected an indexed object, got a ${typeof value} instead. Does your file follow Yaml's rules?`);
  if (Array.isArray(value)) throw new Error(`Expected an indexed object, got an array instead. Does your file follow Yaml's rules?`);
  return value;
}

function parseSyml(source) {
  return parseViaJsYaml(source);
}

/***/ }),
/* 18 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var yaml = __webpack_require__(19);


module.exports = yaml;


/***/ }),
/* 19 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var loader = __webpack_require__(20);
var dumper = __webpack_require__(48);


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = __webpack_require__(26);
module.exports.Schema              = __webpack_require__(25);
module.exports.FAILSAFE_SCHEMA     = __webpack_require__(29);
module.exports.JSON_SCHEMA         = __webpack_require__(28);
module.exports.CORE_SCHEMA         = __webpack_require__(27);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(24);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(44);
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = __webpack_require__(22);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(29);
module.exports.SAFE_SCHEMA    = __webpack_require__(24);
module.exports.DEFAULT_SCHEMA = __webpack_require__(44);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


/***/ }),
/* 20 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common              = __webpack_require__(21);
var YAMLException       = __webpack_require__(22);
var Mark                = __webpack_require__(23);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(24);
var DEFAULT_FULL_SCHEMA = __webpack_require__(44);


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


/***/ }),
/* 21 */
/***/ ((module) => {

"use strict";



function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


/***/ }),
/* 22 */
/***/ ((module) => {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


/***/ }),
/* 23 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



var common = __webpack_require__(21);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


/***/ }),
/* 24 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __webpack_require__(25);


module.exports = new Schema({
  include: [
    __webpack_require__(27)
  ],
  implicit: [
    __webpack_require__(37),
    __webpack_require__(38)
  ],
  explicit: [
    __webpack_require__(39),
    __webpack_require__(41),
    __webpack_require__(42),
    __webpack_require__(43)
  ]
});


/***/ }),
/* 25 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable max-len*/

var common        = __webpack_require__(21);
var YAMLException = __webpack_require__(22);
var Type          = __webpack_require__(26);


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


/***/ }),
/* 26 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var YAMLException = __webpack_require__(22);

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


/***/ }),
/* 27 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __webpack_require__(25);


module.exports = new Schema({
  include: [
    __webpack_require__(28)
  ]
});


/***/ }),
/* 28 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





var Schema = __webpack_require__(25);


module.exports = new Schema({
  include: [
    __webpack_require__(29)
  ],
  implicit: [
    __webpack_require__(33),
    __webpack_require__(34),
    __webpack_require__(35),
    __webpack_require__(36)
  ]
});


/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __webpack_require__(25);


module.exports = new Schema({
  explicit: [
    __webpack_require__(30),
    __webpack_require__(31),
    __webpack_require__(32)
  ]
});


/***/ }),
/* 30 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


/***/ }),
/* 31 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


/***/ }),
/* 33 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),
/* 35 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var common = __webpack_require__(21);
var Type   = __webpack_require__(26);

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


/***/ }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var common = __webpack_require__(21);
var Type   = __webpack_require__(26);

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


/***/ }),
/* 37 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


/***/ }),
/* 38 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


/***/ }),
/* 39 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = undefined;
  NodeBuffer = __webpack_require__(40).Buffer;
} catch (__) {}

var Type       = __webpack_require__(26);


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


/***/ }),
/* 40 */
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),
/* 41 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


/***/ }),
/* 42 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


/***/ }),
/* 43 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


/***/ }),
/* 44 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.





var Schema = __webpack_require__(25);


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __webpack_require__(24)
  ],
  explicit: [
    __webpack_require__(45),
    __webpack_require__(46),
    __webpack_require__(47)
  ]
});


/***/ }),
/* 45 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


/***/ }),
/* 46 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Type = __webpack_require__(26);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


/***/ }),
/* 47 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = undefined;
  esprima = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'esprima'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(26);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*eslint-disable no-use-before-define*/

var common              = __webpack_require__(21);
var YAMLException       = __webpack_require__(22);
var DEFAULT_FULL_SCHEMA = __webpack_require__(44);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(24);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // - | ? | : | , | [ | ] | { | }
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | # | & | * | ! | | | > | ' | "
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | % | @ | `)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


/***/ }),
/* 49 */
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function(expectation) {
      return `"${literalEscape(expectation.text)}"`;
    },

    "class": function(expectation) {
      var escapedParts = "",
        i;

      for (i = 0; i < expectation.parts.length; i++)
        escapedParts += expectation.parts[i] instanceof Array
          ? `${classEscape(expectation.parts[i][0])}-${classEscape(expectation.parts[i][1])}`
          : classEscape(expectation.parts[i]);


      return `[${expectation.inverted ? "^" : ""}${escapedParts}]`;
    },

    any: function(expectation) {
      return "any character";
    },

    end: function(expectation) {
      return "end of input";
    },

    other: function(expectation) {
      return expectation.description;
    },
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return `\\x0${hex(ch)}`; })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return `\\x${hex(ch)}`; });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return `\\x0${hex(ch)}`; })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return `\\x${hex(ch)}`; });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
      i, j;

    for (i = 0; i < expected.length; i++)
      descriptions[i] = describeExpectation(expected[i]);


    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return `${descriptions[0]} or ${descriptions[1]}`;

      default:
        return `${descriptions.slice(0, -1).join(", ")
        }, or ${
          descriptions[descriptions.length - 1]}`;
    }
  }

  function describeFound(found) {
    return found ? `"${literalEscape(found)}"` : "end of input";
  }

  return `Expected ${describeExpected(expected)} but ${describeFound(found)} found.`;
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

    peg$startRuleFunctions = {Start: peg$parseStart},
    peg$startRuleFunction  = peg$parseStart,

    peg$c0 = function(statements) { return [].concat(...statements); },
    peg$c1 = "-",
    peg$c2 = peg$literalExpectation("-", false),
    peg$c3 = function(value) { return value; },
    peg$c4 = function(statements) { return Object.assign({}, ...statements); },
    peg$c5 = "#",
    peg$c6 = peg$literalExpectation("#", false),
    peg$c7 = peg$anyExpectation(),
    peg$c8 = function() { return {}; },
    peg$c9 = ":",
    peg$c10 = peg$literalExpectation(":", false),
    peg$c11 = function(property, value) { return {[property]: value}; },
    peg$c12 = ",",
    peg$c13 = peg$literalExpectation(",", false),
    peg$c14 = function(property, other) { return other; },
    peg$c15 = function(property, others, value) { return Object.assign({}, ...[property].concat(others).map(property => ({[property]: value}))); },
    peg$c16 = function(statements) { return statements; },
    peg$c17 = function(expression) { return expression; },
    peg$c18 = peg$otherExpectation("correct indentation"),
    peg$c19 = " ",
    peg$c20 = peg$literalExpectation(" ", false),
    peg$c21 = function(spaces) { return spaces.length === indentLevel * INDENT_STEP; },
    peg$c22 = function(spaces) { return spaces.length === (indentLevel + 1) * INDENT_STEP; },
    peg$c23 = function() { indentLevel++; return true; },
    peg$c24 = function() { indentLevel--; return true; },
    peg$c25 = function() { return text(); },
    peg$c26 = peg$otherExpectation("pseudostring"),
    peg$c27 = /^[^\r\n\t ?:,\][{}#&*!|>'"%@`\-]/,
    peg$c28 = peg$classExpectation(["\r", "\n", "\t", " ", "?", ":", ",", "]", "[", "{", "}", "#", "&", "*", "!", "|", ">", "'", "\"", "%", "@", "`", "-"], true, false),
    peg$c29 = /^[^\r\n\t ,\][{}:#"']/,
    peg$c30 = peg$classExpectation(["\r", "\n", "\t", " ", ",", "]", "[", "{", "}", ":", "#", "\"", "'"], true, false),
    peg$c31 = function() { return text().replace(/^ *| *$/g, ''); },
    peg$c32 = "--",
    peg$c33 = peg$literalExpectation("--", false),
    peg$c34 = /^[a-zA-Z\/0-9]/,
    peg$c35 = peg$classExpectation([["a", "z"], ["A", "Z"], "/", ["0", "9"]], false, false),
    peg$c36 = /^[^\r\n\t :,]/,
    peg$c37 = peg$classExpectation(["\r", "\n", "\t", " ", ":", ","], true, false),
    peg$c38 = "null",
    peg$c39 = peg$literalExpectation("null", false),
    peg$c40 = function() { return null; },
    peg$c41 = "true",
    peg$c42 = peg$literalExpectation("true", false),
    peg$c43 = function() { return true; },
    peg$c44 = "false",
    peg$c45 = peg$literalExpectation("false", false),
    peg$c46 = function() { return false; },
    peg$c47 = peg$otherExpectation("string"),
    peg$c48 = "\"",
    peg$c49 = peg$literalExpectation("\"", false),
    peg$c50 = function() { return ""; },
    peg$c51 = function(chars) { return chars; },
    peg$c52 = function(chars) { return chars.join(``); },
    peg$c53 = /^[^"\\\0-\x1F\x7F]/,
    peg$c54 = peg$classExpectation(["\"", "\\", ["\0", "\x1F"], "\x7F"], true, false),
    peg$c55 = "\\\"",
    peg$c56 = peg$literalExpectation("\\\"", false),
    peg$c57 = function() { return `"`; },
    peg$c58 = "\\\\",
    peg$c59 = peg$literalExpectation("\\\\", false),
    peg$c60 = function() { return `\\`; },
    peg$c61 = "\\/",
    peg$c62 = peg$literalExpectation("\\/", false),
    peg$c63 = function() { return `/`;  },
    peg$c64 = "\\b",
    peg$c65 = peg$literalExpectation("\\b", false),
    peg$c66 = function() { return `\b`; },
    peg$c67 = "\\f",
    peg$c68 = peg$literalExpectation("\\f", false),
    peg$c69 = function() { return `\f`; },
    peg$c70 = "\\n",
    peg$c71 = peg$literalExpectation("\\n", false),
    peg$c72 = function() { return `\n`; },
    peg$c73 = "\\r",
    peg$c74 = peg$literalExpectation("\\r", false),
    peg$c75 = function() { return `\r`; },
    peg$c76 = "\\t",
    peg$c77 = peg$literalExpectation("\\t", false),
    peg$c78 = function() { return `\t`; },
    peg$c79 = "\\u",
    peg$c80 = peg$literalExpectation("\\u", false),
    peg$c81 = function(h1, h2, h3, h4) {
      return String.fromCharCode(parseInt(`0x${h1}${h2}${h3}${h4}`));
    },
    peg$c82 = /^[0-9a-fA-F]/,
    peg$c83 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
    peg$c84 = peg$otherExpectation("blank space"),
    peg$c85 = /^[ \t]/,
    peg$c86 = peg$classExpectation([" ", "\t"], false, false),
    peg$c87 = peg$otherExpectation("white space"),
    peg$c88 = /^[ \t\n\r]/,
    peg$c89 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
    peg$c90 = "\r\n",
    peg$c91 = peg$literalExpectation("\r\n", false),
    peg$c92 = "\n",
    peg$c93 = peg$literalExpectation("\n", false),
    peg$c94 = "\r",
    peg$c95 = peg$literalExpectation("\r", false),

    peg$currPos          = 0,
    peg$savedPos         = 0,
    peg$posDetailsCache  = [{line: 1, column: 1}],
    peg$maxFailPos       = 0,
    peg$maxFailExpected  = [],
    peg$silentFails      = 0,

    peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions))
      throw new Error(`Can't start parsing from rule "${options.startRule}".`);


    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return {type: "literal", text: text, ignoreCase: ignoreCase};
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase};
  }

  function peg$anyExpectation() {
    return {type: "any"};
  }

  function peg$endExpectation() {
    return {type: "end"};
  }

  function peg$otherExpectation(description) {
    return {type: "other", description: description};
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p])
        p--;


      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column,
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
      endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column,
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column,
      },
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos)  return;

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseStart() {
    var s0;

    s0 = peg$parsePropertyStatements();

    return s0;
  }

  function peg$parseItemStatements() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseItemStatement();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parseItemStatement();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseItemStatement() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseSamedent();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c1;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c2); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseB();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseExpression();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePropertyStatements() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsePropertyStatement();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsePropertyStatement();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c4(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsePropertyStatement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$parseB();
    if (s1 === peg$FAILED)
      s1 = null;

    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s3 = peg$c5;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c6); }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$currPos;
        s6 = peg$currPos;
        peg$silentFails++;
        s7 = peg$parseEOL();
        peg$silentFails--;
        if (s7 === peg$FAILED) {
          s6 = void 0;
        } else {
          peg$currPos = s6;
          s6 = peg$FAILED;
        }
        if (s6 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c7); }
          }
          if (s7 !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseEOL();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED)
        s2 = null;

      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseEOL_ANY();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseEOL_ANY();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c8();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseSamedent();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseName();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseB();
          if (s3 === peg$FAILED)
            s3 = null;

          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c9;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c10); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseB();
              if (s5 === peg$FAILED)
                s5 = null;

              if (s5 !== peg$FAILED) {
                s6 = peg$parseExpression();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c11(s2, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseSamedent();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseLegacyName();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseB();
            if (s3 === peg$FAILED)
              s3 = null;

            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s4 = peg$c9;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseB();
                if (s5 === peg$FAILED)
                  s5 = null;

                if (s5 !== peg$FAILED) {
                  s6 = peg$parseExpression();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseSamedent();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLegacyName();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseB();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseLegacyLiteral();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseEOL_ANY();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseEOL_ANY();
                    }
                  } else {
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseSamedent();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLegacyName();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$currPos;
                s5 = peg$parseB();
                if (s5 === peg$FAILED)
                  s5 = null;

                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s6 = peg$c12;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c13); }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseB();
                    if (s7 === peg$FAILED)
                      s7 = null;

                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseLegacyName();
                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s4;
                        s5 = peg$c14(s2, s8);
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    s5 = peg$parseB();
                    if (s5 === peg$FAILED)
                      s5 = null;

                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s6 = peg$c12;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c13); }
                      }
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseB();
                        if (s7 === peg$FAILED)
                          s7 = null;

                        if (s7 !== peg$FAILED) {
                          s8 = peg$parseLegacyName();
                          if (s8 !== peg$FAILED) {
                            peg$savedPos = s4;
                            s5 = peg$c14(s2, s8);
                            s4 = s5;
                          } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  }
                } else {
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseB();
                  if (s4 === peg$FAILED)
                    s4 = null;

                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s5 = peg$c9;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c10); }
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseB();
                      if (s6 === peg$FAILED)
                        s6 = null;

                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseExpression();
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c15(s2, s3, s7);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseExpression() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parseEOL();
    if (s3 !== peg$FAILED) {
      s4 = peg$parseExtradent();
      if (s4 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s5 = peg$c1;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c2); }
        }
        if (s5 !== peg$FAILED) {
          s6 = peg$parseB();
          if (s6 !== peg$FAILED) {
            s3 = [s3, s4, s5, s6];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 !== peg$FAILED) {
      peg$currPos = s1;
      s1 = void 0;
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseEOL_ANY();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseIndent();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseItemStatements();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseDedent();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseEOL();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseIndent();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePropertyStatements();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDedent();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c16(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseLiteral();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseEOL_ANY();
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseEOL_ANY();
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c17(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parseSamedent() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (input.charCodeAt(peg$currPos) === 32) {
      s2 = peg$c19;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c21(s1);
      if (s2)
        s2 = void 0;
      else
        s2 = peg$FAILED;

      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c18); }
    }

    return s0;
  }

  function peg$parseExtradent() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (input.charCodeAt(peg$currPos) === 32) {
      s2 = peg$c19;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c20); }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c22(s1);
      if (s2)
        s2 = void 0;
      else
        s2 = peg$FAILED;

      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIndent() {
    var s0;

    peg$savedPos = peg$currPos;
    s0 = peg$c23();
    if (s0)
      s0 = void 0;
    else
      s0 = peg$FAILED;


    return s0;
  }

  function peg$parseDedent() {
    var s0;

    peg$savedPos = peg$currPos;
    s0 = peg$c24();
    if (s0)
      s0 = void 0;
    else
      s0 = peg$FAILED;


    return s0;
  }

  function peg$parseName() {
    var s0;

    s0 = peg$parsestring();
    if (s0 === peg$FAILED)
      s0 = peg$parsepseudostring();


    return s0;
  }

  function peg$parseLegacyName() {
    var s0, s1, s2;

    s0 = peg$parsestring();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsepseudostringLegacy();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsepseudostringLegacy();
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c25();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseLiteral() {
    var s0;

    s0 = peg$parsenull();
    if (s0 === peg$FAILED) {
      s0 = peg$parseboolean();
      if (s0 === peg$FAILED) {
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parsepseudostring();
        }
      }
    }

    return s0;
  }

  function peg$parseLegacyLiteral() {
    var s0;

    s0 = peg$parsenull();
    if (s0 === peg$FAILED) {
      s0 = peg$parsestring();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepseudostringLegacy();
      }
    }

    return s0;
  }

  function peg$parsepseudostring() {
    var s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    if (peg$c27.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseB();
      if (s4 === peg$FAILED)
        s4 = null;

      if (s4 !== peg$FAILED) {
        if (peg$c29.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c30); }
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseB();
        if (s4 === peg$FAILED)
          s4 = null;

        if (s4 !== peg$FAILED) {
          if (peg$c29.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c30); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c31();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c26); }
    }

    return s0;
  }

  function peg$parsepseudostringLegacy() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c32) {
      s1 = peg$c32;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c33); }
    }
    if (s1 === peg$FAILED)
      s1 = null;

    if (s1 !== peg$FAILED) {
      if (peg$c34.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c36.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c36.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c37); }
          }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenull() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c38) {
      s1 = peg$c38;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c40();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseboolean() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4) === peg$c41) {
      s1 = peg$c41;
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c42); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c43();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c44) {
        s1 = peg$c44;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsestring() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c48;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c49); }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c48;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c50();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c48;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsechars();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c48;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c47); }
    }

    return s0;
  }

  function peg$parsechars() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsechar();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsechar();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c52(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsechar() {
    var s0, s1, s2, s3, s4, s5;

    if (peg$c53.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c54); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c55) {
        s1 = peg$c55;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c57();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c58) {
          s1 = peg$c58;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c59); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c60();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c61) {
            s1 = peg$c61;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c64) {
              s1 = peg$c64;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c65); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c67) {
                s1 = peg$c67;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c68); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c69();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c70) {
                  s1 = peg$c70;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c71); }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c72();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c73) {
                    s1 = peg$c73;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c74); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c75();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c76) {
                      s1 = peg$c76;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c77); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c78();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c79) {
                        s1 = peg$c79;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c80); }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parsehexDigit();
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parsehexDigit();
                          if (s3 !== peg$FAILED) {
                            s4 = peg$parsehexDigit();
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsehexDigit();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c81(s2, s3, s4, s5);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsehexDigit() {
    var s0;

    if (peg$c82.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c83); }
    }

    return s0;
  }

  function peg$parseB() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c85.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c86); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c85.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c86); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c84); }
    }

    return s0;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  function peg$parseS() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c88.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c89); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c88.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c89); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c87); }
    }

    return s0;
  }

  // eslint-disable-next-line @typescript-eslint/camelcase
  function peg$parseEOL_ANY() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseEOL();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseB();
      if (s4 === peg$FAILED)
        s4 = null;

      if (s4 !== peg$FAILED) {
        s5 = peg$parseEOL();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseB();
        if (s4 === peg$FAILED)
          s4 = null;

        if (s4 !== peg$FAILED) {
          s5 = peg$parseEOL();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEOL() {
    var s0;

    if (input.substr(peg$currPos, 2) === peg$c90) {
      s0 = peg$c90;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c91); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c92;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c93); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c94;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c95); }
        }
      }
    }

    return s0;
  }


  const INDENT_STEP = 2;

  let indentLevel = 0;


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length)
      peg$fail(peg$endExpectation());


    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse,
};


/***/ }),
/* 50 */
/***/ ((module) => {

"use strict";


const preserveCamelCase = string => {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < string.length; i++) {
		const character = string[i];

		if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
			string = string.slice(0, i) + '-' + string.slice(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
		}
	}

	return string;
};

const camelCase = (input, options) => {
	if (!(typeof input === 'string' || Array.isArray(input))) {
		throw new TypeError('Expected the input to be `string | string[]`');
	}

	options = Object.assign({
		pascalCase: false
	}, options);

	const postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;

	if (Array.isArray(input)) {
		input = input.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		input = input.trim();
	}

	if (input.length === 0) {
		return '';
	}

	if (input.length === 1) {
		return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
	}

	const hasUpperCase = input !== input.toLowerCase();

	if (hasUpperCase) {
		input = preserveCamelCase(input);
	}

	input = input
		.replace(/^[_.\- ]+/, '')
		.toLowerCase()
		.replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase())
		.replace(/\d+(\w|$)/g, m => m.toUpperCase());

	return postProcess(input);
};

module.exports = camelCase;
// TODO: Remove this for the next major release
module.exports.default = camelCase;


/***/ }),
/* 51 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ansiStyles = __webpack_require__(52);
const {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(57);
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = __webpack_require__(61);

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level > 3 || options.level < 0) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!Array.isArray(firstString)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = __webpack_require__(62);
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

// For TypeScript
chalk.Level = {
	None: 0,
	Basic: 1,
	Ansi256: 2,
	TrueColor: 3,
	0: 'None',
	1: 'Basic',
	2: 'Ansi256',
	3: 'TrueColor'
};

module.exports = chalk;


/***/ }),
/* 52 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = __webpack_require__(53);
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});


/***/ }),
/* 53 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(54);
const route = __webpack_require__(56);

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),
/* 54 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(55);

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),
/* 55 */
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),
/* 56 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const conversions = __webpack_require__(54);

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),
/* 57 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(58);
const tty = __webpack_require__(59);
const hasFlag = __webpack_require__(60);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if ('GITHUB_ACTIONS' in env) {
		return 1;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),
/* 58 */
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),
/* 59 */
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),
/* 60 */
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),
/* 61 */
/***/ ((module) => {

"use strict";


const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};


/***/ }),
/* 62 */
/***/ ((module) => {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};


/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var vendors = __webpack_require__(64)

var env = process.env

// Used for testing only
Object.defineProperty(exports, "_vendors", ({
  value: vendors.map(function (v) { return v.constant })
}))

exports.name = null
exports.isPR = null

vendors.forEach(function (vendor) {
  var envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env]
  var isCI = envs.every(function (obj) {
    return checkEnv(obj)
  })

  exports[vendor.constant] = isCI

  if (isCI) {
    exports.name = vendor.name

    switch (typeof vendor.pr) {
      case 'string':
        // "pr": "CIRRUS_PR"
        exports.isPR = !!env[vendor.pr]
        break
      case 'object':
        if ('env' in vendor.pr) {
          // "pr": { "env": "BUILDKITE_PULL_REQUEST", "ne": "false" }
          exports.isPR = vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne
        } else if ('any' in vendor.pr) {
          // "pr": { "any": ["ghprbPullId", "CHANGE_ID"] }
          exports.isPR = vendor.pr.any.some(function (key) {
            return !!env[key]
          })
        } else {
          // "pr": { "DRONE_BUILD_EVENT": "pull_request" }
          exports.isPR = checkEnv(vendor.pr)
        }
        break
      default:
        // PR detection not supported for this vendor
        exports.isPR = null
    }
  }
})

exports.isCI = !!(
  env.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari
  env.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
  env.BUILD_NUMBER || // Jenkins, TeamCity
  env.RUN_ID || // TaskCluster, dsari
  exports.name ||
  false
)

function checkEnv (obj) {
  if (typeof obj === 'string') return !!env[obj]
  return Object.keys(obj).every(function (k) {
    return env[k] === obj[k]
  })
}


/***/ }),
/* 64 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("[{\"name\":\"AppVeyor\",\"constant\":\"APPVEYOR\",\"env\":\"APPVEYOR\",\"pr\":\"APPVEYOR_PULL_REQUEST_NUMBER\"},{\"name\":\"Azure Pipelines\",\"constant\":\"AZURE_PIPELINES\",\"env\":\"SYSTEM_TEAMFOUNDATIONCOLLECTIONURI\",\"pr\":\"SYSTEM_PULLREQUEST_PULLREQUESTID\"},{\"name\":\"Bamboo\",\"constant\":\"BAMBOO\",\"env\":\"bamboo_planKey\"},{\"name\":\"Bitbucket Pipelines\",\"constant\":\"BITBUCKET\",\"env\":\"BITBUCKET_COMMIT\",\"pr\":\"BITBUCKET_PR_ID\"},{\"name\":\"Bitrise\",\"constant\":\"BITRISE\",\"env\":\"BITRISE_IO\",\"pr\":\"BITRISE_PULL_REQUEST\"},{\"name\":\"Buddy\",\"constant\":\"BUDDY\",\"env\":\"BUDDY_WORKSPACE_ID\",\"pr\":\"BUDDY_EXECUTION_PULL_REQUEST_ID\"},{\"name\":\"Buildkite\",\"constant\":\"BUILDKITE\",\"env\":\"BUILDKITE\",\"pr\":{\"env\":\"BUILDKITE_PULL_REQUEST\",\"ne\":\"false\"}},{\"name\":\"CircleCI\",\"constant\":\"CIRCLE\",\"env\":\"CIRCLECI\",\"pr\":\"CIRCLE_PULL_REQUEST\"},{\"name\":\"Cirrus CI\",\"constant\":\"CIRRUS\",\"env\":\"CIRRUS_CI\",\"pr\":\"CIRRUS_PR\"},{\"name\":\"AWS CodeBuild\",\"constant\":\"CODEBUILD\",\"env\":\"CODEBUILD_BUILD_ARN\"},{\"name\":\"Codeship\",\"constant\":\"CODESHIP\",\"env\":{\"CI_NAME\":\"codeship\"}},{\"name\":\"Drone\",\"constant\":\"DRONE\",\"env\":\"DRONE\",\"pr\":{\"DRONE_BUILD_EVENT\":\"pull_request\"}},{\"name\":\"dsari\",\"constant\":\"DSARI\",\"env\":\"DSARI\"},{\"name\":\"GitLab CI\",\"constant\":\"GITLAB\",\"env\":\"GITLAB_CI\"},{\"name\":\"GoCD\",\"constant\":\"GOCD\",\"env\":\"GO_PIPELINE_LABEL\"},{\"name\":\"Hudson\",\"constant\":\"HUDSON\",\"env\":\"HUDSON_URL\"},{\"name\":\"Jenkins\",\"constant\":\"JENKINS\",\"env\":[\"JENKINS_URL\",\"BUILD_ID\"],\"pr\":{\"any\":[\"ghprbPullId\",\"CHANGE_ID\"]}},{\"name\":\"Magnum CI\",\"constant\":\"MAGNUM\",\"env\":\"MAGNUM\"},{\"name\":\"Netlify CI\",\"constant\":\"NETLIFY\",\"env\":\"NETLIFY_BUILD_BASE\",\"pr\":{\"env\":\"PULL_REQUEST\",\"ne\":\"false\"}},{\"name\":\"Sail CI\",\"constant\":\"SAIL\",\"env\":\"SAILCI\",\"pr\":\"SAIL_PULL_REQUEST_NUMBER\"},{\"name\":\"Semaphore\",\"constant\":\"SEMAPHORE\",\"env\":\"SEMAPHORE\",\"pr\":\"PULL_REQUEST_NUMBER\"},{\"name\":\"Shippable\",\"constant\":\"SHIPPABLE\",\"env\":\"SHIPPABLE\",\"pr\":{\"IS_PULL_REQUEST\":\"true\"}},{\"name\":\"Solano CI\",\"constant\":\"SOLANO\",\"env\":\"TDDIUM\",\"pr\":\"TDDIUM_PR_ID\"},{\"name\":\"Strider CD\",\"constant\":\"STRIDER\",\"env\":\"STRIDER\"},{\"name\":\"TaskCluster\",\"constant\":\"TASKCLUSTER\",\"env\":[\"TASK_ID\",\"RUN_ID\"]},{\"name\":\"TeamCity\",\"constant\":\"TEAMCITY\",\"env\":\"TEAMCITY_VERSION\"},{\"name\":\"Travis CI\",\"constant\":\"TRAVIS\",\"env\":\"TRAVIS\",\"pr\":{\"env\":\"TRAVIS_PULL_REQUEST\",\"ne\":\"false\"}}]");

/***/ }),
/* 65 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const pTry = __webpack_require__(66);

const pLimit = concurrency => {
	if (concurrency < 1) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = [];
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.length > 0) {
			queue.shift()();
		}
	};

	const run = (fn, resolve, ...args) => {
		activeCount++;

		const result = pTry(fn, ...args);

		resolve(result);

		result.then(next, next);
	};

	const enqueue = (fn, resolve, ...args) => {
		if (activeCount < concurrency) {
			run(fn, resolve, ...args);
		} else {
			queue.push(run.bind(null, fn, resolve, ...args));
		}
	};

	const generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));
	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.length
		}
	});

	return generator;
};

module.exports = pLimit;
module.exports.default = pLimit;


/***/ }),
/* 66 */
/***/ ((module) => {

"use strict";


module.exports = (callback, ...args) => new Promise(resolve => {
	resolve(callback(...args));
});


/***/ }),
/* 67 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(68)
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: __webpack_require__(69).SEMVER_SPEC_VERSION,
  SemVer: __webpack_require__(71),
  compareIdentifiers: __webpack_require__(72).compareIdentifiers,
  rcompareIdentifiers: __webpack_require__(72).rcompareIdentifiers,
  parse: __webpack_require__(73),
  valid: __webpack_require__(74),
  clean: __webpack_require__(75),
  inc: __webpack_require__(76),
  diff: __webpack_require__(77),
  major: __webpack_require__(80),
  minor: __webpack_require__(81),
  patch: __webpack_require__(82),
  prerelease: __webpack_require__(83),
  compare: __webpack_require__(79),
  rcompare: __webpack_require__(84),
  compareLoose: __webpack_require__(85),
  compareBuild: __webpack_require__(86),
  sort: __webpack_require__(87),
  rsort: __webpack_require__(88),
  gt: __webpack_require__(89),
  lt: __webpack_require__(90),
  eq: __webpack_require__(78),
  neq: __webpack_require__(91),
  gte: __webpack_require__(92),
  lte: __webpack_require__(93),
  cmp: __webpack_require__(94),
  coerce: __webpack_require__(95),
  Comparator: __webpack_require__(96),
  Range: __webpack_require__(97),
  satisfies: __webpack_require__(98),
  toComparators: __webpack_require__(99),
  maxSatisfying: __webpack_require__(100),
  minSatisfying: __webpack_require__(101),
  minVersion: __webpack_require__(102),
  validRange: __webpack_require__(103),
  outside: __webpack_require__(104),
  gtr: __webpack_require__(105),
  ltr: __webpack_require__(106),
  intersects: __webpack_require__(107),
  simplifyRange: __webpack_require__(108),
  subset: __webpack_require__(109),
}


/***/ }),
/* 68 */
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(69)
const debug = __webpack_require__(70)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$')


/***/ }),
/* 69 */
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
}


/***/ }),
/* 70 */
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),
/* 71 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(70)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(69)
const { re, t } = __webpack_require__(68)

const { compareIdentifiers } = __webpack_require__(72)
class SemVer {
  constructor (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),
/* 72 */
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
}


/***/ }),
/* 73 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {MAX_LENGTH} = __webpack_require__(69)
const { re, t } = __webpack_require__(68)
const SemVer = __webpack_require__(71)

const parse = (version, options) => {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),
/* 74 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(73)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),
/* 75 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(73)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),
/* 76 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),
/* 77 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(73)
const eq = __webpack_require__(78)

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),
/* 78 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(79)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),
/* 79 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),
/* 80 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),
/* 81 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),
/* 82 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),
/* 83 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(73)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),
/* 84 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(79)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),
/* 85 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(79)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),
/* 86 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(86)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),
/* 88 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(86)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(79)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),
/* 90 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(79)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),
/* 91 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(79)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),
/* 92 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(79)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),
/* 93 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(79)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),
/* 94 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(78)
const neq = __webpack_require__(91)
const gt = __webpack_require__(89)
const gte = __webpack_require__(92)
const lt = __webpack_require__(90)
const lte = __webpack_require__(93)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),
/* 95 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const parse = __webpack_require__(73)
const {re, t} = __webpack_require__(68)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null)
    return null

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),
/* 96 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const {re, t} = __webpack_require__(68)
const cmp = __webpack_require__(94)
const debug = __webpack_require__(70)
const SemVer = __webpack_require__(71)
const Range = __webpack_require__(97)


/***/ }),
/* 97 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      }
    }

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    const loose = this.options.loose
    range = range.trim()
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range, re[t.COMPARATORTRIM])

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    return range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new Comparator(comp, this.options))
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const Comparator = __webpack_require__(96)
const debug = __webpack_require__(70)
const SemVer = __webpack_require__(71)
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = __webpack_require__(68)

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<')
        pr = '-0'

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),
/* 98 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(97)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),
/* 99 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(97)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),
/* 100 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const Range = __webpack_require__(97)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),
/* 101 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const Range = __webpack_require__(97)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),
/* 102 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const Range = __webpack_require__(97)
const gt = __webpack_require__(89)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(97)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),
/* 104 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(71)
const Comparator = __webpack_require__(96)
const {ANY} = Comparator
const Range = __webpack_require__(97)
const satisfies = __webpack_require__(98)
const gt = __webpack_require__(89)
const lt = __webpack_require__(90)
const lte = __webpack_require__(93)
const gte = __webpack_require__(92)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),
/* 105 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(104)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),
/* 106 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(104)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),
/* 107 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(97)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(98)
const compare = __webpack_require__(79)
module.exports = (versions, range, options) => {
  const set = []
  let min = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!min)
        min = version
    } else {
      if (prev) {
        set.push([min, prev])
      }
      prev = null
      min = null
    }
  }
  if (min)
    set.push([min, null])

  const ranges = []
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min)
    else if (!max && min === v[0])
      ranges.push('*')
    else if (!max)
      ranges.push(`>=${min}`)
    else if (min === v[0])
      ranges.push(`<=${max}`)
    else
      ranges.push(`${min} - ${max}`)
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),
/* 109 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(97)
const { ANY } = __webpack_require__(96)
const satisfies = __webpack_require__(98)
const compare = __webpack_require__(79)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else return false
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
// - If LT
//   - If LT.semver is greater than that of any > comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
// - If any C is a = range, and GT or LT are set, return false
// - Else return true

const subset = (sub, dom, options) => {
  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub.length === 1 && sub[0].semver === ANY)
    return dom.length === 1 && dom[0].semver === ANY

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }
    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),
/* 110 */
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultGlobalFolder": () => /* binding */ getDefaultGlobalFolder,
/* harmony export */   "getHomeFolder": () => /* binding */ getHomeFolder,
/* harmony export */   "isFolderInside": () => /* binding */ isFolderInside
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);


function getDefaultGlobalFolder() {
  if (process.platform === `win32`) {
    const base = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(process.env.LOCALAPPDATA || _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.join((0,os__WEBPACK_IMPORTED_MODULE_0__.homedir)(), `AppData`, `Local`));
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.resolve(base, `Yarn/Berry`);
  }

  if (process.env.XDG_DATA_HOME) {
    const base = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(process.env.XDG_DATA_HOME);
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.resolve(base, `yarn/berry`);
  }

  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.resolve(getHomeFolder(), `.yarn/berry`);
}
function getHomeFolder() {
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath((0,os__WEBPACK_IMPORTED_MODULE_0__.homedir)() || `/usr/local/share`);
}
function isFolderInside(target, parent) {
  const relative = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.relative(parent, target);
  return relative && !relative.startsWith(`..`) && !_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.isAbsolute(relative);
}

/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PortablePath": () => /* binding */ PortablePath,
/* harmony export */   "Filename": () => /* binding */ Filename,
/* harmony export */   "npath": () => /* binding */ npath,
/* harmony export */   "ppath": () => /* binding */ ppath,
/* harmony export */   "convertPath": () => /* binding */ convertPath,
/* harmony export */   "toFilename": () => /* binding */ toFilename
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(113);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);

var PathType;

(function (PathType) {
  PathType[PathType["File"] = 0] = "File";
  PathType[PathType["Portable"] = 1] = "Portable";
  PathType[PathType["Native"] = 2] = "Native";
})(PathType || (PathType = {}));

const PortablePath = {
  root: `/`,
  dot: `.`
};
const Filename = {
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  pnpJs: `.pnp.js`,
  rc: `.yarnrc.yml`
};
const npath = Object.create((path__WEBPACK_IMPORTED_MODULE_0___default()));
const ppath = Object.create((path__WEBPACK_IMPORTED_MODULE_0___default().posix));

npath.cwd = () => process.cwd();

ppath.cwd = () => toPortablePath(process.cwd());

ppath.resolve = (...segments) => {
  if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
    return path__WEBPACK_IMPORTED_MODULE_0___default().posix.resolve(...segments);
  } else {
    return path__WEBPACK_IMPORTED_MODULE_0___default().posix.resolve(ppath.cwd(), ...segments);
  }
};

const contains = function (pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to) return `.`;
  if (!from.endsWith(pathUtils.sep)) from = from + pathUtils.sep;

  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};

npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;

npath.contains = (from, to) => contains(npath, from, to);

ppath.contains = (from, to) => contains(ppath, from, to);

const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\\\\(\.\\)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/; // Path should look like "/N:/berry/scripts/plugin-pack.js"
// And transform to "N:\berry\scripts\plugin-pack.js"

function fromPortablePath(p) {
  if (process.platform !== `win32`) return p;
  if (p.match(PORTABLE_PATH_REGEXP)) p = p.replace(PORTABLE_PATH_REGEXP, `$1`);else if (p.match(UNC_PORTABLE_PATH_REGEXP)) p = p.replace(UNC_PORTABLE_PATH_REGEXP, (match, p1, p2) => `\\\\${p1 ? `.\\` : ``}${p2}`);else return p;
  return p.replace(/\//g, `\\`);
} // Path should look like "N:/berry/scripts/plugin-pack.js"
// And transform to "/N:/berry/scripts/plugin-pack.js"


function toPortablePath(p) {
  if (process.platform !== `win32`) return p;
  if (p.match(WINDOWS_PATH_REGEXP)) p = p.replace(WINDOWS_PATH_REGEXP, `/$1`);else if (p.match(UNC_WINDOWS_PATH_REGEXP)) p = p.replace(UNC_WINDOWS_PATH_REGEXP, (match, p1, p2) => `/unc/${p1 ? `.dot/` : ``}${p2}`);
  return p.replace(/\\/g, `/`);
}

function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}
function toFilename(filename) {
  if (npath.parse(filename).dir !== `` || ppath.parse(filename).dir !== ``) throw new Error(`Invalid filename: "${filename}"`);
  return filename;
}

/***/ }),
/* 113 */
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_COMPRESSION_LEVEL": () => /* binding */ DEFAULT_COMPRESSION_LEVEL,
/* harmony export */   "ZipFS": () => /* binding */ ZipFS
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(116);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(117);
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(119);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(120);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(112);








const DEFAULT_COMPRESSION_LEVEL = `mixed`;
const S_IFMT = 0o170000;
const S_IFDIR = 0o040000;
const S_IFREG = 0o100000;
const S_IFLNK = 0o120000;

class DirEntry {
  constructor() {
    this.name = ``;
    this.mode = 0;
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isDirectory() {
    return (this.mode & S_IFMT) === S_IFDIR;
  }

  isFIFO() {
    return false;
  }

  isFile() {
    return (this.mode & S_IFMT) === S_IFREG;
  }

  isSocket() {
    return false;
  }

  isSymbolicLink() {
    return (this.mode & S_IFMT) === S_IFLNK;
  }

}

class StatEntry {
  constructor() {
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 1;
    this.rdev = 0;
    this.blocks = 1;
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isDirectory() {
    return (this.mode & S_IFMT) === S_IFDIR;
  }

  isFIFO() {
    return false;
  }

  isFile() {
    return (this.mode & S_IFMT) === S_IFREG;
  }

  isSocket() {
    return false;
  }

  isSymbolicLink() {
    return (this.mode & S_IFMT) === S_IFLNK;
  }

}

function makeDefaultStats() {
  return Object.assign(new StatEntry(), {
    uid: 0,
    gid: 0,
    size: 0,
    blksize: 0,
    atimeMs: 0,
    mtimeMs: 0,
    ctimeMs: 0,
    birthtimeMs: 0,
    atime: new Date(0),
    mtime: new Date(0),
    ctime: new Date(0),
    birthtime: new Date(0),
    mode: S_IFREG | 0o644
  });
}

function toUnixTimestamp(time) {
  if (typeof time === `string` && String(+time) === time) return +time; // @ts-ignore

  if (Number.isFinite(time)) {
    if (time < 0) {
      return Date.now() / 1000;
    } else {
      return time;
    }
  } // convert to 123.456 UNIX timestamp


  if ((0,util__WEBPACK_IMPORTED_MODULE_2__.isDate)(time)) return time.getTime() / 1000;
  throw new Error(`Invalid time`);
}

class ZipFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_4__.BasePortableFakeFS {
  constructor(source, opts) {
    super();
    this.lzSource = null;
    this.listings = new Map();
    this.entries = new Map();
    this.fds = new Map();
    this.nextFd = 0;
    this.ready = false;
    this.readOnly = false;
    this.libzip = opts.libzip;
    const pathOptions = opts;
    this.level = typeof pathOptions.level !== `undefined` ? pathOptions.level : DEFAULT_COMPRESSION_LEVEL;

    if (source === null) {
      source = Buffer.from([0x50, 0x4B, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    }

    if (typeof source === `string`) {
      const {
        baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_5__.NodeFS()
      } = pathOptions;
      this.baseFs = baseFs;
      this.path = source;
    } else {
      this.path = null;
      this.baseFs = null;
    }

    if (opts.stats) {
      this.stats = opts.stats;
    } else {
      if (typeof source === `string`) {
        try {
          this.stats = this.baseFs.statSync(source);
        } catch (error) {
          if (error.code === `ENOENT` && pathOptions.create) {
            this.stats = makeDefaultStats();
          } else {
            throw error;
          }
        }
      } else {
        this.stats = makeDefaultStats();
      }
    }

    const errPtr = this.libzip.malloc(4);

    try {
      let flags = 0;
      if (typeof source === `string` && pathOptions.create) flags |= this.libzip.ZIP_CREATE | this.libzip.ZIP_TRUNCATE;

      if (opts.readOnly) {
        flags |= this.libzip.ZIP_RDONLY;
        this.readOnly = true;
      }

      if (typeof source === `string`) {
        this.zip = this.libzip.open(_path__WEBPACK_IMPORTED_MODULE_6__.npath.fromPortablePath(source), flags, errPtr);
      } else {
        const lzSource = this.allocateUnattachedSource(source);

        try {
          this.zip = this.libzip.openFromSource(lzSource, flags, errPtr);
          this.lzSource = lzSource;
        } catch (error) {
          this.libzip.source.free(lzSource);
          throw error;
        }
      }

      if (this.zip === 0) {
        const error = this.libzip.struct.errorS();
        this.libzip.error.initWithCode(error, this.libzip.getValue(errPtr, `i32`));
        throw new Error(this.libzip.error.strerror(error));
      }
    } finally {
      this.libzip.free(errPtr);
    }

    this.listings.set(_path__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root, new Set());
    const entryCount = this.libzip.getNumEntries(this.zip, 0);

    for (let t = 0; t < entryCount; ++t) {
      const raw = this.libzip.getName(this.zip, t, 0);
      if (_path__WEBPACK_IMPORTED_MODULE_6__.ppath.isAbsolute(raw)) continue;
      const p = _path__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root, raw);
      this.registerEntry(p, t); // If the raw path is a directory, register it
      // to prevent empty folder being skipped

      if (raw.endsWith(`/`)) {
        this.registerListing(p);
      }
    }

    this.symlinkCount = this.libzip.ext.countSymlinks(this.zip);
    this.ready = true;
  }

  getExtractHint(hints) {
    for (const fileName of this.entries.keys()) {
      const ext = this.pathUtils.extname(fileName);

      if (hints.relevantExtensions.has(ext)) {
        return true;
      }
    }

    return false;
  }

  getAllFiles() {
    return Array.from(this.entries.keys());
  }

  getRealPath() {
    if (!this.path) throw new Error(`ZipFS don't have real paths when loaded from a buffer`);
    return this.path;
  }

  getBufferAndClose() {
    if (!this.ready) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBUSY(`archive closed, close`);
    if (!this.lzSource) throw new Error(`ZipFS was not created from a Buffer`);

    try {
      // Prevent close from cleaning up the source
      this.libzip.source.keep(this.lzSource); // Close the zip archive

      if (this.libzip.close(this.zip) === -1) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip))); // Open the source for reading

      if (this.libzip.source.open(this.lzSource) === -1) throw new Error(this.libzip.error.strerror(this.libzip.source.error(this.lzSource))); // Move to the end of source

      if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_END) === -1) throw new Error(this.libzip.error.strerror(this.libzip.source.error(this.lzSource))); // Get the size of source

      const size = this.libzip.source.tell(this.lzSource); // Move to the start of source

      if (this.libzip.source.seek(this.lzSource, 0, 0, this.libzip.SEEK_SET) === -1) throw new Error(this.libzip.error.strerror(this.libzip.source.error(this.lzSource)));
      const buffer = this.libzip.malloc(size);
      if (!buffer) throw new Error(`Couldn't allocate enough memory`);

      try {
        const rc = this.libzip.source.read(this.lzSource, buffer, size);
        if (rc === -1) throw new Error(this.libzip.error.strerror(this.libzip.source.error(this.lzSource)));else if (rc < size) throw new Error(`Incomplete read`);else if (rc > size) throw new Error(`Overread`);
        const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
        return Buffer.from(memory);
      } finally {
        this.libzip.free(buffer);
      }
    } finally {
      this.libzip.source.close(this.lzSource);
      this.libzip.source.free(this.lzSource);
      this.ready = false;
    }
  }

  saveAndClose() {
    if (!this.path || !this.baseFs) throw new Error(`ZipFS cannot be saved and must be discarded when loaded from a buffer`);
    if (!this.ready) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBUSY(`archive closed, close`);

    if (this.readOnly) {
      this.discardAndClose();
      return;
    }

    const previousMod = this.baseFs.existsSync(this.path) ? this.baseFs.statSync(this.path).mode & 0o777 : null;
    const rc = this.libzip.close(this.zip);
    if (rc === -1) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip))); // this.libzip overrides the chmod when writing the archive, which is a weird
    // behavior I don't totally understand (plus the umask seems bogus in some
    // weird cases - maybe related to emscripten?)
    //
    // See also https://github.com/nih-at/libzip/issues/77

    if (previousMod === null) this.baseFs.chmodSync(this.path, this.stats.mode);else if (previousMod !== (this.baseFs.statSync(this.path).mode & 0o777)) this.baseFs.chmodSync(this.path, previousMod);
    this.ready = false;
  }

  discardAndClose() {
    if (!this.ready) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBUSY(`archive closed, close`);
    this.libzip.discard(this.zip);
    this.ready = false;
  }

  resolve(p) {
    return _path__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root, p);
  }

  async openPromise(p, flags, mode) {
    return this.openSync(p, flags, mode);
  }

  openSync(p, flags, mode) {
    const fd = this.nextFd++;
    this.fds.set(fd, {
      cursor: 0,
      p
    });
    return fd;
  }

  hasOpenFileHandles() {
    return !!this.fds.size;
  }

  async readPromise(fd, buffer, offset, length, position) {
    return this.readSync(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset = 0, length = 0, position = -1) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBADF(`read`);
    let realPosition;
    if (position === -1 || position === null) realPosition = entry.cursor;else realPosition = position;
    const source = this.readFileSync(entry.p);
    source.copy(buffer, offset, realPosition, realPosition + length);
    const bytesRead = Math.max(0, Math.min(source.length - realPosition, length));
    if (position === -1 || position === null) entry.cursor += bytesRead;
    return bytesRead;
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.writeSync(fd, buffer, position);
    } else {
      return this.writeSync(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBADF(`read`);
    throw new Error(`Unimplemented`);
  }

  async closePromise(fd) {
    return this.closeSync(fd);
  }

  closeSync(fd) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBADF(`read`);
    this.fds.delete(fd);
  }

  createReadStream(p, {
    encoding
  } = {}) {
    if (p === null) throw new Error(`Unimplemented`);
    const stream = Object.assign(new stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough(), {
      bytesRead: 0,
      path: p,
      close: () => {
        clearImmediate(immediate);
      }
    });
    const fd = this.openSync(p, `r`);
    const immediate = setImmediate(() => {
      try {
        const data = this.readFileSync(p, encoding);
        stream.bytesRead = data.length;
        stream.end(data);
        stream.destroy();
      } catch (error) {
        stream.emit(`error`, error);
        stream.end();
        stream.destroy();
      } finally {
        this.closeSync(fd);
      }
    });
    return stream;
  }

  createWriteStream(p, {
    encoding
  } = {}) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`open '${p}'`);
    if (p === null) throw new Error(`Unimplemented`);
    const stream = Object.assign(new stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough(), {
      bytesWritten: 0,
      path: p,
      close: () => {
        stream.end();
      }
    });
    const chunks = [];
    stream.on(`data`, chunk => {
      const chunkBuffer = Buffer.from(chunk);
      stream.bytesWritten += chunkBuffer.length;
      chunks.push(chunkBuffer);
    });
    const fd = this.openSync(p, `w`);
    stream.on(`end`, () => {
      try {
        this.writeFileSync(p, Buffer.concat(chunks), encoding);
      } finally {
        this.closeSync(fd);
      }
    });
    return stream;
  }

  async realpathPromise(p) {
    return this.realpathSync(p);
  }

  realpathSync(p) {
    const resolvedP = this.resolveFilename(`lstat '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOENT(`lstat '${p}'`);
    return resolvedP;
  }

  async existsPromise(p) {
    return this.existsSync(p);
  }

  existsSync(p) {
    if (!this.ready) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBUSY(`archive closed, existsSync '${p}'`);

    if (this.symlinkCount === 0) {
      const resolvedP = _path__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root, p);
      return this.entries.has(resolvedP) || this.listings.has(resolvedP);
    }

    let resolvedP;

    try {
      resolvedP = this.resolveFilename(`stat '${p}'`, p);
    } catch (error) {
      return false;
    }

    return this.entries.has(resolvedP) || this.listings.has(resolvedP);
  }

  async accessPromise(p, mode) {
    return this.accessSync(p, mode);
  }

  accessSync(p, mode = fs__WEBPACK_IMPORTED_MODULE_0__.constants.F_OK) {
    const resolvedP = this.resolveFilename(`access '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOENT(`access '${p}'`);

    if (this.readOnly && mode & fs__WEBPACK_IMPORTED_MODULE_0__.constants.W_OK) {
      throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`access '${p}'`);
    }
  }

  async statPromise(p) {
    return this.statSync(p);
  }

  statSync(p) {
    const resolvedP = this.resolveFilename(`stat '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOENT(`stat '${p}'`);
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOTDIR(`stat '${p}'`);
    return this.statImpl(`stat '${p}'`, resolvedP);
  }

  async lstatPromise(p) {
    return this.lstatSync(p);
  }

  lstatSync(p) {
    const resolvedP = this.resolveFilename(`lstat '${p}'`, p, false);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOENT(`lstat '${p}'`);
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOTDIR(`lstat '${p}'`);
    return this.statImpl(`lstat '${p}'`, resolvedP);
  }

  statImpl(reason, p) {
    const entry = this.entries.get(p); // File, or explicit directory

    if (typeof entry !== `undefined`) {
      const stat = this.libzip.struct.statS();
      const rc = this.libzip.statIndex(this.zip, entry, 0, 0, stat);
      if (rc === -1) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
      const uid = this.stats.uid;
      const gid = this.stats.gid;
      const size = this.libzip.struct.statSize(stat) >>> 0;
      const blksize = 512;
      const blocks = Math.ceil(size / blksize);
      const mtimeMs = (this.libzip.struct.statMtime(stat) >>> 0) * 1000;
      const atimeMs = mtimeMs;
      const birthtimeMs = mtimeMs;
      const ctimeMs = mtimeMs;
      const atime = new Date(atimeMs);
      const birthtime = new Date(birthtimeMs);
      const ctime = new Date(ctimeMs);
      const mtime = new Date(mtimeMs);
      const type = this.listings.has(p) ? S_IFDIR : this.isSymbolicLink(entry) ? S_IFLNK : S_IFREG;
      const defaultMode = type === S_IFDIR ? 0o755 : 0o644;
      const mode = type | this.getUnixMode(entry, defaultMode) & 0o777;
      return Object.assign(new StatEntry(), {
        uid,
        gid,
        size,
        blksize,
        blocks,
        atime,
        birthtime,
        ctime,
        mtime,
        atimeMs,
        birthtimeMs,
        ctimeMs,
        mtimeMs,
        mode
      });
    } // Implicit directory


    if (this.listings.has(p)) {
      const uid = this.stats.uid;
      const gid = this.stats.gid;
      const size = 0;
      const blksize = 512;
      const blocks = 0;
      const atimeMs = this.stats.mtimeMs;
      const birthtimeMs = this.stats.mtimeMs;
      const ctimeMs = this.stats.mtimeMs;
      const mtimeMs = this.stats.mtimeMs;
      const atime = new Date(atimeMs);
      const birthtime = new Date(birthtimeMs);
      const ctime = new Date(ctimeMs);
      const mtime = new Date(mtimeMs);
      const mode = S_IFDIR | 0o755;
      return Object.assign(new StatEntry(), {
        uid,
        gid,
        size,
        blksize,
        blocks,
        atime,
        birthtime,
        ctime,
        mtime,
        atimeMs,
        birthtimeMs,
        ctimeMs,
        mtimeMs,
        mode
      });
    }

    throw new Error(`Unreachable`);
  }

  getUnixMode(index, defaultMode) {
    const rc = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
    if (rc === -1) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
    const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
    if (opsys !== this.libzip.ZIP_OPSYS_UNIX) return defaultMode;
    return this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
  }

  registerListing(p) {
    let listing = this.listings.get(p);
    if (listing) return listing;
    const parentListing = this.registerListing(_path__WEBPACK_IMPORTED_MODULE_6__.ppath.dirname(p));
    listing = new Set();
    parentListing.add(_path__WEBPACK_IMPORTED_MODULE_6__.ppath.basename(p));
    this.listings.set(p, listing);
    return listing;
  }

  registerEntry(p, index) {
    const parentListing = this.registerListing(_path__WEBPACK_IMPORTED_MODULE_6__.ppath.dirname(p));
    parentListing.add(_path__WEBPACK_IMPORTED_MODULE_6__.ppath.basename(p));
    this.entries.set(p, index);
  }

  unregisterListing(p) {
    this.listings.delete(p);
    const parentListing = this.listings.get(_path__WEBPACK_IMPORTED_MODULE_6__.ppath.dirname(p));
    parentListing === null || parentListing === void 0 ? void 0 : parentListing.delete(_path__WEBPACK_IMPORTED_MODULE_6__.ppath.basename(p));
  }

  unregisterEntry(p) {
    this.unregisterListing(p);
    const entry = this.entries.get(p);
    this.entries.delete(p);

    if (entry && this.isSymbolicLink(entry)) {
      this.symlinkCount--;
    }
  }

  resolveFilename(reason, p, resolveLastComponent = true) {
    if (!this.ready) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBUSY(`archive closed, ${reason}`);
    let resolvedP = _path__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root, p);
    if (resolvedP === `/`) return _path__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root;
    const fileIndex = this.entries.get(resolvedP);

    if (resolveLastComponent && fileIndex !== undefined) {
      if (this.symlinkCount !== 0 && this.isSymbolicLink(fileIndex)) {
        const target = this.getFileSource(fileIndex).toString();
        return this.resolveFilename(reason, _path__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_6__.ppath.dirname(resolvedP), target), true);
      } else {
        return resolvedP;
      }
    }

    while (true) {
      const parentP = this.resolveFilename(reason, _path__WEBPACK_IMPORTED_MODULE_6__.ppath.dirname(resolvedP), true);
      const isDir = this.listings.has(parentP);
      const doesExist = this.entries.has(parentP);
      if (!isDir && !doesExist) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOENT(reason);
      if (!isDir) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOTDIR(reason);
      resolvedP = _path__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(parentP, _path__WEBPACK_IMPORTED_MODULE_6__.ppath.basename(resolvedP));
      if (!resolveLastComponent || this.symlinkCount === 0) break;
      const index = this.libzip.name.locate(this.zip, resolvedP.slice(1));
      if (index === -1) break;

      if (this.isSymbolicLink(index)) {
        const target = this.getFileSource(index).toString();
        resolvedP = _path__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(_path__WEBPACK_IMPORTED_MODULE_6__.ppath.dirname(resolvedP), target);
      } else {
        break;
      }
    }

    return resolvedP;
  }

  allocateBuffer(content) {
    if (!Buffer.isBuffer(content)) content = Buffer.from(content);
    const buffer = this.libzip.malloc(content.byteLength);
    if (!buffer) throw new Error(`Couldn't allocate enough memory`); // Copy the file into the Emscripten heap

    const heap = new Uint8Array(this.libzip.HEAPU8.buffer, buffer, content.byteLength);
    heap.set(content);
    return {
      buffer,
      byteLength: content.byteLength
    };
  }

  allocateUnattachedSource(content) {
    const error = this.libzip.struct.errorS();
    const {
      buffer,
      byteLength
    } = this.allocateBuffer(content);
    const source = this.libzip.source.fromUnattachedBuffer(buffer, byteLength, 0, true, error);

    if (source === 0) {
      this.libzip.free(error);
      throw new Error(this.libzip.error.strerror(error));
    }

    return source;
  }

  allocateSource(content) {
    const {
      buffer,
      byteLength
    } = this.allocateBuffer(content);
    const source = this.libzip.source.fromBuffer(this.zip, buffer, byteLength, 0, true);

    if (source === 0) {
      this.libzip.free(buffer);
      throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
    }

    return source;
  }

  setFileSource(p, content) {
    const target = _path__WEBPACK_IMPORTED_MODULE_6__.ppath.relative(_path__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root, p);
    const lzSource = this.allocateSource(content);

    try {
      const newIndex = this.libzip.file.add(this.zip, target, lzSource, this.libzip.ZIP_FL_OVERWRITE);

      if (this.level !== `mixed`) {
        // Use store for level 0, and deflate for 1..9
        let method;
        if (this.level === 0) method = this.libzip.ZIP_CM_STORE;else method = this.libzip.ZIP_CM_DEFLATE;
        const rc = this.libzip.file.setCompression(this.zip, newIndex, 0, method, this.level);

        if (rc === -1) {
          throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
        }
      }

      return newIndex;
    } catch (error) {
      this.libzip.source.free(lzSource);
      throw error;
    }
  }

  isSymbolicLink(index) {
    if (this.symlinkCount === 0) return false;
    const attrs = this.libzip.file.getExternalAttributes(this.zip, index, 0, 0, this.libzip.uint08S, this.libzip.uint32S);
    if (attrs === -1) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
    const opsys = this.libzip.getValue(this.libzip.uint08S, `i8`) >>> 0;
    if (opsys !== this.libzip.ZIP_OPSYS_UNIX) return false;
    const attributes = this.libzip.getValue(this.libzip.uint32S, `i32`) >>> 16;
    return (attributes & S_IFMT) === S_IFLNK;
  }

  getFileSource(index, opts = {
    asyncDecompress: false
  }) {
    const stat = this.libzip.struct.statS();
    const rc = this.libzip.statIndex(this.zip, index, 0, 0, stat);
    if (rc === -1) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
    const size = this.libzip.struct.statCompSize(stat);
    const compressionMethod = this.libzip.struct.statCompMethod(stat);
    const buffer = this.libzip.malloc(size);

    try {
      const file = this.libzip.fopenIndex(this.zip, index, 0, this.libzip.ZIP_FL_COMPRESSED);
      if (file === 0) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));

      try {
        const rc = this.libzip.fread(file, buffer, size, 0);
        if (rc === -1) throw new Error(this.libzip.error.strerror(this.libzip.file.getError(file)));else if (rc < size) throw new Error(`Incomplete read`);else if (rc > size) throw new Error(`Overread`);
        const memory = this.libzip.HEAPU8.subarray(buffer, buffer + size);
        const data = Buffer.from(memory);

        if (compressionMethod === 0) {
          return data;
        } else if (opts.asyncDecompress) {
          return new Promise((resolve, reject) => {
            zlib__WEBPACK_IMPORTED_MODULE_3___default().inflateRaw(data, (error, result) => {
              error ? reject(error) : resolve(result);
            });
          });
        } else {
          return zlib__WEBPACK_IMPORTED_MODULE_3___default().inflateRawSync(data);
        }
      } finally {
        this.libzip.fclose(file);
      }
    } finally {
      this.libzip.free(buffer);
    }
  }

  async chmodPromise(p, mask) {
    return this.chmodSync(p, mask);
  }

  chmodSync(p, mask) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`chmod '${p}'`); // We don't allow to make the extracted entries group-writable

    mask &= 0o755;
    const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
    const entry = this.entries.get(resolvedP);
    if (typeof entry === `undefined`) throw new Error(`Assertion failed: The entry should have been registered (${resolvedP})`);
    const oldMod = this.getUnixMode(entry, S_IFREG | 0o000);
    const newMod = oldMod & ~0o777 | mask;
    const rc = this.libzip.file.setExternalAttributes(this.zip, entry, 0, 0, this.libzip.ZIP_OPSYS_UNIX, newMod << 16);

    if (rc === -1) {
      throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
    }
  }

  async renamePromise(oldP, newP) {
    return this.renameSync(oldP, newP);
  }

  renameSync(oldP, newP) {
    throw new Error(`Unimplemented`);
  }

  async copyFilePromise(sourceP, destP, flags) {
    const {
      indexSource,
      indexDest,
      resolvedDestP
    } = this.prepareCopyFile(sourceP, destP, flags);
    const source = await this.getFileSource(indexSource, {
      asyncDecompress: true
    });
    const newIndex = this.setFileSource(resolvedDestP, source);

    if (newIndex !== indexDest) {
      this.registerEntry(resolvedDestP, newIndex);
    }
  }

  copyFileSync(sourceP, destP, flags = 0) {
    const {
      indexSource,
      indexDest,
      resolvedDestP
    } = this.prepareCopyFile(sourceP, destP, flags);
    const source = this.getFileSource(indexSource);
    const newIndex = this.setFileSource(resolvedDestP, source);

    if (newIndex !== indexDest) {
      this.registerEntry(resolvedDestP, newIndex);
    }
  }

  prepareCopyFile(sourceP, destP, flags = 0) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`copyfile '${sourceP} -> '${destP}'`);
    if ((flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_FICLONE_FORCE) !== 0) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOSYS(`unsupported clone operation`, `copyfile '${sourceP}' -> ${destP}'`);
    const resolvedSourceP = this.resolveFilename(`copyfile '${sourceP} -> ${destP}'`, sourceP);
    const indexSource = this.entries.get(resolvedSourceP);
    if (typeof indexSource === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EINVAL(`copyfile '${sourceP}' -> '${destP}'`);
    const resolvedDestP = this.resolveFilename(`copyfile '${sourceP}' -> ${destP}'`, destP);
    const indexDest = this.entries.get(resolvedDestP);
    if ((flags & (fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL | fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_FICLONE_FORCE)) !== 0 && typeof indexDest !== `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EEXIST(`copyfile '${sourceP}' -> '${destP}'`);
    return {
      indexSource,
      resolvedDestP,
      indexDest
    };
  }

  async appendFilePromise(p, content, opts) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`open '${p}'`);
    if (typeof opts === `undefined`) opts = {
      flag: `a`
    };else if (typeof opts === `string`) opts = {
      flag: `a`,
      encoding: opts
    };else if (typeof opts.flag === `undefined`) opts = {
      flag: `a`,
      ...opts
    };
    return this.writeFilePromise(p, content, opts);
  }

  appendFileSync(p, content, opts = {}) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`open '${p}'`);
    if (typeof opts === `undefined`) opts = {
      flag: `a`
    };else if (typeof opts === `string`) opts = {
      flag: `a`,
      encoding: opts
    };else if (typeof opts.flag === `undefined`) opts = {
      flag: `a`,
      ...opts
    };
    return this.writeFileSync(p, content, opts);
  }

  async writeFilePromise(p, content, opts) {
    const {
      encoding,
      index,
      resolvedP
    } = this.prepareWriteFile(p, opts);
    if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`)) content = Buffer.concat([await this.getFileSource(index, {
      asyncDecompress: true
    }), Buffer.from(content)]);
    if (encoding !== null) content = content.toString(encoding);
    const newIndex = this.setFileSource(resolvedP, content);

    if (newIndex !== index) {
      this.registerEntry(resolvedP, newIndex);
    }
  }

  writeFileSync(p, content, opts) {
    const {
      encoding,
      index,
      resolvedP
    } = this.prepareWriteFile(p, opts);
    if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`)) content = Buffer.concat([this.getFileSource(index), Buffer.from(content)]);
    if (encoding !== null) content = content.toString(encoding);
    const newIndex = this.setFileSource(resolvedP, content);

    if (newIndex !== index) {
      this.registerEntry(resolvedP, newIndex);
    }
  }

  prepareWriteFile(p, opts) {
    if (typeof p !== `string`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBADF(`read`);
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`open '${p}'`);
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EISDIR(`open '${p}'`);
    let encoding = null;
    if (typeof opts === `string`) encoding = opts;else if (typeof opts === `object` && opts.encoding) encoding = opts.encoding;
    const index = this.entries.get(resolvedP);
    return {
      encoding,
      resolvedP,
      index
    };
  }

  async unlinkPromise(p) {
    return this.unlinkSync(p);
  }

  unlinkSync(p) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`unlink '${p}'`);
    const resolvedP = this.resolveFilename(`unlink '${p}'`, p);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EISDIR(`unlink '${p}'`);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EINVAL(`unlink '${p}'`);
    this.libzip.delete(this.zip, index);
    this.unregisterEntry(resolvedP);
  }

  async utimesPromise(p, atime, mtime) {
    return this.utimesSync(p, atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`utimes '${p}'`);
    const resolvedP = this.resolveFilename(`utimes '${p}'`, p);
    this.utimesImpl(resolvedP, mtime);
  }

  async lutimesPromise(p, atime, mtime) {
    return this.lutimesSync(p, atime, mtime);
  }

  lutimesSync(p, atime, mtime) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`lutimes '${p}'`);
    const resolvedP = this.resolveFilename(`utimes '${p}'`, p, false);
    this.utimesImpl(resolvedP, mtime);
  }

  utimesImpl(resolvedP, mtime) {
    if (this.listings.has(resolvedP)) if (!this.entries.has(resolvedP)) this.hydrateDirectory(resolvedP);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    const rc = this.libzip.file.setMtime(this.zip, entry, 0, toUnixTimestamp(mtime), 0);

    if (rc === -1) {
      throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
    }
  }

  async mkdirPromise(p, opts) {
    return this.mkdirSync(p, opts);
  }

  mkdirSync(p, {
    mode = 0o755,
    recursive = false
  } = {}) {
    if (recursive) {
      this.mkdirpSync(p, {
        chmod: mode
      });
      return;
    }

    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`mkdir '${p}'`);
    const resolvedP = this.resolveFilename(`mkdir '${p}'`, p);
    if (this.entries.has(resolvedP) || this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EEXIST(`mkdir '${p}'`);
    this.hydrateDirectory(resolvedP);
    this.chmodSync(resolvedP, mode);
  }

  async rmdirPromise(p) {
    return this.rmdirSync(p);
  }

  rmdirSync(p) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`rmdir '${p}'`);
    const resolvedP = this.resolveFilename(`rmdir '${p}'`, p);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOTDIR(`rmdir '${p}'`);
    if (directoryListing.size > 0) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOTEMPTY(`rmdir '${p}'`);
    const index = this.entries.get(resolvedP);
    if (typeof index === `undefined`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EINVAL(`rmdir '${p}'`);
    this.libzip.delete(this.zip, index);
    this.unregisterEntry(resolvedP);
  }

  hydrateDirectory(resolvedP) {
    const index = this.libzip.dir.add(this.zip, _path__WEBPACK_IMPORTED_MODULE_6__.ppath.relative(_path__WEBPACK_IMPORTED_MODULE_6__.PortablePath.root, resolvedP));
    if (index === -1) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
    this.registerListing(resolvedP);
    this.registerEntry(resolvedP, index);
    return index;
  }

  async symlinkPromise(target, p) {
    return this.symlinkSync(target, p);
  }

  symlinkSync(target, p) {
    if (this.readOnly) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EROFS(`symlink '${target}' -> '${p}'`);
    const resolvedP = this.resolveFilename(`symlink '${target}' -> '${p}'`, p);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EISDIR(`symlink '${target}' -> '${p}'`);
    if (this.entries.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EEXIST(`symlink '${target}' -> '${p}'`);
    const index = this.setFileSource(resolvedP, target);
    this.registerEntry(resolvedP, index);
    const rc = this.libzip.file.setExternalAttributes(this.zip, index, 0, 0, this.libzip.ZIP_OPSYS_UNIX, (S_IFLNK | 0o777) << 16);
    if (rc === -1) throw new Error(this.libzip.error.strerror(this.libzip.getError(this.zip)));
    this.symlinkCount += 1;
  }

  async readFilePromise(p, encoding) {
    // This is messed up regarding the TS signatures
    if (typeof encoding === `object`) // @ts-ignore
      encoding = encoding ? encoding.encoding : undefined;
    const data = await this.readFileBuffer(p, {
      asyncDecompress: true
    });
    return encoding ? data.toString(encoding) : data;
  }

  readFileSync(p, encoding) {
    // This is messed up regarding the TS signatures
    if (typeof encoding === `object`) // @ts-ignore
      encoding = encoding ? encoding.encoding : undefined;
    const data = this.readFileBuffer(p);
    return encoding ? data.toString(encoding) : data;
  }

  readFileBuffer(p, opts = {
    asyncDecompress: false
  }) {
    if (typeof p !== `string`) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EBADF(`read`);
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOENT(`open '${p}'`); // Ensures that the last component is a directory, if the user said so (even if it is we'll throw right after with EISDIR anyway)

    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOTDIR(`open '${p}'`);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EISDIR(`read`);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    return this.getFileSource(entry, opts);
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.readdirSync(p, {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    const resolvedP = this.resolveFilename(`scandir '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOENT(`scandir '${p}'`);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOTDIR(`scandir '${p}'`);
    const entries = [...directoryListing];
    if (!withFileTypes) return entries;
    return entries.map(name => {
      return Object.assign(this.statImpl(`lstat`, _path__WEBPACK_IMPORTED_MODULE_6__.ppath.join(p, name)), {
        name
      });
    });
  }

  async readlinkPromise(p) {
    const entry = this.prepareReadlink(p);
    return (await this.getFileSource(entry, {
      asyncDecompress: true
    })).toString();
  }

  readlinkSync(p) {
    const entry = this.prepareReadlink(p);
    return this.getFileSource(entry).toString();
  }

  prepareReadlink(p) {
    const resolvedP = this.resolveFilename(`readlink '${p}'`, p, false);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOENT(`readlink '${p}'`); // Ensure that the last component is a directory (if it is we'll throw right after with EISDIR anyway)

    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.ENOTDIR(`open '${p}'`);
    if (this.listings.has(resolvedP)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EINVAL(`readlink '${p}'`);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    if (!this.isSymbolicLink(entry)) throw _errors__WEBPACK_IMPORTED_MODULE_7__.EINVAL(`readlink '${p}'`);
    return entry;
  }

  watch(p, a, b) {
    let persistent;

    switch (typeof a) {
      case `function`:
      case `string`:
      case `undefined`:
        {
          persistent = true;
        }
        break;

      default:
        {
          // @ts-ignore
          ({
            persistent = true
          } = a);
        }
        break;
    }

    if (!persistent) return {
      on: () => {},
      close: () => {}
    };
    const interval = setInterval(() => {}, 24 * 60 * 60 * 1000);
    return {
      on: () => {},
      close: () => {
        clearInterval(interval);
      }
    };
  }

}

/***/ }),
/* 115 */
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),
/* 116 */
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FakeFS": () => /* binding */ FakeFS,
/* harmony export */   "BasePortableFakeFS": () => /* binding */ BasePortableFakeFS,
/* harmony export */   "normalizeLineEndings": () => /* binding */ normalizeLineEndings
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _algorithms_copyPromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);



class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }

  async *genTraversePromise(init, {
    stableSort = false
  } = {}) {
    const stack = [init];

    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);

      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);

        if (stableSort) {
          for (const entry of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }

  async removePromise(p, {
    recursive = true
  } = {}) {
    let stat;

    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      if (recursive) for (const entry of await this.readdirPromise(p)) await this.removePromise(this.pathUtils.resolve(p, entry)); // 5 gives 1s worth of retries at worst

      for (let t = 0; t < 5; ++t) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code === `EBUSY` || error.code === `ENOTEMPTY`) {
            await new Promise(resolve => setTimeout(resolve, t * 100));
            continue;
          } else {
            throw error;
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }

  removeSync(p, {
    recursive = true
  } = {}) {
    let stat;

    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      if (recursive) for (const entry of this.readdirSync(p)) this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }

  async mkdirpPromise(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) await this.chmodPromise(subPath, chmod);

        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }

  mkdirpSync(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) this.chmodSync(subPath, chmod);

        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }

  async copyPromise(destination, source, {
    baseFs = this,
    overwrite = true,
    stableSort = false,
    stableTime = false
  } = {}) {
    return await (0,_algorithms_copyPromise__WEBPACK_IMPORTED_MODULE_1__.copyPromise)(this, destination, baseFs, source, {
      overwrite,
      stableSort,
      stableTime
    });
  }

  copySync(destination, source, {
    baseFs = this,
    overwrite = true
  } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);

    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);

      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), {
          baseFs,
          overwrite
        });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync((0,_path__WEBPACK_IMPORTED_MODULE_2__.convertPath)(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }

    const mode = stat.mode & 0o777;
    this.chmodSync(destination, mode);
  }

  async changeFilePromise(p, content, {
    automaticNewlines
  } = {}) {
    let current = ``;

    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {// ignore errors, no big deal
    }

    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent) return;
    await this.writeFilePromise(p, normalizedContent);
  }

  changeFileSync(p, content, {
    automaticNewlines = false
  } = {}) {
    let current = ``;

    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {// ignore errors, no big deal
    }

    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent) return;
    this.writeFileSync(p, normalizedContent);
  }

  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }

  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }

  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1000 / 60;
    const startTime = Date.now();
    let fd = null; // Even when we detect that a lock file exists, we still look inside to see
    // whether the pid that created it is still alive. It's not foolproof
    // (there are false positive), but there are no false negative and that's
    // all that matters in 99% of the cases.

    const isAlive = async () => {
      let pid;

      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        // If we can't read the file repeatedly, we assume the process was
        // aborted before even writing finishing writing the payload.
        return Date.now() - startTime < 500;
      }

      try {
        // "As a special case, a signal of 0 can be used to test for the
        // existence of a process" - so we check whether it's alive.
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };

    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!(await isAlive())) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error) {// No big deal if we can't remove it. Just fallback to wait for
              // it to be eventually released by its owner.
            }
          }

          if (Date.now() - startTime < 60 * 1000) {
            await new Promise(resolve => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }

    await this.writePromise(fd, JSON.stringify([process.pid]));

    try {
      return await callback();
    } finally {
      try {
        // closePromise needs to come before unlinkPromise otherwise another process can attempt
        // to get the file handle after the unlink but before close resuling in
        // EPERM: operation not permitted, open
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {// noop
      }
    }
  }

  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  async writeJsonPromise(p, data) {
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  writeJsonSync(p, data) {
    return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`) p = result;

    if (this.lutimesPromise) {
      await this.lutimesPromise(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      await this.utimesPromise(p, stat.atime, stat.mtime);
    }
  }

  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`) p = result;

    if (this.lutimesSync) {
      this.lutimesSync(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      this.utimesSync(p, stat.atime, stat.mtime);
    }
  }

}
FakeFS.DEFAULT_TIME = 315532800;
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(_path__WEBPACK_IMPORTED_MODULE_2__.ppath);
  }

}

function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null) return os__WEBPACK_IMPORTED_MODULE_0__.EOL;
  const crlf = matches.filter(nl => nl === `\r\n`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r\n` : `\n`;
}

function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copyPromise": () => /* binding */ copyPromise
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);

 // 1980-01-01, like Fedora

const defaultTime = 315532800;
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  await destinationFs.mkdirPromise(destination, {
    recursive: true
  });
  const updateTime = typeof destinationFs.lutimesPromise === `function` ? destinationFs.lutimesPromise.bind(destinationFs) : destinationFs.utimesPromise.bind(destinationFs);
  await copyImpl(prelayout, postlayout, updateTime, destinationFs, normalizedDestination, sourceFs, normalizedSource, opts);

  for (const operation of prelayout) await operation();

  await Promise.all(postlayout.map(operation => {
    return operation();
  }));
}

async function copyImpl(prelayout, postlayout, updateTime, destinationFs, destination, sourceFs, source, opts) {
  const destinationStat = await maybeLStat(destinationFs, destination);
  const sourceStat = await sourceFs.lstatPromise(source);
  if (opts.stableTime) postlayout.push(() => updateTime(destination, defaultTime, defaultTime));else postlayout.push(() => updateTime(destination, sourceStat.atime, sourceStat.mtime));

  switch (true) {
    case sourceStat.isDirectory():
      {
        await copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    case sourceStat.isFile():
      {
        await copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    case sourceStat.isSymbolicLink():
      {
        await copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
      break;
  }

  postlayout.push(() => {
    return destinationFs.chmodPromise(destination, sourceStat.mode & 0o777);
  });
}

async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}

async function copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return;
    }
  }

  if (destinationStat === null) prelayout.push(async () => destinationFs.mkdirPromise(destination, {
    mode: sourceStat.mode
  }));
  const entries = await sourceFs.readdirPromise(source);

  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts);
    }
  } else {
    await Promise.all(entries.map(async entry => {
      await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts);
    }));
  }
}

async function copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return;
    }
  }

  if (destinationFs === sourceFs) {
    prelayout.push(async () => destinationFs.copyFilePromise(source, destination, (fs__WEBPACK_IMPORTED_MODULE_0___default().constants.COPYFILE_FICLONE)));
  } else {
    prelayout.push(async () => destinationFs.writeFilePromise(destination, await sourceFs.readFilePromise(source)));
  }
}

async function copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return;
    }
  }

  const target = await sourceFs.readlinkPromise(source);
  prelayout.push(async () => destinationFs.symlinkPromise((0,_path__WEBPACK_IMPORTED_MODULE_1__.convertPath)(destinationFs.pathUtils, target), destination));
}

/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeFS": () => /* binding */ NodeFS
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(120);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);




class NodeFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_1__.BasePortableFakeFS {
  constructor(realFs = (fs__WEBPACK_IMPORTED_MODULE_0___default())) {
    super();
    this.realFs = realFs; // @ts-ignore

    if (typeof this.realFs.lutimes !== `undefined`) {
      this.lutimesPromise = this.lutimesPromiseImpl;
      this.lutimesSync = this.lutimesSyncImpl;
    }
  }

  getExtractHint() {
    return false;
  }

  getRealPath() {
    return _path__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root;
  }

  resolve(p) {
    return _path__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(p);
  }

  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }

  openSync(p, flags, mode) {
    return this.realFs.openSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), flags, mode);
  }

  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }

  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }

  closeSync(fd) {
    this.realFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    const realPath = p !== null ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }

  createWriteStream(p, opts) {
    const realPath = p !== null ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }

  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then(path => {
      return _path__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path);
    });
  }

  realpathSync(p) {
    return _path__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(this.realFs.realpathSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), {}));
  }

  async existsPromise(p) {
    return await new Promise(resolve => {
      this.realFs.exists(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), resolve);
    });
  }

  accessSync(p, mode) {
    return this.realFs.accessSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), mode);
  }

  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }

  existsSync(p) {
    return this.realFs.existsSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async statPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.stat(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  statSync(p) {
    return this.realFs.statSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async lstatPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.lstat(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  lstatSync(p) {
    return this.realFs.lstatSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }

  chmodSync(p, mask) {
    return this.realFs.chmodSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), mask);
  }

  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(oldP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }

  renameSync(oldP, newP) {
    return this.realFs.renameSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(oldP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(newP));
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(sourceP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(sourceP), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }

  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }

  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  unlinkSync(p) {
    return this.realFs.unlinkSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), atime, mtime);
  }

  async lutimesPromiseImpl(p, atime, mtime) {
    // @ts-ignore: Not yet in DefinitelyTyped
    const lutimes = this.realFs.lutimes;
    if (typeof lutimes === `undefined`) throw (0,_errors__WEBPACK_IMPORTED_MODULE_3__.ENOSYS)(`unavailable Node binding`, `lutimes '${p}'`);
    return await new Promise((resolve, reject) => {
      lutimes.call(this.realFs, _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  lutimesSyncImpl(p, atime, mtime) {
    // @ts-ignore: Not yet in DefinitelyTyped
    const lutimesSync = this.realFs.lutimesSync;
    if (typeof lutimesSync === `undefined`) throw (0,_errors__WEBPACK_IMPORTED_MODULE_3__.ENOSYS)(`unavailable Node binding`, `lutimes '${p}'`);
    lutimesSync.call(this.realFs, _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }

  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), opts);
  }

  async rmdirPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.rmdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  rmdirSync(p) {
    return this.realFs.rmdirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
  }

  async symlinkPromise(target, p, type) {
    const symlinkType = type || (target.endsWith(`/`) ? `dir` : `file`);
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(target.replace(/\/+$/, ``)), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), symlinkType, this.makeCallback(resolve, reject));
    });
  }

  symlinkSync(target, p, type) {
    const symlinkType = type || (target.endsWith(`/`) ? `dir` : `file`);
    return this.realFs.symlinkSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(target.replace(/\/+$/, ``)), _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), symlinkType);
  }

  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }

  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? _path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await new Promise((resolve, reject) => {
      if (withFileTypes) {
        this.realFs.readdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), {
          withFileTypes: true
        }, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(value => resolve(value), reject));
      }
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    if (withFileTypes) {
      return this.realFs.readdirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), {
        withFileTypes: true
      });
    } else {
      return this.realFs.readdirSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p));
    }
  }

  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then(path => {
      return _path__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path);
    });
  }

  readlinkSync(p) {
    return _path__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(this.realFs.readlinkSync(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p)));
  }

  watch(p, a, b) {
    return this.realFs.watch(_path__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(p), // @ts-ignore
    a, b);
  }

  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }

}

/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EBUSY": () => /* binding */ EBUSY,
/* harmony export */   "ENOSYS": () => /* binding */ ENOSYS,
/* harmony export */   "EINVAL": () => /* binding */ EINVAL,
/* harmony export */   "EBADF": () => /* binding */ EBADF,
/* harmony export */   "ENOENT": () => /* binding */ ENOENT,
/* harmony export */   "ENOTDIR": () => /* binding */ ENOTDIR,
/* harmony export */   "EISDIR": () => /* binding */ EISDIR,
/* harmony export */   "EEXIST": () => /* binding */ EEXIST,
/* harmony export */   "EROFS": () => /* binding */ EROFS,
/* harmony export */   "ENOTEMPTY": () => /* binding */ ENOTEMPTY
/* harmony export */ });
function makeError(code, message) {
  return Object.assign(new Error(`${code}: ${message}`), {
    code
  });
}

function EBUSY(message) {
  return makeError(`EBUSY`, message);
}
function ENOSYS(message, reason) {
  return makeError(`ENOSYS`, `${message}, ${reason}`);
}
function EINVAL(reason) {
  return makeError(`EINVAL`, `invalid argument, ${reason}`);
}
function EBADF(reason) {
  return makeError(`EBADF`, `bad file descriptor, ${reason}`);
}
function ENOENT(reason) {
  return makeError(`ENOENT`, `no such file or directory, ${reason}`);
}
function ENOTDIR(reason) {
  return makeError(`ENOTDIR`, `not a directory, ${reason}`);
}
function EISDIR(reason) {
  return makeError(`EISDIR`, `illegal operation on a directory, ${reason}`);
}
function EEXIST(reason) {
  return makeError(`EEXIST`, `file already exists, ${reason}`);
}
function EROFS(reason) {
  return makeError(`EROFS`, `read-only filesystem, ${reason}`);
}
function ENOTEMPTY(reason) {
  return makeError(`ENOTEMPTY`, `directory not empty, ${reason}`);
}

/***/ }),
/* 121 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "escapeRegExp": () => /* binding */ escapeRegExp,
/* harmony export */   "assertNever": () => /* binding */ assertNever,
/* harmony export */   "mapAndFilter": () => /* binding */ mapAndFilter,
/* harmony export */   "mapAndFind": () => /* binding */ mapAndFind,
/* harmony export */   "getFactoryWithDefault": () => /* binding */ getFactoryWithDefault,
/* harmony export */   "getArrayWithDefault": () => /* binding */ getArrayWithDefault,
/* harmony export */   "getSetWithDefault": () => /* binding */ getSetWithDefault,
/* harmony export */   "getMapWithDefault": () => /* binding */ getMapWithDefault,
/* harmony export */   "releaseAfterUseAsync": () => /* binding */ releaseAfterUseAsync,
/* harmony export */   "prettifyAsyncErrors": () => /* binding */ prettifyAsyncErrors,
/* harmony export */   "prettifySyncErrors": () => /* binding */ prettifySyncErrors,
/* harmony export */   "bufferStream": () => /* binding */ bufferStream,
/* harmony export */   "BufferStream": () => /* binding */ BufferStream,
/* harmony export */   "DefaultStream": () => /* binding */ DefaultStream,
/* harmony export */   "dynamicRequire": () => /* binding */ dynamicRequire,
/* harmony export */   "dynamicRequireNoCache": () => /* binding */ dynamicRequireNoCache,
/* harmony export */   "sortMap": () => /* binding */ sortMap,
/* harmony export */   "buildIgnorePattern": () => /* binding */ buildIgnorePattern,
/* harmony export */   "replaceEnvVariables": () => /* binding */ replaceEnvVariables
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(122);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(110);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_2__);
/* module decorator */ module = __webpack_require__.hmd(module);




function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, `\\$&`);
}
function assertNever(arg) {
  throw new Error(`Assertion failed: Unexpected object '${arg}'`);
}
function mapAndFilter(iterable, cb) {
  const output = [];

  for (const value of iterable) {
    const out = cb(value);

    if (out !== mapAndFilterSkip) {
      output.push(out);
    }
  }

  return output;
}
const mapAndFilterSkip = Symbol();
mapAndFilter.skip = mapAndFilterSkip;
function mapAndFind(iterable, cb) {
  for (const value of iterable) {
    const out = cb(value);

    if (out !== mapAndFindSkip) {
      return out;
    }
  }

  return undefined;
}
const mapAndFindSkip = Symbol();
mapAndFind.skip = mapAndFindSkip;
function getFactoryWithDefault(map, key, factory) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = factory());
  return value;
}
function getArrayWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = []);
  return value;
}
function getSetWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = new Set());
  return value;
}
function getMapWithDefault(map, key) {
  let value = map.get(key);
  if (typeof value === `undefined`) map.set(key, value = new Map());
  return value;
} // Executes a chunk of code and calls a cleanup function once it returns (even
// if it throws an exception)

async function releaseAfterUseAsync(fn, cleanup) {
  if (cleanup == null) return await fn();

  try {
    return await fn();
  } finally {
    await cleanup();
  }
} // Executes a chunk of code but slightly modify its exception message if it
// throws something

async function prettifyAsyncErrors(fn, update) {
  try {
    return await fn();
  } catch (error) {
    error.message = update(error.message);
    throw error;
  }
} // Same thing but synchronous

function prettifySyncErrors(fn, update) {
  try {
    return fn();
  } catch (error) {
    error.message = update(error.message);
    throw error;
  }
} // Converts a Node stream into a Buffer instance

async function bufferStream(stream) {
  return await new Promise((resolve, reject) => {
    const chunks = [];
    stream.on(`error`, error => {
      reject(error);
    });
    stream.on(`data`, chunk => {
      chunks.push(chunk);
    });
    stream.on(`end`, () => {
      resolve(Buffer.concat(chunks));
    });
  });
} // A stream implementation that buffers a stream to send it all at once

class BufferStream extends stream__WEBPACK_IMPORTED_MODULE_2__.Transform {
  constructor() {
    super(...arguments);
    this.chunks = [];
  }

  _transform(chunk, encoding, cb) {
    if (encoding !== `buffer` || !Buffer.isBuffer(chunk)) throw new Error(`Assertion failed: BufferStream only accept buffers`);
    this.chunks.push(chunk);
    cb(null, null);
  }

  _flush(cb) {
    cb(null, Buffer.concat(this.chunks));
  }

} // A stream implementation that prints a message if nothing was output

class DefaultStream extends stream__WEBPACK_IMPORTED_MODULE_2__.Transform {
  constructor(ifEmpty = Buffer.alloc(0)) {
    super();
    this.active = true;
    this.ifEmpty = ifEmpty;
  }

  _transform(chunk, encoding, cb) {
    if (encoding !== `buffer` || !Buffer.isBuffer(chunk)) throw new Error(`Assertion failed: DefaultStream only accept buffers`);
    this.active = false;
    cb(null, chunk);
  }

  _flush(cb) {
    if (this.active && this.ifEmpty.length > 0) {
      cb(null, this.ifEmpty);
    }
  }

} // Webpack has this annoying tendency to replace dynamic requires by a stub
// code that simply throws when called. It's all fine and dandy in the context
// of a web application, but is quite annoying when working with Node projects!

function dynamicRequire(path) {
  // @ts-ignore
  if (typeof require !== `undefined`) {
    // @ts-ignore
    return require(path);
  } else {
    return __webpack_require__(139)(path);
  }
}
function dynamicRequireNoCache(path) {
  const physicalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(path);
  const currentCacheEntry = __webpack_require__.c[physicalPath];
  delete __webpack_require__.c[physicalPath];
  let result;

  try {
    result = dynamicRequire(physicalPath);
    const freshCacheEntry = __webpack_require__.c[physicalPath];
    const freshCacheIndex = module.children.indexOf(freshCacheEntry);

    if (freshCacheIndex !== -1) {
      module.children.splice(freshCacheIndex, 1);
    }
  } finally {
    __webpack_require__.c[physicalPath] = currentCacheEntry;
  }

  return result;
} // This function transforms an iterable into an array and sorts it according to
// the mapper functions provided as parameter. The mappers are expected to take
// each element from the iterable and generate a string from it, that will then
// be used to compare the entries.
//
// Using sortMap is more efficient than kinda reimplementing the logic in a sort
// predicate because sortMap caches the result of the mappers in such a way that
// they are guaranteed to be executed exactly once for each element.

function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers)) mappers = [mappers];
  const stringified = [];

  for (const mapper of mappers) stringified.push(asArray.map(value => mapper(value)));

  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? +1 : 0;

      if (comparison !== 0) {
        return comparison;
      }
    }

    return 0;
  });
  return indices.map(index => {
    return asArray[index];
  });
}
/**
 * Combines an Array of glob patterns into a regular expression.
 *
 * @param ignorePatterns An array of glob patterns
 *
 * @returns A `string` representing a regular expression or `null` if no glob patterns are provided
 */

function buildIgnorePattern(ignorePatterns) {
  if (ignorePatterns.length === 0) return null;
  return ignorePatterns.map(pattern => {
    return `(${micromatch__WEBPACK_IMPORTED_MODULE_1___default().makeRe(pattern, {
      // @ts-ignore
      windows: false
    }).source})`;
  }).join(`|`);
}
function replaceEnvVariables(value, {
  env
}) {
  const regex = /\${(?<variableName>[\d\w_]+)(?<colon>:)?-?(?<fallback>[^}]+)?}/g;
  return value.replace(regex, (...args) => {
    const {
      variableName,
      colon,
      fallback
    } = args[args.length - 1];
    const variableExist = Object.prototype.hasOwnProperty.call(env, variableName);
    const variableValue = process.env[variableName];
    if (variableValue) return variableValue;
    if (variableExist && !variableValue && colon) return fallback;
    if (variableExist) return variableValue;
    if (fallback) return fallback;
    throw new clipanion__WEBPACK_IMPORTED_MODULE_0__.UsageError(`Environment variable not found (${variableName})`);
  });
}

/***/ }),
/* 122 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(115);
const braces = __webpack_require__(123);
const picomatch = __webpack_require__(133);
const utils = __webpack_require__(136);
const isEmptyString = val => typeof val === 'string' && (val === '' || val === './');

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} list List of strings to match.
 * @param {String|Array<string>} patterns One or more glob patterns to use for matching.
 * @param {Object} options See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = micromatch(list, patterns, { ...options, onResult });

  for (let item of items) {
    if (!matches.includes(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => {
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

module.exports = micromatch;


/***/ }),
/* 123 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringify = __webpack_require__(124);
const compile = __webpack_require__(126);
const expand = __webpack_require__(130);
const parse = __webpack_require__(131);

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),
/* 124 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(125);

module.exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};


/***/ }),
/* 126 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fill = __webpack_require__(127);
const utils = __webpack_require__(125);

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);
      let range = fill(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),
/* 127 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __webpack_require__(115);
const toRegexRange = __webpack_require__(128);

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),
/* 128 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __webpack_require__(129);

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),
/* 129 */
/***/ ((module) => {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),
/* 130 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fill = __webpack_require__(127);
const stringify = __webpack_require__(124);
const utils = __webpack_require__(125);

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),
/* 131 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringify = __webpack_require__(124);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __webpack_require__(132);

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),
/* 132 */
/***/ ((module) => {

"use strict";


module.exports = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),
/* 133 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(134);


/***/ }),
/* 134 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(113);
const scan = __webpack_require__(135);
const parse = __webpack_require__(138);
const utils = __webpack_require__(136);
const constants = __webpack_require__(137);
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return parsed.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${parsed.output})${append}`;
  if (parsed && parsed.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = parsed;
  }

  return regex;
};

picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  const opts = options || {};
  let parsed = { negated: false, fastpaths: true };
  let prefix = '';
  let output;

  if (input.startsWith('./')) {
    input = input.slice(2);
    prefix = parsed.prefix = './';
  }

  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    output = parse.fastpaths(input, options);
  }

  if (output === undefined) {
    parsed = parse(input, options);
    parsed.prefix = prefix + (parsed.prefix || '');
  } else {
    parsed.output = output;
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),
/* 135 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(136);
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __webpack_require__(137);

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(113);
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __webpack_require__(137);

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};


/***/ }),
/* 137 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(113);
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),
/* 138 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const constants = __webpack_require__(137);
const utils = __webpack_require__(136);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = (opts) => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index];
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };
  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.prev.type === 'bos' && eos()) {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance() || '';
      } else {
        value += advance() || '';
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = (opts) => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),
/* 139 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => [];
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 139;
module.exports = webpackEmptyContext;

/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeIdent": () => /* binding */ makeIdent,
/* harmony export */   "makeDescriptor": () => /* binding */ makeDescriptor,
/* harmony export */   "makeLocator": () => /* binding */ makeLocator,
/* harmony export */   "convertToIdent": () => /* binding */ convertToIdent,
/* harmony export */   "convertDescriptorToLocator": () => /* binding */ convertDescriptorToLocator,
/* harmony export */   "convertLocatorToDescriptor": () => /* binding */ convertLocatorToDescriptor,
/* harmony export */   "convertPackageToLocator": () => /* binding */ convertPackageToLocator,
/* harmony export */   "renamePackage": () => /* binding */ renamePackage,
/* harmony export */   "copyPackage": () => /* binding */ copyPackage,
/* harmony export */   "virtualizeDescriptor": () => /* binding */ virtualizeDescriptor,
/* harmony export */   "virtualizePackage": () => /* binding */ virtualizePackage,
/* harmony export */   "isVirtualDescriptor": () => /* binding */ isVirtualDescriptor,
/* harmony export */   "isVirtualLocator": () => /* binding */ isVirtualLocator,
/* harmony export */   "devirtualizeDescriptor": () => /* binding */ devirtualizeDescriptor,
/* harmony export */   "devirtualizeLocator": () => /* binding */ devirtualizeLocator,
/* harmony export */   "bindDescriptor": () => /* binding */ bindDescriptor,
/* harmony export */   "bindLocator": () => /* binding */ bindLocator,
/* harmony export */   "areIdentsEqual": () => /* binding */ areIdentsEqual,
/* harmony export */   "areDescriptorsEqual": () => /* binding */ areDescriptorsEqual,
/* harmony export */   "areLocatorsEqual": () => /* binding */ areLocatorsEqual,
/* harmony export */   "areVirtualPackagesEquivalent": () => /* binding */ areVirtualPackagesEquivalent,
/* harmony export */   "parseIdent": () => /* binding */ parseIdent,
/* harmony export */   "tryParseIdent": () => /* binding */ tryParseIdent,
/* harmony export */   "parseDescriptor": () => /* binding */ parseDescriptor,
/* harmony export */   "tryParseDescriptor": () => /* binding */ tryParseDescriptor,
/* harmony export */   "parseLocator": () => /* binding */ parseLocator,
/* harmony export */   "tryParseLocator": () => /* binding */ tryParseLocator,
/* harmony export */   "parseRange": () => /* binding */ parseRange,
/* harmony export */   "parseFileStyleRange": () => /* binding */ parseFileStyleRange,
/* harmony export */   "makeRange": () => /* binding */ makeRange,
/* harmony export */   "convertToManifestRange": () => /* binding */ convertToManifestRange,
/* harmony export */   "requirableIdent": () => /* binding */ requirableIdent,
/* harmony export */   "stringifyIdent": () => /* binding */ stringifyIdent,
/* harmony export */   "stringifyDescriptor": () => /* binding */ stringifyDescriptor,
/* harmony export */   "stringifyLocator": () => /* binding */ stringifyLocator,
/* harmony export */   "slugifyIdent": () => /* binding */ slugifyIdent,
/* harmony export */   "slugifyLocator": () => /* binding */ slugifyLocator,
/* harmony export */   "prettyIdent": () => /* binding */ prettyIdent,
/* harmony export */   "prettyRange": () => /* binding */ prettyRange,
/* harmony export */   "prettyDescriptor": () => /* binding */ prettyDescriptor,
/* harmony export */   "prettyReference": () => /* binding */ prettyReference,
/* harmony export */   "prettyLocator": () => /* binding */ prettyLocator,
/* harmony export */   "prettyLocatorNoColors": () => /* binding */ prettyLocatorNoColors,
/* harmony export */   "sortDescriptors": () => /* binding */ sortDescriptors,
/* harmony export */   "prettyWorkspace": () => /* binding */ prettyWorkspace,
/* harmony export */   "getIdentVendorPath": () => /* binding */ getIdentVendorPath
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Configuration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(142);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(121);






const VIRTUAL_PROTOCOL = `virtual:`;
const VIRTUAL_ABBREVIATE = 5;
function makeIdent(scope, name) {
  if (scope === null || scope === void 0 ? void 0 : scope.startsWith(`@`)) throw new Error(`Invalid scope: don't prefix it with '@'`);
  return {
    identHash: _hashUtils__WEBPACK_IMPORTED_MODULE_2__.makeHash(scope, name),
    scope,
    name
  };
}
function makeDescriptor(ident, range) {
  return {
    identHash: ident.identHash,
    scope: ident.scope,
    name: ident.name,
    descriptorHash: _hashUtils__WEBPACK_IMPORTED_MODULE_2__.makeHash(ident.identHash, range),
    range
  };
}
function makeLocator(ident, reference) {
  return {
    identHash: ident.identHash,
    scope: ident.scope,
    name: ident.name,
    locatorHash: _hashUtils__WEBPACK_IMPORTED_MODULE_2__.makeHash(ident.identHash, reference),
    reference
  };
}
function convertToIdent(source) {
  return {
    identHash: source.identHash,
    scope: source.scope,
    name: source.name
  };
}
function convertDescriptorToLocator(descriptor) {
  return {
    identHash: descriptor.identHash,
    scope: descriptor.scope,
    name: descriptor.name,
    locatorHash: descriptor.descriptorHash,
    reference: descriptor.range
  };
}
function convertLocatorToDescriptor(locator) {
  return {
    identHash: locator.identHash,
    scope: locator.scope,
    name: locator.name,
    descriptorHash: locator.locatorHash,
    range: locator.reference
  };
}
function convertPackageToLocator(pkg) {
  return {
    identHash: pkg.identHash,
    scope: pkg.scope,
    name: pkg.name,
    locatorHash: pkg.locatorHash,
    reference: pkg.reference
  };
}
function renamePackage(pkg, locator) {
  return {
    identHash: locator.identHash,
    scope: locator.scope,
    name: locator.name,
    locatorHash: locator.locatorHash,
    reference: locator.reference,
    version: pkg.version,
    languageName: pkg.languageName,
    linkType: pkg.linkType,
    dependencies: new Map(pkg.dependencies),
    peerDependencies: new Map(pkg.peerDependencies),
    dependenciesMeta: new Map(pkg.dependenciesMeta),
    peerDependenciesMeta: new Map(pkg.peerDependenciesMeta),
    bin: new Map(pkg.bin)
  };
}
function copyPackage(pkg) {
  return renamePackage(pkg, pkg);
}
function virtualizeDescriptor(descriptor, entropy) {
  if (entropy.includes(`#`)) throw new Error(`Invalid entropy`);
  return makeDescriptor(descriptor, `virtual:${entropy}#${descriptor.range}`);
}
function virtualizePackage(pkg, entropy) {
  if (entropy.includes(`#`)) throw new Error(`Invalid entropy`);
  return renamePackage(pkg, makeLocator(pkg, `virtual:${entropy}#${pkg.reference}`));
}
function isVirtualDescriptor(descriptor) {
  return descriptor.range.startsWith(VIRTUAL_PROTOCOL);
}
function isVirtualLocator(locator) {
  return locator.reference.startsWith(VIRTUAL_PROTOCOL);
}
function devirtualizeDescriptor(descriptor) {
  if (!isVirtualDescriptor(descriptor)) throw new Error(`Not a virtual descriptor`);
  return makeDescriptor(descriptor, descriptor.range.replace(/^[^#]*#/, ``));
}
function devirtualizeLocator(locator) {
  if (!isVirtualLocator(locator)) throw new Error(`Not a virtual descriptor`);
  return makeLocator(locator, locator.reference.replace(/^[^#]*#/, ``));
}
function bindDescriptor(descriptor, params) {
  if (descriptor.range.includes(`::`)) return descriptor;
  return makeDescriptor(descriptor, `${descriptor.range}::${querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify(params)}`);
}
function bindLocator(locator, params) {
  if (locator.reference.includes(`::`)) return locator;
  return makeLocator(locator, `${locator.reference}::${querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify(params)}`);
}
function areIdentsEqual(a, b) {
  return a.identHash === b.identHash;
}
function areDescriptorsEqual(a, b) {
  return a.descriptorHash === b.descriptorHash;
}
function areLocatorsEqual(a, b) {
  return a.locatorHash === b.locatorHash;
}
/**
 * Virtual packages are considered equivalent when they belong to the same
 * package identity and have the same dependencies. Note that equivalence
 * is not the same as equality, as the references may be different.
 */

function areVirtualPackagesEquivalent(a, b) {
  if (!isVirtualLocator(a)) throw new Error(`Invalid package type`);
  if (!isVirtualLocator(b)) throw new Error(`Invalid package type`);
  if (!areIdentsEqual(a, b)) return false;
  if (a.dependencies.size !== b.dependencies.size) return false;

  for (const dependencyDescriptorA of a.dependencies.values()) {
    const dependencyDescriptorB = b.dependencies.get(dependencyDescriptorA.identHash);
    if (!dependencyDescriptorB) return false;

    if (!areDescriptorsEqual(dependencyDescriptorA, dependencyDescriptorB)) {
      return false;
    }
  }

  return true;
}
function parseIdent(string) {
  const ident = tryParseIdent(string);
  if (!ident) throw new Error(`Invalid ident (${string})`);
  return ident;
}
function tryParseIdent(string) {
  const match = string.match(/^(?:@([^/]+?)\/)?([^/]+)$/);
  if (!match) return null;
  const [, scope, name] = match;
  const realScope = typeof scope !== `undefined` ? scope : null;
  return makeIdent(realScope, name);
}
function parseDescriptor(string, strict = false) {
  const descriptor = tryParseDescriptor(string, strict);
  if (!descriptor) throw new Error(`Invalid descriptor (${string})`);
  return descriptor;
}
function tryParseDescriptor(string, strict = false) {
  const match = strict ? string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/) : string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);
  if (!match) return null;
  const [, scope, name, range] = match;
  if (range === `unknown`) throw new Error(`Invalid range (${string})`);
  const realScope = typeof scope !== `undefined` ? scope : null;
  const realRange = typeof range !== `undefined` ? range : `unknown`;
  return makeDescriptor(makeIdent(realScope, name), realRange);
}
function parseLocator(string, strict = false) {
  const locator = tryParseLocator(string, strict);
  if (!locator) throw new Error(`Invalid locator (${string})`);
  return locator;
}
function tryParseLocator(string, strict = false) {
  const match = strict ? string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/) : string.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);
  if (!match) return null;
  const [, scope, name, reference] = match;
  if (reference === `unknown`) throw new Error(`Invalid reference (${string})`);
  const realScope = typeof scope !== `undefined` ? scope : null;
  const realReference = typeof reference !== `undefined` ? reference : `unknown`;
  return makeLocator(makeIdent(realScope, name), realReference);
}
function parseRange(range, opts) {
  const match = range.match(/^([^#:]*:)?((?:(?!::)[^#])*)(?:#((?:(?!::).)*))?(?:::(.*))?$/);
  if (match === null) throw new Error(`Invalid range (${range})`);
  const protocol = typeof match[1] !== `undefined` ? match[1] : null;
  if (typeof (opts === null || opts === void 0 ? void 0 : opts.requireProtocol) === `string` && protocol !== opts.requireProtocol) throw new Error(`Invalid protocol (${protocol})`);else if ((opts === null || opts === void 0 ? void 0 : opts.requireProtocol) && protocol === null) throw new Error(`Missing protocol (${protocol})`);
  const source = typeof match[3] !== `undefined` ? decodeURIComponent(match[2]) : null;
  if ((opts === null || opts === void 0 ? void 0 : opts.requireSource) && source === null) throw new Error(`Missing source (${range})`);
  const rawSelector = typeof match[3] !== `undefined` ? decodeURIComponent(match[3]) : decodeURIComponent(match[2]);
  const selector = (opts === null || opts === void 0 ? void 0 : opts.parseSelector) ? querystring__WEBPACK_IMPORTED_MODULE_0___default().parse(rawSelector) : rawSelector;
  const params = typeof match[4] !== `undefined` ? querystring__WEBPACK_IMPORTED_MODULE_0___default().parse(match[4]) : null;
  return {
    // @ts-ignore
    protocol,
    // @ts-ignore
    source,
    // @ts-ignore
    selector,
    // @ts-ignore
    params
  };
}
function parseFileStyleRange(range, {
  protocol
}) {
  const {
    selector,
    params
  } = parseRange(range, {
    requireProtocol: protocol,
    requireBindings: true
  });
  if (typeof params.locator !== `string`) throw new Error(`Assertion failed: Invalid bindings for ${range}`);
  const parentLocator = parseLocator(params.locator, true);
  const path = selector;
  return {
    parentLocator,
    path
  };
}

function encodeUnsafeCharacters(str) {
  str = str.replace(/%/g, `%25`);
  str = str.replace(/:/g, `%3A`);
  str = str.replace(/#/g, `%23`);
  return str;
}

function hasParams(params) {
  if (params === null) return false;
  return Object.entries(params).length > 0;
}

function makeRange({
  protocol,
  source,
  selector,
  params
}) {
  let range = ``;
  if (protocol !== null) range += `${protocol}`;
  if (source !== null) range += `${encodeUnsafeCharacters(source)}#`;
  range += encodeUnsafeCharacters(selector);
  if (hasParams(params)) range += `::${querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify(params)}`;
  return range;
}
/**
 * The range used internally may differ from the range stored in the
 * Manifest (package.json). This removes any params indicated for internal use.
 * An internal param starts with "__".
 * @param range range to convert
 */

function convertToManifestRange(range) {
  const {
    params,
    protocol,
    source,
    selector
  } = parseRange(range);

  for (const name in params) if (name.startsWith(`__`)) delete params[name];

  return makeRange({
    protocol,
    source,
    params,
    selector
  });
}
function requirableIdent(ident) {
  if (ident.scope) {
    return `@${ident.scope}/${ident.name}`;
  } else {
    return `${ident.name}`;
  }
}
function stringifyIdent(ident) {
  if (ident.scope) {
    return `@${ident.scope}/${ident.name}`;
  } else {
    return `${ident.name}`;
  }
}
function stringifyDescriptor(descriptor) {
  if (descriptor.scope) {
    return `@${descriptor.scope}/${descriptor.name}@${descriptor.range}`;
  } else {
    return `${descriptor.name}@${descriptor.range}`;
  }
}
function stringifyLocator(locator) {
  if (locator.scope) {
    return `@${locator.scope}/${locator.name}@${locator.reference}`;
  } else {
    return `${locator.name}@${locator.reference}`;
  }
}
function slugifyIdent(ident) {
  if (ident.scope !== null) {
    return `@${ident.scope}-${ident.name}`;
  } else {
    return ident.name;
  }
}
function slugifyLocator(locator) {
  const {
    protocol,
    selector
  } = parseRange(locator.reference);
  const humanProtocol = protocol !== null ? protocol.replace(/:$/, ``) : `exotic`;
  const humanVersion = semver__WEBPACK_IMPORTED_MODULE_1___default().valid(selector);
  const humanReference = humanVersion !== null ? `${humanProtocol}-${humanVersion}` : `${humanProtocol}`; // 10 hex characters means that 47 different entries have 10^-9 chances of
  // causing a hash collision. Since this hash is joined with the package name
  // (making it highly unlikely you'll have more than a handful of instances
  // of any single package), this should provide a good enough guard in most
  // cases.
  //
  // Also note that eCryptfs eats some bytes, so the theoretical maximum for a
  // file size is around 140 bytes (but we don't need as much, as explained).

  const hashTruncate = 10;
  const slug = locator.scope ? `${slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}` : `${slugifyIdent(locator)}-${humanReference}-${locator.locatorHash.slice(0, hashTruncate)}`;
  return (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.toFilename)(slug);
}
function prettyIdent(configuration, ident) {
  if (ident.scope) {
    return `${configuration.format(`@${ident.scope}/`, _Configuration__WEBPACK_IMPORTED_MODULE_4__.FormatType.SCOPE)}${configuration.format(ident.name, _Configuration__WEBPACK_IMPORTED_MODULE_4__.FormatType.NAME)}`;
  } else {
    return `${configuration.format(ident.name, _Configuration__WEBPACK_IMPORTED_MODULE_4__.FormatType.NAME)}`;
  }
}

function prettyRangeNoColors(range) {
  if (range.startsWith(VIRTUAL_PROTOCOL)) {
    const nested = prettyRangeNoColors(range.substr(range.indexOf(`#`) + 1));
    const abbrev = range.substr(VIRTUAL_PROTOCOL.length, VIRTUAL_ABBREVIATE); // I'm not satisfied of how the virtual packages appear in the output
    // eslint-disable-next-line no-constant-condition

    return false ? undefined : `${nested} [${abbrev}]`;
  } else {
    return range.replace(/\?.*/, `?[...]`);
  }
}

function prettyRange(configuration, range) {
  return `${configuration.format(prettyRangeNoColors(range), _Configuration__WEBPACK_IMPORTED_MODULE_4__.FormatType.RANGE)}`;
}
function prettyDescriptor(configuration, descriptor) {
  return `${prettyIdent(configuration, descriptor)}${configuration.format(`@`, _Configuration__WEBPACK_IMPORTED_MODULE_4__.FormatType.RANGE)}${prettyRange(configuration, descriptor.range)}`;
}
function prettyReference(configuration, reference) {
  return `${configuration.format(prettyRangeNoColors(reference), _Configuration__WEBPACK_IMPORTED_MODULE_4__.FormatType.REFERENCE)}`;
}
function prettyLocator(configuration, locator) {
  return `${prettyIdent(configuration, locator)}${configuration.format(`@`, _Configuration__WEBPACK_IMPORTED_MODULE_4__.FormatType.REFERENCE)}${prettyReference(configuration, locator.reference)}`;
}
function prettyLocatorNoColors(locator) {
  return `${stringifyIdent(locator)}@${prettyRangeNoColors(locator.reference)}`;
}
function sortDescriptors(descriptors) {
  return _miscUtils__WEBPACK_IMPORTED_MODULE_5__.sortMap(descriptors, [descriptor => stringifyIdent(descriptor), descriptor => descriptor.range]);
}
function prettyWorkspace(configuration, workspace) {
  return prettyIdent(configuration, workspace.locator);
}
/**
 * The presence of a `node_modules` directory in the path is extremely common
 * in the JavaScript ecosystem to denote whether a path belongs to a vendor
 * or not. I considered using a more generic path for packages that aren't
 * always JS-only (such as when using the Git fetcher), but that unfortunately
 * caused various JS apps to start showing errors when working with git repos.
 *
 * As a result, all packages from all languages will follow this convention. At
 * least it'll be consistent, and linkers will always have the ability to remap
 * them to a different location if that's a critical requirement.
 */

function getIdentVendorPath(ident) {
  return `node_modules/${requirableIdent(ident)}`;
}

/***/ }),
/* 141 */
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeHash": () => /* binding */ makeHash,
/* harmony export */   "checksumFile": () => /* binding */ checksumFile,
/* harmony export */   "checksumPattern": () => /* binding */ checksumPattern
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(144);
/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(globby__WEBPACK_IMPORTED_MODULE_1__);



function makeHash(...args) {
  const hash = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)(`sha512`);

  for (const arg of args) hash.update(arg ? arg : ``);

  return hash.digest(`hex`);
}
function checksumFile(path) {
  return new Promise((resolve, reject) => {
    const hash = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)(`sha512`);
    const stream = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.createReadStream(path);
    stream.on(`data`, chunk => {
      hash.update(chunk);
    });
    stream.on(`error`, error => {
      reject(error);
    });
    stream.on(`end`, () => {
      resolve(hash.digest(`hex`));
    });
  });
}
async function checksumPattern(pattern, {
  cwd
}) {
  // Note: We use a two-pass glob instead of using the expandDirectories option
  // from globby, because the native implementation is broken.
  //
  // Ref: https://github.com/sindresorhus/globby/issues/147
  const dirListing = await globby__WEBPACK_IMPORTED_MODULE_1___default()(pattern, {
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(cwd),
    expandDirectories: false,
    onlyDirectories: true,
    unique: true
  });
  const dirPatterns = dirListing.map(entry => {
    return `${entry}/**/*`;
  });
  const listing = await globby__WEBPACK_IMPORTED_MODULE_1___default()([pattern, ...dirPatterns], {
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(cwd),
    expandDirectories: false,
    onlyFiles: false,
    unique: true
  });
  listing.sort();
  const hashes = await Promise.all(listing.map(async entry => {
    const parts = [Buffer.from(entry)];
    const p = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(entry);
    const stat = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.lstatPromise(p);
    if (stat.isSymbolicLink()) parts.push(Buffer.from(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.readlinkPromise(p)));else if (stat.isFile()) parts.push(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.readFilePromise(p));
    return parts.join(`\u0000`);
  }));
  const hash = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)(`sha512`);

  for (const sub of hashes) hash.update(sub);

  return hash.digest(`hex`);
}

/***/ }),
/* 143 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),
/* 144 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(6);
const arrayUnion = __webpack_require__(145);
const merge2 = __webpack_require__(146);
const fastGlob = __webpack_require__(147);
const dirGlob = __webpack_require__(200);
const gitignore = __webpack_require__(202);
const {FilterStream, UniqueStream} = __webpack_require__(205);

const DEFAULT_FILTER = () => false;

const isNegative = pattern => pattern[0] === '!';

const assertPatternsInput = patterns => {
	if (!patterns.every(pattern => typeof pattern === 'string')) {
		throw new TypeError('Patterns must be a string or an array of strings');
	}
};

const checkCwdOption = (options = {}) => {
	if (!options.cwd) {
		return;
	}

	let stat;
	try {
		stat = fs.statSync(options.cwd);
	} catch (_) {
		return;
	}

	if (!stat.isDirectory()) {
		throw new Error('The `cwd` option must be a path to a directory');
	}
};

const getPathString = p => p.stats instanceof fs.Stats ? p.path : p;

const generateGlobTasks = (patterns, taskOptions) => {
	patterns = arrayUnion([].concat(patterns));
	assertPatternsInput(patterns);
	checkCwdOption(taskOptions);

	const globTasks = [];

	taskOptions = {
		ignore: [],
		expandDirectories: true,
		...taskOptions
	};

	for (const [index, pattern] of patterns.entries()) {
		if (isNegative(pattern)) {
			continue;
		}

		const ignore = patterns
			.slice(index)
			.filter(isNegative)
			.map(pattern => pattern.slice(1));

		const options = {
			...taskOptions,
			ignore: taskOptions.ignore.concat(ignore)
		};

		globTasks.push({pattern, options});
	}

	return globTasks;
};

const globDirs = (task, fn) => {
	let options = {};
	if (task.options.cwd) {
		options.cwd = task.options.cwd;
	}

	if (Array.isArray(task.options.expandDirectories)) {
		options = {
			...options,
			files: task.options.expandDirectories
		};
	} else if (typeof task.options.expandDirectories === 'object') {
		options = {
			...options,
			...task.options.expandDirectories
		};
	}

	return fn(task.pattern, options);
};

const getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];

const getFilterSync = options => {
	return options && options.gitignore ?
		gitignore.sync({cwd: options.cwd, ignore: options.ignore}) :
		DEFAULT_FILTER;
};

const globToTask = task => glob => {
	const {options} = task;
	if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
		options.ignore = dirGlob.sync(options.ignore);
	}

	return {
		pattern: glob,
		options
	};
};

module.exports = async (patterns, options) => {
	const globTasks = generateGlobTasks(patterns, options);

	const getFilter = async () => {
		return options && options.gitignore ?
			gitignore({cwd: options.cwd, ignore: options.ignore}) :
			DEFAULT_FILTER;
	};

	const getTasks = async () => {
		const tasks = await Promise.all(globTasks.map(async task => {
			const globs = await getPattern(task, dirGlob);
			return Promise.all(globs.map(globToTask(task)));
		}));

		return arrayUnion(...tasks);
	};

	const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
	const paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));

	return arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));
};

module.exports.sync = (patterns, options) => {
	const globTasks = generateGlobTasks(patterns, options);

	const tasks = globTasks.reduce((tasks, task) => {
		const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
		return tasks.concat(newTask);
	}, []);

	const filter = getFilterSync(options);

	return tasks.reduce(
		(matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.options)),
		[]
	).filter(path_ => !filter(path_));
};

module.exports.stream = (patterns, options) => {
	const globTasks = generateGlobTasks(patterns, options);

	const tasks = globTasks.reduce((tasks, task) => {
		const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
		return tasks.concat(newTask);
	}, []);

	const filter = getFilterSync(options);
	const filterStream = new FilterStream(p => !filter(p));
	const uniqueStream = new UniqueStream();

	return merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))
		.pipe(filterStream)
		.pipe(uniqueStream);
};

module.exports.generateGlobTasks = generateGlobTasks;

module.exports.hasMagic = (patterns, options) => []
	.concat(patterns)
	.some(pattern => fastGlob.isDynamicPattern(pattern, options));

module.exports.gitignore = gitignore;


/***/ }),
/* 145 */
/***/ ((module) => {

"use strict";


module.exports = (...arguments_) => {
	return [...new Set([].concat(...arguments_))];
};


/***/ }),
/* 146 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2016 Teambition
 * Licensed under the MIT license.
 */
const Stream = __webpack_require__(110)
const PassThrough = Stream.PassThrough
const slice = Array.prototype.slice

module.exports = merge2

function merge2 () {
  const streamsQueue = []
  let merging = false
  const args = slice.call(arguments)
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) args.pop()
  else options = {}

  const doEnd = options.end !== false
  if (options.objectMode == null) options.objectMode = true
  if (options.highWaterMark == null) options.highWaterMark = 64 * 1024
  const mergedStream = PassThrough(options)

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options))
    }
    mergeStream()
    return this
  }

  function mergeStream () {
    if (merging) return
    merging = true

    let streams = streamsQueue.shift()
    if (!streams) {
      process.nextTick(endStream)
      return
    }
    if (!Array.isArray(streams)) streams = [streams]

    let pipesCount = streams.length + 1

    function next () {
      if (--pipesCount > 0) return
      merging = false
      mergeStream()
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend)
        stream.removeListener('end', onend)
        next()
      }
      // skip ended stream
      if (stream._readableState.endEmitted) return next()

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)
      stream.pipe(mergedStream, { end: false })
      // compatible for old stream
      stream.resume()
    }

    for (let i = 0; i < streams.length; i++) pipe(streams[i])

    next()
  }

  function endStream () {
    merging = false
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain')
    return doEnd && mergedStream.end()
  }

  mergedStream.setMaxListeners(0)
  mergedStream.add = addStream
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd')
  })

  if (args.length) addStream.apply(null, args)
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) streams = streams.pipe(PassThrough(options))
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause()
  } else {
    for (let i = 0, len = streams.length; i < len; i++) streams[i] = pauseStreams(streams[i], options)
  }
  return streams
}


/***/ }),
/* 147 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const taskManager = __webpack_require__(148);
const async_1 = __webpack_require__(160);
const stream_1 = __webpack_require__(196);
const sync_1 = __webpack_require__(197);
const settings_1 = __webpack_require__(199);
const utils = __webpack_require__(149);
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
module.exports = FastGlob;


/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(149);
function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
exports.generate = generate;
function convertPatternsToTasks(positive, negative, dynamic) {
    const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
    // When we have a global group  there is no reason to divide the patterns into independent tasks.
    // In this case, the global task covers the rest.
    if ('.' in positivePatternsGroup) {
        const task = convertPatternGroupToTask('.', positive, negative, dynamic);
        return [task];
    }
    return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
}
exports.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
}
exports.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
}
exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        }
        else {
            collection[base] = [pattern];
        }
        return collection;
    }, group);
}
exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
}
exports.convertPatternGroupToTask = convertPatternGroupToTask;


/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const array = __webpack_require__(150);
exports.array = array;
const errno = __webpack_require__(151);
exports.errno = errno;
const fs = __webpack_require__(152);
exports.fs = fs;
const path = __webpack_require__(153);
exports.path = path;
const pattern = __webpack_require__(154);
exports.pattern = pattern;
const stream = __webpack_require__(158);
exports.stream = stream;
const string = __webpack_require__(159);
exports.string = string;


/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
}
exports.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        }
        else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
exports.splitWhen = splitWhen;


/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
exports.isEnoentCodeError = isEnoentCodeError;


/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(113);
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
exports.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path.resolve(cwd, filepath);
}
exports.makeAbsolute = makeAbsolute;
function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
exports.escape = escape;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
exports.removeLeadingDotSegment = removeLeadingDotSegment;


/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(113);
const globParent = __webpack_require__(155);
const micromatch = __webpack_require__(122);
const picomatch = __webpack_require__(133);
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
const BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
exports.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    return false;
}
exports.isDynamicPattern = isDynamicPattern;
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
exports.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
exports.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
exports.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
exports.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
exports.getNegativePatterns = getNegativePatterns;
function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
}
exports.getPositivePatterns = getPositivePatterns;
function getBaseDirectory(pattern) {
    return globParent(pattern, { flipBackslashes: false });
}
exports.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
exports.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
    });
}
exports.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    const info = picomatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    // See micromatch/picomatch#58 for more details
    if (info.parts.length === 0) {
        return [pattern];
    }
    return info.parts;
}
exports.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
exports.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
}
exports.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
}
exports.matchAny = matchAny;


/***/ }),
/* 155 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isGlob = __webpack_require__(156);
var pathPosixDirname = __webpack_require__(113).posix.dirname;
var isWin32 = __webpack_require__(58).platform() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\/]*.*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 */
module.exports = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};


/***/ }),
/* 156 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = __webpack_require__(157);
var chars = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};


/***/ }),
/* 157 */
/***/ ((module) => {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};


/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const merge2 = __webpack_require__(146);
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
        stream.once('error', (error) => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
}
exports.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit('close'));
}


/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function isEmpty(input) {
    return input === '';
}
exports.isEmpty = isEmpty;


/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(161);
const provider_1 = __webpack_require__(189);
class ProviderAsync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
            const stream = this.api(root, task, options);
            stream.once('error', reject);
            stream.on('data', (entry) => entries.push(options.transform(entry)));
            stream.once('end', () => resolve(entries));
        });
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderAsync;


/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(110);
const fsStat = __webpack_require__(162);
const fsWalk = __webpack_require__(167);
const reader_1 = __webpack_require__(188);
class ReaderStream extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
                .then((entry) => {
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            })
                .catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath)
            .then((stats) => this._makeEntry(stats, pattern))
            .catch((error) => {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
exports.default = ReaderStream;


/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async = __webpack_require__(163);
const sync = __webpack_require__(164);
const settings_1 = __webpack_require__(165);
exports.Settings = settings_1.default;
function stat(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return async.read(path, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.stat = stat;
function statSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.statSync = statSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function read(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
            return callFailureCallback(callback, lstatError);
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            return callSuccessCallback(callback, lstat);
        }
        settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    return callFailureCallback(callback, statError);
                }
                return callSuccessCallback(callback, lstat);
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = () => true;
            }
            callSuccessCallback(callback, stat);
        });
    });
}
exports.read = read;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function read(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
        }
        return stat;
    }
    catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
exports.read = read;


/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(166);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(6);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __webpack_require__(168);
const stream_1 = __webpack_require__(184);
const sync_1 = __webpack_require__(185);
const settings_1 = __webpack_require__(187);
exports.Settings = settings_1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
exports.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
}
exports.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
}
exports.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __webpack_require__(169);
class AsyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = new Set();
    }
    read(callback) {
        this._reader.onError((error) => {
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
            this._storage.add(entry);
        });
        this._reader.onEnd(() => {
            callSuccessCallback(callback, [...this._storage]);
        });
        this._reader.read();
    }
}
exports.default = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}


/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(170);
const fsScandir = __webpack_require__(171);
const fastq = __webpack_require__(180);
const common = __webpack_require__(182);
const reader_1 = __webpack_require__(183);
class AsyncReader extends reader_1.default {
    constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
            if (error !== null) {
                return done(error, undefined);
            }
            for (const entry of entries) {
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
exports.default = AsyncReader;


/***/ }),
/* 170 */
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async = __webpack_require__(172);
const sync = __webpack_require__(177);
const settings_1 = __webpack_require__(178);
exports.Settings = settings_1.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return async.read(path, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.scandirSync = scandirSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(162);
const rpl = __webpack_require__(173);
const constants_1 = __webpack_require__(174);
const utils = __webpack_require__(175);
function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings, callback);
    }
    return readdir(directory, settings, callback);
}
exports.read = read;
function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
            return callFailureCallback(callback, readdirError);
        }
        const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
        }));
        if (!settings.followSymbolicLinks) {
            return callSuccessCallback(callback, entries);
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
                return callFailureCallback(callback, rplError);
            }
            callSuccessCallback(callback, rplEntries);
        });
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function makeRplTaskEntry(entry, settings) {
    return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
            return done(null, entry);
        }
        settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    return done(statError);
                }
                return done(null, entry);
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            return done(null, entry);
        });
    };
}
function readdir(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
            return callFailureCallback(callback, readdirError);
        }
        const filepaths = names.map((name) => `${directory}${settings.pathSegmentSeparator}${name}`);
        const tasks = filepaths.map((filepath) => {
            return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
        });
        rpl(tasks, (rplError, results) => {
            if (rplError !== null) {
                return callFailureCallback(callback, rplError);
            }
            const entries = [];
            names.forEach((name, index) => {
                const stats = results[index];
                const entry = {
                    name,
                    path: filepaths[index],
                    dirent: utils.fs.createDirentFromStats(name, stats)
                };
                if (settings.stats) {
                    entry.stats = stats;
                }
                entries.push(entry);
            });
            callSuccessCallback(callback, entries);
        });
    });
}
exports.readdir = readdir;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),
/* 173 */
/***/ ((module) => {

module.exports = runParallel

function runParallel (tasks, cb) {
  var results, pending, keys
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}


/***/ }),
/* 174 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
const MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;


/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(176);
exports.fs = fs;


/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(162);
const constants_1 = __webpack_require__(174);
const utils = __webpack_require__(175);
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
exports.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
        const entry = {
            dirent,
            name: dirent.name,
            path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            }
            catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
        const entryPath = `${directory}${settings.pathSegmentSeparator}${name}`;
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
exports.readdir = readdir;


/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(113);
const fsStat = __webpack_require__(162);
const fs = __webpack_require__(179);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(6);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),
/* 180 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reusify = __webpack_require__(181)

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  var cache = reusify(Task)
  var queueHead = null
  var queueTail = null
  var _running = 0

  var self = {
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain
  }

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true
  }

  function length () {
    var current = queueHead
    var counter = 0

    while (current) {
      current = current.next
      counter++
    }

    return counter
  }

  function resume () {
    if (!self.paused) return
    self.paused = false
    for (var i = 0; i < self.concurrency; i++) {
      _running++
      release()
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current
        queueTail = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function unshift (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead
        queueHead = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder)
    }
    var next = queueHead
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null
        }
        queueHead = next.next
        next.next = null
        worker.call(context, next.value, next.worked)
        if (queueTail === null) {
          self.empty()
        }
      } else {
        _running--
      }
    } else if (--_running === 0) {
      self.drain()
    }
  }

  function kill () {
    queueHead = null
    queueTail = null
    self.drain = noop
  }

  function killAndDrain () {
    queueHead = null
    queueTail = null
    self.drain()
    self.drain = noop
  }
}

function noop () {}

function Task () {
  this.value = null
  this.callback = noop
  this.next = null
  this.release = noop
  this.context = null

  var self = this

  this.worked = function worked (err, result) {
    var callback = self.callback
    self.value = null
    self.callback = noop
    callback.call(self.context, err, result)
    self.release(self)
  }
}

module.exports = fastqueue


/***/ }),
/* 181 */
/***/ ((module) => {

"use strict";


function reusify (Constructor) {
  var head = new Constructor()
  var tail = head

  function get () {
    var current = head

    if (current.next) {
      head = current.next
    } else {
      head = new Constructor()
      tail = head
    }

    current.next = null

    return current
  }

  function release (obj) {
    tail.next = obj
    tail = obj
  }

  return {
    get: get,
    release: release
  }
}

module.exports = reusify


/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
exports.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
exports.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[\\/]/).join(separator);
}
exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),
/* 183 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common = __webpack_require__(182);
class Reader {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
exports.default = Reader;


/***/ }),
/* 184 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(110);
const async_1 = __webpack_require__(169);
class StreamProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
            objectMode: true,
            read: () => { },
            destroy: this._reader.destroy.bind(this._reader)
        });
    }
    read() {
        this._reader.onError((error) => {
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry) => {
            this._stream.push(entry);
        });
        this._reader.onEnd(() => {
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
exports.default = StreamProvider;


/***/ }),
/* 185 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __webpack_require__(186);
class SyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
exports.default = SyncProvider;


/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsScandir = __webpack_require__(171);
const common = __webpack_require__(182);
const reader_1 = __webpack_require__(183);
class SyncReader extends reader_1.default {
    constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = new Set();
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return [...this._storage];
    }
    _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
    }
    _handleQueue() {
        for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
                this._handleEntry(entry, base);
            }
        }
        catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.add(entry);
    }
}
exports.default = SyncReader;


/***/ }),
/* 187 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(113);
const fsScandir = __webpack_require__(171);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Infinity);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 188 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(113);
const fsStat = __webpack_require__(162);
const utils = __webpack_require__(149);
class Reader {
    constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
exports.default = Reader;


/***/ }),
/* 189 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(113);
const deep_1 = __webpack_require__(190);
const entry_1 = __webpack_require__(193);
const error_1 = __webpack_require__(194);
const entry_2 = __webpack_require__(195);
class Provider {
    constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
exports.default = Provider;


/***/ }),
/* 190 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(149);
const partial_1 = __webpack_require__(191);
class DeepFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        const depth = this._getEntryLevel(basePath, entry.path);
        if (this._isSkippedByDeep(depth)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(entryDepth) {
        return entryDepth >= this._settings.deep;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _getEntryLevel(basePath, entryPath) {
        const basePathDepth = basePath.split('/').length;
        const entryPathDepth = entryPath.split('/').length;
        return entryPathDepth - (basePath === '' ? 0 : basePathDepth);
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, negativeRe) {
        return !utils.pattern.matchAny(entryPath, negativeRe);
    }
}
exports.default = DeepFilter;


/***/ }),
/* 191 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const matcher_1 = __webpack_require__(192);
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */
            if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index) => {
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
exports.default = PartialMatcher;


/***/ }),
/* 192 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(149);
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        /**
         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
         * So, before expand patterns with brace expansion into separated patterns.
         */
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
}
exports.default = Matcher;


/***/ }),
/* 193 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(149);
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique) {
            if (this._isDuplicateEntry(entry)) {
                return false;
            }
            this._createIndexRecord(entry);
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry, negativeRe)) {
            return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        return this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
    }
    _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
        this.index.set(entry.path, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entry, negativeRe) {
        if (!this._settings.absolute) {
            return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entry.path);
        return this._isMatchToPatterns(fullpath, negativeRe);
    }
    _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe);
    }
}
exports.default = EntryFilter;


/***/ }),
/* 194 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(149);
class ErrorFilter {
    constructor(_settings) {
        this._settings = _settings;
    }
    getFilter() {
        return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
exports.default = ErrorFilter;


/***/ }),
/* 195 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(149);
class EntryTransformer {
    constructor(_settings) {
        this._settings = _settings;
    }
    getTransformer() {
        return (entry) => this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
    }
}
exports.default = EntryTransformer;


/***/ }),
/* 196 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(110);
const stream_2 = __webpack_require__(161);
const provider_1 = __webpack_require__(189);
class ProviderStream extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });
        source
            .once('error', (error) => destination.emit('error', error))
            .on('data', (entry) => destination.emit('data', options.transform(entry)))
            .once('end', () => destination.emit('end'));
        destination
            .once('close', () => source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderStream;


/***/ }),
/* 197 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __webpack_require__(198);
const provider_1 = __webpack_require__(189);
class ProviderSync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderSync;


/***/ }),
/* 198 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(162);
const fsWalk = __webpack_require__(167);
const reader_1 = __webpack_require__(188);
class ReaderSync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        }
        catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
exports.default = ReaderSync;


/***/ }),
/* 199 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(6);
const os = __webpack_require__(58);
const CPU_COUNT = os.cpus().length;
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports.default = Settings;


/***/ }),
/* 200 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(113);
const pathType = __webpack_require__(201);

const getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];

const getPath = (filepath, cwd) => {
	const pth = filepath[0] === '!' ? filepath.slice(1) : filepath;
	return path.isAbsolute(pth) ? pth : path.join(cwd, pth);
};

const addExtensions = (file, extensions) => {
	if (path.extname(file)) {
		return `**/${file}`;
	}

	return `**/${file}.${getExtensions(extensions)}`;
};

const getGlob = (directory, options) => {
	if (options.files && !Array.isArray(options.files)) {
		throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
	}

	if (options.extensions && !Array.isArray(options.extensions)) {
		throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
	}

	if (options.files && options.extensions) {
		return options.files.map(x => path.posix.join(directory, addExtensions(x, options.extensions)));
	}

	if (options.files) {
		return options.files.map(x => path.posix.join(directory, `**/${x}`));
	}

	if (options.extensions) {
		return [path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
	}

	return [path.posix.join(directory, '**')];
};

module.exports = async (input, options) => {
	options = {
		cwd: process.cwd(),
		...options
	};

	if (typeof options.cwd !== 'string') {
		throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
	}

	const globs = await Promise.all([].concat(input).map(async x => {
		const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
		return isDirectory ? getGlob(x, options) : x;
	}));

	return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};

module.exports.sync = (input, options) => {
	options = {
		cwd: process.cwd(),
		...options
	};

	if (typeof options.cwd !== 'string') {
		throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
	}

	const globs = [].concat(input).map(x => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);

	return [].concat.apply([], globs); // eslint-disable-line prefer-spread
};


/***/ }),
/* 201 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const {promisify} = __webpack_require__(115);
const fs = __webpack_require__(6);

async function isType(fsStatType, statsMethodName, filePath) {
	if (typeof filePath !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof filePath}`);
	}

	try {
		const stats = await promisify(fs[fsStatType])(filePath);
		return stats[statsMethodName]();
	} catch (error) {
		if (error.code === 'ENOENT') {
			return false;
		}

		throw error;
	}
}

function isTypeSync(fsStatType, statsMethodName, filePath) {
	if (typeof filePath !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof filePath}`);
	}

	try {
		return fs[fsStatType](filePath)[statsMethodName]();
	} catch (error) {
		if (error.code === 'ENOENT') {
			return false;
		}

		throw error;
	}
}

exports.isFile = isType.bind(null, 'stat', 'isFile');
exports.isDirectory = isType.bind(null, 'stat', 'isDirectory');
exports.isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink');
exports.isFileSync = isTypeSync.bind(null, 'statSync', 'isFile');
exports.isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory');
exports.isSymlinkSync = isTypeSync.bind(null, 'lstatSync', 'isSymbolicLink');


/***/ }),
/* 202 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {promisify} = __webpack_require__(115);
const fs = __webpack_require__(6);
const path = __webpack_require__(113);
const fastGlob = __webpack_require__(147);
const gitIgnore = __webpack_require__(203);
const slash = __webpack_require__(204);

const DEFAULT_IGNORE = [
	'**/node_modules/**',
	'**/flow-typed/**',
	'**/coverage/**',
	'**/.git'
];

const readFileP = promisify(fs.readFile);

const mapGitIgnorePatternTo = base => ignore => {
	if (ignore.startsWith('!')) {
		return '!' + path.posix.join(base, ignore.slice(1));
	}

	return path.posix.join(base, ignore);
};

const parseGitIgnore = (content, options) => {
	const base = slash(path.relative(options.cwd, path.dirname(options.fileName)));

	return content
		.split(/\r?\n/)
		.filter(Boolean)
		.filter(line => !line.startsWith('#'))
		.map(mapGitIgnorePatternTo(base));
};

const reduceIgnore = files => {
	return files.reduce((ignores, file) => {
		ignores.add(parseGitIgnore(file.content, {
			cwd: file.cwd,
			fileName: file.filePath
		}));
		return ignores;
	}, gitIgnore());
};

const ensureAbsolutePathForCwd = (cwd, p) => {
	cwd = slash(cwd);
	if (path.isAbsolute(p)) {
		if (p.startsWith(cwd)) {
			return p;
		}

		throw new Error(`Path ${p} is not in cwd ${cwd}`);
	}

	return path.join(cwd, p);
};

const getIsIgnoredPredecate = (ignores, cwd) => {
	return p => ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p))));
};

const getFile = async (file, cwd) => {
	const filePath = path.join(cwd, file);
	const content = await readFileP(filePath, 'utf8');

	return {
		cwd,
		filePath,
		content
	};
};

const getFileSync = (file, cwd) => {
	const filePath = path.join(cwd, file);
	const content = fs.readFileSync(filePath, 'utf8');

	return {
		cwd,
		filePath,
		content
	};
};

const normalizeOptions = ({
	ignore = [],
	cwd = slash(process.cwd())
} = {}) => {
	return {ignore, cwd};
};

module.exports = async options => {
	options = normalizeOptions(options);

	const paths = await fastGlob('**/.gitignore', {
		ignore: DEFAULT_IGNORE.concat(options.ignore),
		cwd: options.cwd
	});

	const files = await Promise.all(paths.map(file => getFile(file, options.cwd)));
	const ignores = reduceIgnore(files);

	return getIsIgnoredPredecate(ignores, options.cwd);
};

module.exports.sync = options => {
	options = normalizeOptions(options);

	const paths = fastGlob.sync('**/.gitignore', {
		ignore: DEFAULT_IGNORE.concat(options.ignore),
		cwd: options.cwd
	});

	const files = paths.map(file => getFileSync(file, options.cwd));
	const ignores = reduceIgnore(files);

	return getIsIgnoredPredecate(ignores, options.cwd);
};


/***/ }),
/* 203 */
/***/ ((module) => {

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const REGEX_TEST_BLANK_LINE = /^\s+$/
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
const REGEX_SPLITALL_CRLF = /\r?\n/g
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

const SLASH = '/'
const KEY_IGNORE = typeof Symbol !== 'undefined'
  ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore'

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : ''
)

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? ' '
      : ''
  ],

  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => ' '
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\^$.|*+(){]/g,
    match => `\\${match}`
  ],

  [
    // > [abc] matches any character inside the brackets
    // >    (in this case a, b, or c);
    /\[([^\]/]*)($|\])/g,
    (match, p1, p2) => p2 === ']'
      ? `[${sanitizeRange(p1)}]`
      : `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule
    /(^|[^\\]+)\\\*(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1) => `${p1}[^\\/]*`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match ''
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*'

      return `${prefix}(?=$|\\/$)`
    }
  ],

  [
    // unescape
    /\\\\\\/g,
    () => '\\'
  ]
]

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null)

// @param {pattern}
const makeRegex = (pattern, negative, ignorecase) => {
  const r = regexCache[pattern]
  if (r) {
    return r
  }

  // const replacers = negative
  //   ? NEGATIVE_REPLACERS
  //   : POSITIVE_REPLACERS

  const source = REPLACERS.reduce(
    (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
    pattern
  )

  return regexCache[pattern] = ignorecase
    ? new RegExp(source, 'i')
    : new RegExp(source)
}

const isString = subject => typeof subject === 'string'

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin
    this.pattern = pattern
    this.negative = negative
    this.regex = regex
  }
}

const createRule = (pattern, ignorecase) => {
  const origin = pattern
  let negative = false

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')

  const regex = makeRegex(pattern, negative, ignorecase)

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
}

const throwError = (message, Ctor) => {
  throw new Ctor(message)
}

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore '', so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d'
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
}

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)

checkPath.isNotRelative = isNotRelative
checkPath.convert = p => p

class Ignore {
  constructor ({
    ignorecase = true
  } = {}) {
    this._rules = []
    this._ignorecase = ignorecase
    define(this, KEY_IGNORE, true)
    this._initCache()
  }

  _initCache () {
    this._ignoreCache = Object.create(null)
    this._testCache = Object.create(null)
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignorecase)
      this._added = true
      this._rules.push(rule)
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this)

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache()
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false
    let unignored = false

    this._rules.forEach(rule => {
      const {negative} = rule
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path)

      if (matched) {
        ignored = !negative
        unignored = negative
      }
    })

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath)

    checkPath(path, originalPath, throwError)

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH)
    }

    slices.pop()

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    )

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options)

const returnFalse = () => false

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, returnFalse)

factory.isPathValid = isPathValid

// Fixes typescript
factory.default = factory

module.exports = factory

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/')

  checkPath.convert = makePosix

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path)
}


/***/ }),
/* 204 */
/***/ ((module) => {

"use strict";

module.exports = path => {
	const isExtendedLengthPath = /^\\\\\?\\/.test(path);
	const hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex

	if (isExtendedLengthPath || hasNonAscii) {
		return path;
	}

	return path.replace(/\\/g, '/');
};


/***/ }),
/* 205 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {Transform} = __webpack_require__(110);

class ObjectTransform extends Transform {
	constructor() {
		super({
			objectMode: true
		});
	}
}

class FilterStream extends ObjectTransform {
	constructor(filter) {
		super();
		this._filter = filter;
	}

	_transform(data, encoding, callback) {
		if (this._filter(data)) {
			this.push(data);
		}

		callback();
	}
}

class UniqueStream extends ObjectTransform {
	constructor() {
		super();
		this._pushed = new Set();
	}

	_transform(data, encoding, callback) {
		if (!this._pushed.has(data)) {
			this.push(data);
			this._pushed.add(data);
		}

		callback();
	}
}

module.exports = {
	FilterStream,
	UniqueStream
};


/***/ }),
/* 206 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizeLineEndings": () => /* reexport safe */ _FakeFS__WEBPACK_IMPORTED_MODULE_2__.normalizeLineEndings,
/* harmony export */   "DEFAULT_COMPRESSION_LEVEL": () => /* reexport safe */ _ZipFS__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_COMPRESSION_LEVEL,
/* harmony export */   "PortablePath": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_4__.PortablePath,
/* harmony export */   "Filename": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_4__.Filename,
/* harmony export */   "npath": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_4__.npath,
/* harmony export */   "ppath": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_4__.ppath,
/* harmony export */   "toFilename": () => /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_4__.toFilename,
/* harmony export */   "AliasFS": () => /* reexport safe */ _AliasFS__WEBPACK_IMPORTED_MODULE_5__.AliasFS,
/* harmony export */   "FakeFS": () => /* reexport safe */ _FakeFS__WEBPACK_IMPORTED_MODULE_2__.FakeFS,
/* harmony export */   "CwdFS": () => /* reexport safe */ _CwdFS__WEBPACK_IMPORTED_MODULE_6__.CwdFS,
/* harmony export */   "JailFS": () => /* reexport safe */ _JailFS__WEBPACK_IMPORTED_MODULE_7__.JailFS,
/* harmony export */   "LazyFS": () => /* reexport safe */ _LazyFS__WEBPACK_IMPORTED_MODULE_8__.LazyFS,
/* harmony export */   "NoFS": () => /* reexport safe */ _NoFS__WEBPACK_IMPORTED_MODULE_9__.NoFS,
/* harmony export */   "NodeFS": () => /* reexport safe */ _NodeFS__WEBPACK_IMPORTED_MODULE_10__.NodeFS,
/* harmony export */   "PosixFS": () => /* reexport safe */ _PosixFS__WEBPACK_IMPORTED_MODULE_11__.PosixFS,
/* harmony export */   "ProxiedFS": () => /* reexport safe */ _ProxiedFS__WEBPACK_IMPORTED_MODULE_12__.ProxiedFS,
/* harmony export */   "VirtualFS": () => /* reexport safe */ _VirtualFS__WEBPACK_IMPORTED_MODULE_13__.VirtualFS,
/* harmony export */   "ZipFS": () => /* reexport safe */ _ZipFS__WEBPACK_IMPORTED_MODULE_3__.ZipFS,
/* harmony export */   "ZipOpenFS": () => /* reexport safe */ _ZipOpenFS__WEBPACK_IMPORTED_MODULE_14__.ZipOpenFS,
/* harmony export */   "patchFs": () => /* binding */ patchFs,
/* harmony export */   "extendFs": () => /* binding */ extendFs,
/* harmony export */   "xfs": () => /* binding */ xfs
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(119);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(117);
/* harmony import */ var _ZipFS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(114);
/* harmony import */ var _AliasFS__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(207);
/* harmony import */ var _CwdFS__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(209);
/* harmony import */ var _JailFS__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(210);
/* harmony import */ var _LazyFS__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(211);
/* harmony import */ var _NoFS__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(212);
/* harmony import */ var _PosixFS__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(213);
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(208);
/* harmony import */ var _VirtualFS__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(214);
/* harmony import */ var _ZipOpenFS__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(215);





















function getTempName(prefix) {
  const tmpdir = _path__WEBPACK_IMPORTED_MODULE_4__.npath.toPortablePath(os__WEBPACK_IMPORTED_MODULE_0___default().tmpdir());
  const hash = Math.ceil(Math.random() * 0x100000000).toString(16).padStart(8, `0`);
  return _path__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tmpdir, `${prefix}${hash}`);
}

function patchFs(patchedFs, fakeFs) {
  const SYNC_IMPLEMENTATIONS = new Set([`accessSync`, `appendFileSync`, `createReadStream`, `chmodSync`, `closeSync`, `copyFileSync`, `lstatSync`, `lutimesSync`, `mkdirSync`, `openSync`, `readSync`, `readlinkSync`, `readFileSync`, `readdirSync`, `readlinkSync`, `realpathSync`, `renameSync`, `rmdirSync`, `statSync`, `symlinkSync`, `unlinkSync`, `utimesSync`, `watch`, `writeFileSync`, `writeSync`]);
  const ASYNC_IMPLEMENTATIONS = new Set([`accessPromise`, `appendFilePromise`, `chmodPromise`, `closePromise`, `copyFilePromise`, `lstatPromise`, `lutimesPromise`, `mkdirPromise`, `openPromise`, `readdirPromise`, `realpathPromise`, `readFilePromise`, `readdirPromise`, `readlinkPromise`, `renamePromise`, `rmdirPromise`, `statPromise`, `symlinkPromise`, `unlinkPromise`, `utimesPromise`, `writeFilePromise`, `writeSync`]);
  const FILEHANDLE_IMPLEMENTATIONS = new Set([`appendFilePromise`, `chmodPromise`, `chownPromise`, `closePromise`, `readPromise`, `readFilePromise`, `statPromise`, `utimesPromise`, `writePromise`, `writeFilePromise`]);

  const setupFn = (target, name, replacement) => {
    const orig = target[name];
    target[name] = replacement;

    if (typeof (orig === null || orig === void 0 ? void 0 : orig[util__WEBPACK_IMPORTED_MODULE_1__.promisify.custom]) !== `undefined`) {
      replacement[util__WEBPACK_IMPORTED_MODULE_1__.promisify.custom] = orig[util__WEBPACK_IMPORTED_MODULE_1__.promisify.custom];
    }
  };
  /** Callback implementations */


  {
    setupFn(patchedFs, `exists`, (p, ...args) => {
      const hasCallback = typeof args[args.length - 1] === `function`;
      const callback = hasCallback ? args.pop() : () => {};
      process.nextTick(() => {
        fakeFs.existsPromise(p).then(exists => {
          callback(exists);
        }, () => {
          callback(false);
        });
      });
    });
    setupFn(patchedFs, `read`, (p, buffer, ...args) => {
      const hasCallback = typeof args[args.length - 1] === `function`;
      const callback = hasCallback ? args.pop() : () => {};
      process.nextTick(() => {
        fakeFs.readPromise(p, buffer, ...args).then(bytesRead => {
          callback(null, bytesRead, buffer);
        }, error => {
          callback(error);
        });
      });
    });

    for (const fnName of ASYNC_IMPLEMENTATIONS) {
      const origName = fnName.replace(/Promise$/, ``);
      if (typeof patchedFs[origName] === `undefined`) continue;
      const fakeImpl = fakeFs[fnName];
      if (typeof fakeImpl === `undefined`) continue;

      const wrapper = (...args) => {
        const hasCallback = typeof args[args.length - 1] === `function`;
        const callback = hasCallback ? args.pop() : () => {};
        process.nextTick(() => {
          fakeImpl.apply(fakeFs, args).then(result => {
            callback(null, result);
          }, error => {
            callback(error);
          });
        });
      };

      setupFn(patchedFs, origName, wrapper);
    }

    patchedFs.realpath.native = patchedFs.realpath;
  }
  /** Sync implementations */

  {
    setupFn(patchedFs, `existsSync`, p => {
      try {
        return fakeFs.existsSync(p);
      } catch (error) {
        return false;
      }
    });

    for (const fnName of SYNC_IMPLEMENTATIONS) {
      const origName = fnName;
      if (typeof patchedFs[origName] === `undefined`) continue;
      const fakeImpl = fakeFs[fnName];
      if (typeof fakeImpl === `undefined`) continue;
      setupFn(patchedFs, origName, fakeImpl.bind(fakeFs));
    }

    patchedFs.realpathSync.native = patchedFs.realpathSync;
  }
  /** Promise implementations */

  {
    // `fs.promises` is a getter that returns a reference to require(`fs/promises`),
    // so we can just patch `fs.promises` and both will be updated
    const origEmitWarning = process.emitWarning;

    process.emitWarning = () => {};

    let patchedFsPromises;

    try {
      patchedFsPromises = patchedFs.promises;
    } finally {
      process.emitWarning = origEmitWarning;
    }

    if (typeof patchedFsPromises !== `undefined`) {
      // `fs.promises.exists` doesn't exist
      for (const fnName of ASYNC_IMPLEMENTATIONS) {
        const origName = fnName.replace(/Promise$/, ``);
        if (typeof patchedFsPromises[origName] === `undefined`) continue;
        const fakeImpl = fakeFs[fnName];
        if (typeof fakeImpl === `undefined`) continue; // Open is a bit particular with fs.promises: it returns a file handle
        // instance instead of the traditional file descriptor number

        if (fnName === `open`) continue;
        setupFn(patchedFsPromises, origName, fakeImpl.bind(fakeFs));
      }

      class FileHandle {
        constructor(fd) {
          this.fd = fd;
        }

      }

      for (const fnName of FILEHANDLE_IMPLEMENTATIONS) {
        const origName = fnName.replace(/Promise$/, ``);
        const fakeImpl = fakeFs[fnName];
        if (typeof fakeImpl === `undefined`) continue;
        setupFn(FileHandle.prototype, origName, function (...args) {
          return fakeImpl.call(fakeFs, this.fd, ...args);
        });
      }

      setupFn(patchedFsPromises, `open`, async (...args) => {
        // @ts-ignore
        const fd = await fakeFs.openPromise(...args);
        return new FileHandle(fd);
      }); // `fs.promises.realpath` doesn't have a `native` property
    }
  }
}
function extendFs(realFs, fakeFs) {
  const patchedFs = Object.create(realFs);
  patchFs(patchedFs, fakeFs);
  return patchedFs;
}
const tmpdirs = new Set();
let cleanExitRegistered = false;

function registerCleanExit() {
  if (!cleanExitRegistered) cleanExitRegistered = true;else return;

  const cleanExit = () => {
    process.off(`exit`, cleanExit);

    for (const p of tmpdirs) {
      tmpdirs.delete(p);

      try {
        xfs.removeSync(p);
      } catch (_a) {// Too bad if there's an error
      }
    }
  };

  process.on(`exit`, cleanExit);
}

const xfs = Object.assign(new _NodeFS__WEBPACK_IMPORTED_MODULE_10__.NodeFS(), {
  detachTemp(p) {
    tmpdirs.delete(p);
  },

  mktempSync(cb) {
    registerCleanExit();

    while (true) {
      const p = getTempName(`xfs-`);

      try {
        this.mkdirSync(p);
      } catch (error) {
        if (error.code === `EEXIST`) {
          continue;
        } else {
          throw error;
        }
      }

      const realP = this.realpathSync(p);
      tmpdirs.add(realP);

      if (typeof cb !== `undefined`) {
        try {
          return cb(realP);
        } finally {
          if (tmpdirs.has(realP)) {
            tmpdirs.delete(realP);

            try {
              this.removeSync(realP);
            } catch (_a) {// Too bad if there's an error
            }
          }
        }
      } else {
        return p;
      }
    }
  },

  async mktempPromise(cb) {
    registerCleanExit();

    while (true) {
      const p = getTempName(`xfs-`);

      try {
        await this.mkdirPromise(p);
      } catch (error) {
        if (error.code === `EEXIST`) {
          continue;
        } else {
          throw error;
        }
      }

      const realP = await this.realpathPromise(p);
      tmpdirs.add(realP);

      if (typeof cb !== `undefined`) {
        try {
          return await cb(realP);
        } finally {
          if (tmpdirs.has(realP)) {
            tmpdirs.delete(realP);

            try {
              await this.removePromise(realP);
            } catch (_a) {// Too bad if there's an error
            }
          }
        }
      } else {
        return realP;
      }
    }
  }

});

/***/ }),
/* 207 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AliasFS": () => /* binding */ AliasFS
/* harmony export */ });
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(208);

class AliasFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor(target, {
    baseFs,
    pathUtils
  }) {
    super(pathUtils);
    this.target = target;
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.target;
  }

  getBaseFs() {
    return this.baseFs;
  }

  mapFromBase(p) {
    return p;
  }

  mapToBase(p) {
    return p;
  }

}

/***/ }),
/* 208 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProxiedFS": () => /* binding */ ProxiedFS
/* harmony export */ });
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);

class ProxiedFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_0__.FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }

  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }

  openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }

  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }

  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }

  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }

  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }

  existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }

  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }

  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }

  accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }

  statPromise(p) {
    return this.baseFs.statPromise(this.mapToBase(p));
  }

  statSync(p) {
    return this.baseFs.statSync(this.mapToBase(p));
  }

  lstatPromise(p) {
    return this.baseFs.lstatPromise(this.mapToBase(p));
  }

  lstatSync(p) {
    return this.baseFs.lstatSync(this.mapToBase(p));
  }

  chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }

  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }

  renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }

  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }

  copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }

  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }

  writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }

  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }

  unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }

  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }

  utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }

  mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }

  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }

  rmdirPromise(p) {
    return this.baseFs.rmdirPromise(this.mapToBase(p));
  }

  rmdirSync(p) {
    return this.baseFs.rmdirSync(this.mapToBase(p));
  }

  symlinkPromise(target, p, type) {
    return this.baseFs.symlinkPromise(this.mapToBase(target), this.mapToBase(p), type);
  }

  symlinkSync(target, p, type) {
    return this.baseFs.symlinkSync(this.mapToBase(target), this.mapToBase(p), type);
  }

  readFilePromise(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === `utf8`) {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    }
  }

  readFileSync(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === `utf8`) {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    }
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirPromise(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirSync(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }

  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }

  watch(p, a, b) {
    return this.baseFs.watch(this.mapToBase(p), // @ts-ignore
    a, b);
  }

  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }

}

/***/ }),
/* 209 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CwdFS": () => /* binding */ CwdFS
/* harmony export */ });
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(119);
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(208);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);



class CwdFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor(target, {
    baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_1__.NodeFS()
  } = {}) {
    super(_path__WEBPACK_IMPORTED_MODULE_2__.ppath);
    this.target = this.pathUtils.normalize(target);
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
  }

  resolve(p) {
    if (this.pathUtils.isAbsolute(p)) {
      return _path__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(p);
    } else {
      return this.baseFs.resolve(_path__WEBPACK_IMPORTED_MODULE_2__.ppath.join(this.target, p));
    }
  }

  mapFromBase(path) {
    return path;
  }

  mapToBase(path) {
    if (this.pathUtils.isAbsolute(path)) {
      return path;
    } else {
      return this.pathUtils.join(this.target, path);
    }
  }

}

/***/ }),
/* 210 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JailFS": () => /* binding */ JailFS
/* harmony export */ });
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(119);
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(208);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);



const JAIL_ROOT = _path__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root;
class JailFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_1__.ProxiedFS {
  constructor(target, {
    baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_2__.NodeFS()
  } = {}) {
    super(_path__WEBPACK_IMPORTED_MODULE_0__.ppath);
    this.target = this.pathUtils.resolve(_path__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root, target);
    this.baseFs = baseFs;
  }

  getRealPath() {
    return this.pathUtils.resolve(this.baseFs.getRealPath(), this.pathUtils.relative(_path__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root, this.target));
  }

  getTarget() {
    return this.target;
  }

  getBaseFs() {
    return this.baseFs;
  }

  mapToBase(p) {
    const normalized = this.pathUtils.normalize(p);
    if (this.pathUtils.isAbsolute(p)) return this.pathUtils.resolve(this.target, this.pathUtils.relative(JAIL_ROOT, p));
    if (normalized.match(/^\.\.\/?/)) throw new Error(`Resolving this path (${p}) would escape the jail`);
    return this.pathUtils.resolve(this.target, p);
  }

  mapFromBase(p) {
    return this.pathUtils.resolve(JAIL_ROOT, this.pathUtils.relative(this.target, p));
  }

}

/***/ }),
/* 211 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LazyFS": () => /* binding */ LazyFS
/* harmony export */ });
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(208);

class LazyFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor(factory, pathUtils) {
    super(pathUtils);
    this.instance = null;
    this.factory = factory;
  }

  get baseFs() {
    if (!this.instance) this.instance = this.factory();
    return this.instance;
  }

  set baseFs(value) {
    this.instance = value;
  }

  mapFromBase(p) {
    return p;
  }

  mapToBase(p) {
    return p;
  }

}

/***/ }),
/* 212 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NoFS": () => /* binding */ NoFS
/* harmony export */ });
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);



const makeError = () => Object.assign(new Error(`ENOSYS: unsupported filesystem access`), {
  code: `ENOSYS`
});

class NoFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_0__.FakeFS {
  constructor() {
    super(_path__WEBPACK_IMPORTED_MODULE_1__.ppath);
  }

  getExtractHint() {
    throw makeError();
  }

  getRealPath() {
    throw makeError();
  }

  resolve() {
    throw makeError();
  }

  async openPromise() {
    throw makeError();
  }

  openSync() {
    throw makeError();
  }

  async readPromise() {
    throw makeError();
  }

  readSync() {
    throw makeError();
  }

  async writePromise() {
    throw makeError();
  }

  writeSync() {
    throw makeError();
  }

  async closePromise() {
    throw makeError();
  }

  closeSync() {
    throw makeError();
  }

  createWriteStream() {
    throw makeError();
  }

  createReadStream() {
    throw makeError();
  }

  async realpathPromise() {
    throw makeError();
  }

  realpathSync() {
    throw makeError();
  }

  async readdirPromise() {
    throw makeError();
  }

  readdirSync() {
    throw makeError();
  }

  async existsPromise(p) {
    throw makeError();
  }

  existsSync(p) {
    throw makeError();
  }

  async accessPromise() {
    throw makeError();
  }

  accessSync() {
    throw makeError();
  }

  async statPromise() {
    throw makeError();
  }

  statSync() {
    throw makeError();
  }

  async lstatPromise(p) {
    throw makeError();
  }

  lstatSync(p) {
    throw makeError();
  }

  async chmodPromise() {
    throw makeError();
  }

  chmodSync() {
    throw makeError();
  }

  async mkdirPromise() {
    throw makeError();
  }

  mkdirSync() {
    throw makeError();
  }

  async rmdirPromise() {
    throw makeError();
  }

  rmdirSync() {
    throw makeError();
  }

  async symlinkPromise() {
    throw makeError();
  }

  symlinkSync() {
    throw makeError();
  }

  async renamePromise() {
    throw makeError();
  }

  renameSync() {
    throw makeError();
  }

  async copyFilePromise() {
    throw makeError();
  }

  copyFileSync() {
    throw makeError();
  }

  async appendFilePromise() {
    throw makeError();
  }

  appendFileSync() {
    throw makeError();
  }

  async writeFilePromise() {
    throw makeError();
  }

  writeFileSync() {
    throw makeError();
  }

  async unlinkPromise() {
    throw makeError();
  }

  unlinkSync() {
    throw makeError();
  }

  async utimesPromise() {
    throw makeError();
  }

  utimesSync() {
    throw makeError();
  }

  async readFilePromise() {
    throw makeError();
  }

  readFileSync() {
    throw makeError();
  }

  async readlinkPromise() {
    throw makeError();
  }

  readlinkSync() {
    throw makeError();
  }

  watch() {
    throw makeError();
  }

}
NoFS.instance = new NoFS();

/***/ }),
/* 213 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PosixFS": () => /* binding */ PosixFS
/* harmony export */ });
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(208);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);


class PosixFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor(baseFs) {
    super(_path__WEBPACK_IMPORTED_MODULE_1__.npath);
    this.baseFs = baseFs;
  }

  mapFromBase(path) {
    return _path__WEBPACK_IMPORTED_MODULE_1__.npath.fromPortablePath(path);
  }

  mapToBase(path) {
    return _path__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(path);
  }

}

/***/ }),
/* 214 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VirtualFS": () => /* binding */ VirtualFS
/* harmony export */ });
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(119);
/* harmony import */ var _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(208);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);



const NUMBER_REGEXP = /^[0-9]+$/; // $0: full path
// $1: virtual folder
// $2: virtual segment
// $3: hash
// $4: depth
// $5: subpath

const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?\$\$virtual)((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends _ProxiedFS__WEBPACK_IMPORTED_MODULE_0__.ProxiedFS {
  constructor({
    baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_1__.NodeFS()
  } = {}) {
    super(_path__WEBPACK_IMPORTED_MODULE_2__.ppath);
    this.baseFs = baseFs;
  }

  static makeVirtualPath(base, component, to) {
    if (_path__WEBPACK_IMPORTED_MODULE_2__.ppath.basename(base) !== `$$virtual`) throw new Error(`Assertion failed: Virtual folders must be named "$$virtual"`);
    if (!_path__WEBPACK_IMPORTED_MODULE_2__.ppath.basename(component).match(VALID_COMPONENT)) throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`); // Obtains the relative distance between the virtual path and its actual target

    const target = _path__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_path__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(base), to);
    const segments = target.split(`/`); // Counts how many levels we need to go back to start applying the rest of the path

    let depth = 0;

    while (depth < segments.length && segments[depth] === `..`) depth += 1;

    const finalSegments = segments.slice(depth);
    const fullVirtualPath = _path__WEBPACK_IMPORTED_MODULE_2__.ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }

  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5]) return p;
    const target = _path__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(match[1]);
    if (!match[3] || !match[4]) return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum) return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(_path__WEBPACK_IMPORTED_MODULE_2__.ppath.join(target, backstep, subpath));
  }

  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match) return this.baseFs.realpathSync(p);
    if (!match[5]) return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }

  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match) return await this.baseFs.realpathPromise(p);
    if (!match[5]) return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }

  mapToBase(p) {
    return VirtualFS.resolveVirtual(p);
  }

  mapFromBase(p) {
    return p;
  }

}

/***/ }),
/* 215 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZipOpenFS": () => /* binding */ ZipOpenFS
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _FakeFS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
/* harmony import */ var _NodeFS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(119);
/* harmony import */ var _ZipFS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(114);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);





const ZIP_FD = 0x80000000;
const FILE_PARTS_REGEX = /.*?(?<!\/)\.zip(?=\/|$)/;
class ZipOpenFS extends _FakeFS__WEBPACK_IMPORTED_MODULE_1__.BasePortableFakeFS {
  constructor({
    libzip,
    baseFs = new _NodeFS__WEBPACK_IMPORTED_MODULE_2__.NodeFS(),
    filter = null,
    maxOpenFiles = Infinity,
    readOnlyArchives = false,
    useCache = true,
    maxAge = 5000
  }) {
    super();
    this.fdMap = new Map();
    this.nextFd = 3;
    this.isZip = new Set();
    this.notZip = new Set();
    this.limitOpenFilesTimeout = null;
    this.libzip = libzip;
    this.baseFs = baseFs;
    this.zipInstances = useCache ? new Map() : null;
    this.filter = filter;
    this.maxOpenFiles = maxOpenFiles;
    this.readOnlyArchives = readOnlyArchives;
    this.maxAge = maxAge;
  }

  static async openPromise(fn, opts) {
    const zipOpenFs = new ZipOpenFS(opts);

    try {
      return await fn(zipOpenFs);
    } finally {
      zipOpenFs.saveAndClose();
    }
  }

  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  saveAndClose() {
    if (this.zipInstances) {
      for (const [path, {
        zipFs
      }] of this.zipInstances.entries()) {
        zipFs.saveAndClose();
        this.zipInstances.delete(path);
      }
    }
  }

  discardAndClose() {
    if (this.zipInstances) {
      for (const [path, {
        zipFs
      }] of this.zipInstances.entries()) {
        zipFs.discardAndClose();
        this.zipInstances.delete(path);
      }
    }
  }

  resolve(p) {
    return this.baseFs.resolve(p);
  }

  remapFd(zipFs, fd) {
    const remappedFd = this.nextFd++ | ZIP_FD;
    this.fdMap.set(remappedFd, [zipFs, fd]);
    return remappedFd;
  }

  async openPromise(p, flags, mode) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.openPromise(p, flags, mode);
    }, async (zipFs, {
      subPath
    }) => {
      return this.remapFd(zipFs, await zipFs.openPromise(subPath, flags, mode));
    });
  }

  openSync(p, flags, mode) {
    return this.makeCallSync(p, () => {
      return this.baseFs.openSync(p, flags, mode);
    }, (zipFs, {
      subPath
    }) => {
      return this.remapFd(zipFs, zipFs.openSync(subPath, flags, mode));
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) return await this.baseFs.readPromise(fd, buffer, offset, length, position);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, read`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;
    return await zipFs.readPromise(realFd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) return this.baseFs.readSync(fd, buffer, offset, length, position);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, read`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;
    return zipFs.readSync(realFd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) {
      if (typeof buffer === `string`) {
        return await this.baseFs.writePromise(fd, buffer, offset);
      } else {
        return await this.baseFs.writePromise(fd, buffer, offset, length, position);
      }
    }

    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;

    if (typeof buffer === `string`) {
      return await zipFs.writePromise(realFd, buffer, offset);
    } else {
      return await zipFs.writePromise(realFd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) {
      if (typeof buffer === `string`) {
        return this.baseFs.writeSync(fd, buffer, offset);
      } else {
        return this.baseFs.writeSync(fd, buffer, offset, length, position);
      }
    }

    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;

    if (typeof buffer === `string`) {
      return zipFs.writeSync(realFd, buffer, offset);
    } else {
      return zipFs.writeSync(realFd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    if ((fd & ZIP_FD) === 0) return await this.baseFs.closePromise(fd);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, close`), {
      code: `EBADF`
    });
    this.fdMap.delete(fd);
    const [zipFs, realFd] = entry;
    return await zipFs.closePromise(realFd);
  }

  closeSync(fd) {
    if ((fd & ZIP_FD) === 0) return this.baseFs.closeSync(fd);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, close`), {
      code: `EBADF`
    });
    this.fdMap.delete(fd);
    const [zipFs, realFd] = entry;
    return zipFs.closeSync(realFd);
  }

  createReadStream(p, opts) {
    if (p === null) return this.baseFs.createReadStream(p, opts);
    return this.makeCallSync(p, () => {
      return this.baseFs.createReadStream(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.createReadStream(subPath, opts);
    });
  }

  createWriteStream(p, opts) {
    if (p === null) return this.baseFs.createWriteStream(p, opts);
    return this.makeCallSync(p, () => {
      return this.baseFs.createWriteStream(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.createWriteStream(subPath, opts);
    });
  }

  async realpathPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.realpathPromise(p);
    }, async (zipFs, {
      archivePath,
      subPath
    }) => {
      return this.pathUtils.join(await this.baseFs.realpathPromise(archivePath), this.pathUtils.relative(_path__WEBPACK_IMPORTED_MODULE_3__.PortablePath.root, await zipFs.realpathPromise(subPath)));
    });
  }

  realpathSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.realpathSync(p);
    }, (zipFs, {
      archivePath,
      subPath
    }) => {
      return this.pathUtils.join(this.baseFs.realpathSync(archivePath), this.pathUtils.relative(_path__WEBPACK_IMPORTED_MODULE_3__.PortablePath.root, zipFs.realpathSync(subPath)));
    });
  }

  async existsPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.existsPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.existsPromise(subPath);
    });
  }

  existsSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.existsSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.existsSync(subPath);
    });
  }

  async accessPromise(p, mode) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.accessPromise(p, mode);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.accessPromise(subPath, mode);
    });
  }

  accessSync(p, mode) {
    return this.makeCallSync(p, () => {
      return this.baseFs.accessSync(p, mode);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.accessSync(subPath, mode);
    });
  }

  async statPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.statPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.statPromise(subPath);
    });
  }

  statSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.statSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.statSync(subPath);
    });
  }

  async lstatPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.lstatPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.lstatPromise(subPath);
    });
  }

  lstatSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.lstatSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.lstatSync(subPath);
    });
  }

  async chmodPromise(p, mask) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.chmodPromise(p, mask);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.chmodPromise(subPath, mask);
    });
  }

  chmodSync(p, mask) {
    return this.makeCallSync(p, () => {
      return this.baseFs.chmodSync(p, mask);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.chmodSync(subPath, mask);
    });
  }

  async renamePromise(oldP, newP) {
    return await this.makeCallPromise(oldP, async () => {
      return await this.makeCallPromise(newP, async () => {
        return await this.baseFs.renamePromise(oldP, newP);
      }, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      });
    }, async (zipFsO, {
      subPath: subPathO
    }) => {
      return await this.makeCallPromise(newP, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      }, async (zipFsN, {
        subPath: subPathN
      }) => {
        if (zipFsO !== zipFsN) {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
            code: `EEXDEV`
          });
        } else {
          return await zipFsO.renamePromise(subPathO, subPathN);
        }
      });
    });
  }

  renameSync(oldP, newP) {
    return this.makeCallSync(oldP, () => {
      return this.makeCallSync(newP, () => {
        return this.baseFs.renameSync(oldP, newP);
      }, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      });
    }, (zipFsO, {
      subPath: subPathO
    }) => {
      return this.makeCallSync(newP, () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      }, (zipFsN, {
        subPath: subPathN
      }) => {
        if (zipFsO !== zipFsN) {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
            code: `EEXDEV`
          });
        } else {
          return zipFsO.renameSync(subPathO, subPathN);
        }
      });
    });
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    const fallback = async (sourceFs, sourceP, destFs, destP) => {
      if ((flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_FICLONE_FORCE) !== 0) throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), {
        code: `EXDEV`
      });
      if (flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL && (await this.existsPromise(sourceP))) throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), {
        code: `EEXIST`
      });
      let content;

      try {
        content = await sourceFs.readFilePromise(sourceP);
      } catch (error) {
        throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), {
          code: `EINVAL`
        });
      }

      await destFs.writeFilePromise(destP, content);
    };

    return await this.makeCallPromise(sourceP, async () => {
      return await this.makeCallPromise(destP, async () => {
        return await this.baseFs.copyFilePromise(sourceP, destP, flags);
      }, async (zipFsD, {
        subPath: subPathD
      }) => {
        return await fallback(this.baseFs, sourceP, zipFsD, subPathD);
      });
    }, async (zipFsS, {
      subPath: subPathS
    }) => {
      return await this.makeCallPromise(destP, async () => {
        return await fallback(zipFsS, subPathS, this.baseFs, destP);
      }, async (zipFsD, {
        subPath: subPathD
      }) => {
        if (zipFsS !== zipFsD) {
          return await fallback(zipFsS, subPathS, zipFsD, subPathD);
        } else {
          return await zipFsS.copyFilePromise(subPathS, subPathD, flags);
        }
      });
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    const fallback = (sourceFs, sourceP, destFs, destP) => {
      if ((flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_FICLONE_FORCE) !== 0) throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), {
        code: `EXDEV`
      });
      if (flags & fs__WEBPACK_IMPORTED_MODULE_0__.constants.COPYFILE_EXCL && this.existsSync(sourceP)) throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), {
        code: `EEXIST`
      });
      let content;

      try {
        content = sourceFs.readFileSync(sourceP);
      } catch (error) {
        throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), {
          code: `EINVAL`
        });
      }

      destFs.writeFileSync(destP, content);
    };

    return this.makeCallSync(sourceP, () => {
      return this.makeCallSync(destP, () => {
        return this.baseFs.copyFileSync(sourceP, destP, flags);
      }, (zipFsD, {
        subPath: subPathD
      }) => {
        return fallback(this.baseFs, sourceP, zipFsD, subPathD);
      });
    }, (zipFsS, {
      subPath: subPathS
    }) => {
      return this.makeCallSync(destP, () => {
        return fallback(zipFsS, subPathS, this.baseFs, destP);
      }, (zipFsD, {
        subPath: subPathD
      }) => {
        if (zipFsS !== zipFsD) {
          return fallback(zipFsS, subPathS, zipFsD, subPathD);
        } else {
          return zipFsS.copyFileSync(subPathS, subPathD, flags);
        }
      });
    });
  }

  async appendFilePromise(p, content, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.appendFilePromise(p, content, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.appendFilePromise(subPath, content, opts);
    });
  }

  appendFileSync(p, content, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.appendFileSync(p, content, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.appendFileSync(subPath, content, opts);
    });
  }

  async writeFilePromise(p, content, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.writeFilePromise(p, content, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.writeFilePromise(subPath, content, opts);
    });
  }

  writeFileSync(p, content, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.writeFileSync(p, content, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.writeFileSync(subPath, content, opts);
    });
  }

  async unlinkPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.unlinkPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.unlinkPromise(subPath);
    });
  }

  unlinkSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.unlinkSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.unlinkSync(subPath);
    });
  }

  async utimesPromise(p, atime, mtime) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.utimesPromise(p, atime, mtime);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.utimesPromise(subPath, atime, mtime);
    });
  }

  utimesSync(p, atime, mtime) {
    return this.makeCallSync(p, () => {
      return this.baseFs.utimesSync(p, atime, mtime);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.utimesSync(subPath, atime, mtime);
    });
  }

  async mkdirPromise(p, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.mkdirPromise(p, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.mkdirPromise(subPath, opts);
    });
  }

  mkdirSync(p, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.mkdirSync(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.mkdirSync(subPath, opts);
    });
  }

  async rmdirPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.rmdirPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.rmdirPromise(subPath);
    });
  }

  rmdirSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.rmdirSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.rmdirSync(subPath);
    });
  }

  async symlinkPromise(target, p, type) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.symlinkPromise(target, p, type);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.symlinkPromise(target, subPath);
    });
  }

  symlinkSync(target, p, type) {
    return this.makeCallSync(p, () => {
      return this.baseFs.symlinkSync(target, p, type);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.symlinkSync(target, subPath);
    });
  }

  async readFilePromise(p, encoding) {
    return this.makeCallPromise(p, async () => {
      // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
      switch (encoding) {
        case `utf8`:
          return await this.baseFs.readFilePromise(p, encoding);

        default:
          return await this.baseFs.readFilePromise(p, encoding);
      }
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readFilePromise(subPath, encoding);
    });
  }

  readFileSync(p, encoding) {
    return this.makeCallSync(p, () => {
      // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
      switch (encoding) {
        case `utf8`:
          return this.baseFs.readFileSync(p, encoding);

        default:
          return this.baseFs.readFileSync(p, encoding);
      }
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readFileSync(subPath, encoding);
    });
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.readdirPromise(p, {
        withFileTypes: withFileTypes
      });
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readdirPromise(subPath, {
        withFileTypes: withFileTypes
      });
    }, {
      requireSubpath: false
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.makeCallSync(p, () => {
      return this.baseFs.readdirSync(p, {
        withFileTypes: withFileTypes
      });
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readdirSync(subPath, {
        withFileTypes: withFileTypes
      });
    }, {
      requireSubpath: false
    });
  }

  async readlinkPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.readlinkPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readlinkPromise(subPath);
    });
  }

  readlinkSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.readlinkSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readlinkSync(subPath);
    });
  }

  watch(p, a, b) {
    return this.makeCallSync(p, () => {
      return this.baseFs.watch(p, // @ts-ignore
      a, b);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.watch(subPath, // @ts-ignore
      a, b);
    });
  }

  async makeCallPromise(p, discard, accept, {
    requireSubpath = true
  } = {}) {
    if (typeof p !== `string`) return await discard();
    const normalizedP = this.resolve(p);
    const zipInfo = this.findZip(normalizedP);
    if (!zipInfo) return await discard();
    if (requireSubpath && zipInfo.subPath === `/`) return await discard();
    return await this.getZipPromise(zipInfo.archivePath, async zipFs => await accept(zipFs, zipInfo));
  }

  makeCallSync(p, discard, accept, {
    requireSubpath = true
  } = {}) {
    if (typeof p !== `string`) return discard();
    const normalizedP = this.resolve(p);
    const zipInfo = this.findZip(normalizedP);
    if (!zipInfo) return discard();
    if (requireSubpath && zipInfo.subPath === `/`) return discard();
    return this.getZipSync(zipInfo.archivePath, zipFs => accept(zipFs, zipInfo));
  }

  findZip(p) {
    if (this.filter && !this.filter.test(p)) return null;
    let filePath = ``;

    while (true) {
      const parts = FILE_PARTS_REGEX.exec(p.substr(filePath.length));
      if (!parts) return null;
      filePath = this.pathUtils.join(filePath, parts[0]);

      if (this.isZip.has(filePath) === false) {
        if (this.notZip.has(filePath)) continue;

        try {
          if (!this.baseFs.lstatSync(filePath).isFile()) {
            this.notZip.add(filePath);
            continue;
          }
        } catch (_a) {
          return null;
        }

        this.isZip.add(filePath);
      }

      return {
        archivePath: filePath,
        subPath: this.pathUtils.join(_path__WEBPACK_IMPORTED_MODULE_3__.PortablePath.root, p.substr(filePath.length))
      };
    }
  }

  limitOpenFiles(max) {
    if (this.zipInstances === null) return;
    const now = Date.now();
    let nextExpiresAt = now + this.maxAge;
    let closeCount = max === null ? 0 : this.zipInstances.size - max;

    for (const [path, {
      zipFs,
      expiresAt
    }] of this.zipInstances.entries()) {
      if (zipFs.hasOpenFileHandles()) {
        continue;
      } else if (now >= expiresAt) {
        zipFs.saveAndClose();
        this.zipInstances.delete(path);
        closeCount -= 1;
        continue;
      } else if (max === null || closeCount <= 0) {
        nextExpiresAt = expiresAt;
        break;
      }

      zipFs.saveAndClose();
      this.zipInstances.delete(path);
      closeCount -= 1;
    }

    if (this.limitOpenFilesTimeout === null && (max === null && this.zipInstances.size > 0 || max !== null)) {
      this.limitOpenFilesTimeout = setTimeout(() => {
        this.limitOpenFilesTimeout = null;
        this.limitOpenFiles(null);
      }, nextExpiresAt - now).unref();
    }
  }

  async getZipPromise(p, accept) {
    const getZipOptions = async () => ({
      baseFs: this.baseFs,
      libzip: this.libzip,
      readOnly: this.readOnlyArchives,
      stats: await this.baseFs.statPromise(p)
    });

    if (this.zipInstances) {
      let cachedZipFs = this.zipInstances.get(p);

      if (!cachedZipFs) {
        const zipOptions = await getZipOptions(); // We need to recheck because concurrent getZipPromise calls may
        // have instantiated the zip archive while we were waiting

        cachedZipFs = this.zipInstances.get(p);

        if (!cachedZipFs) {
          cachedZipFs = {
            zipFs: new _ZipFS__WEBPACK_IMPORTED_MODULE_4__.ZipFS(p, zipOptions),
            expiresAt: 0
          };
        }
      } // Removing then re-adding the field allows us to easily implement
      // a basic LRU garbage collection strategy


      this.zipInstances.delete(p);
      this.limitOpenFiles(this.maxOpenFiles - 1);
      this.zipInstances.set(p, cachedZipFs);
      cachedZipFs.expiresAt = Date.now() + this.maxAge;
      return await accept(cachedZipFs.zipFs);
    } else {
      const zipFs = new _ZipFS__WEBPACK_IMPORTED_MODULE_4__.ZipFS(p, await getZipOptions());

      try {
        return await accept(zipFs);
      } finally {
        zipFs.saveAndClose();
      }
    }
  }

  getZipSync(p, accept) {
    const getZipOptions = () => ({
      baseFs: this.baseFs,
      libzip: this.libzip,
      readOnly: this.readOnlyArchives,
      stats: this.baseFs.statSync(p)
    });

    if (this.zipInstances) {
      let cachedZipFs = this.zipInstances.get(p);

      if (!cachedZipFs) {
        cachedZipFs = {
          zipFs: new _ZipFS__WEBPACK_IMPORTED_MODULE_4__.ZipFS(p, getZipOptions()),
          expiresAt: 0
        };
      } // Removing then re-adding the field allows us to easily implement
      // a basic LRU garbage collection strategy


      this.zipInstances.delete(p);
      this.limitOpenFiles(this.maxOpenFiles - 1);
      this.zipInstances.set(p, cachedZipFs);
      cachedZipFs.expiresAt = Date.now() + this.maxAge;
      return accept(cachedZipFs.zipFs);
    } else {
      const zipFs = new _ZipFS__WEBPACK_IMPORTED_MODULE_4__.ZipFS(p, getZipOptions());

      try {
        return accept(zipFs);
      } finally {
        zipFs.saveAndClose();
      }
    }
  }

}

/***/ }),
/* 216 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CorePlugin": () => /* binding */ CorePlugin
/* harmony export */ });
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(217);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(140);


const CorePlugin = {
  hooks: {
    reduceDependency: (dependency, project, locator, initialDependency, {
      resolver,
      resolveOptions
    }) => {
      for (const {
        pattern,
        reference
      } of project.topLevelWorkspace.manifest.resolutions) {
        if (pattern.from && pattern.from.fullName !== _structUtils__WEBPACK_IMPORTED_MODULE_0__.requirableIdent(locator)) continue;
        if (pattern.from && pattern.from.description && pattern.from.description !== locator.reference) continue;
        if (pattern.descriptor.fullName !== _structUtils__WEBPACK_IMPORTED_MODULE_0__.requirableIdent(dependency)) continue;
        if (pattern.descriptor.description && pattern.descriptor.description !== dependency.range) continue;
        const alias = resolver.bindDescriptor(_structUtils__WEBPACK_IMPORTED_MODULE_0__.makeDescriptor(dependency, reference), project.topLevelWorkspace.anchoredLocator, resolveOptions);
        return alias;
      }

      return dependency;
    },
    validateProject: async (project, report) => {
      for (const workspace of project.workspaces) {
        const workspaceName = _structUtils__WEBPACK_IMPORTED_MODULE_0__.prettyWorkspace(project.configuration, workspace);
        await project.configuration.triggerHook(hooks => {
          return hooks.validateWorkspace;
        }, workspace, {
          reportWarning: (name, text) => report.reportWarning(name, `${workspaceName}: ${text}`),
          reportError: (name, text) => report.reportError(name, `${workspaceName}: ${text}`)
        });
      }
    },
    validateWorkspace: async (workspace, report) => {
      // Validate manifest
      const {
        manifest
      } = workspace;
      if (manifest.resolutions.length && workspace.cwd !== workspace.project.cwd) manifest.errors.push(new Error(`Resolutions field will be ignored`));

      for (const manifestError of manifest.errors) {
        report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.INVALID_MANIFEST, manifestError.message);
      }
    }
  }
};

/***/ }),
/* 217 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessageName": () => /* binding */ MessageName
/* harmony export */ });
// The values in this enum should never be reassigned, even if some are removed
// over time (it would mess up the search results, which are the whole point of
// having this system)
var MessageName;

(function (MessageName) {
  MessageName[MessageName["UNNAMED"] = 0] = "UNNAMED";
  MessageName[MessageName["EXCEPTION"] = 1] = "EXCEPTION";
  MessageName[MessageName["MISSING_PEER_DEPENDENCY"] = 2] = "MISSING_PEER_DEPENDENCY";
  MessageName[MessageName["CYCLIC_DEPENDENCIES"] = 3] = "CYCLIC_DEPENDENCIES";
  MessageName[MessageName["DISABLED_BUILD_SCRIPTS"] = 4] = "DISABLED_BUILD_SCRIPTS";
  MessageName[MessageName["BUILD_DISABLED"] = 5] = "BUILD_DISABLED";
  MessageName[MessageName["SOFT_LINK_BUILD"] = 6] = "SOFT_LINK_BUILD";
  MessageName[MessageName["MUST_BUILD"] = 7] = "MUST_BUILD";
  MessageName[MessageName["MUST_REBUILD"] = 8] = "MUST_REBUILD";
  MessageName[MessageName["BUILD_FAILED"] = 9] = "BUILD_FAILED";
  MessageName[MessageName["RESOLVER_NOT_FOUND"] = 10] = "RESOLVER_NOT_FOUND";
  MessageName[MessageName["FETCHER_NOT_FOUND"] = 11] = "FETCHER_NOT_FOUND";
  MessageName[MessageName["LINKER_NOT_FOUND"] = 12] = "LINKER_NOT_FOUND";
  MessageName[MessageName["FETCH_NOT_CACHED"] = 13] = "FETCH_NOT_CACHED";
  MessageName[MessageName["YARN_IMPORT_FAILED"] = 14] = "YARN_IMPORT_FAILED";
  MessageName[MessageName["REMOTE_INVALID"] = 15] = "REMOTE_INVALID";
  MessageName[MessageName["REMOTE_NOT_FOUND"] = 16] = "REMOTE_NOT_FOUND";
  MessageName[MessageName["RESOLUTION_PACK"] = 17] = "RESOLUTION_PACK";
  MessageName[MessageName["CACHE_CHECKSUM_MISMATCH"] = 18] = "CACHE_CHECKSUM_MISMATCH";
  MessageName[MessageName["UNUSED_CACHE_ENTRY"] = 19] = "UNUSED_CACHE_ENTRY";
  MessageName[MessageName["MISSING_LOCKFILE_ENTRY"] = 20] = "MISSING_LOCKFILE_ENTRY";
  MessageName[MessageName["WORKSPACE_NOT_FOUND"] = 21] = "WORKSPACE_NOT_FOUND";
  MessageName[MessageName["TOO_MANY_MATCHING_WORKSPACES"] = 22] = "TOO_MANY_MATCHING_WORKSPACES";
  MessageName[MessageName["CONSTRAINTS_MISSING_DEPENDENCY"] = 23] = "CONSTRAINTS_MISSING_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_INCOMPATIBLE_DEPENDENCY"] = 24] = "CONSTRAINTS_INCOMPATIBLE_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_EXTRANEOUS_DEPENDENCY"] = 25] = "CONSTRAINTS_EXTRANEOUS_DEPENDENCY";
  MessageName[MessageName["CONSTRAINTS_INVALID_DEPENDENCY"] = 26] = "CONSTRAINTS_INVALID_DEPENDENCY";
  MessageName[MessageName["CANT_SUGGEST_RESOLUTIONS"] = 27] = "CANT_SUGGEST_RESOLUTIONS";
  MessageName[MessageName["FROZEN_LOCKFILE_EXCEPTION"] = 28] = "FROZEN_LOCKFILE_EXCEPTION";
  MessageName[MessageName["CROSS_DRIVE_VIRTUAL_LOCAL"] = 29] = "CROSS_DRIVE_VIRTUAL_LOCAL";
  MessageName[MessageName["FETCH_FAILED"] = 30] = "FETCH_FAILED";
  MessageName[MessageName["DANGEROUS_NODE_MODULES"] = 31] = "DANGEROUS_NODE_MODULES";
  MessageName[MessageName["NODE_GYP_INJECTED"] = 32] = "NODE_GYP_INJECTED";
  MessageName[MessageName["AUTHENTICATION_NOT_FOUND"] = 33] = "AUTHENTICATION_NOT_FOUND";
  MessageName[MessageName["INVALID_CONFIGURATION_KEY"] = 34] = "INVALID_CONFIGURATION_KEY";
  MessageName[MessageName["NETWORK_ERROR"] = 35] = "NETWORK_ERROR";
  MessageName[MessageName["LIFECYCLE_SCRIPT"] = 36] = "LIFECYCLE_SCRIPT";
  MessageName[MessageName["CONSTRAINTS_MISSING_FIELD"] = 37] = "CONSTRAINTS_MISSING_FIELD";
  MessageName[MessageName["CONSTRAINTS_INCOMPATIBLE_FIELD"] = 38] = "CONSTRAINTS_INCOMPATIBLE_FIELD";
  MessageName[MessageName["CONSTRAINTS_EXTRANEOUS_FIELD"] = 39] = "CONSTRAINTS_EXTRANEOUS_FIELD";
  MessageName[MessageName["CONSTRAINTS_INVALID_FIELD"] = 40] = "CONSTRAINTS_INVALID_FIELD";
  MessageName[MessageName["AUTHENTICATION_INVALID"] = 41] = "AUTHENTICATION_INVALID";
  MessageName[MessageName["PROLOG_UNKNOWN_ERROR"] = 42] = "PROLOG_UNKNOWN_ERROR";
  MessageName[MessageName["PROLOG_SYNTAX_ERROR"] = 43] = "PROLOG_SYNTAX_ERROR";
  MessageName[MessageName["PROLOG_EXISTENCE_ERROR"] = 44] = "PROLOG_EXISTENCE_ERROR";
  MessageName[MessageName["STACK_OVERFLOW_RESOLUTION"] = 45] = "STACK_OVERFLOW_RESOLUTION";
  MessageName[MessageName["AUTOMERGE_FAILED_TO_PARSE"] = 46] = "AUTOMERGE_FAILED_TO_PARSE";
  MessageName[MessageName["AUTOMERGE_IMMUTABLE"] = 47] = "AUTOMERGE_IMMUTABLE";
  MessageName[MessageName["AUTOMERGE_SUCCESS"] = 48] = "AUTOMERGE_SUCCESS";
  MessageName[MessageName["AUTOMERGE_REQUIRED"] = 49] = "AUTOMERGE_REQUIRED";
  MessageName[MessageName["DEPRECATED_CLI_SETTINGS"] = 50] = "DEPRECATED_CLI_SETTINGS";
  MessageName[MessageName["PLUGIN_NAME_NOT_FOUND"] = 51] = "PLUGIN_NAME_NOT_FOUND";
  MessageName[MessageName["INVALID_PLUGIN_REFERENCE"] = 52] = "INVALID_PLUGIN_REFERENCE";
  MessageName[MessageName["CONSTRAINTS_AMBIGUITY"] = 53] = "CONSTRAINTS_AMBIGUITY";
  MessageName[MessageName["CACHE_OUTSIDE_PROJECT"] = 54] = "CACHE_OUTSIDE_PROJECT";
  MessageName[MessageName["IMMUTABLE_INSTALL"] = 55] = "IMMUTABLE_INSTALL";
  MessageName[MessageName["IMMUTABLE_CACHE"] = 56] = "IMMUTABLE_CACHE";
  MessageName[MessageName["INVALID_MANIFEST"] = 57] = "INVALID_MANIFEST";
  MessageName[MessageName["PACKAGE_PREPARATION_FAILED"] = 58] = "PACKAGE_PREPARATION_FAILED";
  MessageName[MessageName["INVALID_RANGE_PEER_DEPENDENCY"] = 59] = "INVALID_RANGE_PEER_DEPENDENCY";
  MessageName[MessageName["INCOMPATIBLE_PEER_DEPENDENCY"] = 60] = "INCOMPATIBLE_PEER_DEPENDENCY";
  MessageName[MessageName["DEPRECATED_PACKAGE"] = 61] = "DEPRECATED_PACKAGE";
  MessageName[MessageName["INCOMPATIBLE_OS"] = 62] = "INCOMPATIBLE_OS";
  MessageName[MessageName["INCOMPATIBLE_CPU"] = 63] = "INCOMPATIBLE_CPU";
  MessageName[MessageName["FROZEN_ARTIFACT_EXCEPTION"] = 64] = "FROZEN_ARTIFACT_EXCEPTION";
  MessageName[MessageName["TELEMETRY_NOTICE"] = 65] = "TELEMETRY_NOTICE";
})(MessageName || (MessageName = {}));

/***/ }),
/* 218 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dynamicRequire": () => /* binding */ dynamicRequire,
/* harmony export */   "builtinModules": () => /* binding */ builtinModules
/* harmony export */ });
/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(219);
/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(module__WEBPACK_IMPORTED_MODULE_0__);

function dynamicRequire(request) {
  const req = typeof require !== `undefined` ? require : __webpack_require__(139);
  return req(request);
}
function builtinModules() {
  // @ts-ignore
  return new Set((module__WEBPACK_IMPORTED_MODULE_0___default().builtinModules) || Object.keys(process.binding(`natives`)));
}

/***/ }),
/* 219 */
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),
/* 220 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiResolver": () => /* binding */ MultiResolver
/* harmony export */ });
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(140);

class MultiResolver {
  constructor(resolvers) {
    this.resolvers = resolvers.filter(resolver => resolver);
  }

  supportsDescriptor(descriptor, opts) {
    const resolver = this.tryResolverByDescriptor(descriptor, opts);
    return !!resolver;
  }

  supportsLocator(locator, opts) {
    const resolver = this.tryResolverByLocator(locator, opts);
    return !!resolver;
  }

  shouldPersistResolution(locator, opts) {
    const resolver = this.getResolverByLocator(locator, opts);
    return resolver.shouldPersistResolution(locator, opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return resolver.bindDescriptor(descriptor, fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return resolver.getResolutionDependencies(descriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    const resolver = this.getResolverByDescriptor(descriptor, opts);
    return await resolver.getCandidates(descriptor, dependencies, opts);
  }

  async resolve(locator, opts) {
    const resolver = this.getResolverByLocator(locator, opts);
    return await resolver.resolve(locator, opts);
  }

  tryResolverByDescriptor(descriptor, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsDescriptor(descriptor, opts));
    if (!resolver) return null;
    return resolver;
  }

  getResolverByDescriptor(descriptor, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsDescriptor(descriptor, opts));
    if (!resolver) throw new Error(`${_structUtils__WEBPACK_IMPORTED_MODULE_0__.prettyDescriptor(opts.project.configuration, descriptor)} isn't supported by any available resolver`);
    return resolver;
  }

  tryResolverByLocator(locator, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsLocator(locator, opts));
    if (!resolver) return null;
    return resolver;
  }

  getResolverByLocator(locator, opts) {
    const resolver = this.resolvers.find(resolver => resolver.supportsLocator(locator, opts));
    if (!resolver) throw new Error(`${_structUtils__WEBPACK_IMPORTED_MODULE_0__.prettyLocator(opts.project.configuration, locator)} isn't supported by any available resolver`);
    return resolver;
  }

}

/***/ }),
/* 221 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VirtualResolver": () => /* binding */ VirtualResolver
/* harmony export */ });
class VirtualResolver {
  static isVirtualDescriptor(descriptor) {
    if (!descriptor.range.startsWith(VirtualResolver.protocol)) return false;
    return true;
  }

  static isVirtualLocator(locator) {
    if (!locator.reference.startsWith(VirtualResolver.protocol)) return false;
    return true;
  }

  supportsDescriptor(descriptor, opts) {
    return VirtualResolver.isVirtualDescriptor(descriptor);
  }

  supportsLocator(locator, opts) {
    return VirtualResolver.isVirtualLocator(locator);
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, locator, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `bindDescriptor` anymore.
    throw new Error(`Assertion failed: calling "bindDescriptor" on a virtual descriptor is unsupported`);
  }

  getResolutionDependencies(descriptor, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `bindDescriptor` anymore.
    throw new Error(`Assertion failed: calling "getResolutionDependencies" on a virtual descriptor is unsupported`);
  }

  async getCandidates(descriptor, dependencies, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `getCandidates` anymore.
    throw new Error(`Assertion failed: calling "getCandidates" on a virtual descriptor is unsupported`);
  }

  async resolve(locator, opts) {
    // It's unsupported because packages inside the dependency tree should
    // only become virtual AFTER they have all been resolved, by which point
    // you shouldn't need to call `resolve` anymore.
    throw new Error(`Assertion failed: calling "resolve" on a virtual locator is unsupported`);
  }

}
VirtualResolver.protocol = `virtual:`;

/***/ }),
/* 222 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceResolver": () => /* binding */ WorkspaceResolver
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(223);

class WorkspaceResolver {
  supportsDescriptor(descriptor, opts) {
    if (descriptor.range.startsWith(WorkspaceResolver.protocol)) return true;
    const workspace = opts.project.tryWorkspaceByDescriptor(descriptor);
    if (workspace !== null) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(WorkspaceResolver.protocol)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const workspace = opts.project.getWorkspaceByDescriptor(descriptor);
    return [workspace.anchoredLocator];
  }

  async resolve(locator, opts) {
    const workspace = opts.project.getWorkspaceByCwd(locator.reference.slice(WorkspaceResolver.protocol.length));
    return { ...locator,
      version: workspace.manifest.version || `0.0.0`,
      languageName: `unknown`,
      linkType: _types__WEBPACK_IMPORTED_MODULE_0__.LinkType.SOFT,
      dependencies: new Map([...workspace.manifest.dependencies, ...workspace.manifest.devDependencies]),
      peerDependencies: new Map([...workspace.manifest.peerDependencies]),
      dependenciesMeta: workspace.manifest.dependenciesMeta,
      peerDependenciesMeta: workspace.manifest.peerDependenciesMeta,
      bin: workspace.manifest.bin
    };
  }

}
WorkspaceResolver.protocol = `workspace:`;

/***/ }),
/* 223 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkType": () => /* binding */ LinkType
/* harmony export */ });
var LinkType;

(function (LinkType) {
  LinkType["HARD"] = "HARD";
  LinkType["SOFT"] = "SOFT";
})(LinkType || (LinkType = {}));

/***/ }),
/* 224 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TAG_REGEXP": () => /* binding */ TAG_REGEXP,
/* harmony export */   "ProtocolResolver": () => /* binding */ ProtocolResolver
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(140);


const TAG_REGEXP = /^(?!v)[a-z0-9-.]+$/i;
class ProtocolResolver {
  supportsDescriptor(descriptor, opts) {
    if (semver__WEBPACK_IMPORTED_MODULE_0___default().validRange(descriptor.range)) return true;
    if (TAG_REGEXP.test(descriptor.range)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (semver__WEBPACK_IMPORTED_MODULE_0___default().validRange(locator.reference)) return true;
    if (TAG_REGEXP.test(locator.reference)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    return opts.resolver.shouldPersistResolution(this.forwardLocator(locator, opts), opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return opts.resolver.bindDescriptor(this.forwardDescriptor(descriptor, opts), fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    return opts.resolver.getResolutionDependencies(this.forwardDescriptor(descriptor, opts), opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    return await opts.resolver.getCandidates(this.forwardDescriptor(descriptor, opts), dependencies, opts);
  }

  async resolve(locator, opts) {
    const pkg = await opts.resolver.resolve(this.forwardLocator(locator, opts), opts);
    return _structUtils__WEBPACK_IMPORTED_MODULE_1__.renamePackage(pkg, locator);
  }

  forwardDescriptor(descriptor, opts) {
    return _structUtils__WEBPACK_IMPORTED_MODULE_1__.makeDescriptor(descriptor, `${opts.project.configuration.get(`defaultProtocol`)}${descriptor.range}`);
  }

  forwardLocator(locator, opts) {
    return _structUtils__WEBPACK_IMPORTED_MODULE_1__.makeLocator(locator, `${opts.project.configuration.get(`defaultProtocol`)}${locator.reference}`);
  }

}

/***/ }),
/* 225 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultiFetcher": () => /* binding */ MultiFetcher
/* harmony export */ });
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(217);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(140);



class MultiFetcher {
  constructor(fetchers) {
    this.fetchers = fetchers;
  }

  supports(locator, opts) {
    if (!this.tryFetcher(locator, opts)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const fetcher = this.getFetcher(locator, opts);
    return fetcher.getLocalPath(locator, opts);
  }

  async fetch(locator, opts) {
    const fetcher = this.getFetcher(locator, opts);
    return await fetcher.fetch(locator, opts);
  }

  tryFetcher(locator, opts) {
    const fetcher = this.fetchers.find(fetcher => fetcher.supports(locator, opts));
    if (!fetcher) return null;
    return fetcher;
  }

  getFetcher(locator, opts) {
    const fetcher = this.fetchers.find(fetcher => fetcher.supports(locator, opts));
    if (!fetcher) throw new _Report__WEBPACK_IMPORTED_MODULE_0__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.FETCHER_NOT_FOUND, `${_structUtils__WEBPACK_IMPORTED_MODULE_2__.prettyLocator(opts.project.configuration, locator)} isn't supported by any available fetcher`);
    return fetcher;
  }

}

/***/ }),
/* 226 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReportError": () => /* binding */ ReportError,
/* harmony export */   "Report": () => /* binding */ Report
/* harmony export */ });
/* unused harmony export isReportError */
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(110);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var string_decoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(227);
/* harmony import */ var string_decoder__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(string_decoder__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(217);



class ReportError extends Error {
  constructor(code, message) {
    super(message);
    this.reportCode = code;
  }

}
function isReportError(error) {
  return typeof error.reportCode !== `undefined`;
}
class Report {
  constructor() {
    this.reportedInfos = new Set();
    this.reportedWarnings = new Set();
    this.reportedErrors = new Set();
  }

  static progressViaCounter(max) {
    let current = 0;
    let unlock;
    let lock = new Promise(resolve => {
      unlock = resolve;
    });

    const set = n => {
      const thisUnlock = unlock;
      lock = new Promise(resolve => {
        unlock = resolve;
      });
      current = n;
      thisUnlock();
    };

    const tick = (n = 0) => {
      set(current + 1);
    };

    const gen = async function* () {
      while (current < max) {
        await lock;
        yield {
          progress: current / max
        };
      }
    }();

    return {
      [Symbol.asyncIterator]() {
        return gen;
      },

      set,
      tick
    };
  }

  reportInfoOnce(name, text, opts) {
    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedInfos.has(key)) {
      this.reportedInfos.add(key);
      this.reportInfo(name, text);
    }
  }

  reportWarningOnce(name, text, opts) {
    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedWarnings.has(key)) {
      this.reportedWarnings.add(key);
      this.reportWarning(name, text);
    }
  }

  reportErrorOnce(name, text, opts) {
    const key = opts && opts.key ? opts.key : text;

    if (!this.reportedErrors.has(key)) {
      this.reportedErrors.add(key);
      this.reportError(name, text);
    }
  }

  reportExceptionOnce(error) {
    if (isReportError(error)) {
      this.reportErrorOnce(error.reportCode, error.message, {
        key: error
      });
    } else {
      this.reportErrorOnce(_MessageName__WEBPACK_IMPORTED_MODULE_2__.MessageName.EXCEPTION, error.stack || error.message, {
        key: error
      });
    }
  }

  createStreamReporter(prefix = null) {
    const stream = new stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough();
    const decoder = new string_decoder__WEBPACK_IMPORTED_MODULE_1__.StringDecoder();
    let buffer = ``;
    stream.on(`data`, chunk => {
      let chunkStr = decoder.write(chunk);
      let lineIndex;

      do {
        lineIndex = chunkStr.indexOf(`\n`);

        if (lineIndex !== -1) {
          const line = buffer + chunkStr.substr(0, lineIndex);
          chunkStr = chunkStr.substr(lineIndex + 1);
          buffer = ``;

          if (prefix !== null) {
            this.reportInfo(null, `${prefix} ${line}`);
          } else {
            this.reportInfo(null, line);
          }
        }
      } while (lineIndex !== -1);

      buffer += chunkStr;
    });
    stream.on(`end`, () => {
      const last = decoder.end();

      if (last !== ``) {
        if (prefix !== null) {
          this.reportInfo(null, `${prefix} ${last}`);
        } else {
          this.reportInfo(null, last);
        }
      }
    });
    return stream;
  }

}

/***/ }),
/* 227 */
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),
/* 228 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VirtualFetcher": () => /* binding */ VirtualFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(214);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(207);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(140);


class VirtualFetcher {
  supports(locator) {
    if (!locator.reference.startsWith(`virtual:`)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const splitPoint = locator.reference.indexOf(`#`);
    if (splitPoint === -1) throw new Error(`Invalid virtual package reference`);
    const nextReference = locator.reference.slice(splitPoint + 1);
    const nextLocator = _structUtils__WEBPACK_IMPORTED_MODULE_0__.makeLocator(locator, nextReference);
    return opts.fetcher.getLocalPath(nextLocator, opts);
  }

  async fetch(locator, opts) {
    const splitPoint = locator.reference.indexOf(`#`);
    if (splitPoint === -1) throw new Error(`Invalid virtual package reference`);
    const nextReference = locator.reference.slice(splitPoint + 1);
    const nextLocator = _structUtils__WEBPACK_IMPORTED_MODULE_0__.makeLocator(locator, nextReference);
    const parentFetch = await opts.fetcher.fetch(nextLocator, opts);
    return await this.ensureVirtualLink(locator, parentFetch, opts);
  }

  getLocatorFilename(locator) {
    return _structUtils__WEBPACK_IMPORTED_MODULE_0__.slugifyLocator(locator);
  }

  async ensureVirtualLink(locator, sourceFetch, opts) {
    const to = sourceFetch.packageFs.getRealPath();
    const virtualFolder = opts.project.configuration.get(`virtualFolder`);
    const virtualName = this.getLocatorFilename(locator);
    const virtualPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.VirtualFS.makeVirtualPath(virtualFolder, virtualName, to); // We then use an alias to tell anyone that asks us that we're operating within the virtual folder, while still using the same old fs

    const aliasFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.AliasFS(virtualPath, {
      baseFs: sourceFetch.packageFs,
      pathUtils: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath
    });
    return { ...sourceFetch,
      packageFs: aliasFs
    };
  }

}

/***/ }),
/* 229 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceFetcher": () => /* binding */ WorkspaceFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(209);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(222);


class WorkspaceFetcher {
  supports(locator) {
    if (!locator.reference.startsWith(_WorkspaceResolver__WEBPACK_IMPORTED_MODULE_0__.WorkspaceResolver.protocol)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return this.getWorkspace(locator, opts).cwd;
  }

  async fetch(locator, opts) {
    const sourcePath = this.getWorkspace(locator, opts).cwd;
    return {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.CwdFS(sourcePath),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: sourcePath
    };
  }

  getWorkspace(locator, opts) {
    return opts.project.getWorkspaceByCwd(locator.reference.slice(_WorkspaceResolver__WEBPACK_IMPORTED_MODULE_0__.WorkspaceResolver.protocol.length));
  }

}

/***/ }),
/* 230 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Manifest": () => /* binding */ Manifest
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(119);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(121);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(140);





class Manifest {
  constructor() {
    this.indent = `  `;
    this.name = null;
    this.version = null;
    this.os = null;
    this.cpu = null;
    this.type = null;
    this["private"] = false;
    this.license = null;
    this.main = null;
    this.module = null;
    this.browser = null;
    this.languageName = null;
    this.bin = new Map();
    this.scripts = new Map();
    this.dependencies = new Map();
    this.devDependencies = new Map();
    this.peerDependencies = new Map();
    this.workspaceDefinitions = [];
    this.dependenciesMeta = new Map();
    this.peerDependenciesMeta = new Map();
    this.resolutions = [];
    this.files = null;
    this.publishConfig = null;
    this.preferUnplugged = null;
    this.raw = {};
    /**
     * errors found in the raw manifest while loading
     */

    this.errors = [];
  }

  static async tryFind(path, {
    baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.NodeFS()
  } = {}) {
    const manifestPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(path, `package.json`);
    if (!(await baseFs.existsPromise(manifestPath))) return null;
    return await Manifest.fromFile(manifestPath, {
      baseFs
    });
  }

  static async find(path, {
    baseFs
  } = {}) {
    const manifest = await Manifest.tryFind(path, {
      baseFs
    });
    if (manifest === null) throw new Error(`Manifest not found`);
    return manifest;
  }

  static async fromFile(path, {
    baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.NodeFS()
  } = {}) {
    const manifest = new Manifest();
    await manifest.loadFile(path, {
      baseFs
    });
    return manifest;
  }

  static fromText(text) {
    const manifest = new Manifest();
    manifest.loadFromText(text);
    return manifest;
  }

  loadFromText(text) {
    let data;

    try {
      data = JSON.parse(stripBOM(text) || `{}`);
    } catch (error) {
      error.message += ` (when parsing ${text})`;
      throw error;
    }

    this.load(data);
    this.indent = getIndent(text);
  }

  async loadFile(path, {
    baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.NodeFS()
  }) {
    const content = await baseFs.readFilePromise(path, `utf8`);
    let data;

    try {
      data = JSON.parse(stripBOM(content) || `{}`);
    } catch (error) {
      error.message += ` (when parsing ${path})`;
      throw error;
    }

    this.load(data);
    this.indent = getIndent(content);
  }

  load(data) {
    if (typeof data !== `object` || data === null) throw new Error(`Utterly invalid manifest data (${data})`);
    this.raw = data;
    const errors = [];

    if (typeof data.name === `string`) {
      try {
        this.name = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(data.name);
      } catch (error) {
        errors.push(new Error(`Parsing failed for the 'name' field`));
      }
    }

    if (typeof data.version === `string`) this.version = data.version;

    if (Array.isArray(data.os)) {
      const os = [];
      this.os = os;

      for (const item of data.os) {
        if (typeof item !== `string`) {
          errors.push(new Error(`Parsing failed for the 'os' field`));
        } else {
          os.push(item);
        }
      }
    }

    if (Array.isArray(data.cpu)) {
      const cpu = [];
      this.cpu = cpu;

      for (const item of data.cpu) {
        if (typeof item !== `string`) {
          errors.push(new Error(`Parsing failed for the 'cpu' field`));
        } else {
          cpu.push(item);
        }
      }
    }

    if (typeof data.type === `string`) this.type = data.type;
    if (typeof data.private === `boolean`) this.private = data.private;
    if (typeof data.license === `string`) this.license = data.license;
    if (typeof data.languageName === `string`) this.languageName = data.languageName;
    if (typeof data.main === `string`) this.main = data.main;
    if (typeof data.module === `string`) this.module = data.module;
    if (typeof data.browser === `string`) this.browser = data.browser;

    if (typeof data.bin === `string`) {
      if (this.name !== null) {
        this.bin = new Map([[this.name.name, data.bin]]);
      } else {
        errors.push(new Error(`String bin field, but no attached package name`));
      }
    } else if (typeof data.bin === `object` && data.bin !== null) {
      for (const [key, value] of Object.entries(data.bin)) {
        if (typeof value !== `string`) {
          errors.push(new Error(`Invalid bin definition for '${key}'`));
          continue;
        }

        this.bin.set(key, value);
      }
    }

    if (typeof data.scripts === `object` && data.scripts !== null) {
      for (const [key, value] of Object.entries(data.scripts)) {
        if (typeof value !== `string`) {
          errors.push(new Error(`Invalid script definition for '${key}'`));
          continue;
        }

        this.scripts.set(key, value);
      }
    }

    if (typeof data.dependencies === `object` && data.dependencies !== null) {
      for (const [name, range] of Object.entries(data.dependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, range);
        this.dependencies.set(descriptor.identHash, descriptor);
      }
    }

    if (typeof data.devDependencies === `object` && data.devDependencies !== null) {
      for (const [name, range] of Object.entries(data.devDependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, range);
        this.devDependencies.set(descriptor.identHash, descriptor);
      }
    }

    if (typeof data.peerDependencies === `object` && data.peerDependencies !== null) {
      for (let [name, range] of Object.entries(data.peerDependencies)) {
        let ident;

        try {
          ident = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        }

        if (typeof range !== `string` || !semver__WEBPACK_IMPORTED_MODULE_1___default().validRange(range)) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          range = `*`;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, range);
        this.peerDependencies.set(descriptor.identHash, descriptor);
      }
    }

    const workspaces = Array.isArray(data.workspaces) ? data.workspaces : typeof data.workspaces === `object` && data.workspaces !== null && Array.isArray(data.workspaces.packages) ? data.workspaces.packages : [];

    for (const entry of workspaces) {
      if (typeof entry !== `string`) {
        errors.push(new Error(`Invalid workspace definition for '${entry}'`));
        continue;
      }

      this.workspaceDefinitions.push({
        pattern: entry
      });
    }

    if (typeof data.dependenciesMeta === `object` && data.dependenciesMeta !== null) {
      for (const [pattern, meta] of Object.entries(data.dependenciesMeta)) {
        if (typeof meta !== `object` || meta === null) {
          errors.push(new Error(`Invalid meta field for '${pattern}`));
          continue;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseDescriptor(pattern);
        const dependencyMeta = this.ensureDependencyMeta(descriptor);
        Object.assign(dependencyMeta, meta);
      }
    }

    if (typeof data.peerDependenciesMeta === `object` && data.peerDependenciesMeta !== null) {
      for (const [pattern, meta] of Object.entries(data.peerDependenciesMeta)) {
        if (typeof meta !== `object` || meta === null) {
          errors.push(new Error(`Invalid meta field for '${pattern}`));
          continue;
        }

        const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseDescriptor(pattern);
        const peerDependencyMeta = this.ensurePeerDependencyMeta(descriptor);
        Object.assign(peerDependencyMeta, meta);
      }
    }

    if (typeof data.resolutions === `object` && data.resolutions !== null) {
      for (const [pattern, reference] of Object.entries(data.resolutions)) {
        if (typeof reference !== `string`) {
          errors.push(new Error(`Invalid resolution entry for '${pattern}'`));
          continue;
        }

        try {
          this.resolutions.push({
            pattern: (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseResolution)(pattern),
            reference
          });
        } catch (error) {
          errors.push(error);
          continue;
        }
      }
    }

    if (Array.isArray(data.files) && data.files.length !== 0) {
      this.files = new Set();

      for (const filename of data.files) {
        if (typeof filename !== `string`) {
          errors.push(new Error(`Invalid files entry for '${filename}'`));
          continue;
        }

        this.files.add(filename);
      }
    }

    if (typeof data.publishConfig === `object` && data.publishConfig !== null) {
      this.publishConfig = {};
      if (typeof data.publishConfig.access === `string`) this.publishConfig.access = data.publishConfig.access;
      if (typeof data.publishConfig.main === `string`) this.publishConfig.main = data.publishConfig.main;
      if (typeof data.publishConfig.module === `string`) this.publishConfig.module = data.publishConfig.module;
      if (typeof data.publishConfig.browser === `string`) this.publishConfig.browser = data.publishConfig.browser;
      if (typeof data.publishConfig.registry === `string`) this.publishConfig.registry = data.publishConfig.registry;

      if (typeof data.publishConfig.bin === `string`) {
        if (this.name !== null) {
          this.publishConfig.bin = new Map([[this.name.name, data.publishConfig.bin]]);
        } else {
          errors.push(new Error(`String bin field, but no attached package name`));
        }
      } else if (typeof data.publishConfig.bin === `object` && data.publishConfig.bin !== null) {
        this.publishConfig.bin = new Map();

        for (const [key, value] of Object.entries(data.publishConfig.bin)) {
          if (typeof value !== `string`) {
            errors.push(new Error(`Invalid bin definition for '${key}'`));
            continue;
          }

          this.publishConfig.bin.set(key, value);
        }
      }

      if (Array.isArray(data.publishConfig.executableFiles)) {
        this.publishConfig.executableFiles = new Set();

        for (const value of data.publishConfig.executableFiles) {
          if (typeof value !== `string`) {
            errors.push(new Error(`Invalid executable file definition`));
            continue;
          }

          this.publishConfig.executableFiles.add(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(value));
        }
      }
    } // We treat optional dependencies after both the regular dependency field
    // and the dependenciesMeta field have been generated (because we will
    // override them)


    if (typeof data.optionalDependencies === `object` && data.optionalDependencies !== null) {
      for (const [name, range] of Object.entries(data.optionalDependencies)) {
        if (typeof range !== `string`) {
          errors.push(new Error(`Invalid dependency range for '${name}'`));
          continue;
        }

        let ident;

        try {
          ident = _structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(name);
        } catch (error) {
          errors.push(new Error(`Parsing failed for the dependency name '${name}'`));
          continue;
        } // Note that we store the optional dependencies in the same store as
        // the one that keep the regular dependencies, because they're
        // effectively the same (the only difference is that optional
        // dependencies have an extra field set in dependenciesMeta).


        const realDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, range);
        this.dependencies.set(realDescriptor.identHash, realDescriptor);
        const identDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(ident, `unknown`);
        const dependencyMeta = this.ensureDependencyMeta(identDescriptor);
        Object.assign(dependencyMeta, {
          optional: true
        });
      }
    }

    if (typeof data.preferUnplugged === `boolean`) this.preferUnplugged = data.preferUnplugged;
    this.errors = errors;
  }

  getForScope(type) {
    switch (type) {
      case `dependencies`:
        return this.dependencies;

      case `devDependencies`:
        return this.devDependencies;

      case `peerDependencies`:
        return this.peerDependencies;

      default:
        {
          throw new Error(`Unsupported value ("${type}")`);
        }
    }
  }

  hasConsumerDependency(ident) {
    if (this.dependencies.has(ident.identHash)) return true;
    if (this.peerDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasHardDependency(ident) {
    if (this.dependencies.has(ident.identHash)) return true;
    if (this.devDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasSoftDependency(ident) {
    if (this.peerDependencies.has(ident.identHash)) return true;
    return false;
  }

  hasDependency(ident) {
    if (this.hasHardDependency(ident)) return true;
    if (this.hasSoftDependency(ident)) return true;
    return false;
  }

  isCompatibleWithOS(os) {
    return this.os === null || isManifestFieldCompatible(this.os, os);
  }

  isCompatibleWithCPU(cpu) {
    return this.cpu === null || isManifestFieldCompatible(this.cpu, cpu);
  }

  ensureDependencyMeta(descriptor) {
    if (descriptor.range !== `unknown` && !semver__WEBPACK_IMPORTED_MODULE_1___default().valid(descriptor.range)) throw new Error(`Invalid meta field range for '${_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyDescriptor(descriptor)}'`);
    const identString = _structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(descriptor);
    const range = descriptor.range !== `unknown` ? descriptor.range : null;
    let dependencyMetaSet = this.dependenciesMeta.get(identString);
    if (!dependencyMetaSet) this.dependenciesMeta.set(identString, dependencyMetaSet = new Map());
    let dependencyMeta = dependencyMetaSet.get(range);
    if (!dependencyMeta) dependencyMetaSet.set(range, dependencyMeta = {});
    return dependencyMeta;
  }

  ensurePeerDependencyMeta(descriptor) {
    if (descriptor.range !== `unknown`) throw new Error(`Invalid meta field range for '${_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyDescriptor(descriptor)}'`);
    const identString = _structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(descriptor);
    let peerDependencyMeta = this.peerDependenciesMeta.get(identString);
    if (!peerDependencyMeta) this.peerDependenciesMeta.set(identString, peerDependencyMeta = {});
    return peerDependencyMeta;
  }

  setRawField(name, value, {
    after = []
  } = {}) {
    const afterSet = new Set(after.filter(key => {
      return Object.prototype.hasOwnProperty.call(this.raw, key);
    }));

    if (afterSet.size === 0 || Object.prototype.hasOwnProperty.call(this.raw, name)) {
      this.raw[name] = value;
    } else {
      const oldRaw = this.raw;
      const newRaw = this.raw = {};
      let inserted = false;

      for (const key of Object.keys(oldRaw)) {
        newRaw[key] = oldRaw[key];

        if (!inserted) {
          afterSet.delete(key);

          if (afterSet.size === 0) {
            newRaw[name] = value;
            inserted = true;
          }
        }
      }
    }
  }

  exportTo(data, {
    compatibilityMode = true
  } = {}) {
    // Note that we even set the fields that we re-set later; it
    // allows us to preserve the key ordering
    Object.assign(data, this.raw);
    if (this.name !== null) data.name = _structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(this.name);else delete data.name;
    if (this.version !== null) data.version = this.version;else delete data.version;
    if (this.os !== null) data.os = this.os;else delete this.os;
    if (this.cpu !== null) data.cpu = this.cpu;else delete this.cpu;
    if (this.type !== null) data.type = this.type;else delete data.type;
    if (this.private) data.private = true;else delete data.private;
    if (this.license !== null) data.license = this.license;else delete data.license;
    if (this.languageName !== null) data.languageName = this.languageName;else delete data.languageName;
    if (this.main !== null) data.main = this.main;else delete data.main;
    if (this.module !== null) data.module = this.module;else delete data.module;
    if (this.browser !== null) data.browser = this.browser;else delete data.browser;

    if (this.bin.size === 1 && this.name !== null && this.bin.has(this.name.name)) {
      data.bin = this.bin.get(this.name.name);
    } else if (this.bin.size > 0) {
      data.bin = Object.assign({}, ...Array.from(this.bin.keys()).sort().map(name => {
        return {
          [name]: this.bin.get(name)
        };
      }));
    } else {
      delete data.bin;
    }

    const regularDependencies = [];
    const optionalDependencies = [];

    for (const dependency of this.dependencies.values()) {
      const dependencyMetaSet = this.dependenciesMeta.get(_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency));
      let isOptionallyBuilt = false;

      if (compatibilityMode) {
        if (dependencyMetaSet) {
          const meta = dependencyMetaSet.get(null);

          if (meta && meta.optional) {
            isOptionallyBuilt = true;
          }
        }
      }

      if (isOptionallyBuilt) {
        optionalDependencies.push(dependency);
      } else {
        regularDependencies.push(dependency);
      }
    }

    if (regularDependencies.length > 0) {
      data.dependencies = Object.assign({}, ..._structUtils__WEBPACK_IMPORTED_MODULE_4__.sortDescriptors(regularDependencies).map(dependency => {
        return {
          [_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.dependencies;
    }

    if (optionalDependencies.length > 0) {
      data.optionalDependencies = Object.assign({}, ..._structUtils__WEBPACK_IMPORTED_MODULE_4__.sortDescriptors(optionalDependencies).map(dependency => {
        return {
          [_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.optionalDependencies;
    }

    if (this.devDependencies.size > 0) {
      data.devDependencies = Object.assign({}, ..._structUtils__WEBPACK_IMPORTED_MODULE_4__.sortDescriptors(this.devDependencies.values()).map(dependency => {
        return {
          [_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.devDependencies;
    }

    if (this.peerDependencies.size > 0) {
      data.peerDependencies = Object.assign({}, ..._structUtils__WEBPACK_IMPORTED_MODULE_4__.sortDescriptors(this.peerDependencies.values()).map(dependency => {
        return {
          [_structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyIdent(dependency)]: dependency.range
        };
      }));
    } else {
      delete data.peerDependencies;
    }

    data.dependenciesMeta = {};

    for (const [identString, dependencyMetaSet] of _miscUtils__WEBPACK_IMPORTED_MODULE_5__.sortMap(this.dependenciesMeta.entries(), ([identString, dependencyMetaSet]) => identString)) {
      for (const [range, meta] of _miscUtils__WEBPACK_IMPORTED_MODULE_5__.sortMap(dependencyMetaSet.entries(), ([range, meta]) => range !== null ? `0${range}` : `1`)) {
        const key = range !== null ? _structUtils__WEBPACK_IMPORTED_MODULE_4__.stringifyDescriptor(_structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(_structUtils__WEBPACK_IMPORTED_MODULE_4__.parseIdent(identString), range)) : identString;
        const metaCopy = { ...meta
        };
        if (compatibilityMode && range === null) delete metaCopy.optional;
        if (Object.keys(metaCopy).length === 0) continue;
        data.dependenciesMeta[key] = metaCopy;
      }
    }

    if (Object.keys(data.dependenciesMeta).length === 0) delete data.dependenciesMeta;

    if (this.peerDependenciesMeta.size > 0) {
      data.peerDependenciesMeta = Object.assign({}, ..._miscUtils__WEBPACK_IMPORTED_MODULE_5__.sortMap(this.peerDependenciesMeta.entries(), ([identString, meta]) => identString).map(([identString, meta]) => {
        return {
          [identString]: meta
        };
      }));
    } else {
      delete data.peerDependenciesMeta;
    }

    if (this.resolutions.length > 0) {
      data.resolutions = Object.assign({}, ...this.resolutions.map(({
        pattern,
        reference
      }) => {
        return {
          [(0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.stringifyResolution)(pattern)]: reference
        };
      }));
    } else {
      delete data.resolutions;
    }

    if (this.files !== null) data.files = Array.from(this.files);else delete data.files;
    if (this.preferUnplugged !== null) data.preferUnplugged = this.preferUnplugged;else delete data.preferUnplugged;
    return data;
  }

}
Manifest.fileName = `package.json`;
Manifest.allDependencies = [`dependencies`, `devDependencies`, `peerDependencies`];
Manifest.hardDependencies = [`dependencies`, `devDependencies`];

function getIndent(content) {
  const indentMatch = content.match(/^[ \t]+/m);

  if (indentMatch) {
    return indentMatch[0];
  } else {
    return `  `;
  }
}

function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    return content.slice(1);
  } else {
    return content;
  }
}

function isManifestFieldCompatible(rules, actual) {
  let isNotWhitelist = true;
  let isBlacklist = false;

  for (const rule of rules) {
    if (rule[0] === `!`) {
      isBlacklist = true;

      if (actual === rule.slice(1)) {
        return false;
      }
    } else {
      isNotWhitelist = false;

      if (rule === actual) {
        return true;
      }
    }
  } // Blacklists with whitelisted items should be treated as whitelists for `os` and `cpu` in `package.json`


  return isBlacklist && isNotWhitelist;
}

/***/ }),
/* 231 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "satisfiesWithPrereleases": () => /* binding */ satisfiesWithPrereleases
/* harmony export */ });
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Returns whether the given semver version satisfies the given range. Notably
 * this supports prerelease versions so that "2.0.0-rc.0" satisfies the range
 * ">=1.0.0", for example.
 *
 * This function exists because the semver.satisfies method does not include
 * pre releases. This means ranges such as * would not satisfy 1.0.0-rc. The
 * includePrerelease flag has a weird behavior and cannot be used (if you want
 * to try it out, just run the `semverUtils` testsuite using this flag instead
 * of our own implementation, and you'll see the failing cases).
 *
 * See https://github.com/yarnpkg/berry/issues/575 for more context.
 */

function satisfiesWithPrereleases(version, range, loose = false) {
  let semverRange;

  try {
    semverRange = new (semver__WEBPACK_IMPORTED_MODULE_0___default().Range)(range, loose);
  } catch (err) {
    return false;
  }

  if (!version) return false;
  let semverVersion;

  try {
    semverVersion = new (semver__WEBPACK_IMPORTED_MODULE_0___default().SemVer)(version, semverRange.loose);

    if (semverVersion.prerelease) {
      semverVersion.prerelease = [];
    }
  } catch (err) {
    return false;
  } // A range has multiple sets of comparators. A version must satisfy all
  // comparators in a set and at least one set to satisfy the range.


  return semverRange.set.some(comparatorSet => {
    for (const comparator of comparatorSet) if (comparator.semver.prerelease) comparator.semver.prerelease = [];

    return comparatorSet.every(comparator => {
      return comparator.test(semverVersion);
    });
  });
}

/***/ }),
/* 232 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": () => /* reexport safe */ _Cache__WEBPACK_IMPORTED_MODULE_0__.Cache,
/* harmony export */   "DEFAULT_RC_FILENAME": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_RC_FILENAME,
/* harmony export */   "DEFAULT_LOCK_FILENAME": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LOCK_FILENAME,
/* harmony export */   "Configuration": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.Configuration,
/* harmony export */   "FormatType": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.FormatType,
/* harmony export */   "ProjectLookup": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.ProjectLookup,
/* harmony export */   "SettingsType": () => /* reexport safe */ _Configuration__WEBPACK_IMPORTED_MODULE_1__.SettingsType,
/* harmony export */   "BuildType": () => /* reexport safe */ _Installer__WEBPACK_IMPORTED_MODULE_2__.BuildType,
/* harmony export */   "LightReport": () => /* reexport safe */ _LightReport__WEBPACK_IMPORTED_MODULE_3__.LightReport,
/* harmony export */   "Manifest": () => /* reexport safe */ _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest,
/* harmony export */   "MessageName": () => /* reexport safe */ _MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName,
/* harmony export */   "Project": () => /* reexport safe */ _Project__WEBPACK_IMPORTED_MODULE_6__.Project,
/* harmony export */   "TAG_REGEXP": () => /* reexport safe */ _ProtocolResolver__WEBPACK_IMPORTED_MODULE_7__.TAG_REGEXP,
/* harmony export */   "ReportError": () => /* reexport safe */ _Report__WEBPACK_IMPORTED_MODULE_8__.ReportError,
/* harmony export */   "Report": () => /* reexport safe */ _Report__WEBPACK_IMPORTED_MODULE_8__.Report,
/* harmony export */   "StreamReport": () => /* reexport safe */ _StreamReport__WEBPACK_IMPORTED_MODULE_9__.StreamReport,
/* harmony export */   "TelemetryManager": () => /* reexport safe */ _TelemetryManager__WEBPACK_IMPORTED_MODULE_10__.TelemetryManager,
/* harmony export */   "ThrowReport": () => /* reexport safe */ _ThrowReport__WEBPACK_IMPORTED_MODULE_11__.ThrowReport,
/* harmony export */   "VirtualFetcher": () => /* reexport safe */ _VirtualFetcher__WEBPACK_IMPORTED_MODULE_12__.VirtualFetcher,
/* harmony export */   "WorkspaceResolver": () => /* reexport safe */ _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_13__.WorkspaceResolver,
/* harmony export */   "Workspace": () => /* reexport safe */ _Workspace__WEBPACK_IMPORTED_MODULE_14__.Workspace,
/* harmony export */   "YarnVersion": () => /* reexport safe */ _YarnVersion__WEBPACK_IMPORTED_MODULE_15__.YarnVersion,
/* harmony export */   "LinkType": () => /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_16__.LinkType,
/* harmony export */   "hashUtils": () => /* reexport module object */ _hashUtils__WEBPACK_IMPORTED_MODULE_17__,
/* harmony export */   "httpUtils": () => /* reexport module object */ _httpUtils__WEBPACK_IMPORTED_MODULE_18__,
/* harmony export */   "execUtils": () => /* reexport module object */ _execUtils__WEBPACK_IMPORTED_MODULE_19__,
/* harmony export */   "folderUtils": () => /* reexport module object */ _folderUtils__WEBPACK_IMPORTED_MODULE_20__,
/* harmony export */   "miscUtils": () => /* reexport module object */ _miscUtils__WEBPACK_IMPORTED_MODULE_21__,
/* harmony export */   "scriptUtils": () => /* reexport module object */ _scriptUtils__WEBPACK_IMPORTED_MODULE_22__,
/* harmony export */   "semverUtils": () => /* reexport module object */ _semverUtils__WEBPACK_IMPORTED_MODULE_23__,
/* harmony export */   "structUtils": () => /* reexport module object */ _structUtils__WEBPACK_IMPORTED_MODULE_24__,
/* harmony export */   "tgzUtils": () => /* reexport module object */ _tgzUtils__WEBPACK_IMPORTED_MODULE_25__
/* harmony export */ });
/* harmony import */ var _execUtils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(271);
/* harmony import */ var _folderUtils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(111);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(142);
/* harmony import */ var _httpUtils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(273);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(121);
/* harmony import */ var _scriptUtils__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(254);
/* harmony import */ var _semverUtils__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(231);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(140);
/* harmony import */ var _tgzUtils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(282);
/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);
/* harmony import */ var _Configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _Installer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(237);
/* harmony import */ var _LightReport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(238);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(230);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217);
/* harmony import */ var _Project__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(242);
/* harmony import */ var _ProtocolResolver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(224);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(226);
/* harmony import */ var _StreamReport__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(239);
/* harmony import */ var _TelemetryManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(272);
/* harmony import */ var _ThrowReport__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(250);
/* harmony import */ var _VirtualFetcher__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(228);
/* harmony import */ var _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(222);
/* harmony import */ var _Workspace__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(249);
/* harmony import */ var _YarnVersion__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(270);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(223);





































/***/ }),
/* 233 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": () => /* binding */ Cache
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(119);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(211);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(114);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(207);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(217);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(226);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(142);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(121);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(140);









const CACHE_VERSION = 6;
class Cache {
  constructor(cacheCwd, {
    configuration,
    immutable = configuration.get(`enableImmutableCache`),
    check = false
  }) {
    // Contains the list of cache files that got accessed since the last time
    // you cleared the variable. Useful to know which files aren't needed
    // anymore when used in conjunction with fetchEverything.
    this.markedFiles = new Set();
    this.mutexes = new Map();
    this.configuration = configuration;
    this.cwd = cacheCwd;
    this.immutable = immutable;
    this.check = check;
    const cacheKeyOverride = configuration.get(`cacheKeyOverride`);

    if (cacheKeyOverride !== null) {
      this.cacheKey = `${cacheKeyOverride}`;
    } else {
      const compressionLevel = configuration.get(`compressionLevel`);
      const compressionKey = compressionLevel !== _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_COMPRESSION_LEVEL ? `c${compressionLevel}` : ``;
      this.cacheKey = [CACHE_VERSION, compressionKey].join(``);
    }
  }

  static async find(configuration, {
    immutable,
    check
  } = {}) {
    const cache = new Cache(configuration.get(`cacheFolder`), {
      configuration,
      immutable,
      check
    });
    await cache.setup();
    return cache;
  }

  get mirrorCwd() {
    if (!this.configuration.get(`enableMirror`)) return null;
    const mirrorCwd = `${this.configuration.get(`globalFolder`)}/cache`;
    return mirrorCwd !== this.cwd ? mirrorCwd : null;
  }

  getVersionFilename(locator) {
    return `${_structUtils__WEBPACK_IMPORTED_MODULE_3__.slugifyLocator(locator)}-${this.cacheKey}.zip`;
  }

  getChecksumFilename(locator, checksum) {
    // We only want the actual checksum (not the cache version, since the whole
    // point is to avoid changing the filenames when the cache version changes)
    const contentChecksum = getHashComponent(checksum); // We only care about the first few characters. It doesn't matter if that
    // makes the hash easier to collide with, because we check the file hashes
    // during each install anyway.

    const significantChecksum = contentChecksum.slice(0, 10);
    return `${_structUtils__WEBPACK_IMPORTED_MODULE_3__.slugifyLocator(locator)}-${significantChecksum}.zip`;
  }

  getLocatorPath(locator, expectedChecksum) {
    // If there is no mirror, then the local cache *is* the mirror, in which
    // case we use the versioned filename pattern.
    if (this.mirrorCwd === null) return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(this.cwd, this.getVersionFilename(locator)); // If we don't yet know the checksum, discard the path resolution for now
    // until the checksum can be obtained from somewhere (mirror or network).

    if (expectedChecksum === null) return null; // If the cache key changed then we assume that the content probably got
    // altered as well and thus the existing path won't be good enough anymore.

    const cacheKey = getCacheKeyComponent(expectedChecksum);
    if (cacheKey !== this.cacheKey) return null;
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(this.cwd, this.getChecksumFilename(locator, expectedChecksum));
  }

  getLocatorMirrorPath(locator) {
    const mirrorCwd = this.mirrorCwd;
    return mirrorCwd !== null ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(mirrorCwd, this.getVersionFilename(locator)) : null;
  }

  async setup() {
    if (!this.configuration.get(`enableGlobalCache`)) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.mkdirPromise(this.cwd, {
        recursive: true
      });
      const gitignorePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(this.cwd, `.gitignore`);
      const gitignoreExists = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.existsPromise(gitignorePath);

      if (!gitignoreExists) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.writeFilePromise(gitignorePath, `/.gitignore\n*.lock\n`);
      }
    }
  }

  async fetchPackageFromCache(locator, expectedChecksum, {
    onHit,
    onMiss,
    loader,
    skipIntegrityCheck
  }) {
    const mirrorPath = this.getLocatorMirrorPath(locator);
    const baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.NodeFS();

    const validateFile = async (path, refetchPath = null) => {
      const actualChecksum = !skipIntegrityCheck || !expectedChecksum ? `${this.cacheKey}/${await _hashUtils__WEBPACK_IMPORTED_MODULE_7__.checksumFile(path)}` : expectedChecksum;

      if (refetchPath !== null) {
        const previousChecksum = !skipIntegrityCheck || !expectedChecksum ? `${this.cacheKey}/${await _hashUtils__WEBPACK_IMPORTED_MODULE_7__.checksumFile(refetchPath)}` : expectedChecksum;

        if (actualChecksum !== previousChecksum) {
          throw new _Report__WEBPACK_IMPORTED_MODULE_8__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_9__.MessageName.CACHE_CHECKSUM_MISMATCH, `The remote archive doesn't match the local checksum - has the local cache been corrupted?`);
        }
      }

      if (expectedChecksum !== null && actualChecksum !== expectedChecksum) {
        let checksumBehavior; // Using --check-cache overrides any preconfigured checksum behavior

        if (this.check) checksumBehavior = `throw`; // If the lockfile references an old cache format, we tolerate different checksums
        else if (getCacheKeyComponent(expectedChecksum) !== getCacheKeyComponent(actualChecksum)) checksumBehavior = `update`;else checksumBehavior = this.configuration.get(`checksumBehavior`);

        switch (checksumBehavior) {
          case `ignore`:
            return expectedChecksum;

          case `update`:
            return actualChecksum;

          default:
          case `throw`:
            {
              throw new _Report__WEBPACK_IMPORTED_MODULE_8__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_9__.MessageName.CACHE_CHECKSUM_MISMATCH, `The remote archive doesn't match the expected checksum`);
            }
        }
      }

      return actualChecksum;
    };

    const validateFileAgainstRemote = async cachePath => {
      if (!loader) throw new Error(`Cache check required but no loader configured for ${_structUtils__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(this.configuration, locator)}`);
      const zipFs = await loader();
      const refetchPath = zipFs.getRealPath();
      zipFs.saveAndClose();
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.chmodPromise(refetchPath, 0o644);
      return await validateFile(cachePath, refetchPath);
    };

    const loadPackageThroughMirror = async () => {
      if (mirrorPath === null || !_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.existsSync(mirrorPath)) {
        const zipFs = await loader();
        const realPath = zipFs.getRealPath();
        zipFs.saveAndClose();
        return realPath;
      }

      const tempDir = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.mktempPromise();
      const tempPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tempDir, this.getVersionFilename(locator));
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.copyFilePromise(mirrorPath, tempPath, (fs__WEBPACK_IMPORTED_MODULE_1___default().constants.COPYFILE_FICLONE));
      return tempPath;
    };

    const loadPackage = async () => {
      if (!loader) throw new Error(`Cache entry required but missing for ${_structUtils__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(this.configuration, locator)}`);
      if (this.immutable) throw new _Report__WEBPACK_IMPORTED_MODULE_8__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_9__.MessageName.IMMUTABLE_CACHE, `Cache entry required but missing for ${_structUtils__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(this.configuration, locator)}`);
      const originalPath = await loadPackageThroughMirror();
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.chmodPromise(originalPath, 0o644); // Do this before moving the file so that we don't pollute the cache with corrupted archives

      const checksum = await validateFile(originalPath);
      const cachePath = this.getLocatorPath(locator, checksum);
      if (!cachePath) throw new Error(`Assertion failed: Expected the cache path to be available`);
      return await this.writeFileWithLock(cachePath, async () => {
        return await this.writeFileWithLock(mirrorPath, async () => {
          // Doing a move is important to ensure atomic writes (todo: cross-drive?)
          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.movePromise(originalPath, cachePath);
          if (mirrorPath !== null) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.copyFilePromise(cachePath, mirrorPath, (fs__WEBPACK_IMPORTED_MODULE_1___default().constants.COPYFILE_FICLONE));
          return [cachePath, checksum];
        });
      });
    };

    const loadPackageThroughMutex = async () => {
      const mutex = loadPackage();
      this.mutexes.set(locator.locatorHash, mutex);

      try {
        return await mutex;
      } finally {
        this.mutexes.delete(locator.locatorHash);
      }
    };

    for (let mutex; mutex = this.mutexes.get(locator.locatorHash);) await mutex; // We don't yet know whether the cache path can be computed yet, since that
    // depends on whether the cache is actually the mirror or not, and whether
    // the checksum is known or not.


    const tentativeCachePath = this.getLocatorPath(locator, expectedChecksum);
    const cacheExists = tentativeCachePath !== null ? baseFs.existsSync(tentativeCachePath) : false;
    const action = cacheExists ? onHit : onMiss; // Note: must be synchronous, otherwise the mutex may break (a concurrent
    // execution may start while we're running the action)

    if (action) action();
    let cachePath;
    let checksum;

    if (!cacheExists) {
      [cachePath, checksum] = await loadPackageThroughMutex();
    } else {
      cachePath = tentativeCachePath;

      if (this.check) {
        checksum = await validateFileAgainstRemote(cachePath);
      } else {
        checksum = await validateFile(cachePath);
      }
    }

    this.markedFiles.add(cachePath);
    let zipFs = null;
    const libzip = await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)();
    const lazyFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.LazyFS(() => _miscUtils__WEBPACK_IMPORTED_MODULE_11__.prettifySyncErrors(() => {
      return zipFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ZipFS(cachePath, {
        baseFs,
        libzip,
        readOnly: true
      });
    }, message => {
      return `Failed to open the cache entry for ${_structUtils__WEBPACK_IMPORTED_MODULE_3__.prettyLocator(this.configuration, locator)}: ${message}`;
    }), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath); // We use an AliasFS to speed up getRealPath calls (e.g. VirtualFetcher.ensureVirtualLink)
    // (there's no need to create the lazy baseFs instance to gather the already-known cachePath)

    const aliasFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.AliasFS(cachePath, {
      baseFs: lazyFs,
      pathUtils: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath
    });

    const releaseFs = () => {
      if (zipFs !== null) {
        zipFs.discardAndClose();
      }
    };

    return [aliasFs, releaseFs, checksum];
  }

  async writeFileWithLock(file, generator) {
    if (file === null) return await generator();
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.dirname(file), {
      recursive: true
    });
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.lockPromise(file, async () => {
      return await generator();
    });
  }

}

function getCacheKeyComponent(checksum) {
  const split = checksum.indexOf(`/`);
  return split !== -1 ? checksum.slice(0, split) : null;
}

function getHashComponent(checksum) {
  const split = checksum.indexOf(`/`);
  return split !== -1 ? checksum.slice(split + 1) : checksum;
}

/***/ }),
/* 234 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLibzipSync": () => /* binding */ getLibzipSync,
/* harmony export */   "getLibzipPromise": () => /* binding */ getLibzipPromise
/* harmony export */ });
/* harmony import */ var _makeInterface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(235);

let mod = null;
function getLibzipSync() {
  if (mod === null) mod = (0,_makeInterface__WEBPACK_IMPORTED_MODULE_0__.makeInterface)(__webpack_require__(236));
  return mod;
}
async function getLibzipPromise() {
  return getLibzipSync();
}

/***/ }),
/* 235 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeInterface": () => /* binding */ makeInterface
/* harmony export */ });
const number64 = [`number`, `number`];
const makeInterface = libzip => ({
  // Those are getters because they can change after memory growth
  get HEAP8() {
    return libzip.HEAP8;
  },

  get HEAPU8() {
    return libzip.HEAPU8;
  },

  SEEK_SET: 0,
  SEEK_CUR: 1,
  SEEK_END: 2,
  ZIP_CHECKCONS: 4,
  ZIP_CREATE: 1,
  ZIP_EXCL: 2,
  ZIP_TRUNCATE: 8,
  ZIP_RDONLY: 16,
  ZIP_FL_OVERWRITE: 8192,
  ZIP_FL_COMPRESSED: 4,
  ZIP_OPSYS_DOS: 0x00,
  ZIP_OPSYS_AMIGA: 0x01,
  ZIP_OPSYS_OPENVMS: 0x02,
  ZIP_OPSYS_UNIX: 0x03,
  ZIP_OPSYS_VM_CMS: 0x04,
  ZIP_OPSYS_ATARI_ST: 0x05,
  ZIP_OPSYS_OS_2: 0x06,
  ZIP_OPSYS_MACINTOSH: 0x07,
  ZIP_OPSYS_Z_SYSTEM: 0x08,
  ZIP_OPSYS_CPM: 0x09,
  ZIP_OPSYS_WINDOWS_NTFS: 0x0a,
  ZIP_OPSYS_MVS: 0x0b,
  ZIP_OPSYS_VSE: 0x0c,
  ZIP_OPSYS_ACORN_RISC: 0x0d,
  ZIP_OPSYS_VFAT: 0x0e,
  ZIP_OPSYS_ALTERNATE_MVS: 0x0f,
  ZIP_OPSYS_BEOS: 0x10,
  ZIP_OPSYS_TANDEM: 0x11,
  ZIP_OPSYS_OS_400: 0x12,
  ZIP_OPSYS_OS_X: 0x13,
  ZIP_CM_DEFAULT: -1,
  ZIP_CM_STORE: 0,
  ZIP_CM_DEFLATE: 8,
  uint08S: libzip._malloc(1),
  uint16S: libzip._malloc(2),
  uint32S: libzip._malloc(4),
  uint64S: libzip._malloc(8),
  malloc: libzip._malloc,
  free: libzip._free,
  getValue: libzip.getValue,
  open: libzip.cwrap(`zip_open`, `number`, [`string`, `number`, `number`]),
  openFromSource: libzip.cwrap(`zip_open_from_source`, `number`, [`number`, `number`, `number`]),
  close: libzip.cwrap(`zip_close`, `number`, [`number`]),
  discard: libzip.cwrap(`zip_discard`, null, [`number`]),
  getError: libzip.cwrap(`zip_get_error`, `number`, [`number`]),
  getName: libzip.cwrap(`zip_get_name`, `string`, [`number`, `number`, `number`]),
  getNumEntries: libzip.cwrap(`zip_get_num_entries`, `number`, [`number`, `number`]),
  delete: libzip.cwrap(`zip_delete`, `number`, [`number`, `number`]),
  stat: libzip.cwrap(`zip_stat`, `number`, [`number`, `string`, `number`, `number`]),
  statIndex: libzip.cwrap(`zip_stat_index`, `number`, [`number`, ...number64, `number`, `number`]),
  fopen: libzip.cwrap(`zip_fopen`, `number`, [`number`, `string`, `number`]),
  fopenIndex: libzip.cwrap(`zip_fopen_index`, `number`, [`number`, ...number64, `number`]),
  fread: libzip.cwrap(`zip_fread`, `number`, [`number`, `number`, `number`, `number`]),
  fclose: libzip.cwrap(`zip_fclose`, `number`, [`number`]),
  dir: {
    add: libzip.cwrap(`zip_dir_add`, `number`, [`number`, `string`])
  },
  file: {
    add: libzip.cwrap(`zip_file_add`, `number`, [`number`, `string`, `number`, `number`]),
    getError: libzip.cwrap(`zip_file_get_error`, `number`, [`number`]),
    getExternalAttributes: libzip.cwrap(`zip_file_get_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
    setExternalAttributes: libzip.cwrap(`zip_file_set_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
    setMtime: libzip.cwrap(`zip_file_set_mtime`, `number`, [`number`, ...number64, `number`, `number`]),
    setCompression: libzip.cwrap(`zip_set_file_compression`, `number`, [`number`, ...number64, `number`, `number`])
  },
  ext: {
    countSymlinks: libzip.cwrap(`zip_ext_count_symlinks`, `number`, [`number`])
  },
  error: {
    initWithCode: libzip.cwrap(`zip_error_init_with_code`, null, [`number`, `number`]),
    strerror: libzip.cwrap(`zip_error_strerror`, `string`, [`number`])
  },
  name: {
    locate: libzip.cwrap(`zip_name_locate`, `number`, [`number`, `string`, `number`])
  },
  source: {
    fromUnattachedBuffer: libzip.cwrap(`zip_source_buffer_create`, `number`, [`number`, `number`, `number`, `number`]),
    fromBuffer: libzip.cwrap(`zip_source_buffer`, `number`, [`number`, `number`, ...number64, `number`]),
    free: libzip.cwrap(`zip_source_free`, null, [`number`]),
    keep: libzip.cwrap(`zip_source_keep`, null, [`number`]),
    open: libzip.cwrap(`zip_source_open`, `number`, [`number`]),
    close: libzip.cwrap(`zip_source_close`, `number`, [`number`]),
    seek: libzip.cwrap(`zip_source_seek`, `number`, [`number`, ...number64, `number`]),
    tell: libzip.cwrap(`zip_source_tell`, `number`, [`number`]),
    read: libzip.cwrap(`zip_source_read`, `number`, [`number`, `number`, `number`]),
    error: libzip.cwrap(`zip_source_error`, `number`, [`number`]),
    setMtime: libzip.cwrap(`zip_source_set_mtime`, `number`, [`number`, `number`])
  },
  struct: {
    stat: libzip.cwrap(`zipstruct_stat`, `number`, []),
    statS: libzip.cwrap(`zipstruct_statS`, `number`, []),
    statName: libzip.cwrap(`zipstruct_stat_name`, `string`, [`number`]),
    statIndex: libzip.cwrap(`zipstruct_stat_index`, `number`, [`number`]),
    statSize: libzip.cwrap(`zipstruct_stat_size`, `number`, [`number`]),
    statCompSize: libzip.cwrap(`zipstruct_stat_comp_size`, `number`, [`number`]),
    statCompMethod: libzip.cwrap(`zipstruct_stat_comp_method`, `number`, [`number`]),
    statMtime: libzip.cwrap(`zipstruct_stat_mtime`, `number`, [`number`]),
    error: libzip.cwrap(`zipstruct_error`, `number`, []),
    errorS: libzip.cwrap(`zipstruct_errorS`, `number`, [])
  }
});

/***/ }),
/* 236 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var frozenFs = Object.assign({}, __webpack_require__(6));
var Module = typeof Module !== "undefined" ? Module : {};
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}
var arguments_ = [];
var thisProgram = "./this.program";
var quit_ = function(status, toThrow) {
  throw toThrow;
};
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = true;
var scriptDirectory = "";
function locateFile(path) {
  if (Module["locateFile"]) {
    return Module["locateFile"](path, scriptDirectory);
  }
  return scriptDirectory + path;
}
var read_, readBinary;
var nodeFS;
var nodePath;
if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = __webpack_require__(113).dirname(scriptDirectory) + "/";
  } else {
    scriptDirectory = __dirname + "/";
  }
  read_ = function shell_read(filename, binary) {
    var ret = tryParseAsDataURI(filename);
    if (ret) {
      return binary ? ret : ret.toString();
    }
    if (!nodeFS) nodeFS = frozenFs;
    if (!nodePath) nodePath = __webpack_require__(113);
    filename = nodePath["normalize"](filename);
    return nodeFS["readFileSync"](filename, binary ? null : "utf8");
  };
  readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };
  if (process["argv"].length > 1) {
    thisProgram = process["argv"][1].replace(/\\/g, "/");
  }
  arguments_ = process["argv"].slice(2);
  if (true) {
    module["exports"] = Module;
  }
  (function() {})("uncaughtException", function(ex) {
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });
  (function() {})("unhandledRejection", abort);
  quit_ = function(status) {
    process["exit"](status);
  };
  Module["inspect"] = function() {
    return "[Emscripten Module object]";
  };
} else {
}
var out = Module["print"] || console.log.bind(console);
var err = Module["printErr"] || console.warn.bind(console);
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
moduleOverrides = null;
if (Module["arguments"]) arguments_ = Module["arguments"];
if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
if (Module["quit"]) quit_ = Module["quit"];
var tempRet0 = 0;
var setTempRet0 = function(value) {
  tempRet0 = value;
};
var wasmBinary;
if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
var noExitRuntime;
if (Module["noExitRuntime"]) noExitRuntime = Module["noExitRuntime"];
if (typeof WebAssembly !== "object") {
  abort("no native wasm support detected");
}
function getValue(ptr, type, noSafe) {
  type = type || "i8";
  if (type.charAt(type.length - 1) === "*") type = "i32";
  switch (type) {
    case "i1":
      return HEAP8[ptr >> 0];
    case "i8":
      return HEAP8[ptr >> 0];
    case "i16":
      return HEAP16[ptr >> 1];
    case "i32":
      return HEAP32[ptr >> 2];
    case "i64":
      return HEAP32[ptr >> 2];
    case "float":
      return HEAPF32[ptr >> 2];
    case "double":
      return HEAPF64[ptr >> 3];
    default:
      abort("invalid type for getValue: " + type);
  }
  return null;
}
var wasmMemory;
var wasmTable = new WebAssembly.Table({
  initial: 31,
  maximum: 31 + 0,
  element: "anyfunc"
});
var ABORT = false;
var EXITSTATUS = 0;
function assert(condition, text) {
  if (!condition) {
    abort("Assertion failed: " + text);
  }
}
function getCFunc(ident) {
  var func = Module["_" + ident];
  assert(
    func,
    "Cannot call unknown function " + ident + ", make sure it is exported"
  );
  return func;
}
function ccall(ident, returnType, argTypes, args, opts) {
  var toC = {
    string: function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) {
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    array: function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };
  function convertReturnValue(ret) {
    if (returnType === "string") return UTF8ToString(ret);
    if (returnType === "boolean") return Boolean(ret);
    return ret;
  }
  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  var numericArgs = argTypes.every(function(type) {
    return type === "number";
  });
  var numericRet = returnType !== "string";
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  };
}
var UTF8Decoder =
  typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = "";
    while (idx < endPtr) {
      var u0 = heap[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heap[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode(((u0 & 31) << 6) | u1);
        continue;
      }
      var u2 = heap[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
      }
    }
  }
  return str;
}
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
}
function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) return 0;
  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1;
  for (var i = 0; i < str.length; ++i) {
    var u = str.charCodeAt(i);
    if (u >= 55296 && u <= 57343) {
      var u1 = str.charCodeAt(++i);
      u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);
    }
    if (u <= 127) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 2047) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 192 | (u >> 6);
      heap[outIdx++] = 128 | (u & 63);
    } else if (u <= 65535) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 224 | (u >> 12);
      heap[outIdx++] = 128 | ((u >> 6) & 63);
      heap[outIdx++] = 128 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 240 | (u >> 18);
      heap[outIdx++] = 128 | ((u >> 12) & 63);
      heap[outIdx++] = 128 | ((u >> 6) & 63);
      heap[outIdx++] = 128 | (u & 63);
    }
  }
  heap[outIdx] = 0;
  return outIdx - startIdx;
}
function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    var u = str.charCodeAt(i);
    if (u >= 55296 && u <= 57343)
      u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);
    if (u <= 127) ++len;
    else if (u <= 2047) len += 2;
    else if (u <= 65535) len += 3;
    else len += 4;
  }
  return len;
}
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}
function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}
var WASM_PAGE_SIZE = 65536;
function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}
var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module["HEAP8"] = HEAP8 = new Int8Array(buf);
  Module["HEAP16"] = HEAP16 = new Int16Array(buf);
  Module["HEAP32"] = HEAP32 = new Int32Array(buf);
  Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
  Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
  Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
  Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
  Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
}
var DYNAMIC_BASE = 5263680,
  DYNAMICTOP_PTR = 20640;
var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
if (Module["wasmMemory"]) {
  wasmMemory = Module["wasmMemory"];
} else {
  wasmMemory = new WebAssembly.Memory({
    initial: INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
    maximum: 2147483648 / WASM_PAGE_SIZE
  });
}
if (wasmMemory) {
  buffer = wasmMemory.buffer;
}
INITIAL_INITIAL_MEMORY = buffer.byteLength;
updateGlobalBufferAndViews(buffer);
HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
function callRuntimeCallbacks(callbacks) {
  while (callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == "function") {
      callback(Module);
      continue;
    }
    var func = callback.func;
    if (typeof func === "number") {
      if (callback.arg === undefined) {
        Module["dynCall_v"](func);
      } else {
        Module["dynCall_vi"](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}
var __ATPRERUN__ = [];
var __ATINIT__ = [];
var __ATMAIN__ = [];
var __ATPOSTRUN__ = [];
var runtimeInitialized = false;
function preRun() {
  if (Module["preRun"]) {
    if (typeof Module["preRun"] == "function")
      Module["preRun"] = [Module["preRun"]];
    while (Module["preRun"].length) {
      addOnPreRun(Module["preRun"].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}
function initRuntime() {
  runtimeInitialized = true;
  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
  TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
  FS.ignorePermissions = false;
  callRuntimeCallbacks(__ATMAIN__);
}
function postRun() {
  if (Module["postRun"]) {
    if (typeof Module["postRun"] == "function")
      Module["postRun"] = [Module["postRun"]];
    while (Module["postRun"].length) {
      addOnPostRun(Module["postRun"].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}
function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
var Math_abs = Math.abs;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_min = Math.min;
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null;
function getUniqueRunDependency(id) {
  return id;
}
function addRunDependency(id) {
  runDependencies++;
  if (Module["monitorRunDependencies"]) {
    Module["monitorRunDependencies"](runDependencies);
  }
}
function removeRunDependency(id) {
  runDependencies--;
  if (Module["monitorRunDependencies"]) {
    Module["monitorRunDependencies"](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback();
    }
  }
}
Module["preloadedImages"] = {};
Module["preloadedAudios"] = {};
function abort(what) {
  if (Module["onAbort"]) {
    Module["onAbort"](what);
  }
  what += "";
  out(what);
  err(what);
  ABORT = true;
  EXITSTATUS = 1;
  what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
  throw new WebAssembly.RuntimeError(what);
}
function hasPrefix(str, prefix) {
  return String.prototype.startsWith
    ? str.startsWith(prefix)
    : str.indexOf(prefix) === 0;
}
var dataURIPrefix = "data:application/octet-stream;base64,";
function isDataURI(filename) {
  return hasPrefix(filename, dataURIPrefix);
}
var wasmBinaryFile =
  "data:application/octet-stream;base64,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AiwgASgCDBCDAwsgASgCDEEAQgBBBRAiGiABKAIMKAIABEAgASgCDCgCABAcCyABKAIMEBYLIAFBEGokAAuBAgEBfyMAQRBrIgEkACABIAA2AgwgASABKAIMKAIcNgIEIAEoAgQQ6gIgASABKAIEKAIUNgIIIAEoAgggASgCDCgCEEsEQCABIAEoAgwoAhA2AggLAkAgASgCCEUNACABKAIMKAIMIAEoAgQoAhAgASgCCBAaGiABKAIMIgAgASgCCCAAKAIMajYCDCABKAIEIgAgASgCCCAAKAIQajYCECABKAIMIgAgASgCCCAAKAIUajYCFCABKAIMIgAgACgCECABKAIIazYCECABKAIEIgAgACgCFCABKAIIazYCFCABKAIEKAIUDQAgASgCBCABKAIEKAIINgIQCyABQRBqJAALYAEBfyMAQRBrIgEkACABIAA2AgggASABKAIIQgIQHzYCBAJAIAEoAgRFBEAgAUEAOwEODAELIAEgASgCBC0AACABKAIELQABQQh0ajsBDgsgAS8BDiEAIAFBEGokACAAC1oBAX8jAEEgayICJAAgAiAANgIcIAIgATcDECACIAIoAhwgAikDEBDPATYCDCACKAIMBEAgAigCHCIAIAIpAxAgACkDEHw3AxALIAIoAgwhACACQSBqJAAgAAtvAQF/IwBBEGsiAiQAIAIgADYCCCACIAE7AQYgAiACKAIIQgIQHzYCAAJAIAIoAgBFBEAgAkF/NgIMDAELIAIoAgAgAi8BBjoAACACKAIAIAIvAQZBCHU6AAEgAkEANgIMCyACKAIMGiACQRBqJAALjwEBAX8jAEEQayICJAAgAiAANgIIIAIgATYCBCACIAIoAghCBBAfNgIAAkAgAigCAEUEQCACQX82AgwMAQsgAigCACACKAIEOgAAIAIoAgAgAigCBEEIdjoAASACKAIAIAIoAgRBEHY6AAIgAigCACACKAIEQRh2OgADIAJBADYCDAsgAigCDBogAkEQaiQAC7YCAQF/IwBBMGsiBCQAIAQgADYCJCAEIAE2AiAgBCACNwMYIAQgAzYCFAJAIAQoAiQpAxhCASAEKAIUrYaDUARAIAQoAiRBDGpBHEEAEBUgBEJ/NwMoDAELAkAgBCgCJCgCAEUEQCAEIAQoAiQoAgggBCgCICAEKQMYIAQoAhQgBCgCJCgC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AwEBfyMAQTBrIgMkACADIAA2AiQgAyABNgIgIAMgAjcDGAJAIAMoAiQtAChBAXEEQCADQn83AygMAQsCQAJAIAMoAiQoAiBBAE0NACADKQMYQv///////////wBWDQAgAykDGEIAWA0BIAMoAiANAQsgAygCJEEMakESQQAQFSADQn83AygMAQsgAygCJC0ANUEBcQRAIANCfzcDKAwBCwJ/IwBBEGsiACADKAIkNgIMIAAoAgwtADRBAXELBEAgA0IANwMoDAELIAMpAxhQBEAgA0IANwMoDAELIANCADcDEANAIAMpAxAgAykDGFQEQCADIAMoAiQgAygCICADKQMQp2ogAykDGCADKQMQfUEBECIiAjcDCCACQgBTBEAgAygCJEEBOgA1IAMpAxBQBEAgA0J/NwMoDAQLIAMgAykDEDcDKAwDCyADKQMIUARAIAMoAiRBAToANAUgAyADKQMIIAMpAxB8NwMQDAILCwsgAyADKQMQNwMoCyADKQMoIQIgA0EwaiQAIAILNgEBfyMAQRBrIgEgADYCDAJ+IAEoAgwtAABBAXEEQCABKAIMKQMIIAEoAgwpAxB9DAELQgALC7IBAgF/AX4jAEEQayIBJAAgASAANgIEIAEgASgCBEIIEB82AgACQCABKAIARQRAIAFCADcDCAwBCyABIAEoAgAtAACtIAEoAgAtAAetQjiGIAEoAgAtAAatQjCGfCABKAIALQAFrUIohnwgASgCAC0ABK1CIIZ8IAEoAgAtAAOtQhiGfCABKAIALQACrUIQhnwgASgCAC0AAa1CCIZ8fDcDCAsgASkDCCECIAFBEGokACACC6gBAQF/IwBBEGsiASQAIAEgADYCCAJAIAEoAggoAiBBAE0EQCABKAIIQQxqQRJBABAVIAFBfzYCDAwBCyABKAIIIgAgACgCIEF/ajYCICABKAIIKAIgRQRAIAEoAghBAEIAQQIQIhogASgCCCgCAARAIAEoAggoAgAQMkEASARAIAEoAghBDGpBFEEAEBULCwsgAUEANgIMCyABKAIMIQAgAUEQaiQAIAAL8QICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgA2AgAgAyACIARrQXxxIgJqIgFBfGogADYCACACQQlJDQAgAyAANgIIIAMgADYCBCABQXhqIAA2AgAgAUF0aiAANgIAIAJBGUkNACADIAA2AhggAyAANgIUIAMgADYCECADIAA2AgwgAUFwaiAANgIAIAFBbGogADYCACABQWhqIAA2AgAgAUFkaiAANgIAIAIgA0EEcUEYciIBayICQSBJDQAgAK0iBUIghiAFhCEFIAEgA2ohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCwvcAQEBfyMAQRBrIgEkACABIAA2AgwgASgCDARAIAEoAgwoAigEQCABKAIMKAIoQQA2AiggASgCDCgCKEIANwMgIAEoAgwCfiABKAIMKQMYIAEoAgwpAyBWBEAgASgCDCkDGAwBCyABKAIMKQMgCzcDGAsgASABKAIMKQMYNwMAA0AgASkDACABKAIMKQMIWkUEQCABKAIMKAIAIAEpAwCnQQR0aigCABAWIAEgASkDAEIBfDcDAAwBCwsgASgCDCgCABAWIAEoAgwoAgQQFiABKAIMEBYLIAFBEGokAAtgAgF/AX4jAEEQayIBJAAgASAANgIEAkAgASgCBCgCJEEBRwRAIAEoAgRBDGpBEkEAEBUgAUJ/NwMIDAELIAEgASgCBEEAQgBBDRAiNwMICyABKQMIIQIgAUEQaiQAIAILoAEBAX8jAEEgayIDJAAgAyAANgIYIAMgATYCFCADIAI3AwggAyADKAIYKAIAIAMoAhQgAykDCBDLASICNwMAAkAgAkIAUwRAIAMoAhhBCGogAygCGCgCABAYIANBfzYCHAwBCyADKQMAIAMpAwhSBEAgAygCGEEIakEGQRsQFSADQX82AhwMAQsgA0EANgIcCyADKAIcIQAgA0EgaiQAIAALawEBfyMAQSBrIgIgADYCHCACQgEgAigCHK2GNwMQIAJBDGogATYCAANAIAIgAigCDCIAQQRqNgIMIAIgACgCADYCCCACKAIIQQBIRQRAIAIgAikDEEIBIAIoAgithoQ3AxAMAQsLIAIpAxALLwEBfyMAQRBrIgEkACABIAA2AgwgASgCDCgCCBAWIAEoAgxBADYCCCABQRBqJAALzQEBAX8jAEEQayICJAAgAiAANgIIIAIgATYCBAJAIAIoAggtAChBAXEEQCACQX82AgwMAQsgAigCBEUEQCACKAIIQQxqQRJBABAVIAJBfzYCDAwBCyACKAIEEDwgAigCCCgCAARAIAIoAggoAgAgAigCBBA5QQBIBEAgAigCCEEMaiACKAIIKAIAEBggAkF/NgIMDAILCyACKAIIIAIoAgRCOEEDECJCAFMEQCACQX82AgwMAQsgAkEANgIMCyACKAIMIQAgAkEQaiQAIAALMQEBfyMAQRBrIgEkACABIAA2AgwgASgCDARAIAEoAgwQXCABKAIMEBYLIAFBEGokAAvfBAEBfyMAQSBrIgIgADYCGCACIAE2AhQCQCACKAIYRQRAIAJBATYCHAwBCyACIAIoAhgoAgA2AgwCQCACKAIYKAIIBEAgAiACKAIYKAIINgIQDAELIAJBATYCECACQQA2AggDQAJAIAIoAgggAigCGC8BBE8NAAJAIAIoAgwgAigCCGotAABBH0oEQCACKAIMIAIoAghqLQAAQYABSA0BCyACKAIMIAIoAghqLQAAQQ1GDQAgAigCDCACKAIIai0AAEEKRg0AIAIoAgwgAigCCGotAABBCUYEQAwBCyACQQM2AhACQCACKAIMIAIoAghqLQAAQeABcUHAAUYEQCACQQE2AgAMAQsCQCACKAIMIAIoAghqLQAAQfABcUHgAUYEQCACQQI2AgAMAQsCQCACKAIMIAIoAghqLQAAQfgBcUHwAUYEQCACQQM2AgAMAQsgAkEENgIQDAQLCwsgAigCCCACKAIAaiACKAIYLwEETwRAIAJBBDYCEAwCCyACQQE2AgQDQCACKAIEIAIoAgBNBEAgAigCDCACKAIIIAIoAgRqai0AAEHAAXFBgAFHBEAgAkEENgIQDAYFIAIgAigCBEEBajYCBAwCCwALCyACIAIoAgAgAigCCGo2AggLIAIgAigCCEEBajYCCAwBCwsLIAIoAhggAigCEDYCCCACKAIUBEACQCACKAIUQQJHDQAgAigCEEEDRw0AIAJBAjYCECACKAIYQQI2AggLAkAgAigCFCACKAIQRg0AIAIoAhBBAUYNACACQQU2AhwMAgsLIAIgAigCEDYCHAsgAigCHAtqAQF/IwBBEGsiASAANgIMIAEoAgxCADcD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KQMgQv////8PVg0AIAMoAqQBKQMoQv////8PWA0CCyADKAIcIAMoAqQBKQMoEC4gAygCHCADKAKkASkDIBAuDAELAkACQCADKAKgAUGACHENACADKAKkASkDIEL/////D1YNACADKAKkASkDKEL/////D1YNACADKAKkASkDSEL/////D1gNAQsgAygCpAEpAyhC/////w9aBEAgAygCHCADKAKkASkDKBAuCyADKAKkASkDIEL/////D1oEQCADKAIcIAMoAqQBKQMgEC4LIAMoAqQBKQNIQv////8PWgRAIAMoAhwgAygCpAEpA0gQLgsLCwJ/IwBBEGsiACADKAIcNgIMIAAoAgwtAABBAXFFCwRAIAMoAqgBQQhqQRRBABAVIAMoAhwQFyADKAKQARAkIANBfzYCrAEMAgsgA0EBAn8jAEEQayIAIAMoAhw2AgwCfiAAKAIMLQAAQQFxBEAgACgCDCkDEAwBC0IAC6dB//8DcQsgA0EgakGABhBQNgKMASADKAIcEBcgAygCjAEgAygCkAE2AgAgAyADKAKMATYCkAELIAMtAIUBQQFxBEAgAyADQRVqQgcQKjYCECADKAIQRQRAIAMoAqgBQQhqQQ5BABAVIAMoApABECQgA0F/NgKsAQwCCyADKAIQQQIQICADKAIQQc/TAEECEEAgAygCECADKAKkAS8BUkH/AXEQiwEgAygCECADKAKkASgCEEH//wNxECACfyMAQRBrIgAgAygCEDYCDCAAKAIMLQAAQQFxRQsEQCADKAKoAUEIakEUQQAQFSADKAIQEBcgAygCkAEQJCADQX82AqwBDAILIANBgbICQQcgA0EVakGABhBQNgIMIAMoAhAQFyADKAIMIAMoApABNgIAIAMgAygCDDYCkAELIAMgA0HQAGpCLhAqIgA2AkwgAEUEQCADKAKoAUEIakEOQQAQFSADKAKQARAkIANBfzYCrAEMAQsgAygCTEHF0wBBytMAIAMoAqABQYACcRtBBBBAIAMoAqABQYACcUUEQCADKAJMAn9BLSADLQCGAUEBcQ0AGiADKAKkAS8BCAtB//8DcRAgCyADKAJMAn9BLSADLQCGAUEBcQ0AGiADKAKkAS8BCgtB//8DcRAgIAMoAkwgAygCpAEvAQwQIAJAIAMtAIUBQQFxBEAgAygCTEHjABAgDAELIAMoAkwgAygCpAEoAhBB//8DcRAgCyADKAKkASgCFCADQZ4BaiADQZwBahDEASADKAJMIAMvAZ4BECAgAygCTCADLwGcARAgAkACQCADLQCFAUEBcUUNACADKAKkASkDKEIUWg0AIAMoAkxBABAhDAELIAMoAkwgAygCpAEoAhgQIQsCQAJAIAMoAqABQYACcUGAAkcNACADKAKkASkDIEL/////D1QEQCADKAKkASkDKEL/////D1QNAQsgAygCTEF/ECEgAygCTEF/ECEMAQsCQCADKAKkASkDIEL/////D1QEQCADKAJMIAMoAqQBKQMgpxAhDAELIAMoAkxBfxAhCwJAIAMoAqQBKQMoQv////8PVARAIAMoAkwgAygCpAEpAyinECEMAQsgAygCTEF/ECELCyADKAJMIAMoAqQBKAIwEFJB//8DcRAgIAMgAygCpAEoAjQgAygCoAEQgwFB//8DcSADKAKQAUGABhCDAUH//wNxajYCiAEgAygCTCADKAKIAUH//wNxECAgAygCoAFBgAJxRQRAIAMoAkwgAygCpAEoAjgQUkH//wNxECAgAygCTCADKAKkASgCPEH//wNxECAgAygCTCADKAKkAS8BQBAgIAMoAkwgAygCpAEoAkQQIQJAIAMoAqQBKQNIQv////8PVARAIAMoAkwgAygCpAEpA0inECEMAQsgAygCTEF/ECELCwJ/IwBBEGsiACADKAJMNgIMIAAoAgwtAABBAXFFCwRAIAMoAqgBQQhqQRRBABAVIAMoAkwQFyADKAKQARAkIANBfzYCrAEMAQsgAygCqAEgA0HQAGoCfiMAQRBrIgAgAygCTDYCDAJ+IAAoAgwtAABBAXEEQCAAKAIMKQMQDAELQgALCxA2QQBIBEAgAygCTBAXIAMoApABECQgA0F/NgKsAQwBCyADKAJMEBcgAygCpAEoAjAEQCADKAKoASADKAKkASgCMBCHAUEASARAIAMoApABECQgA0F/NgKsAQwCCwsgAygCkAEEQCADKAKoASADKAKQAUGABhCCAUEASARAIAMoApABECQgA0F/NgKsAQwCCwsgAygCkAEQJCADKAKkASgCNARAIAMoAqgBIAMoAqQBKAI0IAMoAqABEIIBQQBIBEAgA0F/NgKsAQwCCwsgAygCoAFBgAJxRQRAIAMoAqQBKAI4BEAgAygC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AigCGEECdGovAQAEQCACIAIoAhgiATYCECACKAIsQdwWaiEDIAIoAiwiBCgC0ChBAWohACAEIAA2AtAoIABBAnQgA2ogATYCACACKAIYIAIoAixB2ChqakEAOgAADAELIAIoAiQgAigCGEECdGpBADsBAgsgAiACKAIYQQFqNgIYDAELCwNAIAIoAiwoAtAoQQJIBEACQCACKAIQQQJIBEAgAiACKAIQQQFqIgA2AhAMAQtBACEACyACKAIsQdwWaiEDIAIoAiwiBCgC0ChBAWohASAEIAE2AtAoIAFBAnQgA2ogADYCACACIAA2AgwgAigCJCACKAIMQQJ0akEBOwEAIAIoAgwgAigCLEHYKGpqQQA6AAAgAigCLCIAIAAoAqgtQX9qNgKoLSACKAIgBEAgAigCLCIAIAAoAqwtIAIoAiAgAigCDEECdGovAQJrNgKsLQsMAQsLIAIoAiggAigCEDYCBCACIAIoAiwoAtAoQQJtNgIYA0AgAigCGEEBSEUEQCACKAIsIAIoAiQgAigCGBB1IAIgAigCGEF/ajYCGAwBCwsgAiACKAIcNgIMA0AgAiACKAIsKALgFjYCGCACKAIsQdwWaiEBIAIoAiwiAygC0CghACADIABBf2o2AtAoIAIoAiwgAEECdCABaigCADYC4BYgAigCLCACKAIkQQEQdSACIAIoAiwoAuAWNgIUIAIoAhghASACKAIsQdwWaiEDIAIoAiwiBCgC1ChBf2ohACAEIAA2AtQoIABBAnQgA2ogATYCACACKAIUIQEgAigCLEHcFmohAyACKAIsIgQoAtQoQX9qIQAgBCAANgLUKCAAQQJ0IANqIAE2AgAgAigCJCACKAIMQQJ0aiACKAIkIAIoAhhBAnRqLwEAIAIoAiQgAigCFEECdGovAQBqOwEAIAIoAgwgAigCLEHYKGpqAn8gAigCGCACKAIsQdgoamotAAAgAigCFCACKAIsQdgoamotAABOBEAgAigCGCACKAIsQdgoamotAAAMAQsgAigCFCACKAIsQdgoamotAAALQQFqOgAAIAIoAiQgAigCFEECdGogAigCDCIAOwECIAIoAiQgAigCGEECdGogADsBAiACIAIoAgwiAEEBajYCDCACKAIsIAA2AuAWIAIoAiwgAigCJEEBEHUgAigCLCgC0ChBAk4NAAsgAigCLCgC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AiAANgIIIAIgATYCBAJAAkACQCACKAIIKQMoQv////8PWg0AIAIoAggpAyBC/////w9aDQAgAigCBEGABHFFDQEgAigCCCkDSEL/////D1QNAQsgAkEBOgAPDAELIAJBADoADwsgAi0AD0EBcQvMAQEBfyMAQSBrIgIkACACIAA3AxAgAiABNgIMIAJBMBAZIgE2AggCQCABRQRAIAIoAgxBDkEAEBUgAkEANgIcDAELIAIoAghBADYCACACKAIIQgA3AxAgAigCCEIANwMIIAIoAghCADcDICACKAIIQgA3AxggAigCCEEANgIoIAIoAghBADoALCACKAIIIAIpAxAgAigCDBDGAUEBcUUEQCACKAIIECUgAkEANgIcDAELIAIgAigCCDYCHAsgAigCHCEBIAJBIGokACABC9kCAQF/IwBBIGsiAyQAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgA0EMakIEECo2AggCQCADKAIIRQRAIANBfzYCHAwBCwNAIAMoAhQEQCADKAIUKAIEIAMoAhBxQYAGcQRAIAMoAghCABAtGiADKAIIIAMoAhQvAQgQICADKAIIIAMoAhQvAQoQIAJ/IwBBEGsiACADKAIINgIMIAAoAgwtAABBAXFFCwRAIAMoAhhBCGpBFEEAEBUgAygCCBAXIANBfzYCHAwECyADKAIYIANBDGpCBBA2QQBIBEAgAygCCBAXIANBfzYCHAwECyADKAIULwEKQQBKBEAgAygCGCADKAIUKAIMIAMoAhQvAQqtEDZBAEgEQCADKAIIEBcgA0F/NgIcDAULCwsgAyADKAIUKAIANgIUDAELCyADKAIIEBcgA0EANgIcCyADKAIcIQAgA0EgaiQAIAALaAEBfyMAQRBrIgIgADYCDCACIAE2AgggAkEAOwEGA0AgAigCDARAIAIoAgwoAgQgAigCCHFBgAZxBEAgAiACKAIMLwEKIAIvAQZBBGpqOwEGCyACIAIoAgwoAgA2AgwMAQsLIAIvAQYL8AEBAX8jAEEQayIBJAAgASAANgIMIAEgASgCDDYCCCABQQA2AgQDQCABKAIMBEACQAJAIAEoAgwvAQhB9cYBRg0AIAEoAgwvAQhB9eABRg0AIAEoAgwvAQhBgbICRg0AIAEoAgwvAQhBAUcNAQsgASABKAIMKAIANgIAIAEoAgggASgCDEYEQCABIAEoAgA2AggLIAEoAgxBADYCACABKAIMECQgASgCBARAIAEoAgQgASgCADYCAAsgASABKAIANgIMDAILIAEgASgCDDYCBCABIAEoAgwoAgA2AgwMAQsLIAEoAgghACABQRBqJAAgAAuzBAEBfyMAQUBqIgUkACAFIAA2AjggBSABOwE2IAUgAjYCMCAFIAM2AiwgBSAENgIoIAUgBSgCOCAFLwE2rRAqIgA2AiQCQCAARQRAIAUoAihBDkEAEBUgBUEAOgA/DAELIAVBADYCICAFQQA2AhgDQAJ/IwBBEGsiACAFKAIkNgIMIAAoAgwtAABBAXELBH8gBSgCJBAwQgRaBUEAC0EBcQRAIAUgBSgCJBAeOwEWIAUgBSgCJBAeOwEUIAUgBSgCJCAFLwEUrRAfNgIQIAUoAhBFBEAgBSgCKEEVQQAQFSAFKAIkEBcgBSgCGBAkIAVBADoAPwwDCyAFIAUvARYgBS8BFCAFKAIQIAUoAjAQUCIANgIcIABFBEAgBSgCKEEOQQAQFSAFKAIkEBcgBSgCGBAkIAVBADoAPwwDCwJAIAUoAhgEQCAFKAIgIAUoAhw2AgAgBSAFKAIcNgIgDAELIAUgBSgCHCIANgIgIAUgADYCGAsMAQsLIAUoAiQQSEEBcUUEQCAFIAUoAiQQMD4CDCAFIAUoAiQgBSgCDK0QHzYCCAJAAkAgBSgCDEEETw0AIAUoAghFDQAgBSgCCEGy0wAgBSgCDBBTRQ0BCyAFKAIoQRVBABAVIAUoAiQQFyAFKAIYECQgBUEAOgA/DAILCyAFKAIkEBcCQCAFKAIsBEAgBSgCLCAFKAIYNgIADAELIAUoAhgQJAsgBUEBOgA/CyAFLQA/QQFxIQAgBUFAayQAIAAL7wIBAX8jAEEgayICJAAgAiAANgIYIAIgATYCFAJAIAIoAhhFBEAgAiACKAIUNgIcDAELIAIgAigCGDYCCANAIAIoAggoAgAEQCACIAIoAggoAgA2AggMAQsLA0AgAigCFARAIAIgAigCFCgCADYCECACQQA2AgQgAiACKAIYNgIMA0ACQCACKAIMRQ0AAkAgAigCDC8BCCACKAIULwEIRw0AIAIoAgwvAQogAigCFC8BCkcNACACKAIMLwEKBEAgAigCDCgCDCACKAIUKAIMIAIoAgwvAQoQUw0BCyACKAIMIgAgACgCBCACKAIUKAIEQYAGcXI2AgQgAkEBNgIEDAELIAIgAigCDCgCADYCDAwBCwsgAigCFEEANgIAAkAgAigCBARAIAIoAhQQJAwBCyACKAIIIAIoAhQiADYCACACIAA2AggLIAIgAigCEDYCFAwBCwsgAiACKAIYNgIcCyACKAIcIQAgAkEgaiQAIAALXQEBfyMAQRBrIgIkACACIAA2AgggAiABNgIEAkAgAigCBEUEQCACQQA2AgwMAQsgAiACKAIIIAIoAgQoAgAgAigCBC8BBK0QNjYCDAsgAigCDCEAIAJBEGokACAAC48BAQF/IwBBEGsiAiQAIAIgADYCCCACIAE2AgQCQAJAIAIoAggEQCACKAIEDQELIAIgAigCCCACKAIERjYCDAwBCyACKAIILwEEIAIoAgQvAQRHBEAgAkEANgIMDAELIAIgAigCCCgCACACKAIEKAIAIAIoAggvAQQQU0U2AgwLIAIoAgwhACACQRBqJAAgAAtVAQF/IwBBEGsiASQAIAEgADYCDCABQQBBAEEAEBs2AgggASgCDARAIAEgASgCCCABKAIMKAIAIAEoAgwvAQQQGzYCCAsgASgCCCEAIAFBEGokACAAC6ABAQF/IwBBIGsiBSQAIAUgADYCGCAFIAE2AhQgBSACOwESIAUgAzoAESAFIAQ2AgwgBSAFKAIYIAUoAhQgBS8BEiAFLQARQQFxIAUoAgwQYCIANgIIAkAgAEUEQCAFQQA2AhwMAQsgBSAFKAIIIAUvARJBACAFKAIMEFE2AgQgBSgCCBAWIAUgBSgCBDYCHAsgBSgCHCEAIAVBIGokACAAC18BAX8jAEEQayICJAAgAiAANgIIIAIgAToAByACIAIoAghCARAfNgIAAkAgAigCAEUEQCACQX82AgwMAQsgAigCACACLQAHOgAAIAJBADYCDAsgAigCDBogAkEQaiQAC1QBAX8jAEEQayIBJAAgASAANgIIIAEgASgCCEIBEB82AgQCQCABKAIERQRAIAFBADoADwwBCyABIAEoAgQtAAA6AA8LIAEtAA8hACABQRBqJAAgAAs4AQF/IwBBEGsiASAANgIMIAEoAgxBADYCACABKAIMQQA2AgQgASgCDEEANgIIIAEoAgxBADoADAufAgEBfyMAQUBqIgUkACAFIAA3AzAgBSABNwMoIAUg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AigCf0EAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACIAIoAiwiAEEBajYCLCAALQABIQEgAiACKAIoIgBBAWo2AihBACAALQABIAFHDQAaIAIgAigCLCIAQQFqNgIsIAAtAAEhASACIAIoAigiAEEBajYCKEEAIAAtAAEgAUcNABogAiACKAIsIgBBAWo2AiwgAC0AASEBIAIgAigCKCIAQQFqNgIoQQAgAC0AASABRw0AGiACKAIsIAIoAgxJC0EBcQ0ACyACQYICIAIoAgwgAigCLGtrNgIkIAIgAigCDEH+fWo2AiwgAigCJCACKAIgSgRAIAIoAjggAigCNDYCcCACIAIoAiQ2AiAgAigCJCACKAIcTg0CIAIgAigCLCACKAIgQQFrai0AADoACyACIAIoAiwgAigCIGotAAA6AAoLCyACIAIoAhQgAigCNCACKAIQcUEBdGovAQAiATYCNEEAIQAgASACKAIYSwR/IAIgAigCMEF/aiIANgIwIABBAEcFQQALQQFxDQELCwJAIAIoAiAgAigCOCgCdE0EQCACIAIoAiA2AjwMAQsgAiACKAI4KAJ0NgI8CyACKAI8C54QAQF/IwBBMGsiAiQAIAIgADYCKCACIAE2AiQgAgJ/IAIoAigoAgxBBWsgAigCKCgCLEsEQCACKAIoKAIsDAELIAIoAigoAgxBBWsLNgIgIAJBADYCECACIAIoAigoAgAoAgQ2AgwDQAJAIAJB//8DNgIcIAIgAigCKCgCvC1BKmpBA3U2AhQgAigCKCgCACgCECACKAIUSQ0AIAIgAigCKCgCACgCECACKAIUazYCFCACIAIoAigoAmwgAigCKCgCXGs2AhggAigCHCACKAIYIAIoAigoAgAoAgRqSwRAIAIgAigCGCACKAIoKAIAKAIEajYCHAsgAigCHCACKAIUSwRAIAIgAigCFDYCHAsCQCACKAIcIAIoAiBPDQACQCACKAIcRQRAIAIoAiRBBEcNAQsgAigCJEUNACACKAIcIAIoAhggAigCKCgCACgCBGpGDQELDAELQQAhACACQQFBACACKAIkQQRGBH8gAigCHCACKAIYIAIoAigoAgAoAgRqRgVBAAtBAXEbNgIQIAIoAihBAEEAIAIoAhAQVyACKAIoKAIIIAIoAigoAhRBBGtqIAIoAhw6AAAgAigCKCgCCCACKAIoKAIUQQNraiACKAIcQQh2OgAAIAIoAigoAgggAigCKCgCFEECa2ogAigCHEF/czoAACACKAIoKAIIIAIoAigoAhRBAWtqIAIoAhxBf3NBCHY6AAAgAigCKCgCABAdIAIoAhgEQCACKAIYIAIoAhxLBEAgAiACKAIcNgIYCyACKAIoKAIAKAIMIAIoAigoAjggAigCKCgCXGogAigCGBAaGiACKAIoKAIAIgAgAigCGCAAKAIMajYCDCACKAIoKAIAIgAgACgCECACKAIYazYCECACKAIoKAIAIgAgAigCGCAAKAIUajYCFCACKAIoIgAgAigCGCAAKAJcajYCXCACIAIoAhwgAigCGGs2AhwLIAIoAhwEQCACKAIoKAIAIAIoAigoAgAoAgwgAigCHBBzGiACKAIoKAIAIgAgAigCHCAAKAIMajYCDCACKAIoKAIAIgAgACgCECACKAIcazYCECACKAIoKAIAIgAgAigCHCAAKAIUajYCFAsgAigCEEUNAQsLIAIgAigCDCACKAIoKAIAKAIEazYCDCACKAIMBEACQCACKAIMIAIoAigoAixPBEAgAigCKEECNgKwLSACKAIoKAI4IAIoAigoAgAoAgAgAigCKCgCLGsgAigCKCgCLBAaGiACKAIoIAIoAigoAiw2AmwMAQsgAigCKCgCPCACKAIoKAJsayACKAIMTQRAIAIoAigiACAAKAJsIAIoAigoAixrNgJsIAIoAigoAjggAigCKCgCOCACKAIoKAIsaiACKAIoKAJsEBoaIAIoAigoArAtQQJJBEAgAigCKCIAIAAoArAtQQFqNgKwLQsLIAIoAigoAjggAigCKCgCbGogAigCKCgCACgCACACKAIMayACKAIMEBoaIAIoAigiACACKAIMIAAoAmxqNgJsCyACKAIoIAIoAigoAmw2AlwgAigCKCIBAn8gAigCDCACKAIoKAIsIAIoAigoArQta0sEQCACKAIoKAIsIAIoAigoArQtawwBCyACKAIMCyABKAK0LWo2ArQtCyACKAIoKALALSACKAIoKAJsSQRAIAIoAiggAigCKCgCbDYCwC0LAkAgAigCEARAIAJBAzYCLAwBCwJAIAIoAiRFDQAgAigCJEEERg0AIAIoAigoAgAoAgQNACACKAIoKAJsIAIoAigoAlxHDQAgAkEBNgIsDAELIAIgAigCKCgCPCACKAIoKAJsa0EBazYCFAJAIAIoAigoAgAoAgQgAigCFE0NACACKAIoKAJcIAIoAigoAixIDQAgAigCKCIAIAAoAlwgAigCKCgCLGs2AlwgAigCKCIAIAAoAmwgAigCKCgCLGs2AmwgAigCKCgCOCACKAIoKAI4IAIoAigoAixqIAIoAigoAmwQGhogAigCKCgCsC1BAkkEQCACKAIoIgAgACgCsC1BAWo2ArAtCyACIAIoAigoAiwgAigCFGo2AhQLIAIoAhQgAigCKCgCACgCBEsEQCACIAIoAigoAgAoAgQ2AhQLIAIoAhQEQCACKAIoKAIAIAIoAigoAjggAigCKCgCbGogAigCFBBzGiACKAIoIgAgAigCFCAAKAJsajYCbAsgAigCKCgCwC0gAigCKCgCbEkEQCACKAIoIAIoAigoAmw2AsAtCyACIAIoAigoArwtQSpqQQN1NgIUIAICf0H//wMgAigCKCgCDCACKAIUa0H//wNLDQAaIAIoAigoAgwgAigCFGsLNgIUIAICfyACKAIUIAIoAigoAixLBEAgAigCKCgCLAwBCyACKAIUCzYCICACIAIoAigoAmwgAigCKCgCXGs2AhgCQCACKAIYIAIoAiBJBEAgAigCGEUEQCACKAIkQQRHDQILIAIoAiRFDQEgAigCKCgCACgCBA0BIAIoAhggAigCFEsNAQsgAgJ/IAIoAhggAigCFEsEQCACKAIUDAELIAIoAhgLNgIcIAJBAUEAAn9BACACKAIkQQRHDQAaQQAgAigCKCgCACgCBA0AGiACKAIcIAIoAhhGC0EBcRs2AhAgAigCKCACKAIoKAI4IAIoAigoAlxqIAIoAhwgAigCEBBXIAIoAigiACACKAIcIAAoAlxqNgJcIAIoAigoAgAQHQsgAkECQQAgAigCEBs2AiwL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NgIUIAMgAjYCECADIAMoAhQgA0EIakHAAEEAEEciADYCDAJAIABFBEAgA0EANgIcDAELIAMoAghBBWpB//8DSwRAIAMoAhBBEkEAEBUgA0EANgIcDAELIANBACADKAIIQQVqrRAqIgA2AgQgAEUEQCADKAIQQQ5BABAVIANBADYCHAwBCyADKAIEQQEQiwEgAygCBCADKAIUEIkBECEgAygCBCADKAIMIAMoAggQQAJ/IwBBEGsiACADKAIENgIMIAAoAgwtAABBAXFFCwRAIAMoAhBBFEEAEBUgAygCBBAXIANBADYCHAwBCyADIAMvARoCfyMAQRBrIgAgAygCBDYCDAJ+IAAoAgwtAABBAXEEQCAAKAIMKQMQDAELQgALp0H//wNxCwJ/IwBBEGsiACADKAIENgIMIAAoAgwoAgQLQYAGEFA2AgAgAygCBBAXIAMgAygCADYCHAsgAygCHCEAIANBIGokACAAC7QCAQF/IwBBMGsiAyQAIAMgADYCKCADIAE3AyAgAyACNgIcAkAgAykDIFAEQCADQQE6AC8MAQsgAyADKAIoKQMQIAMpAyB8NwMIAkAgAykDCCADKQMgWgRAIAMpAwhC/////wBYDQELIAMoAhxBDkEAEBUgA0EAOgAvDAELIAMgAygCKCgCACADKQMIp0EEdBBOIgA2AgQgAEUEQCADKAIcQQ5BABAVIANBADoALwwBCyADKAIoIAMoAgQ2AgAgAyADKAIoKQMINwMQA0AgAykDECADKQMIWkUEQCADKAIoKAIAIAMpAxCnQQR0ahCNASADIAMpAxBCAXw3AxAMAQsLIAMoAiggAykDCCIBNwMQIAMoAiggATcDCCADQQE6AC8LIAMtAC9BAXEhACADQTBqJAAgAAu2BQEBfyMAQTBrIgIkACACIAA2AiggAiABNwMgAkAgAikDICACKAIoKQMwWgRAIAIoAihBCGpBEkEAEBUgAkF/NgIsDAELIAIgAigCKCgCQCACKQMgp0EEdGo2AhwCQCACKAIcKAIABEAgAigCHCgCAC0ABEEBcUUNAQsgAkEANgIsDAELIAIoAhwoAgApA0hCGnxC////////////AFYEQCACKAIoQQhqQQRBFhAVIAJBfzYCLAwBCyACKAIoKAIAIAIoAhwoAgApA0hCGnxBABAoQQBIBEAgAigCKEEIaiACKAIoKAIAEBggAkF/NgIsDAELIAIgAigCKCgCAEIEIAJBGGogAigCKEEIahBBIgA2AhQgAEUEQCACQX82AiwMAQsgAiACKAIUEB47ARIgAiACKAIUEB47ARAgAigCFBBIQQFxRQRAIAIoAhQQFyACKAIoQQhqQRRBABAVIAJBfzYCLAwBCyACKAIUEBcgAi8BEEEASgRAIAIoAigoAgAgAi8BEq1BARAoQQBIBEAgAigCKEEIakEEQbScASgCABAVIAJBfzYCLAwCCyACQQAgAigCKCgCACACLwEQQQAgAigCKEEIahBgNgIIIAIoAghFBEAgAkF/NgIsDAILIAIoAgggAi8BEEGAAiACQQxqIAIoAihBCGoQhQFBAXFFBEAgAigCCBAWIAJBfzYCLAwCCyACKAIIEBYgAigCDARAIAIgAigCDBCEATYCDCACKAIcKAIAKAI0IAIoAgwQhgEhACACKAIcKAIAIAA2AjQLCyACKAIcKAIAQQE6AAQCQCACKAIcKAIERQ0AIAIoAhwoAgQtAARBAXENACACKAIcKAIEIAIoAhwoAgAoAjQ2AjQgAigCHCgCBEEBOgAECyACQQA2AiwLIAIoAiwhACACQTBqJAAgAAsHACAAKAIgC4wBAQF/IwBBIGsiAiQAIAIgADYCGCACIAE2AhQgAkEANgIQAkAgAigCFEUEQCACQQA2AhwMAQsgAiACKAIUEBk2AgwgAigCDEUEQCACKAIQQQ5BABAVIAJBADYCHAwBCyACKAIMIAIoAhggAigCFBAaGiACIAIoAgw2AhwLIAIoAhwhACACQSBqJAAgAAsYAEGonAFCADcCAEGwnAFBADYCAEGonAELiAEBAX8jAEEgayIDJAAgAyAANgIUIAMgATYCECADIAI3AwgCQAJAIAMoAhQoAiRBAUYEQCADKQMIQv///////////wBYDQELIAMoAhRBDGpBEkEAEBUgA0J/NwMYDAELIAMgAygCFCADKAIQIAMpAwhBCxAiNwMYCyADKQMYIQIgA0EgaiQAIAILcwEBfyMAQSBrIgEkACABIAA2AhggAUIINwMQIAEgASgCGCkDECABKQMQfDcDCAJAIAEpAwggASgCGCkDEFQEQCABKAIYQQA6AAAgAUF/NgIcDAELIAEgASgCGCABKQMIEC02AhwLIAEoAhwaIAFBIGokAAsI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IAJBCGoiABA8AkAgAigCSCAAEDkEQCMAQRBrIgAgAigCSDYCDCACIAAoAgxBDGo2AgQjAEEQayIAIAIoAgQ2AgwCQCAAKAIMKAIAQQVHDQAjAEEQayIAIAIoAgQ2AgwgACgCDCgCBEEsRw0AIAJBADYCTAwCCyACKAJEIAIoAgQQRCACQX82AkwMAQsgAkEBNgJMCyACKAJMIQAgAkHQAGokACAAC+oBAQF/IwBBMGsiAyQAIAMgADYCKCADIAE2AiQgAyACNgIgIwBBEGsiACADQQhqIgE2AgwgACgCDEEANgIAIAAoAgxBADYCBCAAKAIMQQA2AgggAyADKAIoIAEQ/AEiADYCGAJAIABFBEAgAygCICADQQhqIgAQkwEgABA4IANBADYCLAwBCyADIAMoAhggAygCJCADQQhqEJIBIgA2AhwgAEUEQCADKAIYEBwgAygCICADQQhqIgAQkwEgABA4IANBADYCLAwBCyADQQhqEDggAyADKAIcNgIsCyADKAIsIQAgA0EwaiQAIAALyAIBAX8jAEEQayIBJAAgASAANgIIIAFB2AAQGTYCBAJAIAEoAgRFBEAgASgCCEEOQQAQFSABQQA2AgwMAQsgASgCCBCCAyEAIAEoAgQgADYCUCAARQRAIAEoAgQQFiABQQA2AgwMAQsgASgCBEEANgIAIAEoAgRBADYCBCMAQRBrIgAgASgCBEEIajYCDCAAKAIMQQA2AgAgACgCDEEANgIEIAAoAgxBADYCCCABKAIEQQA2AhggASgCBEEANgIUIAEoAgRBADYCHCABKAIEQQA2AiQgASgCBEEANgIgIAEoAgRBADoAKCABKAIEQgA3AzggASgCBEIANwMwIAEoAgRBADYCQCABKAIEQQA2AkggASgCBEEANgJEIAEoAgRBADYCTCABKAIEQQA2AlQgASABKAIENgIMCyABKAIMIQAgAUEQaiQAIAALgQEBAX8jAEEgayICJAAgAiAANgIYIAJCADcDECACQn83AwggAiABNgIEAkACQCACKAIYBEAgAikDCEJ/WQ0BCyACKAIEQRJBABAVIAJBADYCHAwBCyACIAIoAhggAikDECACKQMIIAIoAgQQgAI2AhwLIAIoAhwhACACQSBqJAAgAAvNAQECfyMAQSBrIgEkACABIAA2AhggAUEAOgAXIAFBgIAgNgIMAkAgAS0AF0EBcQRAIAEgASgCDEECcjYCDAwBCyABIAEoAgw2AgwLIAEoAhghACABKAIMIQIgAUG2AzYCACABIAAgAiABEGkiADYCEAJAIABBAEgEQCABQQA2AhwMAQsgASABKAIQQYKYAUGGmAEgAS0AF0EBcRsQmAEiADYCCCAARQRAIAFBADYCHAwBCyABIAEoAgg2AhwLIAEoAhwhACABQSBqJAAgAAvIAgEBfyMAQYABayIBJAAgASAANgJ4IAEgASgCeCgCGBAsQQhqEBkiADYCdAJAIABFBEAgASgCeEEOQQAQFSABQX82AnwMAQsCQCABKAJ4KAIYIAFBEGoQnQFFBEAgASABKAIcNgJsDAELIAFBfzYCbAsgASgCdCEAIAEgASgCeCgCGDYCACAAQfiXASABEG8gASABKAJ0IAEoAmwQhgIiADYCcCAAQX9GBEAgASgCeEEMQbScASgCABAVIAEoAnQQFiABQX82AnwMAQsgASABKAJwQYKYARCYASIANgJoIABFBEAgASgCeEEMQbScASgCABAVIAEoAnAQaCABKAJ0EGoaIAEoAnQQFiABQX82AnwMAQsgASgCeCABKAJoNgKEASABKAJ4IAEoAnQ2AoABIAFBADYCfAsgASgCfCEAIAFBgAFqJAAgAAvAEAEBfyMAQeAAayIEJAAgBCAANgJUIAQgATYCUCAEIAI3A0ggBCADNgJEIAQgBCgCVDYCQCAEIAQoAlA2AjwCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAEKAJEDhMGBwIMBAUKDgEDCRALDw0IEREAEQsgBEIANwNYDBELIAQoAkAoAhhFBEAgBCgCQEEcQQAQFSAEQn83A1gMEQsgBCAEKAJAEP4BrDcDWAwQCyAEKAJAKAIYBEAgBCgCQCgCHBBUGiAEKAJAQQA2AhwLIARCADcDWAwPCyAEKAJAKAKEARBUQQBIBEAgBCgCQEEANgKEASAEKAJAQQZBtJwBKAIAEBULIAQoAkBBADYChAEgBCgCQCgCgAEgBCgCQCgCGBAHIgBBgWBPBH9BtJwBQQAgAGs2AgBBfwUgAAtBAEgEQCAEKAJAQQJBtJwBKAIAEBUgBEJ/NwNYDA8LIAQoAkAoAoABEBYgBCgCQEEANgKAASAEQgA3A1gMDgsgBCAEKAJAIAQoAlAgBCkDSBBCNwNYDA0LIAQoAkAoAhgQFiAEKAJAKAKAARAWIAQoAkAoAhwEQCAEKAJAKAIcEFQaCyAEKAJAEBYgBEIANwNYDAwLIAQoAkAoAhgEQCAEKAJAKAIYEP0BIQAgBCgCQCAANgIcIABFBEAgBCgCQEELQbScASgCABAVIARCfzcDWAwNCwsgBCgCQCkDaEIAVgRAIAQoAkAoAhwgBCgCQCkDaCAEKAJAEJUBQQBIBEAgBEJ/NwNYDA0LCyAEKAJAQgA3A3ggBEIANwNYDAsLAkAgBCgCQCkDcEIAVgRAIAQgBCgCQCkDcCAEKAJAKQN4fTcDMCAEKQMwIAQpA0hWBEAgBCAEKQNINwMwCwwBCyAEIAQpA0g3AzALIAQpAzBC/////w9WBEAgBEL/////DzcDMAsgBCAEKAI8IAQpAzCnIAQoAkAoAhwQjAIiADYCLCAARQRAAn8gBCgCQCgCHCIAKAJMQX9MBEAgACgCAAwBCyAAKAIAC0EFdkEBcQRAIAQoAkBBBUG0nAEoAgAQFSAEQn83A1gMDAsLIAQoAkAiACAAKQN4IAQoAiytfDcDeCAEIAQoAiytNwNYDAoLIAQoAkAoAhgQakEASARAIAQoAkBBFkG0nAEoAgAQFSAEQn83A1gMCgsgBEIANwNYDAkLIAQoAkAoAoQBBEAgBCgCQCgChAEQVBogBCgCQEEANgKEAQsgBCgCQCgCgAEQahogBCgCQCgCgAEQFiAEKAJAQQA2AoABIARCADcDWAwICyAEAn8gBCkDSEIQVARAIAQoAkBBEkEAEBVBAAwBCyAEKAJQCzYCGCAEKAIYRQRAIARCfzcDWAwICyAEQQE2AhwCQAJAAkACQAJAIAQoAhgoAggOAwACAQMLIAQgBCgCGCkDADcDIAwDCwJAIAQoAkApA3BQBEAgBCgCQCgCHCAEKAIYKQMAQQIgBCgCQBBnQQBIBEAgBEJ/NwNYDA0LIAQgBCgCQCgCHBCaASICNwMgIAJCAFMEQCAEKAJAQQRBtJwBKAIAEBUgBEJ/NwNYDA0LIAQgBCkDICAEKAJAKQNofTcDICAEQQA2AhwMAQsgBCAEKAJAKQNwIAQoAhgpAwB8NwMgCwwCCyAEIAQoAkApA3ggBCgCGCkDAHw3AyAMAQsgBCgCQEESQQAQFSAEQn83A1gMCAsCQAJAIAQpAyBCAFMNACAEKAJAKQNwQgBSBEAgBCkDICAEKAJAKQNwVg0BCyAEKQMgIAQoAkApA2h8IAQoAkApA2haDQELIAQoAkBBEkEAEBUgBEJ/NwNYDAgLIAQoAkAgBCkDIDcDeCAEKAIcBEAgBCgCQCgCHCAEKAJAKQN4IAQoAkApA2h8IAQoAkAQlQFBAEgEQCAEQn83A1gMCQsLIARCADcDWAwHCyAEAn8gBCkDSEIQVARAIAQoAkBBEkEAEBVBAAwBCyAEKAJQCzYCFCAEKAIURQRAIARCfzcDWAwHCyAEKAJAKAKEASAEKAIUKQMAIAQoAhQoAgggBCgCQBBnQQBIBEAgBEJ/NwNYDAcLIARCADcDWAwGCyAEKQNIQjhUBEAgBEJ/NwNYDAYLAn8jAEEQayIAIAQoAkBB2ABqNgIMIAAoAgwoAgALBEAgBCgCQAJ/IwBBEGsiACAEKAJAQdgAajYCDCAAKAIMKAIACwJ/IwBBEGsiACAEKAJAQdgAajYCDCAAKAIMKAIECxAVIARCfzcDWAwGCyAEKAJQIgAgBCgCQCIBKQAgNwAAIAAgASkAUDcAMCAAIAEpAEg3ACggACABKQBANwAgIAAgASkAODcAGCAAIAEpADA3ABAgACABKQAoNwAIIARCODcDWAwFCyAEIAQoAkApAxA3A1gMBAsgBCAEKAJAKQN4NwNYDAMLIAQgBCgCQCgChAEQmgE3AwggBCkDCEIAUwRAIAQoAkBBHkG0nAEoAgAQFSAEQn83A1gMAwsgBCAEKQMINwNYDAILAkAgBCgCQCgChAEiACgCTEEATgRAIAAgACgCAEFPcTYCAAwBCyAAIAAoAgBBT3E2AgALIAQgBCgCUCAEKQNIpyAEKAJAKAKEARCtAjYCBAJAIAQpA0ggBCgCBK1RBEACfyAEKAJAKAKEASIAKAJMQX9MBEAgACgCAAwBCyAAKAIAC0EFdkEBcUUNAQsgBCgCQEEGQbScASgCABAVIARCfzcDWAwCCyAEIAQoAgStNwNYDAELIAQoAkBBHEEAEBUgBEJ/NwNYCyAEKQNYIQIgBEHgAGokACACC6AJAQF/IwBBoAFrIgQkACAEIAA2ApgBIARBADYClAEgBCABNwOIASAEIAI3A4ABIARBADYCfCAEIAM2AngCQAJAIAQoApQBDQAgBCgCmAENACAEKAJ4QRJBABAVIARBADYCnAEMAQsgBCkDgAFCAFMEQCAEQgA3A4ABCwJAIAQpA4gBQv///////////wBYBEAgBCkDiAEgBCkDgAF8IAQpA4gBWg0BCyAEKAJ4QRJBABAVIARBADYCnAEMAQsgBEGIARAZIgA2AnQgAEUEQCAEKAJ4QQ5BABAVIARBADYCnAEMAQsgBCgCdEEANgIYIAQoApgBBEAgBCgCmAEQkQIhACAEKAJ0IAA2AhggAEUEQCAEKAJ4QQ5BABAVIAQoAnQQFiAEQQA2ApwBDAILCyAEKAJ0IAQoApQBNgIcIAQoAnQgBCkDiAE3A2ggBCgCdCAEKQOAATcDcAJAIAQoAnwEQCAEKAJ0IgAgBCgCfCIDKQMANwMgIAAgAykDMDcDUCAAIAMpAyg3A0ggACADKQMgNwNAIAAgAykDGDcDOCAAIAMpAxA3AzAgACADKQMINwMoIAQoAnRBADYCKCAEKAJ0IgAgACkDIEL+////D4M3AyAMAQsgBCgCdEEgahA8CyAEKAJ0KQNwQgBWBEAgBCgCdCAEKAJ0KQNwNwM4IAQoAnQiACAAKQMgQgSENwMgCyMAQRBrIgAgBCgCdEHYAGo2AgwgACgCDEEANgIAIAAoAgxBADYCBCAAKAIMQQA2AgggBCgCdEEANgKAASAEKAJ0QQA2AoQBIwBBEGsiACAEKAJ0NgIMIAAoAgxBADYCACAAKAIMQQA2AgQgACgCDEEANgIIIARBfzYCBCAEQQc2AgBBDiAEEDdCP4QhASAEKAJ0IAE3AxACQCAEKAJ0KAIYBEAgBCAEKAJ0KAIYIARBGGoQnQFBAE46ABcgBC0AF0EBcUUEQAJAIAQoAnQpA2hQRQ0AIAQoAnQpA3BQRQ0AIAQoAnRC//8DNwMQCwsMAQsgBAJ/AkAgBCgCdCgCHCIAKAJMQQBIDQALIAAoAjwLIARBGGoQjgJBAE46ABcLAkAgBC0AF0EBcUUEQCAEKAJ0QdgAakEFQbScASgCABAVDAELIAQoAnQpAyBCEINQBEAgBCgCdCAEKAJYNgJIIAQoAnQiACAAKQMgQhCENwMgCyAEKAIkQYDgA3FBgIACRgRAIAQoAnRC/4EBNwMQIAQoAnQpA2ggBCgCdCkDcHwgBCkDQFYEQCAEKAJ4QRJBABAVIAQoAnQoAhgQFiAEKAJ0EBYgBEEANgKcAQwDCyAEKAJ0KQNwUARAIAQoAnQgBCkDQCAEKAJ0KQNofTcDOCAEKAJ0IgAgACkDIEIEhDcDIAJAIAQoAnQoAhhFDQAgBCkDiAFQRQ0AIAQoAnRC//8DNwMQCwsLCyAEKAJ0IgAgACkDEEKAgBCENwMQIARBHiAEKAJ0IAQoAngQkQEiADYCcCAARQRAIAQoAnQoAhgQFiAEKAJ0EBYgBEEANgKcAQwBCyAEIAQoAnA2ApwBCyAEKAKcASEAIARBoAFqJAAgAAsJACAAKAI8EAUL9wEBBH8jAEEgayIDJAAgAyABNgIQIAMgAiAAKAIwIgRBAEdrNgIUIAAoAiwhBSADIAQ2AhwgAyAFNgIYAkACQAJ/An9BACAAKAI8IANBEGpBAiADQQxqEA0iBEUNABpBtJwBIAQ2AgBBfwsEQCADQX82AgxBfwwBCyADKAIMIgRBAEoNASAECyECIAAgACgCACACQTBxQRBzcjYCAAwBCyAEIAMoAhQiBk0EQCAEIQIMAQsgACAAKAIsIgU2AgQgACAFIAQgBmtqNgIIIAAoAjBFDQAgACAFQQFqNgIEIAEgAmpBf2ogBS0AADoAAAsgA0EgaiQAIAILgQMBB38jAEEgayIDJAAgAyAAKAIcIgU2AhAgACgCFCEEIAMgAjYCHCADIAE2AhggAyAEIAVrIgE2AhQgASACaiEFQQIhByADQRBqIQECfwJAAkACf0EAIAAoAjwgA0EQakECIANBDGoQAyIERQ0AGkG0nAEgBDYCAEF/C0UEQANAIAUgAygCDCIERg0CIARBf0wNAyABIAQgASgCBCIISyIGQQN0aiIJIAQgCEEAIAYbayIIIAkoAgBqNgIAIAFBDEEEIAYbaiIJIAkoAgAgCGs2AgAgBSAEayEFAn9BACAAKAI8IAFBCGogASAGGyIBIAcgBmsiByADQQxqEAMiBEUNABpBtJwBIAQ2AgBBfwtFDQALCyADQX82AgwgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgASgCBGsLIQAgA0EgaiQAIAALYAEBfyMAQRBrIgMkAAJ+An9BACAAKAI8IAGnIAFCIIinIAJB/wFxIANBCGoQCyIARQ0AGkG0nAEgADYCAEF/C0UEQCADKQMIDAELIANCfzcDCEJ/CyEBIANBEGokACABC9oBAQJ/AkAgAUH/AXEiAwRAIABBA3EEQANAIAAtAAAiAkUNAyACIAFB/wFxRg0DIABBAWoiAEEDcQ0ACwsCQCAAKAIAIgJBf3MgAkH//ft3anFBgIGChHhxDQAgA0GBgoQIbCEDA0AgAiADcyICQX9zIAJB//37d2pxQYCBgoR4cQ0BIAAoAgQhAiAAQQRqIQAgAkH//ft3aiACQX9zcUGAgYKEeHFFDQALCwNAIAAiAi0AACIDBEAgAkEBaiEAIAMgAUH/AXFHDQELCyACDwsgABAsIABqDwsgAAvFAwEBfyMAQTBrIgIkACACIAA2AiggAiABNgIkIAJBADYCECACIAIoAiggAigCKBAsajYCGCACIAIoAhhBf2o2AhwDQCACKAIcIAIoAihPBH8gAigCHCwAAEHYAEYFQQALQQFxBEAgAiACKAIQQQFqNgIQIAIgAigCHEF/ajYCHAwBCwsCQCACKAIQRQRAQbScAUEcNgIAIAJBfzYCLAwBCyACIAIoAhxBAWo2AhwDQCACEIcCNgIMIAIgAigCHDYCFANAIAIoAhQgAigCGEkEQCACIAIoAgxBJHA6AAsCfyACLAALQQpIBEAgAiwAC0EwagwBCyACLAALQdcAagshACACIAIoAhQiAUEBajYCFCABIAA6AAAgAiACKAIMQSRuNgIMDAELCyACKAIoIQAgAgJ/QbYDIAIoAiRBf0YNABogAigCJAs2AgAgAiAAQcKBICACEGkiADYCICAAQQBOBEAgAigCJEF/RwRAIAIoAiggAigCJBAPIgBBgWBPBH9BtJwBQQAgAGs2AgBBAAUgAAsaCyACIAIoAiA2AiwMAgtBtJwBKAIAQRRGDQALIAJBfzYCLAsgAigCLCEAIAJBMGokACAAC1cBAn8jAEEQayIAJAACQCAAQQhqEIgCQQFxBEAgACAAKAIINgIMDAELQZShAS0AAEEBcUUEQEEAEAEQigILIAAQiQI2AgwLIAAoAgwhASAAQRBqJAAgAQulAQEBfyMAQRBrIgEkACABIAA2AgggAUEEOwEGIAFB55cBQQBBABBpIgA2AgACQCAAQQBIBEAgAUEAOgAPDAELIAEoAgAgASgCCCABLwEGEBAiAEGBYE8Ef0G0nAFBACAAazYCAEF/BSAACyABLwEGRwRAIAEoAgAQaCABQQA6AA8MAQsgASgCABBoIAFBAToADwsgAS0AD0EBcSEAIAFBEGokACAAC6EBAQR/QcyaASgCACEAAkBByJoBKAIAIgNFBEAgACAAKAIAQe2cmY4EbEG54ABqQf////8HcSIANgIADAELIABB0JoBKAIAIgJBAnRqIgEgASgCACAAQZChASgCACIBQQJ0aigCAGoiADYCAEGQoQFBACABQQFqIgEgASADRhs2AgBB0JoBQQAgAkEBaiICIAIgA0YbNgIAIABBAXYhAAsgAAujAQIDfwF+QciaASgCACIBRQRAQcyaASgCACAANgIADwtB0JoBQQNBA0EBIAFBB0YbIAFBH0YbNgIAQZChAUEANgIAAkAgAUEATARAQcyaASgCACECDAELQcyaASgCACECIACtIQQDQCACIANBAnRqIARCrf7V5NSF/ajYAH5CAXwiBEIgiD4CACADQQFqIgMgAUcNAAsLIAIgAigCAEEBcjYCAAuhAQEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIKAIkQQNGBEAgAUEANgIMDAELIAEoAggoAiBBAEsEQCABKAIIEDJBAEgEQCABQX82AgwMAgsLIAEoAggoAiQEQCABKAIIEGwLIAEoAghBAEIAQQ8QIkIAUwRAIAFBfzYCDAwBCyABKAIIQQM2AiQgAUEANgIMCyABKAIMIQAgAUEQaiQAIAALsQEBAn8gAigCTEEATgR/QQEFQQALGiACIAItAEoiA0F/aiADcjoASgJ/IAEgAigCCCACKAIEIgRrIgNBAUgNABogACAEIAMgASADIAFJGyIDEBoaIAIgAigCBCADajYCBCAAIANqIQAgASADawsiAwRAA0ACQCACEI0CRQRAIAIgACADIAIoAiARAQAiBEEBakEBSw0BCyABIANrDwsgACAEaiEAIAMgBGsiAw0ACwsgAQt8AQJ/IAAgAC0ASiIBQX9qIAFyOgBKIAAoAhQgACgCHEsEQCAAQQBBACAAKAIkEQEAGgsgAEEANgIcIABCADcDECAAKAIAIgFBBHEEQCAAIAFBIHI2AgBBfw8LIAAgACgCLCAAKAIwaiICNgIIIAAgAjYCBCABQRt0QR91C3YBAn8jAEEgayICJAACfwJAIAAgARAJIgNBeEYEQCAA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aiINIAVBD2o6AAAgBkF/akEtQSsgCEEASBs6AAAgBEEIcSEIIAlBEGohBwNAIAciBQJ/IAGZRAAAAAAAAOBBYwRAIAGqDAELQYCAgIB4CyIGQYCHAWotAAAgC3I6AAAgASAGt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgCUEQamtBAUcNAAJAIAgNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAsgAEEgIAIgDgJ/AkAgA0UNACAHIAlrQW5qIANODQAgAyAPaiANa0ECagwBCyAPIAlBEGprIA1rIAdqCyIDaiIMIAQQJyAAIAogDhAjIABBMCACIAwgBEGAgARzECcgACAJQRBqIAcgCUEQamsiBRAjIABBMCADIAUgDyANayIDamtBAEEAECcgACANIAMQIwsgAEEgIAIgDCAEQYDAAHMQJyAJQbAEaiQAIAIgDCAMIAJIGwstACAAUEUEQANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgOIIgBCAFINAAsLIAELNQAgAFBFBEADQCABQX9qIgEgAKdBD3FBgIcBai0AACACcjoAACAAQgSIIgBCAFINAAsLIAELywIBA38jAEHQAWsiAyQAIAMgAjYCzAFBACECIANBoAFqQQBBKBAzIAMgAygCzAE2AsgBAkBBACABIANByAFqIANB0ABqIANBoAFqEHBBAEgNACAAKAJMQQBOBEBBASECCyAAKAIAIQQgACwASkEATARAIAAgBEFfcTYCAAsgBEEgcSEFAn8gACgCMARAIAAgASADQcgBaiADQdAAaiADQaABahBwDAELIABB0AA2AjAgACADQdAAajYCECAAIAM2AhwgACADNgIUIAAoAiwhBCAAIAM2AiwgACABIANByAFqIANB0ABqIANBoAFqEHAgBEUNABogAEEAQQAgACgCJBEBABogAEEANgIwIAAgBDYCLCAAQQA2AhwgAEEANgIQIAAoAhQaIABBADYCFEEACxogACAAKAIAIAVyNgIAIAJFDQALIANB0AFqJAALLwAgAQJ/IAIoAkxBf0wEQCAAIAEgAhBxDAELIAAgASACEHELIgBGBEAgAQ8LIAALWQEBfyAAIAAtAEoiAUF/aiABcjoASiAAKAIAIgFBCHEEQCAAIAFBIHI2AgBBfw8LIABCADcCBCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQQQALBgBB9KABCwYAQfCgAQsGAEHooAEL2QMCAn8CfiMAQSBrIgIkAAJAIAFC////////////AIMiBUKAgICAgIDA/0N8IAVCgICAgICAwIC8f3xUBEAgAUIEhiAAQjyIhCEEIABC//////////8PgyIAQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQQMAgsgBEKAgICAgICAgEB9IQQgAEKAgICAgICAgAiFQgBSDQEgBEIBgyAEfCEEDAELIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhBAwBC0KAgICAgICA+P8AIQQgBUL///////+//8MAVg0AQgAhBCAFQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQf+If2oQtAIgAiAAIARBgfgAIANrELMCIAIpAwhCBIYgAikDACIAQjyIhCEEIAIpAxAgAikDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgBEIBfCEEDAELIABCgICAgICAgIAIhUIAUg0AIARCAYMgBHwhBAsgAkEgaiQAIAQgAUKAgICAgICAgIB/g4S/C1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC1ABAX4CQCADQcAAcQRAIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAiADrSIEhiABQcAAIANrrYiEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC4sCAAJAIAAEfyABQf8ATQ0BAkBBkJoBKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIB8akH//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLQbScAUEZNgIAQX8FQQELDwsgACABOgAAQQELvgIBAX8jAEHAwABrIgMkACADIAA2ArhAIAMgATYCtEAgAyACNwOoQAJAIAMoArRAEElBAEgEQCADKAK4QEEIaiADKAK0QBAYIANBfzYCvEAMAQsgA0EANgIMIANCADcDEANAAkAgAyADKAK0QCADQSBqQoDAABAvIgI3AxggAkIAVw0AIAMoArhAIANBIGogAykDGBA2QQBIBEAgA0F/NgIMBSADKQMYQoDAAFINAiADKAK4QCgCVEUNAiADKQOoQEIAVw0CIAMgAykDGCADKQMQfDcDECADKAK4QCgCVCADKQMQuSADKQOoQLmjEFgMAgsLCyADKQMYQgBTBEAgAygCuEBBCGogAygCtEAQGCADQX82AgwLIAMoArRAEDIaIAMgAygCDDYCvEALIAMoArxAIQAgA0HAwABqJAAgAAuqAQEBfyMAQTBrIgMkACADIAA2AiggAyABNgIkIAMgAjcDGCADIAMoAigoAgAQNSICNwMQAkAgAkIAUwRAIANBfzYCLAwBCyADIAMoAiggAygCJCADKQMYEJADIgI3AwAgAkIAUwRAIANBfzYCLAwBCyADIAMoAigoAgAQNSICNwMIIAJCAFMEQCADQX82AiwMAQsgA0EANgIsCyADKAIsIQAgA0EwaiQAIAAL/gEBAX8jAEGgwABrIgIkACACIAA2AphAIAIgATcDkEAgAiACKQOQQLo5AwACQANAIAIpA5BAQgBWBEAgAgJ+QoDAACACKQOQQEKAwABWDQAaIAIpA5BACz4CDCACKAKYQCgCACACQRBqIAIoAgytIAIoAphAQQhqEGFBAEgEQCACQX82ApxADAMLIAIoAphAIAJBEGogAigCDK0QNkEASARAIAJBfzYCnEAMAwUgAiACKQOQQCACNQIMfTcDkEAgAigCmEAoAlQgAisDACACKQOQQLqhIAIrAwCjEFgMAgsACwsgAkEANgKcQAsgAigCnEAhACACQaDAAGokACAAC+cRAgF/AX4jAEGgAWsiAyQAIAMgADYCmAEgAyABNgKUASADIAI2ApABAkAgAygClAEgA0E4ahA5QQBIBEAgAygCmAFBCGogAygClAEQGCADQX82ApwBDAELIAMpAzhCwACDUARAIAMgAykDOELAAIQ3AzggA0EAOwFoCwJAAkAgAygCkAEoAhBBf0cEQCADKAKQASgCEEF+Rw0BCyADLwFoRQ0AIAMoApABIAMvAWg2AhAMAQsCQAJAIAMoApABKAIQDQAgAykDOEIEg1ANACADIAMpAzhCCIQ3AzggAyADKQNQNwNYDAELIAMgAykDOEL3////D4M3AzgLCyADKQM4QoABg1AEQCADIAMpAzhCgAGENwM4IANBADsBagsgA0GAAjYCJAJAIAMpAzhCBINQBEAgAyADKAIkQYAIcjYCJCADQn83A3AMAQsgAygCkAEgAykDUDcDKCADIAMpA1A3A3ACQCADKQM4QgiDUARAAkACQAJAAkACQAJ/AkAgAygCkAEoAhBBf0cEQCADKAKQASgCEEF+Rw0BC0EIDAELIAMoApABKAIQC0H//wNxDg0CAwMDAwMDAwEDAwMAAwsgA0KUwuTzDzcDEAwDCyADQoODsP8PNwMQDAILIANC/////w83AxAMAQsgA0IANwMQCyADKQNQIAMpAxBWBEAgAyADKAIkQYAIcjYCJAsMAQsgAygCkAEgAykDWDcDIAsLIAMgAygCmAEoAgAQNSIENwOIASAEQgBTBEAgAygCmAFBCGogAygCmAEoAgAQGCADQX82ApwBDAELIAMoApABIgAgAC8BDEH3/wNxOwEMIAMgAygCmAEgAygCkAEgAygCJBBeIgA2AiggAEEASARAIANBfzYCnAEMAQsgAyADLwFoAn8CQCADKAKQASgCEEF/RwRAIAMoApABKAIQQX5HDQELQQgMAQsgAygCkAEoAhALQf//A3FHOgAiIAMgAy0AIkEBcQR/IAMvAWhBAEcFQQALQQFxOgAhIAMgAy8BaAR/IAMtACEFQQELQQFxOgAgIAMgAy0AIkEBcQR/IAMoApABKAIQQQBHBUEAC0EBcToAHyADAn9BASADLQAiQQFxDQAaQQEgAygCkAEoAgBBgAFxDQAaIAMoApABLwFSIAMvAWpHC0EBcToAHiADIAMtAB5BAXEEfyADLwFqQQBHBUEAC0EBcToAHSADIAMtAB5BAXEEfyADKAKQAS8BUkEARwVBAAtBAXE6ABwgAyADKAKUATYCNCMAQRBrIgAgAygCNDYCDCAAKAIMIgAgACgCMEEBajYCMCADLQAdQQFxBEAgAyADLwFqQQAQdyIANgIMIABFBEAgAygCmAFBCGpBGEEAEBUgAygCNBAcIANBfzYCnAEMAgsgAyADKAKYASADKAI0IAMvAWpBACADKAKYASgCHCADKAIMEQYAIgA2AjAgAEUEQCADKAI0EBwgA0F/NgKcAQwCCyADKAI0EBwgAyADKAIwNgI0CyADLQAhQQFxBEAgAyADKAKYASADKAI0IAMvAWgQrAEiADYCMCAARQRAIAMoAjQQHCADQX82ApwBDAILIAMoAjQQHCADIAMoAjA2AjQLIAMtACBBAXEEQCADIAMoApgBIAMoAjRBABCqASIANgIwIABFBEAgAygCNBAcIANBfzYCnAEMAgsgAygCNBAcIAMgAygCMDYCNAsgAy0AH0EBcQRAIAMgAygCmAEgAygCNCADKAKQASgCECADKAKQAS8BUBDCAiIANgIwIABFBEAgAygCNBAcIANBfzYCnAEMAgsgAygCNBAcIAMgAygCMDYCNAsgAy0AHEEBcQRAIANBADYCBAJAIAMoApABKAJUBEAgAyADKAKQASgCVDYCBAwBCyADKAKYASgCHARAIAMgAygCmAEoAhw2AgQLCyADIAMoApABLwFSQQEQdyIANgIIIABFBEAgAygCmAFBCGpBGEEAEBUgAygCNBAcIANBfzYCnAEMAgsgAyADKAKYASADKAI0IAMoApABLwFSQQEgAygCBCADKAIIEQYAIgA2AjAgAEUEQCADKAI0EBwgA0F/NgKcAQwCCyADKAI0EBwgAyADKAIwNgI0CyADIAMoApgBKAIAEDUiBDcDgAEgBEIAUwRAIAMoApgBQQhqIAMoApgBKAIAEBggA0F/NgKcAQwBCyADIAMoApgBIAMoAjQgAykDcBC2AjYCLCADKAI0IANBOGoQOUEASARAIAMoApgBQQhqIAMoAjQQGCADQX82AiwLIAMgAygCNBC8AiIAOgAjIABBGHRBGHVBAEgEQCADKAKYAUEIaiADKAI0EBggA0F/NgIsCyADKAI0EBwgAygCLEEASARAIANBfzYCnAEMAQsgAyADKAKYASgCABA1IgQ3A3ggBEIAUwRAIAMoApgBQQhqIAMoApgBKAIAEBggA0F/NgKcAQwBCyADKAKYASgCACADKQOIARCoAUEASARAIAMoApgBQQhqIAMoApgB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AB9BAXEhACADQSBqJAAgAAuQAQEBfyMAQRBrIgEkACABIAA2AgggASABKAIINgIEAkAgASgCBC0ABEEBcQRAIAEgASgCBEEQahCzATYCAAwBCyABIAEoAgRBEGoQzgI2AgALAkAgASgCAARAIAEoAgQoAgBBDSABKAIAEBUgAUEAOgAPDAELIAFBAToADwsgAS0AD0EBcSEAIAFBEGokACAAC8ABAQF/IwBBEGsiASQAIAEgADYCCCABIAEoAgg2AgQgASgCBEEANgIUIAEoAgRBADYCECABKAIEQQA2AiAgASgCBEEANgIcAkAgASgCBC0ABEEBcQRAIAEgASgCBEEQaiABKAIEKAIIEOICNgIADAELIAEgASgCBEEQahDSAjYCAAsCQCABKAIABEAgASgCBCgCAEENIAEoAgAQFSABQQA6AA8MAQsgAUEBOgAPCyABLQAPQQFxIQAgAUEQaiQAIAALbwEBfyMAQRBrIgEgADYCCCABIAEoAgg2AgQCQCABKAIELQAEQQFxRQRAIAFBADYCDAwBCyABKAIEKAIIQQNIBEAgAUECNgIMDAELIAEoAgQoAghBB0oEQCABQQE2AgwMAQsgAUEANgIMCyABKAIMCywBAX8jAEEQayIBJAAgASAANgIMIAEgASgCDDYCCCABKAIIEBYgAUEQaiQACzwBAX8jAEEQayIDJAAgAyAAOwEOIAMgATYCCCADIAI2AgRBASADKAIIIAMoAgQQsAEhACADQRBqJAAgAAuZAQEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIEEsEQCABQX42AgwMAQsgASABKAIIKAIcNgIEIAEoAgQoAjgEQCABKAIIKAIoIAEoAgQoAjggASgCCCgCJBEEAAsgASgCCCgCKCABKAIIKAIcIAEoAggoAiQRBAAgASgCCEEANgIcIAFBADYCDAsgASgCDCEAIAFBEGokACAAC50EAQF/IwBBIGsiAyQAIAMgADYCGCADIAE2AhQgAyACNgIQIAMgAygCGCgCHDYCDAJAIAMoAgwoAjhFBEAgAygCGCgCKEEBIAMoAgwoAih0QQEgAygCGCgCIBEBACEAIAMoAgwgADYCOCADKAIMKAI4RQRAIANBATYCHAwCCwsgAygCDCgCLEUEQCADKAIMQQEgAygCDCgCKHQ2AiwgAygCDEEANgI0IAMo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NgIECwNAAkAgASABKAJQKAJUIAEoAjxBASABKAJQKAJcdEEBa3FBAnRqKAEANgEgIAEtACEgASgCOE0NACABKAJERQ0LIAEgASgCREF/ajYCRCABIAEoAkwiAEEBajYCTCABIAEoAjwgAC0AACABKAI4dGo2AjwgASABKAI4QQhqNgI4DAELCyABLQAgQfABcUUEQCABIAEoASA2ARgDQAJAIAEgASgCUCgCVCABLwEaIAEoAjxBASABLQAZIAEtABhqdEEBa3EgAS0AGXZqQQJ0aigBADYBICABLQAZIAEtACFqIAEoAjhNDQAgASgCREUNDCABIAEoAkRBf2o2AkQgASABKAJMIgBBAWo2AkwgASABKAI8IAAtAAAgASgCOHRqNgI8IAEgASgCOEEIajYCOAwBCwsgASABKAI8IAEtABl2NgI8IAEgASgCOCABLQAZazYCOCABKAJQIgAgAS0AGSAAKALIN2o2Asg3CyABIAEoAjwgAS0AIXY2AjwgASABKAI4IAEtACFrNgI4IAEoAlAiACABLQAhIAAoAsg3ajYCyDcgAS0AIEHAAHEEQCABKAJYQaPxADYCGCABKAJQQdH+ADYCBAwLCyABKAJQIAEvASI2AkggASgCUCABLQAgQQ9xNgJMIAEoAlBBy/4ANgIECyABKAJQKAJMBEADQCABKAI4IAEoAlAoAkxJBEAgASgCREUNCyABIAEoAkRBf2o2AkQgASABKAJMIgBBAWo2AkwgASABKAI8IAAtAAAgASgCOHRqNgI8IAEgASgCOEEIajYCOAwBCwsgASgCUCIAIAAoAkggASgCPEEBIAEoAlAoAkx0QQFrcWo2AkggASABKAI8IAEoAlAoAkx2NgI8IAEgASgCOCABKAJQKAJMazYCOCABKAJQIgAgASgCUCgCTCAAKALIN2o2Asg3CyABKAJQQcz+ADYCBAsgASgCQEUNByABIAEoAjAgASgCQGs2AiwCQCABKAJQKAJIIAEoAixLBEAgASABKAJQKAJIIAEoAixrNgIsIAEoAiwgASgCUCgCMEsEQCABKAJQKALENwRAIAEoAlhBufEANgIYIAEoAlBB0f4ANgIEDAwLCwJAIAEoAiwgASgCUCgCNEsEQCABIAEoAiwgASgCUCgCNGs2AiwgASABKAJQKAI4IAEoAlAoAiwgASgCLGtqNgIo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GCABKAIENgIcIAEoAgQgASgCGDYCACABKAIEQQA2AjggASgCBEG0/gA2AgQgASABKAIYIAEoAhQQ0wI2AgggASgCCARAIAEoAhgoAiggASgCBCABKAIYKAIkEQQAIAEoAhhBADYCHAsgASABKAIINgIcCyABKAIcIQAgAUEgaiQAIAALrQIBAX8jAEEgayICJAAgAiAANgIYIAIgATYCFAJAIAIoAhgQSwRAIAJBfjYCHAwBCyACIAIoAhgoAhw2AgwCQCACKAIUQQBIBEAgAkEANgIQIAJBACACKAIUazYCFAwBCyACIAIoAhRBBHVBBWo2AhAgAigCFEEwSARAIAIgAigCFEEPcTYCFAsLAkAgAigCFEUNACACKAIUQQhOBEAgAigCFEEPTA0BCyACQX42AhwMAQsCQCACKAIMKAI4RQ0AIAIoAgwoAiggAigCFEYNACACKAIYKAIoIAIoAgwoAjggAigCGCgCJBEEACACKAIMQQA2AjgLIAIoAgwgAigCEDYCDCACKAIMIAIoAhQ2AiggAiACKAIYENQCNgIcCyACKAIcIQAgAkEgaiQAIAALcgEBfyMAQRBrIgEkACABIAA2AggCQCABKAIIEEsEQCABQX42AgwMAQsgASABKAIIKAIcNgIEIAEoAgRBADYCLCABKAIEQQA2AjAgASgCBEEANgI0IAEgASgCCBDVAjYCDAsgASgCDCEAIAFBEGokACAAC5sCAQF/IwBBEGsiASQAIAEgADYCCAJAIAEoAggQSwRAIAFBfjYCDAwBCyABIAEoAggoAhw2AgQgASgCBEEANgIgIAEoAghBADYCFCABKAIIQQA2AgggASgCCEEANgIYIAEoAgQoAgwEQCABKAIIIAEoAgQoAgxBAXE2AjALIAEoAgRBtP4ANgIEIAEoAgRBADYCCCABKAIEQQA2AhAgASgCBEGAgAI2AhggASgCBEEANgIkIAEoAgRBADYCPCABKAIEQQA2AkAgASgCBCABKAIEQbQKaiIANgJwIAEoAgQgADYCVCABKAIEIAA2AlAgASgCBEEBNgLENyABKAIEQX82Asg3IAFBADYCDAsgASgCDCEAIAFBEGokACAAC5IVAQF/IwBB4ABrIgIgADYCXCACIAE2AlggAiACKAJcKAIcNgJUIAIgAigCXCgCADYCUCACIAIoAlAgAigCXCgCBEEFa2o2AkwgAiACKAJcKAIMNgJIIAIgAigCSCACKAJYIAIoAlwoAhBrazYCRCACIAIoAkggAigCXCgCEEGBAmtqNgJAIAIgAigCVCgCLDYCPCACIAIoAlQoAjA2AjggAiACKAJUKAI0NgI0IAIgAigCVCgCODYCMCACIAIoAlQoAjw2AiwgAiACKAJUKAJANgIoIAIgAigCVCgCUDYCJCACIAIoAlQoAlQ2AiAgAkEBIAIoAlQoAlh0QQFrNgIcIAJBASACKAJUKAJcdEEBazYCGANAIAIoAihBD0kEQCACIAIoAlAiAEEBajYCUCACIAIoAiwgAC0AACACKAIodGo2AiwgAiACKAIoQQhqNgIoIAIgAigCUCIAQQFqNgJQIAIgAigCLCAALQAAIAIoAih0ajYCLCACIAIoAihBCGo2AigLIAJBEGogAigCJCACKAIsIAIoAhxxQQJ0aigBADYBAAJAAkADQCACIAItABE2AgwgAiACKAIsIAIoAgx2NgIsIAIgAigCKCACKAIMazYCKCACIAItABA2AgwgAigCDEUEQCACLwESIQAgAiACKAJIIgFBAWo2AkggASAAOgAADAILIAIoAgxBEHEEQCACIAIvARI2AgggAiACKAIMQQ9xNgIMIAIoAgwEQCACKAIoIAIoAgxJBEAgAiACKAJQIgBBAWo2AlAgAiACKAIsIAAtAAAgAigCKHRqNgIsIAIgAigCKEEIajYCKAsgAiACKAIIIAIoAixBASACKAIMdEEBa3FqNgIIIAIgAigCLCACKAIMdjYCLCACIAIoAiggAigCDGs2AigLIAIoAihBD0kEQCACIAIoAlAiAEEBajYCUCACIAIoAiwgAC0AACACKAIodGo2AiwgAiACKAIoQQhqNgIoIAIgAigCUCIAQQFqNgJQIAIgAigCLCAALQAAIAIoAih0ajYCLCACIAIoAihBCGo2AigLIAJBEGogAigCICACKAIsIAIoAhhxQQJ0aigBADYBAAJAA0AgAiACLQARNgIMIAIgAigCLCACKAIMdjYCLCACIAIoAiggAigCDGs2AiggAiACLQAQNgIMIAIoAgxBEHEEQCACIAIvARI2AgQgAiACKAIMQQ9xNgIMIAIoAiggAigCDEkEQCACIAIoAlAiAEEBajYCUCACIAIoAiwgAC0AACACKAIodGo2AiwgAiACKAIoQQhqNgIoIAIoAiggAigCDEkEQCACIAIoAlAiAEEBajYCUCACIAIoAiwgAC0AACACKAIodGo2AiwgAiACKAIoQQhqNgIoCwsgAiACKAIEIAIoAixBASACKAIMdEEBa3FqNgIEIAIgAigCLCACKAIMdjYCLCACIAIoAiggAigCDGs2AiggAiACKAJIIAIoAkRrNgIMAkAgAigCBCACKAIMSwRAIAIgAigCBCACKAIMazYCDCACKAIMIAIoAjhLBEAgAigCVCgCxDcEQCACKAJcQbDtADYCGCACKAJUQdH+ADYCBAwKCwsgAiACKAIwNgIAAkAgAigCNEUEQCACIAIoAgAgAigCPCACKAIMa2o2AgAgAigCDCACKAIISQRAIAIgAigCCCACKAIMazYCCANAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIMQX9qIgA2AgwgAA0ACyACIAIoAkggAigCBGs2AgALDAELAkAgAigCNCACKAIMSQRAIAIgAigCACACKAI8IAIoAjRqIAIoAgxrajYCACACIAIoAgwgAigCNGs2AgwgAigCDCACKAIISQRAIAIgAigCCCACKAIMazYCCANAIAIgAigCACIAQQFqNgIAIAAtAAAhACACIAIoAkgiAUEBajYCSCABIAA6AAAgAiACKAIMQX9qIgA2AgwgAA0ACyACIAIoAjA2AgAgAigCNCACKAIISQRAIAIgAigCNDYCDCACIAIoAgggAigCDGs2AggDQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCDEF/aiIANgIMIAANAAsgAiACKAJIIAIoAgRrNgIACwsMAQsgAiACKAIAIAIoAjQgAigCDGtqNgIAIAIoAgwgAigCCEkEQCACIAIoAgggAigCDGs2AggDQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCDEF/aiIANgIMIAANAAsgAiACKAJIIAIoAgRrNgIACwsLA0AgAigCCEECTUUEQCACIAIoAgAiAEEBajYCACAALQAAIQAgAiACKAJIIgFBAWo2AkggASAAOgAAIAIgAigCACIAQQFqNgIAIAAtAAAhACAC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LCgCHCgCLARAIAIoAjgoAjAgAigCLCgCCCACKAIsKAIUEBshACACKAI4IAA2AjALIAIoAixBADYCICACKAIsQcUANgIECwsgAigCLCgCBEHFAEYEQCACKAIsKAIcKAIQBEAgAiACKAIsKAIUNgIgIAIgAigCLCgCHCgCFEH//wNxIAIoAiwoAiBrNgIcA0AgAigCLCgCFCACKAIcaiACKAIsKAIMSwRAIAIgAigCLCgCDCACKAIsKAIUazYCGCACKAIsKAIIIAIoAiwoAhRqIAIoAiwoAhwoAhAgAigCLCgCIGogAigCGBAaGiACKAIsIAIoAiwoAgw2AhQCQCACKAIsKAIcKAIsRQ0AIAIoAiwoAhQgAigCIE0NACACKAI4KAIwIAIoAiwoAgggAigCIGogAigCLCgCFCACKAIgaxAbIQAgAigCOCAANgIwCyACKAIsIgAgAigCGCAAKAIgajYCICACKAI4EB0gAigCLCgCFARAIAIoAixBfzYCKCACQQA2AjwMBQUgAkEANgIgIAIgAigCHCACKAIYazYCHAwCCwALCyACKAIsKAIIIAIoAiwoAhRqIAIoAiwoAhwoAhAgAigCLCgCIGogAigCHBAaGiACKAIsIgAgAigCHCAAKAIUajYCFAJAIAIoAiwoAhwoAixFDQAgAigCLCgCFCACKAIgTQ0AIAIoAjgoAjAgAigCLCgCCCACKAIgaiACKAIsKAIUIAIoAiBrEBshACACKAI4IAA2AjALIAIoAixBADYCIAsgAigCLEHJADYCBAsgAigCLCgCBEHJAEYEQCACKAIsKAIcKAIcBEAgAiACKAIsKAIUNgIUA0AgAigCLCgCFCACKAIsKAIMRgRAAkAgAigCLCgCHCgCLEUNACACKAIsKAIUIAIoAhRNDQAgAigCOCgCMCACKAIsKAIIIAIoAhRqIAIoAiwoAhQgAigCFGsQGyEAIAIoAjggADYCMAsgAigCOBAdIAIoAiwoAhQEQCACKAIsQX82AiggAkEANgI8DAULIAJBADYCFAsgAigCLCgCHCgCHCEBIAIoAiwiAygCICEAIAMgAEEBajYCICACIAAgAWotAAA2AhAgAigCECEBIAIoAiwoAgghAyACKAIsIgQoAhQhACAEIABBAWo2AhQgACADaiABOgAAIAIoAhANAAsCQCACKAIsKAIcKAIs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AigCEEEPSkUEQCACKAI8QbwWaiACKAIQQQF0akEAOwEAIAIgAigCEEEBajYCEAwBCwsgAigCNCACKAI8QdwWaiACKAI8KALUKEECdGooAgBBAnRqQQA7AQIgAiACKAI8KALUKEEBajYCHANAIAIoAhxBvQRIBEAgAiACKAI8QdwWaiACKAIcQQJ0aigCADYCGCACIAIoAjQgAigCNCACKAIYQQJ0ai8BAkECdGovAQJBAWo2AhAgAigCECACKAIgSgRAIAIgAigCIDYCECACIAIoAgRBAWo2AgQLIAIoAjQgAigCGEECdGogAigCEDsBAiACKAIYIAIoAjBMBEAgAigCPCACKAIQQQF0akG8FmoiACAALwEAQQFqOwEAIAJBADYCDCACKAIYIAIoAiROBEAgAiACKAIoIAIoAhggAigCJGtBAnRqKAIANgIMCyACIAIoAjQgAigCGEECdGovAQA7AQogAigCPCIAIAAoAqgtIAIvAQogAigCECACKAIMamxqNgKoLSACKAIsBEAgAigCPCIAIAAoAqwtIAIvAQogAigCLCACKAIYQQJ0ai8BAiACKAIMamxqNgKsLQsLIAIgAigCHEEBajYCHAwBCwsCQCACKAIERQ0AA0AgAiACKAIgQQFrNgIQA0AgAigCPEG8FmogAigCEEEBdGovAQBFBEAgAiACKAIQQX9qNgIQDAELCyACKAI8IAIoAhBBAXRqQbwWaiIAIAAvAQBBf2o7AQAgAigCPCACKAIQQQF0akG+FmoiACAALwEAQQJqOwEAIAIoAjwgAigCIEEBdGpBvBZqIgAgAC8BAEF/ajsBACACIAIoAgRBAms2AgQgAigCBEEASg0ACyACIAIoAiA2AhADQCACKAIQRQ0BIAIgAigCPEG8FmogAigCEEEBdGovAQA2AhgDQCACKAIYBEAgAigCPEHcFmohACACIAIoAhxBf2oiATYCHCACIAFBAnQgAGooAgA2AhQgAigCFCACKAIwSg0BIAIoAjQgAigCFEECdGovAQIgAigCEEcEQCACKAI8IgAgACgCqC0gAigCNCACKAIUQQJ0ai8BACACKAIQIAIoAjQgAigCFEECdGovAQJrbGo2AqgtIAIoAjQgAigCFEECdGogAigCEDsBAgsgAiACKAIYQX9qNgIYDAELCyACIAIoAhBBf2o2AhAMAAAL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NgKwFiABKAIMQajbADYCuBYgASgCDEEAOwG4LSABKAIMQQA2ArwtIAEoAgwQuQEgAUEQaiQAC9cNAQF/IwBBIGsiAyAANgIYIAMgATYCFCADIAI2AhAgAyADKAIYQRB2NgIMIAMgAygCGEH//wNxNgIYAkAgAygCEEEBRgRAIAMgAygCFC0AACADKAIYajYCGCADKAIYQfH/A08EQCADIAMoAhhB8f8DazYCGAsgAyADKAIYIAMoAgxqNgIMIAMoAgxB8f8DTwRAIAMgAygCDEHx/wNrNgIMCyADIAMoAhggAygCDEEQdHI2AhwMAQsgAygCFEUEQCADQQE2AhwMAQsgAygCEEEQSQRAA0AgAyADKAIQIgBBf2o2AhAgAARAIAMgAygCFCIAQQFqNgIUIAMgAC0AACADKAIYajYCGCADIAMoAhggAygCDGo2AgwMAQsLIAMoAhhB8f8DTwRAIAMgAygCGEHx/wNrNgIYCyADIAMoAgxB8f8DcDYCDCADIAMoAhggAygCDEEQdHI2AhwMAQsDQCADKAIQQbArSUUEQCADIAMoAhBBsCtrNgIQIANB2wI2AggDQCADIAMoAhQtAAAgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AASADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQACIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAMgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ABCADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAFIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAYgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AByADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAIIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAkgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ACiADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQALIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAwgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ADSADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAOIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAA8gAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFEEQajYCFCADIAMoAghBf2oiADYCCCAADQALIAMgAygCGEHx/wNwNgIYIAMgAygCDEHx/wNwNgIMDAELCyADKAIQBEADQCADKAIQQRBJRQRAIAMgAygCEEEQazYCECADIAMoAhQtAAAgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AASADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQACIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAMgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ABCADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAFIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAYgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0AByADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAIIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAkgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ACiADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQALIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAAwgAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFC0ADSADKAIYajYCGCADIAMoAhggAygCDGo2AgwgAyADKAIULQAOIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDCADIAMoAhQtAA8gAygCGGo2AhggAyADKAIYIAMoAgxqNgIMIAMgAygCFEEQajYCFAwBCwsDQCADIAMoAhAiAEF/ajYCECAABEAgAyADKAIUIgBBAWo2AhQgAyAALQAAIAMoAhhqNgIYIAMgAygCGCADKAIMajYCDAwBCwsgAyADKAIYQfH/A3A2AhggAyADKAIMQfH/A3A2AgwLIAMgAygCGCADKAIMQRB0cjYC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AgAiBg0AIARBEGoiAigCACIGDQBBACEDDAELA0AgAiEFIAYiA0EUaiICKAIAIgYNACADQRBqIQIgAygCECIGDQALIAVBADYCAAsgCEUNAAJAIAQgBCgCHCIFQQJ0QeieAWoiAigCAEYEQCACIAM2AgAgAw0BQbycAUG8nAEoAgBBfiAFd3E2AgAMAgsgCEEQQRQgCCgCECAERhtqIAM2AgAgA0UNAQsgAyAINgIYIAQoAhAiAgRAIAMgAjYCECACIAM2AhgLIAQoAhQiAkUNACADIAI2AhQgAiADNgIYCyAKQQ9NBEAgACAHQQFxIAlyQQJyNgIEIAAgCWoiASABKAIEQQFyNgIEDAELIAAgB0EBcSABckECcjYCBCAAIAFqIgIgCkEDcjYCBCAAIAlqIgEgASgCBEEBcjYCBCACIAoQugELIAAhAgsgAgvnAwEBfyMAQUBqIgMkACADIAA2AjQgAyABNgIwIAMgAjcDKCADAn4gAykDKCADKAI0KQMwIAMoAjQpAzh9VARAIAMpAygMAQsgAygCNCkDMCADKAI0KQM4fQs3AygCQCADKQMoUARAIANCADcDOAwBCyADKQMoQv///////////wBWBEAgA0J/NwM4DAELIAMgAygCNCkDQDcDGCADIAMoAjQpAzggAygCNCgCBCADKQMYp0EDdGopAwB9NwMQIANCADcDIANAIAMpAyAgAykDKFQEQCADAn4gAykDKCADKQMgfSADKAI0KAIAIAMpAxinQQR0aikDCCADKQMQfVQEQCADKQMoIAMpAyB9DAELIAMoAjQoAgAgAykDGKdBBHRqKQMIIAMpAxB9CzcDCCADKAIwIAMpAyCnaiADKAI0KAIAIAMpAxinQQR0aigCACADKQMQp2ogAykDCKcQGhogAykDCCADKAI0KAIAIAMpAxinQQR0aikDCCADKQMQfVEEQCADIAMpAxhCAXw3AxgLIAMgAykDCCADKQMgfDcDICADQgA3AxAMAQsLIAMoAjQiACADKQMgIAApAzh8NwM4IAMoAjQgAykDGDcDQCADIAMpAyA3AzgLIAMpAzghAiADQUBrJAAgAguuBAEBfyMAQUBqIgMkACADIAA2AjggAyABNwMwIAMgAjYCLAJAIAMpAzBQBEAgA0EAQgBBASADKAIsEE02AjwMAQsgAykDMCADKAI4KQMw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IgA2AhAgAEEASARAIANCfzcDuAEMAwsgAygCEARAIANBAToAFwsgAyADKQMYQgF8NwMYDAELCyADIAMoArQBKAIAEDUiAjcDICACQgBTBEAgAygCtAFBCGogAygCtAEoAgAQGCADQn83A7gBDAELIAMgAykDICADKQOgAX03A5gBAkAgAykDoAFC/////w9YBEAgAykDqAFC//8DWA0BCyADQQE6ABcLIAMgA0EwakLiABAqIgA2AiwgAEUEQCADKAK0AUEIakEOQQAQFSADQn83A7gBDAELIAMtABdBAXEEQCADKAIsQbbTAEEEEEAgAygCLEIsEC4gAygCLEEtECAgAygCLEEtECAgAygCLEEAECEgAygCLEEAECEgAygCLCADKQOoARAuIAMoAiwgAykDqAEQLiADKAIsIAMpA5gBEC4gAygCLCADKQOgARAuIAMoAixBu9MAQQQQQCADKAIsQQAQISADKAIsIAMpA6ABIAMpA5gBfBAuIAMoAixBARAhCyADKAIsQcDTAEEEEEAgAygCLEEAECEgAygCLAJ+Qv//AyADKQOoAUL//wNaDQAaIAMpA6gBC6dB//8DcRAgIAMoAiwCfkL//wMgAykDqAFC//8DWg0AGiADKQOoAQunQf//A3EQICADKAIsAn9BfyADKQOYAUL/////D1oNABogAykDmAGnCxAhIAMoAiwCf0F/IAMpA6ABQv////8PWg0AGiADKQOgAacLECEgAwJ/IAMoArQBLQAoQQFxBEAgAygCtAEoAiQMAQsgAygCtAEoAiALNgKUASADKAIsAn8gAygClAEEQCADKAKUAS8BBAwBC0EAC0H//wNxECACfyMAQRBrIgAgAygCLDYCDCAAKAIMLQAAQQFxRQsEQCADKAK0AUEIakEUQQAQFSADKAIsEBcgA0J/NwO4AQwBCyADKAK0AQJ/IwBBEGsiACADKAIsNgIMIAAoAgwoAgQLAn4jAEEQayIAIAMoAiw2AgwCfiAAKAIMLQAAQQFxBEAgACgCDCkDEAwBC0IACwsQNkEASARAIAMoAiwQFyADQn83A7gBDAELIAMoAiwQFyADKAKUAQRAIAMoArQBIAMoApQBKAIAIAMoApQBLwEErRA2QQBIBEAgA0J/NwO4AQwCCwsgAyADKQOYATcDuAELIAMpA7gBIQIgA0HAAWokACACCwcAIAAvATALCABBAUE4EHsLAwABCwvyjQEnAEGACAuUBU5vIGVycm9yAE11bHRpLWRpc2sgemlwIGFyY2hpdmVzIG5vdCBzdXBwb3J0ZWQAUmVuYW1pbmcgdGVtcG9yYXJ5IGZpbGUgZmFpbGVkAENsb3NpbmcgemlwIGFyY2hpdmUgZmFpbGVkAFNlZWsgZXJyb3IAUmVhZCBlcnJvcgBXcml0ZSBlcnJvcgBDUkMgZXJyb3IAQ29udGFpbmluZyB6aXAgYXJjaGl2ZSB3YXMgY2xvc2VkAE5vIHN1Y2ggZmlsZQBGaWxlIGFscmVhZHkgZXhpc3RzAENhbid0IG9wZW4gZmlsZQBGYWlsdXJlIHRvIGNyZWF0ZSB0ZW1wb3JhcnkgZmlsZQBabGliIGVycm9yAE1hbGxvYyBmYWlsdXJlAEVudHJ5IGhhcyBiZWVuIGNoYW5nZWQAQ29tcHJlc3Npb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQAUHJlbWF0dXJlIGVuZCBvZiBmaWxlAEludmFsaWQgYXJndW1lbnQATm90IGEgemlwIGFyY2hpdmUASW50ZXJuYWwgZXJyb3IAWmlwIGFyY2hpdmUgaW5jb25zaXN0ZW50AENhbid0IHJlbW92ZSBmaWxlAEVudHJ5IGhhcyBiZWVuIGRlbGV0ZWQARW5jcnlwdGlvbiBtZXRob2Qgbm90IHN1cHBvcnRlZABSZWFkLW9ubHkgYXJjaGl2ZQBObyBwYXNzd29yZCBwcm92aWRlZABXcm9uZyBwYXNzd29yZCBwcm92aWRlZABPcGVyYXRpb24gbm90IHN1cHBvcnRlZABSZXNvdXJjZSBzdGlsbCBpbiB1c2UAVGVsbCBlcnJvcgBDb21wcmVzc2VkIGRhdGEgaW52YWxpZABBoQ0LgAEEAAAJBAAALwQAAE4EAABpBAAAdAQAAH8EAACLBAAAlQQAALcEAADEBAAA2AQAAOgEAAAJBQAAFAUAACMFAAA6BQAAWwUAAHEFAACCBQAAlAUAAKMFAAC8BQAAzgUAAOUFAAAFBgAAFwYAACwGAABEBgAAXAYAAHIGAAB9BgAAIABBuA4LEQEAAAABAAAAAQAAAAEAAAABAEHcDgsJAQAAAAEAAAACAEGIDwsBAQBBqA8LAQEAQbQPC5JFljAHdyxhDu66UQmZ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CAC6AAgAegAIAPoACAAGAAgAhgAIAEYACADGAAgAJgAIAKYACABmAAgA5gAIABYACACWAAgAVgAIANYACAA2AAgAtgAIAHYACAD2AAgADgAIAI4ACABOAAgAzgAIAC4ACACuAAgAbgAIAO4ACAAeAAgAngAIAF4ACADeAAgAPgAIAL4ACAB+AAgA/gAIAAEACACBAAgAQQAIAMEACAAhAAgAoQAIAGEACADhAAgAEQAIAJEACABRAAgA0QAIADEACACxAAgAcQAIAPEACAAJAAgAiQAIAEkACADJAAgAKQAIAKkACABpAAgA6QAIABkACACZAAgAWQAIANkACAA5AAgAuQAIAHkACAD5AAgABQAIAIUACABFAAgAxQAIACUACAClAAgAZQAIAOUACAAVAAgAlQAIAFUACADVAAgANQAIALUACAB1AAgA9QAIAA0ACACNAAgATQAIAM0ACAAtAAgArQAIAG0ACADtAAgAHQAIAJ0ACABdAAgA3QAIAD0ACAC9AAgAfQAIAP0ACAATAAkAEwEJAJMACQCTAQkAUwAJAFMBCQDTAAkA0wEJADMACQAzAQkAswAJALMBCQBzAAkAcwEJAPMACQDzAQkACwAJAAsBCQCLAAkAiwEJAEsACQBLAQkAywAJAMsBCQArAAkAKwEJAKsACQCrAQkAawAJAGsBCQDrAAkA6wEJABsACQAbAQkAmwAJAJsBCQBbAAkAWwEJANsACQDbAQkAOwAJADsBCQC7AAkAuwEJAHsACQB7AQkA+wAJAPsBCQAHAAkABwEJAIcACQCHAQkARwAJAEcBCQDHAAkAxwEJACcACQAnAQkApwAJAKcBCQBnAAkAZwEJAOcACQDnAQkAFwAJABcBCQCXAAkAlwEJAFcACQBXAQkA1wAJANcBCQA3AAkANwEJALcACQC3AQkAdwAJAHcBCQD3AAkA9wEJAA8ACQAPAQkAjwAJAI8BCQBPAAkATwEJAM8ACQDPAQkALwAJAC8BCQCvAAkArwEJAG8ACQBvAQkA7wAJAO8BCQAfAAkAHwEJAJ8ACQCfAQkAXwAJAF8BCQDfAAkA3wEJAD8ACQA/AQkAvwAJAL8BCQB/AAkAfwEJAP8ACQD/AQkAAAAHAEAABwAgAAcAYAAHABAABwBQAAcAMAAHAHAABwAIAAcASAAHACgABwBoAAcAGAAHAFgA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aWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAABVbmtub3duIGVycm9yICVkACVzJXMlcwAAOiAAL3Byb2Mvc2VsZi9mZC8AL2Rldi91cmFuZG9tAHJ3YQAlcy5YWFhYWFgAcitiAHJiAFBLBQYAQZCYAQtOCgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAAAEAAAAIAAAAEEwAADBMAEGQmgELAlBQAEHImgELCR8AAABkTQAAAwBB5JoBC4wBLfRRWM+MscBG9rXLKTEDxwRbcDC0Xf0geH+LmthZKVBoSImrp1YDbP+3zYg/1He0K6WjcPG65Kj8QYP92W/hinovLXSWBx8NCV4Ddixw90ClLKdvV0GoqnTfoFhkA0rHxDxTrq9fGAQVseNtKIarDKS/Q/DpUIE5VxZSN/////////////////////8=";
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}
function getBinary() {
  try {
    if (wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    var binary = tryParseAsDataURI(wasmBinaryFile);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(wasmBinaryFile);
    } else {
      throw "sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)";
    }
  } catch (err) {
    abort(err);
  }
}
function createWasm() {
  var info = { a: asmLibraryArg };
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module["asm"] = exports;
    removeRunDependency("wasm-instantiate");
  }
  addRunDependency("wasm-instantiate");
  function instantiateSync() {
    var instance;
    var module;
    var binary;
    try {
      binary = getBinary();
      module = new WebAssembly.Module(binary);
      instance = new WebAssembly.Instance(module, info);
    } catch (e) {
      var str = e.toString();
      err("failed to compile wasm module: " + str);
      if (
        str.indexOf("imported Memory") >= 0 ||
        str.indexOf("memory import") >= 0
      ) {
        err(
          "Memory size incompatibility issues may be due to changing INITIAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set INITIAL_MEMORY at runtime to something smaller than it was at compile time)."
        );
      }
      throw e;
    }
    receiveInstance(instance, module);
  }
  if (Module["instantiateWasm"]) {
    try {
      var exports = Module["instantiateWasm"](info, receiveInstance);
      return exports;
    } catch (e) {
      err("Module.instantiateWasm callback failed with error: " + e);
      return false;
    }
  }
  instantiateSync();
  return Module["asm"];
}
var tempDouble;
var tempI64;
__ATINIT__.push({
  func: function() {
    ___wasm_call_ctors();
  }
});
function demangle(func) {
  return func;
}
function demangleAll(text) {
  var regex = /\b_Z[\w\d_]+/g;
  return text.replace(regex, function(x) {
    var y = demangle(x);
    return x === y ? x : y + " [" + x + "]";
  });
}
function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    try {
      throw new Error();
    } catch (e) {
      err = e;
    }
    if (!err.stack) {
      return "(no stack trace available)";
    }
  }
  return err.stack.toString();
}
function stackTrace() {
  var js = jsStackTrace();
  if (Module["extraStackTrace"]) js += "\n" + Module["extraStackTrace"]();
  return demangleAll(js);
}
var PATH = {
  splitPath: function(filename) {
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    return splitPathRe.exec(filename).slice(1);
  },
  normalizeArray: function(parts, allowAboveRoot) {
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === ".") {
        parts.splice(i, 1);
      } else if (last === "..") {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }
    if (allowAboveRoot) {
      for (; up; up--) {
        parts.unshift("..");
      }
    }
    return parts;
  },
  normalize: function(path) {
    var isAbsolute = path.charAt(0) === "/",
      trailingSlash = path.substr(-1) === "/";
    path = PATH.normalizeArray(
      path.split("/").filter(function(p) {
        return !!p;
      }),
      !isAbsolute
    ).join("/");
    if (!path && !isAbsolute) {
      path = ".";
    }
    if (path && trailingSlash) {
      path += "/";
    }
    return (isAbsolute ? "/" : "") + path;
  },
  dirname: function(path) {
    var result = PATH.splitPath(path),
      root = result[0],
      dir = result[1];
    if (!root && !dir) {
      return ".";
    }
    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  },
  basename: function(path) {
    if (path === "/") return "/";
    var lastSlash = path.lastIndexOf("/");
    if (lastSlash === -1) return path;
    return path.substr(lastSlash + 1);
  },
  extname: function(path) {
    return PATH.splitPath(path)[3];
  },
  join: function() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return PATH.normalize(paths.join("/"));
  },
  join2: function(l, r) {
    return PATH.normalize(l + "/" + r);
  }
};
function setErrNo(value) {
  HEAP32[___errno_location() >> 2] = value;
  return value;
}
var PATH_FS = {
  resolve: function() {
    var resolvedPath = "",
      resolvedAbsolute = false;
    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = i >= 0 ? arguments[i] : FS.cwd();
      if (typeof path !== "string") {
        throw new TypeError("Arguments to path.resolve must be strings");
      } else if (!path) {
        return "";
      }
      resolvedPath = path + "/" + resolvedPath;
      resolvedAbsolute = path.charAt(0) === "/";
    }
    resolvedPath = PATH.normalizeArray(
      resolvedPath.split("/").filter(function(p) {
        return !!p;
      }),
      !resolvedAbsolute
    ).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
  },
  relative: function(from, to) {
    from = PATH_FS.resolve(from).substr(1);
    to = PATH_FS.resolve(to).substr(1);
    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "") break;
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "") break;
      }
      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }
    var fromParts = trim(from.split("/"));
    var toParts = trim(to.split("/"));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push("..");
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  }
};
var TTY = {
  ttys: [],
  init: function() {},
  shutdown: function() {},
  register: function(dev, ops) {
    TTY.ttys[dev] = { input: [], output: [], ops: ops };
    FS.registerDevice(dev, TTY.stream_ops);
  },
  stream_ops: {
    open: function(stream) {
      var tty = TTY.ttys[stream.node.rdev];
      if (!tty) {
        throw new FS.ErrnoError(43);
      }
      stream.tty = tty;
      stream.seekable = false;
    },
    close: function(stream) {
      stream.tty.ops.flush(stream.tty);
    },
    flush: function(stream) {
      stream.tty.ops.flush(stream.tty);
    },
    read: function(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.get_char) {
        throw new FS.ErrnoError(60);
      }
      var bytesRead = 0;
      for (var i = 0; i < length; i++) {
        var result;
        try {
          result = stream.tty.ops.get_char(stream.tty);
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (result === undefined && bytesRead === 0) {
          throw new FS.ErrnoError(6);
        }
        if (result === null || result === undefined) break;
        bytesRead++;
        buffer[offset + i] = result;
      }
      if (bytesRead) {
        stream.node.timestamp = Date.now();
      }
      return bytesRead;
    },
    write: function(stream, buffer, offset, length, pos) {
      if (!stream.tty || !stream.tty.ops.put_char) {
        throw new FS.ErrnoError(60);
      }
      try {
        for (var i = 0; i < length; i++) {
          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
        }
      } catch (e) {
        throw new FS.ErrnoError(29);
      }
      if (length) {
        stream.node.timestamp = Date.now();
      }
      return i;
    }
  },
  default_tty_ops: {
    get_char: function(tty) {
      if (!tty.input.length) {
        var result = null;
        if (ENVIRONMENT_IS_NODE) {
          var BUFSIZE = 256;
          var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
          var bytesRead = 0;
          try {
            bytesRead = nodeFS.readSync(
              process.stdin.fd,
              buf,
              0,
              BUFSIZE,
              null
            );
          } catch (e) {
            if (e.toString().indexOf("EOF") != -1) bytesRead = 0;
            else throw e;
          }
          if (bytesRead > 0) {
            result = buf.slice(0, bytesRead).toString("utf-8");
          } else {
            result = null;
          }
        } else if (
          typeof window != "undefined" &&
          typeof window.prompt == "function"
        ) {
          result = window.prompt("Input: ");
          if (result !== null) {
            result += "\n";
          }
        } else if (typeof readline == "function") {
          result = readline();
          if (result !== null) {
            result += "\n";
          }
        }
        if (!result) {
          return null;
        }
        tty.input = intArrayFromString(result, true);
      }
      return tty.input.shift();
    },
    put_char: function(tty, val) {
      if (val === null || val === 10) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    },
    flush: function(tty) {
      if (tty.output && tty.output.length > 0) {
        out(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    }
  },
  default_tty1_ops: {
    put_char: function(tty, val) {
      if (val === null || val === 10) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    },
    flush: function(tty) {
      if (tty.output && tty.output.length > 0) {
        err(UTF8ArrayToString(tty.output, 0));
        tty.output = [];
      }
    }
  }
};
var MEMFS = {
  ops_table: null,
  mount: function(mount) {
    return MEMFS.createNode(null, "/", 16384 | 511, 0);
  },
  createNode: function(parent, name, mode, dev) {
    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
      throw new FS.ErrnoError(63);
    }
    if (!MEMFS.ops_table) {
      MEMFS.ops_table = {
        dir: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          },
          stream: { llseek: MEMFS.stream_ops.llseek }
        },
        file: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap,
            msync: MEMFS.stream_ops.msync
          }
        },
        link: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          },
          stream: {}
        },
        chrdev: {
          node: {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          },
          stream: FS.chrdev_stream_ops
        }
      };
    }
    var node = FS.createNode(parent, name, mode, dev);
    if (FS.isDir(node.mode)) {
      node.node_ops = MEMFS.ops_table.dir.node;
      node.stream_ops = MEMFS.ops_table.dir.stream;
      node.contents = {};
    } else if (FS.isFile(node.mode)) {
      node.node_ops = MEMFS.ops_table.file.node;
      node.stream_ops = MEMFS.ops_table.file.stream;
      node.usedBytes = 0;
      node.contents = null;
    } else if (FS.isLink(node.mode)) {
      node.node_ops = MEMFS.ops_table.link.node;
      node.stream_ops = MEMFS.ops_table.link.stream;
    } else if (FS.isChrdev(node.mode)) {
      node.node_ops = MEMFS.ops_table.chrdev.node;
      node.stream_ops = MEMFS.ops_table.chrdev.stream;
    }
    node.timestamp = Date.now();
    if (parent) {
      parent.contents[name] = node;
    }
    return node;
  },
  getFileDataAsRegularArray: function(node) {
    if (node.contents && node.contents.subarray) {
      var arr = [];
      for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
      return arr;
    }
    return node.contents;
  },
  getFileDataAsTypedArray: function(node) {
    if (!node.contents) return new Uint8Array(0);
    if (node.contents.subarray)
      return node.contents.subarray(0, node.usedBytes);
    return new Uint8Array(node.contents);
  },
  expandFileStorage: function(node, newCapacity) {
    var prevCapacity = node.contents ? node.contents.length : 0;
    if (prevCapacity >= newCapacity) return;
    var CAPACITY_DOUBLING_MAX = 1024 * 1024;
    newCapacity = Math.max(
      newCapacity,
      (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0
    );
    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
    var oldContents = node.contents;
    node.contents = new Uint8Array(newCapacity);
    if (node.usedBytes > 0)
      node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    return;
  },
  resizeFileStorage: function(node, newSize) {
    if (node.usedBytes == newSize) return;
    if (newSize == 0) {
      node.contents = null;
      node.usedBytes = 0;
      return;
    }
    if (!node.contents || node.contents.subarray) {
      var oldContents = node.contents;
      node.contents = new Uint8Array(newSize);
      if (oldContents) {
        node.contents.set(
          oldContents.subarray(0, Math.min(newSize, node.usedBytes))
        );
      }
      node.usedBytes = newSize;
      return;
    }
    if (!node.contents) node.contents = [];
    if (node.contents.length > newSize) node.contents.length = newSize;
    else while (node.contents.length < newSize) node.contents.push(0);
    node.usedBytes = newSize;
  },
  node_ops: {
    getattr: function(node) {
      var attr = {};
      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
      attr.ino = node.id;
      attr.mode = node.mode;
      attr.nlink = 1;
      attr.uid = 0;
      attr.gid = 0;
      attr.rdev = node.rdev;
      if (FS.isDir(node.mode)) {
        attr.size = 4096;
      } else if (FS.isFile(node.mode)) {
        attr.size = node.usedBytes;
      } else if (FS.isLink(node.mode)) {
        attr.size = node.link.length;
      } else {
        attr.size = 0;
      }
      attr.atime = new Date(node.timestamp);
      attr.mtime = new Date(node.timestamp);
      attr.ctime = new Date(node.timestamp);
      attr.blksize = 4096;
      attr.blocks = Math.ceil(attr.size / attr.blksize);
      return attr;
    },
    setattr: function(node, attr) {
      if (attr.mode !== undefined) {
        node.mode = attr.mode;
      }
      if (attr.timestamp !== undefined) {
        node.timestamp = attr.timestamp;
      }
      if (attr.size !== undefined) {
        MEMFS.resizeFileStorage(node, attr.size);
      }
    },
    lookup: function(parent, name) {
      throw FS.genericErrors[44];
    },
    mknod: function(parent, name, mode, dev) {
      return MEMFS.createNode(parent, name, mode, dev);
    },
    rename: function(old_node, new_dir, new_name) {
      if (FS.isDir(old_node.mode)) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {}
        if (new_node) {
          for (var i in new_node.contents) {
            throw new FS.ErrnoError(55);
          }
        }
      }
      delete old_node.parent.contents[old_node.name];
      old_node.name = new_name;
      new_dir.contents[new_name] = old_node;
      old_node.parent = new_dir;
    },
    unlink: function(parent, name) {
      delete parent.contents[name];
    },
    rmdir: function(parent, name) {
      var node = FS.lookupNode(parent, name);
      for (var i in node.contents) {
        throw new FS.ErrnoError(55);
      }
      delete parent.contents[name];
    },
    readdir: function(node) {
      var entries = [".", ".."];
      for (var key in node.contents) {
        if (!node.contents.hasOwnProperty(key)) {
          continue;
        }
        entries.push(key);
      }
      return entries;
    },
    symlink: function(parent, newname, oldpath) {
      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
      node.link = oldpath;
      return node;
    },
    readlink: function(node) {
      if (!FS.isLink(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      return node.link;
    }
  },
  stream_ops: {
    read: function(stream, buffer, offset, length, position) {
      var contents = stream.node.contents;
      if (position >= stream.node.usedBytes) return 0;
      var size = Math.min(stream.node.usedBytes - position, length);
      if (size > 8 && contents.subarray) {
        buffer.set(contents.subarray(position, position + size), offset);
      } else {
        for (var i = 0; i < size; i++)
          buffer[offset + i] = contents[position + i];
      }
      return size;
    },
    write: function(stream, buffer, offset, length, position, canOwn) {
      if (buffer.buffer === HEAP8.buffer) {
        canOwn = false;
      }
      if (!length) return 0;
      var node = stream.node;
      node.timestamp = Date.now();
      if (buffer.subarray && (!node.contents || node.contents.subarray)) {
        if (canOwn) {
          node.contents = buffer.subarray(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (node.usedBytes === 0 && position === 0) {
          node.contents = buffer.slice(offset, offset + length);
          node.usedBytes = length;
          return length;
        } else if (position + length <= node.usedBytes) {
          node.contents.set(buffer.subarray(offset, offset + length), position);
          return length;
        }
      }
      MEMFS.expandFileStorage(node, position + length);
      if (node.contents.subarray && buffer.subarray)
        node.contents.set(buffer.subarray(offset, offset + length), position);
      else {
        for (var i = 0; i < length; i++) {
          node.contents[position + i] = buffer[offset + i];
        }
      }
      node.usedBytes = Math.max(node.usedBytes, position + length);
      return length;
    },
    llseek: function(stream, offset, whence) {
      var position = offset;
      if (whence === 1) {
        position += stream.position;
      } else if (whence === 2) {
        if (FS.isFile(stream.node.mode)) {
          position += stream.node.usedBytes;
        }
      }
      if (position < 0) {
        throw new FS.ErrnoError(28);
      }
      return position;
    },
    allocate: function(stream, offset, length) {
      MEMFS.expandFileStorage(stream.node, offset + length);
      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
    },
    mmap: function(stream, address, length, position, prot, flags) {
      assert(address === 0);
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr;
      var allocated;
      var contents = stream.node.contents;
      if (!(flags & 2) && contents.buffer === buffer) {
        allocated = false;
        ptr = contents.byteOffset;
      } else {
        if (position > 0 || position + length < contents.length) {
          if (contents.subarray) {
            contents = contents.subarray(position, position + length);
          } else {
            contents = Array.prototype.slice.call(
              contents,
              position,
              position + length
            );
          }
        }
        allocated = true;
        ptr = _malloc(length);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        HEAP8.set(contents, ptr);
      }
      return { ptr: ptr, allocated: allocated };
    },
    msync: function(stream, buffer, offset, length, mmapFlags) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (mmapFlags & 2) {
        return 0;
      }
      var bytesWritten = MEMFS.stream_ops.write(
        stream,
        buffer,
        0,
        length,
        offset,
        false
      );
      return 0;
    }
  }
};
var ERRNO_CODES = {
  EPERM: 63,
  ENOENT: 44,
  ESRCH: 71,
  EINTR: 27,
  EIO: 29,
  ENXIO: 60,
  E2BIG: 1,
  ENOEXEC: 45,
  EBADF: 8,
  ECHILD: 12,
  EAGAIN: 6,
  EWOULDBLOCK: 6,
  ENOMEM: 48,
  EACCES: 2,
  EFAULT: 21,
  ENOTBLK: 105,
  EBUSY: 10,
  EEXIST: 20,
  EXDEV: 75,
  ENODEV: 43,
  ENOTDIR: 54,
  EISDIR: 31,
  EINVAL: 28,
  ENFILE: 41,
  EMFILE: 33,
  ENOTTY: 59,
  ETXTBSY: 74,
  EFBIG: 22,
  ENOSPC: 51,
  ESPIPE: 70,
  EROFS: 69,
  EMLINK: 34,
  EPIPE: 64,
  EDOM: 18,
  ERANGE: 68,
  ENOMSG: 49,
  EIDRM: 24,
  ECHRNG: 106,
  EL2NSYNC: 156,
  EL3HLT: 107,
  EL3RST: 108,
  ELNRNG: 109,
  EUNATCH: 110,
  ENOCSI: 111,
  EL2HLT: 112,
  EDEADLK: 16,
  ENOLCK: 46,
  EBADE: 113,
  EBADR: 114,
  EXFULL: 115,
  ENOANO: 104,
  EBADRQC: 103,
  EBADSLT: 102,
  EDEADLOCK: 16,
  EBFONT: 101,
  ENOSTR: 100,
  ENODATA: 116,
  ETIME: 117,
  ENOSR: 118,
  ENONET: 119,
  ENOPKG: 120,
  EREMOTE: 121,
  ENOLINK: 47,
  EADV: 122,
  ESRMNT: 123,
  ECOMM: 124,
  EPROTO: 65,
  EMULTIHOP: 36,
  EDOTDOT: 125,
  EBADMSG: 9,
  ENOTUNIQ: 126,
  EBADFD: 127,
  EREMCHG: 128,
  ELIBACC: 129,
  ELIBBAD: 130,
  ELIBSCN: 131,
  ELIBMAX: 132,
  ELIBEXEC: 133,
  ENOSYS: 52,
  ENOTEMPTY: 55,
  ENAMETOOLONG: 37,
  ELOOP: 32,
  EOPNOTSUPP: 138,
  EPFNOSUPPORT: 139,
  ECONNRESET: 15,
  ENOBUFS: 42,
  EAFNOSUPPORT: 5,
  EPROTOTYPE: 67,
  ENOTSOCK: 57,
  ENOPROTOOPT: 50,
  ESHUTDOWN: 140,
  ECONNREFUSED: 14,
  EADDRINUSE: 3,
  ECONNABORTED: 13,
  ENETUNREACH: 40,
  ENETDOWN: 38,
  ETIMEDOUT: 73,
  EHOSTDOWN: 142,
  EHOSTUNREACH: 23,
  EINPROGRESS: 26,
  EALREADY: 7,
  EDESTADDRREQ: 17,
  EMSGSIZE: 35,
  EPROTONOSUPPORT: 66,
  ESOCKTNOSUPPORT: 137,
  EADDRNOTAVAIL: 4,
  ENETRESET: 39,
  EISCONN: 30,
  ENOTCONN: 53,
  ETOOMANYREFS: 141,
  EUSERS: 136,
  EDQUOT: 19,
  ESTALE: 72,
  ENOTSUP: 138,
  ENOMEDIUM: 148,
  EILSEQ: 25,
  EOVERFLOW: 61,
  ECANCELED: 11,
  ENOTRECOVERABLE: 56,
  EOWNERDEAD: 62,
  ESTRPIPE: 135
};
var NODEFS = {
  isWindows: false,
  staticInit: function() {
    NODEFS.isWindows = !!process.platform.match(/^win/);
    var flags = { fs: fs.constants };
    if (flags["fs"]) {
      flags = flags["fs"];
    }
    NODEFS.flagsForNodeMap = {
      1024: flags["O_APPEND"],
      64: flags["O_CREAT"],
      128: flags["O_EXCL"],
      0: flags["O_RDONLY"],
      2: flags["O_RDWR"],
      4096: flags["O_SYNC"],
      512: flags["O_TRUNC"],
      1: flags["O_WRONLY"]
    };
  },
  bufferFrom: function(arrayBuffer) {
    return Buffer["alloc"] ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
  },
  convertNodeCode: function(e) {
    var code = e.code;
    return ERRNO_CODES[code];
  },
  mount: function(mount) {
    return NODEFS.createNode(null, "/", NODEFS.getMode(mount.opts.root), 0);
  },
  createNode: function(parent, name, mode, dev) {
    if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
      throw new FS.ErrnoError(28);
    }
    var node = FS.createNode(parent, name, mode);
    node.node_ops = NODEFS.node_ops;
    node.stream_ops = NODEFS.stream_ops;
    return node;
  },
  getMode: function(path) {
    var stat;
    try {
      stat = fs.lstatSync(path);
      if (NODEFS.isWindows) {
        stat.mode = stat.mode | ((stat.mode & 292) >> 2);
      }
    } catch (e) {
      if (!e.code) throw e;
      throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
    }
    return stat.mode;
  },
  realPath: function(node) {
    var parts = [];
    while (node.parent !== node) {
      parts.push(node.name);
      node = node.parent;
    }
    parts.push(node.mount.opts.root);
    parts.reverse();
    return PATH.join.apply(null, parts);
  },
  flagsForNode: function(flags) {
    flags &= ~2097152;
    flags &= ~2048;
    flags &= ~32768;
    flags &= ~524288;
    var newFlags = 0;
    for (var k in NODEFS.flagsForNodeMap) {
      if (flags & k) {
        newFlags |= NODEFS.flagsForNodeMap[k];
        flags ^= k;
      }
    }
    if (!flags) {
      return newFlags;
    } else {
      throw new FS.ErrnoError(28);
    }
  },
  node_ops: {
    getattr: function(node) {
      var path = NODEFS.realPath(node);
      var stat;
      try {
        stat = fs.lstatSync(path);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      if (NODEFS.isWindows && !stat.blksize) {
        stat.blksize = 4096;
      }
      if (NODEFS.isWindows && !stat.blocks) {
        stat.blocks = ((stat.size + stat.blksize - 1) / stat.blksize) | 0;
      }
      return {
        dev: stat.dev,
        ino: stat.ino,
        mode: stat.mode,
        nlink: stat.nlink,
        uid: stat.uid,
        gid: stat.gid,
        rdev: stat.rdev,
        size: stat.size,
        atime: stat.atime,
        mtime: stat.mtime,
        ctime: stat.ctime,
        blksize: stat.blksize,
        blocks: stat.blocks
      };
    },
    setattr: function(node, attr) {
      var path = NODEFS.realPath(node);
      try {
        if (attr.mode !== undefined) {
          fs.chmodSync(path, attr.mode);
          node.mode = attr.mode;
        }
        if (attr.timestamp !== undefined) {
          var date = new Date(attr.timestamp);
          fs.utimesSync(path, date, date);
        }
        if (attr.size !== undefined) {
          fs.truncateSync(path, attr.size);
        }
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    lookup: function(parent, name) {
      var path = PATH.join2(NODEFS.realPath(parent), name);
      var mode = NODEFS.getMode(path);
      return NODEFS.createNode(parent, name, mode);
    },
    mknod: function(parent, name, mode, dev) {
      var node = NODEFS.createNode(parent, name, mode, dev);
      var path = NODEFS.realPath(node);
      try {
        if (FS.isDir(node.mode)) {
          fs.mkdirSync(path, node.mode);
        } else {
          fs.writeFileSync(path, "", { mode: node.mode });
        }
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      return node;
    },
    rename: function(oldNode, newDir, newName) {
      var oldPath = NODEFS.realPath(oldNode);
      var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
      try {
        fs.renameSync(oldPath, newPath);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
      oldNode.name = newName;
    },
    unlink: function(parent, name) {
      var path = PATH.join2(NODEFS.realPath(parent), name);
      try {
        fs.unlinkSync(path);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    rmdir: function(parent, name) {
      var path = PATH.join2(NODEFS.realPath(parent), name);
      try {
        fs.rmdirSync(path);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    readdir: function(node) {
      var path = NODEFS.realPath(node);
      try {
        return fs.readdirSync(path);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    symlink: function(parent, newName, oldPath) {
      var newPath = PATH.join2(NODEFS.realPath(parent), newName);
      try {
        fs.symlinkSync(oldPath, newPath);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    readlink: function(node) {
      var path = NODEFS.realPath(node);
      try {
        path = fs.readlinkSync(path);
        path = NODEJS_PATH.relative(
          NODEJS_PATH.resolve(node.mount.opts.root),
          path
        );
        return path;
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    }
  },
  stream_ops: {
    open: function(stream) {
      var path = NODEFS.realPath(stream.node);
      try {
        if (FS.isFile(stream.node.mode)) {
          stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
        }
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    close: function(stream) {
      try {
        if (FS.isFile(stream.node.mode) && stream.nfd) {
          fs.closeSync(stream.nfd);
        }
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    read: function(stream, buffer, offset, length, position) {
      if (length === 0) return 0;
      try {
        return fs.readSync(
          stream.nfd,
          NODEFS.bufferFrom(buffer.buffer),
          offset,
          length,
          position
        );
      } catch (e) {
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    write: function(stream, buffer, offset, length, position) {
      try {
        return fs.writeSync(
          stream.nfd,
          NODEFS.bufferFrom(buffer.buffer),
          offset,
          length,
          position
        );
      } catch (e) {
        throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
      }
    },
    llseek: function(stream, offset, whence) {
      var position = offset;
      if (whence === 1) {
        position += stream.position;
      } else if (whence === 2) {
        if (FS.isFile(stream.node.mode)) {
          try {
            var stat = fs.fstatSync(stream.nfd);
            position += stat.size;
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        }
      }
      if (position < 0) {
        throw new FS.ErrnoError(28);
      }
      return position;
    },
    mmap: function(stream, address, length, position, prot, flags) {
      assert(address === 0);
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr = _malloc(length);
      NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
      return { ptr: ptr, allocated: true };
    },
    msync: function(stream, buffer, offset, length, mmapFlags) {
      if (!FS.isFile(stream.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (mmapFlags & 2) {
        return 0;
      }
      var bytesWritten = NODEFS.stream_ops.write(
        stream,
        buffer,
        0,
        length,
        offset,
        false
      );
      return 0;
    }
  }
};
var NODERAWFS = {
  lookupPath: function(path) {
    return { path: path, node: { mode: NODEFS.getMode(path) } };
  },
  createStandardStreams: function() {
    FS.streams[0] = {
      fd: 0,
      nfd: 0,
      position: 0,
      path: "",
      flags: 0,
      tty: true,
      seekable: false
    };
    for (var i = 1; i < 3; i++) {
      FS.streams[i] = {
        fd: i,
        nfd: i,
        position: 0,
        path: "",
        flags: 577,
        tty: true,
        seekable: false
      };
    }
  },
  cwd: function() {
    return process.cwd();
  },
  chdir: function() {
    process.chdir.apply(void 0, arguments);
  },
  mknod: function(path, mode) {
    if (FS.isDir(path)) {
      fs.mkdirSync(path, mode);
    } else {
      fs.writeFileSync(path, "", { mode: mode });
    }
  },
  mkdir: function() {
    fs.mkdirSync.apply(void 0, arguments);
  },
  symlink: function() {
    fs.symlinkSync.apply(void 0, arguments);
  },
  rename: function() {
    fs.renameSync.apply(void 0, arguments);
  },
  rmdir: function() {
    fs.rmdirSync.apply(void 0, arguments);
  },
  readdir: function() {
    fs.readdirSync.apply(void 0, arguments);
  },
  unlink: function() {
    fs.unlinkSync.apply(void 0, arguments);
  },
  readlink: function() {
    return fs.readlinkSync.apply(void 0, arguments);
  },
  stat: function() {
    return fs.statSync.apply(void 0, arguments);
  },
  lstat: function() {
    return fs.lstatSync.apply(void 0, arguments);
  },
  chmod: function() {
    fs.chmodSync.apply(void 0, arguments);
  },
  fchmod: function() {
    fs.fchmodSync.apply(void 0, arguments);
  },
  chown: function() {
    fs.chownSync.apply(void 0, arguments);
  },
  fchown: function() {
    fs.fchownSync.apply(void 0, arguments);
  },
  truncate: function() {
    fs.truncateSync.apply(void 0, arguments);
  },
  ftruncate: function() {
    fs.ftruncateSync.apply(void 0, arguments);
  },
  utime: function() {
    fs.utimesSync.apply(void 0, arguments);
  },
  open: function(path, flags, mode, suggestFD) {
    if (typeof flags === "string") {
      flags = VFS.modeStringToFlags(flags);
    }
    var nfd = fs.openSync(path, NODEFS.flagsForNode(flags), mode);
    var fd = suggestFD != null ? suggestFD : FS.nextfd(nfd);
    var stream = {
      fd: fd,
      nfd: nfd,
      position: 0,
      path: path,
      flags: flags,
      seekable: true
    };
    FS.streams[fd] = stream;
    return stream;
  },
  close: function(stream) {
    if (!stream.stream_ops) {
      fs.closeSync(stream.nfd);
    }
    FS.closeStream(stream.fd);
  },
  llseek: function(stream, offset, whence) {
    if (stream.stream_ops) {
      return VFS.llseek(stream, offset, whence);
    }
    var position = offset;
    if (whence === 1) {
      position += stream.position;
    } else if (whence === 2) {
      position += fs.fstatSync(stream.nfd).size;
    } else if (whence !== 0) {
      throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
    }
    if (position < 0) {
      throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
    }
    stream.position = position;
    return position;
  },
  read: function(stream, buffer, offset, length, position) {
    if (stream.stream_ops) {
      return VFS.read(stream, buffer, offset, length, position);
    }
    var seeking = typeof position !== "undefined";
    if (!seeking && stream.seekable) position = stream.position;
    var bytesRead = fs.readSync(
      stream.nfd,
      NODEFS.bufferFrom(buffer.buffer),
      offset,
      length,
      position
    );
    if (!seeking) stream.position += bytesRead;
    return bytesRead;
  },
  write: function(stream, buffer, offset, length, position) {
    if (stream.stream_ops) {
      return VFS.write(stream, buffer, offset, length, position);
    }
    if (stream.flags & +"1024") {
      FS.llseek(stream, 0, +"2");
    }
    var seeking = typeof position !== "undefined";
    if (!seeking && stream.seekable) position = stream.position;
    var bytesWritten = fs.writeSync(
      stream.nfd,
      NODEFS.bufferFrom(buffer.buffer),
      offset,
      length,
      position
    );
    if (!seeking) stream.position += bytesWritten;
    return bytesWritten;
  },
  allocate: function() {
    throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
  },
  mmap: function() {
    throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
  },
  msync: function() {
    return 0;
  },
  munmap: function() {
    return 0;
  },
  ioctl: function() {
    throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
  }
};
var FS = {
  root: null,
  mounts: [],
  devices: {},
  streams: [],
  nextInode: 1,
  nameTable: null,
  currentPath: "/",
  initialized: false,
  ignorePermissions: true,
  trackingDelegate: {},
  tracking: { openFlags: { READ: 1, WRITE: 2 } },
  ErrnoError: null,
  genericErrors: {},
  filesystems: null,
  syncFSRequests: 0,
  handleFSError: function(e) {
    if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace();
    return setErrNo(e.errno);
  },
  lookupPath: function(path, opts) {
    path = PATH_FS.resolve(FS.cwd(), path);
    opts = opts || {};
    if (!path) return { path: "", node: null };
    var defaults = { follow_mount: true, recurse_count: 0 };
    for (var key in defaults) {
      if (opts[key] === undefined) {
        opts[key] = defaults[key];
      }
    }
    if (opts.recurse_count > 8) {
      throw new FS.ErrnoError(32);
    }
    var parts = PATH.normalizeArray(
      path.split("/").filter(function(p) {
        return !!p;
      }),
      false
    );
    var current = FS.root;
    var current_path = "/";
    for (var i = 0; i < parts.length; i++) {
      var islast = i === parts.length - 1;
      if (islast && opts.parent) {
        break;
      }
      current = FS.lookupNode(current, parts[i]);
      current_path = PATH.join2(current_path, parts[i]);
      if (FS.isMountpoint(current)) {
        if (!islast || (islast && opts.follow_mount)) {
          current = current.mounted.root;
        }
      }
      if (!islast || opts.follow) {
        var count = 0;
        while (FS.isLink(current.mode)) {
          var link = FS.readlink(current_path);
          current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
          var lookup = FS.lookupPath(current_path, {
            recurse_count: opts.recurse_count
          });
          current = lookup.node;
          if (count++ > 40) {
            throw new FS.ErrnoError(32);
          }
        }
      }
    }
    return { path: current_path, node: current };
  },
  getPath: function(node) {
    var path;
    while (true) {
      if (FS.isRoot(node)) {
        var mount = node.mount.mountpoint;
        if (!path) return mount;
        return mount[mount.length - 1] !== "/"
          ? mount + "/" + path
          : mount + path;
      }
      path = path ? node.name + "/" + path : node.name;
      node = node.parent;
    }
  },
  hashName: function(parentid, name) {
    var hash = 0;
    for (var i = 0; i < name.length; i++) {
      hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
    }
    return ((parentid + hash) >>> 0) % FS.nameTable.length;
  },
  hashAddNode: function(node) {
    var hash = FS.hashName(node.parent.id, node.name);
    node.name_next = FS.nameTable[hash];
    FS.nameTable[hash] = node;
  },
  hashRemoveNode: function(node) {
    var hash = FS.hashName(node.parent.id, node.name);
    if (FS.nameTable[hash] === node) {
      FS.nameTable[hash] = node.name_next;
    } else {
      var current = FS.nameTable[hash];
      while (current) {
        if (current.name_next === node) {
          current.name_next = node.name_next;
          break;
        }
        current = current.name_next;
      }
    }
  },
  lookupNode: function(parent, name) {
    var errCode = FS.mayLookup(parent);
    if (errCode) {
      throw new FS.ErrnoError(errCode, parent);
    }
    var hash = FS.hashName(parent.id, name);
    for (var node = FS.nameTable[hash]; node; node = node.name_next) {
      var nodeName = node.name;
      if (node.parent.id === parent.id && nodeName === name) {
        return node;
      }
    }
    return FS.lookup(parent, name);
  },
  createNode: function(parent, name, mode, rdev) {
    var node = new FS.FSNode(parent, name, mode, rdev);
    FS.hashAddNode(node);
    return node;
  },
  destroyNode: function(node) {
    FS.hashRemoveNode(node);
  },
  isRoot: function(node) {
    return node === node.parent;
  },
  isMountpoint: function(node) {
    return !!node.mounted;
  },
  isFile: function(mode) {
    return (mode & 61440) === 32768;
  },
  isDir: function(mode) {
    return (mode & 61440) === 16384;
  },
  isLink: function(mode) {
    return (mode & 61440) === 40960;
  },
  isChrdev: function(mode) {
    return (mode & 61440) === 8192;
  },
  isBlkdev: function(mode) {
    return (mode & 61440) === 24576;
  },
  isFIFO: function(mode) {
    return (mode & 61440) === 4096;
  },
  isSocket: function(mode) {
    return (mode & 49152) === 49152;
  },
  flagModes: {
    r: 0,
    rs: 1052672,
    "r+": 2,
    w: 577,
    wx: 705,
    xw: 705,
    "w+": 578,
    "wx+": 706,
    "xw+": 706,
    a: 1089,
    ax: 1217,
    xa: 1217,
    "a+": 1090,
    "ax+": 1218,
    "xa+": 1218
  },
  modeStringToFlags: function(str) {
    var flags = FS.flagModes[str];
    if (typeof flags === "undefined") {
      throw new Error("Unknown file open mode: " + str);
    }
    return flags;
  },
  flagsToPermissionString: function(flag) {
    var perms = ["r", "w", "rw"][flag & 3];
    if (flag & 512) {
      perms += "w";
    }
    return perms;
  },
  nodePermissions: function(node, perms) {
    if (FS.ignorePermissions) {
      return 0;
    }
    if (perms.indexOf("r") !== -1 && !(node.mode & 292)) {
      return 2;
    } else if (perms.indexOf("w") !== -1 && !(node.mode & 146)) {
      return 2;
    } else if (perms.indexOf("x") !== -1 && !(node.mode & 73)) {
      return 2;
    }
    return 0;
  },
  mayLookup: function(dir) {
    var errCode = FS.nodePermissions(dir, "x");
    if (errCode) return errCode;
    if (!dir.node_ops.lookup) return 2;
    return 0;
  },
  mayCreate: function(dir, name) {
    try {
      var node = FS.lookupNode(dir, name);
      return 20;
    } catch (e) {}
    return FS.nodePermissions(dir, "wx");
  },
  mayDelete: function(dir, name, isdir) {
    var node;
    try {
      node = FS.lookupNode(dir, name);
    } catch (e) {
      return e.errno;
    }
    var errCode = FS.nodePermissions(dir, "wx");
    if (errCode) {
      return errCode;
    }
    if (isdir) {
      if (!FS.isDir(node.mode)) {
        return 54;
      }
      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
        return 10;
      }
    } else {
      if (FS.isDir(node.mode)) {
        return 31;
      }
    }
    return 0;
  },
  mayOpen: function(node, flags) {
    if (!node) {
      return 44;
    }
    if (FS.isLink(node.mode)) {
      return 32;
    } else if (FS.isDir(node.mode)) {
      if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
        return 31;
      }
    }
    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
  },
  MAX_OPEN_FDS: 4096,
  nextfd: function(fd_start, fd_end) {
    fd_start = fd_start || 0;
    fd_end = fd_end || FS.MAX_OPEN_FDS;
    for (var fd = fd_start; fd <= fd_end; fd++) {
      if (!FS.streams[fd]) {
        return fd;
      }
    }
    throw new FS.ErrnoError(33);
  },
  getStream: function(fd) {
    return FS.streams[fd];
  },
  createStream: function(stream, fd_start, fd_end) {
    if (!FS.FSStream) {
      FS.FSStream = function() {};
      FS.FSStream.prototype = {
        object: {
          get: function() {
            return this.node;
          },
          set: function(val) {
            this.node = val;
          }
        },
        isRead: {
          get: function() {
            return (this.flags & 2097155) !== 1;
          }
        },
        isWrite: {
          get: function() {
            return (this.flags & 2097155) !== 0;
          }
        },
        isAppend: {
          get: function() {
            return this.flags & 1024;
          }
        }
      };
    }
    var newStream = new FS.FSStream();
    for (var p in stream) {
      newStream[p] = stream[p];
    }
    stream = newStream;
    var fd = FS.nextfd(fd_start, fd_end);
    stream.fd = fd;
    FS.streams[fd] = stream;
    return stream;
  },
  closeStream: function(fd) {
    FS.streams[fd] = null;
  },
  chrdev_stream_ops: {
    open: function(stream) {
      var device = FS.getDevice(stream.node.rdev);
      stream.stream_ops = device.stream_ops;
      if (stream.stream_ops.open) {
        stream.stream_ops.open(stream);
      }
    },
    llseek: function() {
      throw new FS.ErrnoError(70);
    }
  },
  major: function(dev) {
    return dev >> 8;
  },
  minor: function(dev) {
    return dev & 255;
  },
  makedev: function(ma, mi) {
    return (ma << 8) | mi;
  },
  registerDevice: function(dev, ops) {
    FS.devices[dev] = { stream_ops: ops };
  },
  getDevice: function(dev) {
    return FS.devices[dev];
  },
  getMounts: function(mount) {
    var mounts = [];
    var check = [mount];
    while (check.length) {
      var m = check.pop();
      mounts.push(m);
      check.push.apply(check, m.mounts);
    }
    return mounts;
  },
  syncfs: function(populate, callback) {
    if (typeof populate === "function") {
      callback = populate;
      populate = false;
    }
    FS.syncFSRequests++;
    if (FS.syncFSRequests > 1) {
      err(
        "warning: " +
          FS.syncFSRequests +
          " FS.syncfs operations in flight at once, probably just doing extra work"
      );
    }
    var mounts = FS.getMounts(FS.root.mount);
    var completed = 0;
    function doCallback(errCode) {
      FS.syncFSRequests--;
      return callback(errCode);
    }
    function done(errCode) {
      if (errCode) {
        if (!done.errored) {
          done.errored = true;
          return doCallback(errCode);
        }
        return;
      }
      if (++completed >= mounts.length) {
        doCallback(null);
      }
    }
    mounts.forEach(function(mount) {
      if (!mount.type.syncfs) {
        return done(null);
      }
      mount.type.syncfs(mount, populate, done);
    });
  },
  mount: function(type, opts, mountpoint) {
    var root = mountpoint === "/";
    var pseudo = !mountpoint;
    var node;
    if (root && FS.root) {
      throw new FS.ErrnoError(10);
    } else if (!root && !pseudo) {
      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
      mountpoint = lookup.path;
      node = lookup.node;
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      if (!FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
    }
    var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] };
    var mountRoot = type.mount(mount);
    mountRoot.mount = mount;
    mount.root = mountRoot;
    if (root) {
      FS.root = mountRoot;
    } else if (node) {
      node.mounted = mount;
      if (node.mount) {
        node.mount.mounts.push(mount);
      }
    }
    return mountRoot;
  },
  unmount: function(mountpoint) {
    var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
    if (!FS.isMountpoint(lookup.node)) {
      throw new FS.ErrnoError(28);
    }
    var node = lookup.node;
    var mount = node.mounted;
    var mounts = FS.getMounts(mount);
    Object.keys(FS.nameTable).forEach(function(hash) {
      var current = FS.nameTable[hash];
      while (current) {
        var next = current.name_next;
        if (mounts.indexOf(current.mount) !== -1) {
          FS.destroyNode(current);
        }
        current = next;
      }
    });
    node.mounted = null;
    var idx = node.mount.mounts.indexOf(mount);
    node.mount.mounts.splice(idx, 1);
  },
  lookup: function(parent, name) {
    return parent.node_ops.lookup(parent, name);
  },
  mknod: function(path, mode, dev) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    if (!name || name === "." || name === "..") {
      throw new FS.ErrnoError(28);
    }
    var errCode = FS.mayCreate(parent, name);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.mknod) {
      throw new FS.ErrnoError(63);
    }
    return parent.node_ops.mknod(parent, name, mode, dev);
  },
  create: function(path, mode) {
    mode = mode !== undefined ? mode : 438;
    mode &= 4095;
    mode |= 32768;
    return FS.mknod(path, mode, 0);
  },
  mkdir: function(path, mode) {
    mode = mode !== undefined ? mode : 511;
    mode &= 511 | 512;
    mode |= 16384;
    return FS.mknod(path, mode, 0);
  },
  mkdirTree: function(path, mode) {
    var dirs = path.split("/");
    var d = "";
    for (var i = 0; i < dirs.length; ++i) {
      if (!dirs[i]) continue;
      d += "/" + dirs[i];
      try {
        FS.mkdir(d, mode);
      } catch (e) {
        if (e.errno != 20) throw e;
      }
    }
  },
  mkdev: function(path, mode, dev) {
    if (typeof dev === "undefined") {
      dev = mode;
      mode = 438;
    }
    mode |= 8192;
    return FS.mknod(path, mode, dev);
  },
  symlink: function(oldpath, newpath) {
    if (!PATH_FS.resolve(oldpath)) {
      throw new FS.ErrnoError(44);
    }
    var lookup = FS.lookupPath(newpath, { parent: true });
    var parent = lookup.node;
    if (!parent) {
      throw new FS.ErrnoError(44);
    }
    var newname = PATH.basename(newpath);
    var errCode = FS.mayCreate(parent, newname);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.symlink) {
      throw new FS.ErrnoError(63);
    }
    return parent.node_ops.symlink(parent, newname, oldpath);
  },
  rename: function(old_path, new_path) {
    var old_dirname = PATH.dirname(old_path);
    var new_dirname = PATH.dirname(new_path);
    var old_name = PATH.basename(old_path);
    var new_name = PATH.basename(new_path);
    var lookup, old_dir, new_dir;
    try {
      lookup = FS.lookupPath(old_path, { parent: true });
      old_dir = lookup.node;
      lookup = FS.lookupPath(new_path, { parent: true });
      new_dir = lookup.node;
    } catch (e) {
      throw new FS.ErrnoError(10);
    }
    if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
    if (old_dir.mount !== new_dir.mount) {
      throw new FS.ErrnoError(75);
    }
    var old_node = FS.lookupNode(old_dir, old_name);
    var relative = PATH_FS.relative(old_path, new_dirname);
    if (relative.charAt(0) !== ".") {
      throw new FS.ErrnoError(28);
    }
    relative = PATH_FS.relative(new_path, old_dirname);
    if (relative.charAt(0) !== ".") {
      throw new FS.ErrnoError(55);
    }
    var new_node;
    try {
      new_node = FS.lookupNode(new_dir, new_name);
    } catch (e) {}
    if (old_node === new_node) {
      return;
    }
    var isdir = FS.isDir(old_node.mode);
    var errCode = FS.mayDelete(old_dir, old_name, isdir);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    errCode = new_node
      ? FS.mayDelete(new_dir, new_name, isdir)
      : FS.mayCreate(new_dir, new_name);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!old_dir.node_ops.rename) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
      throw new FS.ErrnoError(10);
    }
    if (new_dir !== old_dir) {
      errCode = FS.nodePermissions(old_dir, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
    }
    try {
      if (FS.trackingDelegate["willMovePath"]) {
        FS.trackingDelegate["willMovePath"](old_path, new_path);
      }
    } catch (e) {
      err(
        "FS.trackingDelegate['willMovePath']('" +
          old_path +
          "', '" +
          new_path +
          "') threw an exception: " +
          e.message
      );
    }
    FS.hashRemoveNode(old_node);
    try {
      old_dir.node_ops.rename(old_node, new_dir, new_name);
    } catch (e) {
      throw e;
    } finally {
      FS.hashAddNode(old_node);
    }
    try {
      if (FS.trackingDelegate["onMovePath"])
        FS.trackingDelegate["onMovePath"](old_path, new_path);
    } catch (e) {
      err(
        "FS.trackingDelegate['onMovePath']('" +
          old_path +
          "', '" +
          new_path +
          "') threw an exception: " +
          e.message
      );
    }
  },
  rmdir: function(path) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    var node = FS.lookupNode(parent, name);
    var errCode = FS.mayDelete(parent, name, true);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.rmdir) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(node)) {
      throw new FS.ErrnoError(10);
    }
    try {
      if (FS.trackingDelegate["willDeletePath"]) {
        FS.trackingDelegate["willDeletePath"](path);
      }
    } catch (e) {
      err(
        "FS.trackingDelegate['willDeletePath']('" +
          path +
          "') threw an exception: " +
          e.message
      );
    }
    parent.node_ops.rmdir(parent, name);
    FS.destroyNode(node);
    try {
      if (FS.trackingDelegate["onDeletePath"])
        FS.trackingDelegate["onDeletePath"](path);
    } catch (e) {
      err(
        "FS.trackingDelegate['onDeletePath']('" +
          path +
          "') threw an exception: " +
          e.message
      );
    }
  },
  readdir: function(path) {
    var lookup = FS.lookupPath(path, { follow: true });
    var node = lookup.node;
    if (!node.node_ops.readdir) {
      throw new FS.ErrnoError(54);
    }
    return node.node_ops.readdir(node);
  },
  unlink: function(path) {
    var lookup = FS.lookupPath(path, { parent: true });
    var parent = lookup.node;
    var name = PATH.basename(path);
    var node = FS.lookupNode(parent, name);
    var errCode = FS.mayDelete(parent, name, false);
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    if (!parent.node_ops.unlink) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isMountpoint(node)) {
      throw new FS.ErrnoError(10);
    }
    try {
      if (FS.trackingDelegate["willDeletePath"]) {
        FS.trackingDelegate["willDeletePath"](path);
      }
    } catch (e) {
      err(
        "FS.trackingDelegate['willDeletePath']('" +
          path +
          "') threw an exception: " +
          e.message
      );
    }
    parent.node_ops.unlink(parent, name);
    FS.destroyNode(node);
    try {
      if (FS.trackingDelegate["onDeletePath"])
        FS.trackingDelegate["onDeletePath"](path);
    } catch (e) {
      err(
        "FS.trackingDelegate['onDeletePath']('" +
          path +
          "') threw an exception: " +
          e.message
      );
    }
  },
  readlink: function(path) {
    var lookup = FS.lookupPath(path);
    var link = lookup.node;
    if (!link) {
      throw new FS.ErrnoError(44);
    }
    if (!link.node_ops.readlink) {
      throw new FS.ErrnoError(28);
    }
    return PATH_FS.resolve(
      FS.getPath(link.parent),
      link.node_ops.readlink(link)
    );
  },
  stat: function(path, dontFollow) {
    var lookup = FS.lookupPath(path, { follow: !dontFollow });
    var node = lookup.node;
    if (!node) {
      throw new FS.ErrnoError(44);
    }
    if (!node.node_ops.getattr) {
      throw new FS.ErrnoError(63);
    }
    return node.node_ops.getattr(node);
  },
  lstat: function(path) {
    return FS.stat(path, true);
  },
  chmod: function(path, mode, dontFollow) {
    var node;
    if (typeof path === "string") {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    node.node_ops.setattr(node, {
      mode: (mode & 4095) | (node.mode & ~4095),
      timestamp: Date.now()
    });
  },
  lchmod: function(path, mode) {
    FS.chmod(path, mode, true);
  },
  fchmod: function(fd, mode) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    FS.chmod(stream.node, mode);
  },
  chown: function(path, uid, gid, dontFollow) {
    var node;
    if (typeof path === "string") {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    node.node_ops.setattr(node, { timestamp: Date.now() });
  },
  lchown: function(path, uid, gid) {
    FS.chown(path, uid, gid, true);
  },
  fchown: function(fd, uid, gid) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    FS.chown(stream.node, uid, gid);
  },
  truncate: function(path, len) {
    if (len < 0) {
      throw new FS.ErrnoError(28);
    }
    var node;
    if (typeof path === "string") {
      var lookup = FS.lookupPath(path, { follow: true });
      node = lookup.node;
    } else {
      node = path;
    }
    if (!node.node_ops.setattr) {
      throw new FS.ErrnoError(63);
    }
    if (FS.isDir(node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!FS.isFile(node.mode)) {
      throw new FS.ErrnoError(28);
    }
    var errCode = FS.nodePermissions(node, "w");
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
  },
  ftruncate: function(fd, len) {
    var stream = FS.getStream(fd);
    if (!stream) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(28);
    }
    FS.truncate(stream.node, len);
  },
  utime: function(path, atime, mtime) {
    var lookup = FS.lookupPath(path, { follow: true });
    var node = lookup.node;
    node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
  },
  open: function(path, flags, mode, fd_start, fd_end) {
    if (path === "") {
      throw new FS.ErrnoError(44);
    }
    flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
    mode = typeof mode === "undefined" ? 438 : mode;
    if (flags & 64) {
      mode = (mode & 4095) | 32768;
    } else {
      mode = 0;
    }
    var node;
    if (typeof path === "object") {
      node = path;
    } else {
      path = PATH.normalize(path);
      try {
        var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
        node = lookup.node;
      } catch (e) {}
    }
    var created = false;
    if (flags & 64) {
      if (node) {
        if (flags & 128) {
          throw new FS.ErrnoError(20);
        }
      } else {
        node = FS.mknod(path, mode, 0);
        created = true;
      }
    }
    if (!node) {
      throw new FS.ErrnoError(44);
    }
    if (FS.isChrdev(node.mode)) {
      flags &= ~512;
    }
    if (flags & 65536 && !FS.isDir(node.mode)) {
      throw new FS.ErrnoError(54);
    }
    if (!created) {
      var errCode = FS.mayOpen(node, flags);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
    }
    if (flags & 512) {
      FS.truncate(node, 0);
    }
    flags &= ~(128 | 512 | 131072);
    var stream = FS.createStream(
      {
        node: node,
        path: FS.getPath(node),
        flags: flags,
        seekable: true,
        position: 0,
        stream_ops: node.stream_ops,
        ungotten: [],
        error: false
      },
      fd_start,
      fd_end
    );
    if (stream.stream_ops.open) {
      stream.stream_ops.open(stream);
    }
    if (Module["logReadFiles"] && !(flags & 1)) {
      if (!FS.readFiles) FS.readFiles = {};
      if (!(path in FS.readFiles)) {
        FS.readFiles[path] = 1;
        err("FS.trackingDelegate error on read file: " + path);
      }
    }
    try {
      if (FS.trackingDelegate["onOpenFile"]) {
        var trackingFlags = 0;
        if ((flags & 2097155) !== 1) {
          trackingFlags |= FS.tracking.openFlags.READ;
        }
        if ((flags & 2097155) !== 0) {
          trackingFlags |= FS.tracking.openFlags.WRITE;
        }
        FS.trackingDelegate["onOpenFile"](path, trackingFlags);
      }
    } catch (e) {
      err(
        "FS.trackingDelegate['onOpenFile']('" +
          path +
          "', flags) threw an exception: " +
          e.message
      );
    }
    return stream;
  },
  close: function(stream) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (stream.getdents) stream.getdents = null;
    try {
      if (stream.stream_ops.close) {
        stream.stream_ops.close(stream);
      }
    } catch (e) {
      throw e;
    } finally {
      FS.closeStream(stream.fd);
    }
    stream.fd = null;
  },
  isClosed: function(stream) {
    return stream.fd === null;
  },
  llseek: function(stream, offset, whence) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (!stream.seekable || !stream.stream_ops.llseek) {
      throw new FS.ErrnoError(70);
    }
    if (whence != 0 && whence != 1 && whence != 2) {
      throw new FS.ErrnoError(28);
    }
    stream.position = stream.stream_ops.llseek(stream, offset, whence);
    stream.ungotten = [];
    return stream.position;
  },
  read: function(stream, buffer, offset, length, position) {
    if (length < 0 || position < 0) {
      throw new FS.ErrnoError(28);
    }
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 1) {
      throw new FS.ErrnoError(8);
    }
    if (FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!stream.stream_ops.read) {
      throw new FS.ErrnoError(28);
    }
    var seeking = typeof position !== "undefined";
    if (!seeking) {
      position = stream.position;
    } else if (!stream.seekable) {
      throw new FS.ErrnoError(70);
    }
    var bytesRead = stream.stream_ops.read(
      stream,
      buffer,
      offset,
      length,
      position
    );
    if (!seeking) stream.position += bytesRead;
    return bytesRead;
  },
  write: function(stream, buffer, offset, length, position, canOwn) {
    if (length < 0 || position < 0) {
      throw new FS.ErrnoError(28);
    }
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(8);
    }
    if (FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(31);
    }
    if (!stream.stream_ops.write) {
      throw new FS.ErrnoError(28);
    }
    if (stream.seekable && stream.flags & 1024) {
      FS.llseek(stream, 0, 2);
    }
    var seeking = typeof position !== "undefined";
    if (!seeking) {
      position = stream.position;
    } else if (!stream.seekable) {
      throw new FS.ErrnoError(70);
    }
    var bytesWritten = stream.stream_ops.write(
      stream,
      buffer,
      offset,
      length,
      position,
      canOwn
    );
    if (!seeking) stream.position += bytesWritten;
    try {
      if (stream.path && FS.trackingDelegate["onWriteToFile"])
        FS.trackingDelegate["onWriteToFile"](stream.path);
    } catch (e) {
      err(
        "FS.trackingDelegate['onWriteToFile']('" +
          stream.path +
          "') threw an exception: " +
          e.message
      );
    }
    return bytesWritten;
  },
  allocate: function(stream, offset, length) {
    if (FS.isClosed(stream)) {
      throw new FS.ErrnoError(8);
    }
    if (offset < 0 || length <= 0) {
      throw new FS.ErrnoError(28);
    }
    if ((stream.flags & 2097155) === 0) {
      throw new FS.ErrnoError(8);
    }
    if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
      throw new FS.ErrnoError(43);
    }
    if (!stream.stream_ops.allocate) {
      throw new FS.ErrnoError(138);
    }
    stream.stream_ops.allocate(stream, offset, length);
  },
  mmap: function(stream, address, length, position, prot, flags) {
    if (
      (prot & 2) !== 0 &&
      (flags & 2) === 0 &&
      (stream.flags & 2097155) !== 2
    ) {
      throw new FS.ErrnoError(2);
    }
    if ((stream.flags & 2097155) === 1) {
      throw new FS.ErrnoError(2);
    }
    if (!stream.stream_ops.mmap) {
      throw new FS.ErrnoError(43);
    }
    return stream.stream_ops.mmap(
      stream,
      address,
      length,
      position,
      prot,
      flags
    );
  },
  msync: function(stream, buffer, offset, length, mmapFlags) {
    if (!stream || !stream.stream_ops.msync) {
      return 0;
    }
    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
  },
  munmap: function(stream) {
    return 0;
  },
  ioctl: function(stream, cmd, arg) {
    if (!stream.stream_ops.ioctl) {
      throw new FS.ErrnoError(59);
    }
    return stream.stream_ops.ioctl(stream, cmd, arg);
  },
  readFile: function(path, opts) {
    opts = opts || {};
    opts.flags = opts.flags || "r";
    opts.encoding = opts.encoding || "binary";
    if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
      throw new Error('Invalid encoding type "' + opts.encoding + '"');
    }
    var ret;
    var stream = FS.open(path, opts.flags);
    var stat = FS.stat(path);
    var length = stat.size;
    var buf = new Uint8Array(length);
    FS.read(stream, buf, 0, length, 0);
    if (opts.encoding === "utf8") {
      ret = UTF8ArrayToString(buf, 0);
    } else if (opts.encoding === "binary") {
      ret = buf;
    }
    FS.close(stream);
    return ret;
  },
  writeFile: function(path, data, opts) {
    opts = opts || {};
    opts.flags = opts.flags || "w";
    var stream = FS.open(path, opts.flags, opts.mode);
    if (typeof data === "string") {
      var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
      var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
      FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
    } else if (ArrayBuffer.isView(data)) {
      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
    } else {
      throw new Error("Unsupported data type");
    }
    FS.close(stream);
  },
  cwd: function() {
    return FS.currentPath;
  },
  chdir: function(path) {
    var lookup = FS.lookupPath(path, { follow: true });
    if (lookup.node === null) {
      throw new FS.ErrnoError(44);
    }
    if (!FS.isDir(lookup.node.mode)) {
      throw new FS.ErrnoError(54);
    }
    var errCode = FS.nodePermissions(lookup.node, "x");
    if (errCode) {
      throw new FS.ErrnoError(errCode);
    }
    FS.currentPath = lookup.path;
  },
  createDefaultDirectories: function() {
    FS.mkdir("/tmp");
    FS.mkdir("/home");
    FS.mkdir("/home/web_user");
  },
  createDefaultDevices: function() {
    FS.mkdir("/dev");
    FS.registerDevice(FS.makedev(1, 3), {
      read: function() {
        return 0;
      },
      write: function(stream, buffer, offset, length, pos) {
        return length;
      }
    });
    FS.mkdev("/dev/null", FS.makedev(1, 3));
    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
    FS.mkdev("/dev/tty", FS.makedev(5, 0));
    FS.mkdev("/dev/tty1", FS.makedev(6, 0));
    var random_device;
    if (
      typeof crypto === "object" &&
      typeof crypto["getRandomValues"] === "function"
    ) {
      var randomBuffer = new Uint8Array(1);
      random_device = function() {
        crypto.getRandomValues(randomBuffer);
        return randomBuffer[0];
      };
    } else if (ENVIRONMENT_IS_NODE) {
      try {
        var crypto_module = __webpack_require__(143);
        random_device = function() {
          return crypto_module["randomBytes"](1)[0];
        };
      } catch (e) {}
    } else {
    }
    if (!random_device) {
      random_device = function() {
        abort("random_device");
      };
    }
    FS.createDevice("/dev", "random", random_device);
    FS.createDevice("/dev", "urandom", random_device);
    FS.mkdir("/dev/shm");
    FS.mkdir("/dev/shm/tmp");
  },
  createSpecialDirectories: function() {
    FS.mkdir("/proc");
    FS.mkdir("/proc/self");
    FS.mkdir("/proc/self/fd");
    FS.mount(
      {
        mount: function() {
          var node = FS.createNode("/proc/self", "fd", 16384 | 511, 73);
          node.node_ops = {
            lookup: function(parent, name) {
              var fd = +name;
              var stream = FS.getStream(fd);
              if (!stream) throw new FS.ErrnoError(8);
              var ret = {
                parent: null,
                mount: { mountpoint: "fake" },
                node_ops: {
                  readlink: function() {
                    return stream.path;
                  }
                }
              };
              ret.parent = ret;
              return ret;
            }
          };
          return node;
        }
      },
      {},
      "/proc/self/fd"
    );
  },
  createStandardStreams: function() {
    if (Module["stdin"]) {
      FS.createDevice("/dev", "stdin", Module["stdin"]);
    } else {
      FS.symlink("/dev/tty", "/dev/stdin");
    }
    if (Module["stdout"]) {
      FS.createDevice("/dev", "stdout", null, Module["stdout"]);
    } else {
      FS.symlink("/dev/tty", "/dev/stdout");
    }
    if (Module["stderr"]) {
      FS.createDevice("/dev", "stderr", null, Module["stderr"]);
    } else {
      FS.symlink("/dev/tty1", "/dev/stderr");
    }
    var stdin = FS.open("/dev/stdin", "r");
    var stdout = FS.open("/dev/stdout", "w");
    var stderr = FS.open("/dev/stderr", "w");
  },
  ensureErrnoError: function() {
    if (FS.ErrnoError) return;
    FS.ErrnoError = function ErrnoError(errno, node) {
      this.node = node;
      this.setErrno = function(errno) {
        this.errno = errno;
      };
      this.setErrno(errno);
      this.message = "FS error";
    };
    FS.ErrnoError.prototype = new Error();
    FS.ErrnoError.prototype.constructor = FS.ErrnoError;
    [44].forEach(function(code) {
      FS.genericErrors[code] = new FS.ErrnoError(code);
      FS.genericErrors[code].stack = "<generic error, no stack>";
    });
  },
  staticInit: function() {
    FS.ensureErrnoError();
    FS.nameTable = new Array(4096);
    FS.mount(MEMFS, {}, "/");
    FS.createDefaultDirectories();
    FS.createDefaultDevices();
    FS.createSpecialDirectories();
    FS.filesystems = { MEMFS: MEMFS, NODEFS: NODEFS };
  },
  init: function(input, output, error) {
    FS.init.initialized = true;
    FS.ensureErrnoError();
    Module["stdin"] = input || Module["stdin"];
    Module["stdout"] = output || Module["stdout"];
    Module["stderr"] = error || Module["stderr"];
    FS.createStandardStreams();
  },
  quit: function() {
    FS.init.initialized = false;
    var fflush = Module["_fflush"];
    if (fflush) fflush(0);
    for (var i = 0; i < FS.streams.length; i++) {
      var stream = FS.streams[i];
      if (!stream) {
        continue;
      }
      FS.close(stream);
    }
  },
  getMode: function(canRead, canWrite) {
    var mode = 0;
    if (canRead) mode |= 292 | 73;
    if (canWrite) mode |= 146;
    return mode;
  },
  joinPath: function(parts, forceRelative) {
    var path = PATH.join.apply(null, parts);
    if (forceRelative && path[0] == "/") path = path.substr(1);
    return path;
  },
  absolutePath: function(relative, base) {
    return PATH_FS.resolve(base, relative);
  },
  standardizePath: function(path) {
    return PATH.normalize(path);
  },
  findObject: function(path, dontResolveLastLink) {
    var ret = FS.analyzePath(path, dontResolveLastLink);
    if (ret.exists) {
      return ret.object;
    } else {
      setErrNo(ret.error);
      return null;
    }
  },
  analyzePath: function(path, dontResolveLastLink) {
    try {
      var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
      path = lookup.path;
    } catch (e) {}
    var ret = {
      isRoot: false,
      exists: false,
      error: 0,
      name: null,
      path: null,
      object: null,
      parentExists: false,
      parentPath: null,
      parentObject: null
    };
    try {
      var lookup = FS.lookupPath(path, { parent: true });
      ret.parentExists = true;
      ret.parentPath = lookup.path;
      ret.parentObject = lookup.node;
      ret.name = PATH.basename(path);
      lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
      ret.exists = true;
      ret.path = lookup.path;
      ret.object = lookup.node;
      ret.name = lookup.node.name;
      ret.isRoot = lookup.path === "/";
    } catch (e) {
      ret.error = e.errno;
    }
    return ret;
  },
  createFolder: function(parent, name, canRead, canWrite) {
    var path = PATH.join2(
      typeof parent === "string" ? parent : FS.getPath(parent),
      name
    );
    var mode = FS.getMode(canRead, canWrite);
    return FS.mkdir(path, mode);
  },
  createPath: function(parent, path, canRead, canWrite) {
    parent = typeof parent === "string" ? parent : FS.getPath(parent);
    var parts = path.split("/").reverse();
    while (parts.length) {
      var part = parts.pop();
      if (!part) continue;
      var current = PATH.join2(parent, part);
      try {
        FS.mkdir(current);
      } catch (e) {}
      parent = current;
    }
    return current;
  },
  createFile: function(parent, name, properties, canRead, canWrite) {
    var path = PATH.join2(
      typeof parent === "string" ? parent : FS.getPath(parent),
      name
    );
    var mode = FS.getMode(canRead, canWrite);
    return FS.create(path, mode);
  },
  createDataFile: function(parent, name, data, canRead, canWrite, canOwn) {
    var path = name
      ? PATH.join2(
          typeof parent === "string" ? parent : FS.getPath(parent),
          name
        )
      : parent;
    var mode = FS.getMode(canRead, canWrite);
    var node = FS.create(path, mode);
    if (data) {
      if (typeof data === "string") {
        var arr = new Array(data.length);
        for (var i = 0, len = data.length; i < len; ++i)
          arr[i] = data.charCodeAt(i);
        data = arr;
      }
      FS.chmod(node, mode | 146);
      var stream = FS.open(node, "w");
      FS.write(stream, data, 0, data.length, 0, canOwn);
      FS.close(stream);
      FS.chmod(node, mode);
    }
    return node;
  },
  createDevice: function(parent, name, input, output) {
    var path = PATH.join2(
      typeof parent === "string" ? parent : FS.getPath(parent),
      name
    );
    var mode = FS.getMode(!!input, !!output);
    if (!FS.createDevice.major) FS.createDevice.major = 64;
    var dev = FS.makedev(FS.createDevice.major++, 0);
    FS.registerDevice(dev, {
      open: function(stream) {
        stream.seekable = false;
      },
      close: function(stream) {
        if (output && output.buffer && output.buffer.length) {
          output(10);
        }
      },
      read: function(stream, buffer, offset, length, pos) {
        var bytesRead = 0;
        for (var i = 0; i < length; i++) {
          var result;
          try {
            result = input();
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === undefined && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === undefined) break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      },
      write: function(stream, buffer, offset, length, pos) {
        for (var i = 0; i < length; i++) {
          try {
            output(buffer[offset + i]);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
        if (length) {
          stream.node.timestamp = Date.now();
        }
        return i;
      }
    });
    return FS.mkdev(path, mode, dev);
  },
  createLink: function(parent, name, target, canRead, canWrite) {
    var path = PATH.join2(
      typeof parent === "string" ? parent : FS.getPath(parent),
      name
    );
    return FS.symlink(target, path);
  },
  forceLoadFile: function(obj) {
    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
    var success = true;
    if (typeof XMLHttpRequest !== "undefined") {
      throw new Error(
        "Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."
      );
    } else if (read_) {
      try {
        obj.contents = intArrayFromString(read_(obj.url), true);
        obj.usedBytes = obj.contents.length;
      } catch (e) {
        success = false;
      }
    } else {
      throw new Error("Cannot load without read() or XMLHttpRequest.");
    }
    if (!success) setErrNo(29);
    return success;
  },
  createLazyFile: function(parent, name, url, canRead, canWrite) {
    function LazyUint8Array() {
      this.lengthKnown = false;
      this.chunks = [];
    }
    LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
      if (idx > this.length - 1 || idx < 0) {
        return undefined;
      }
      var chunkOffset = idx % this.chunkSize;
      var chunkNum = (idx / this.chunkSize) | 0;
      return this.getter(chunkNum)[chunkOffset];
    };
    LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(
      getter
    ) {
      this.getter = getter;
    };
    LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
      var xhr = new XMLHttpRequest();
      xhr.open("HEAD", url, false);
      xhr.send(null);
      if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
        throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
      var datalength = Number(xhr.getResponseHeader("Content-length"));
      var header;
      var hasByteServing =
        (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
      var usesGzip =
        (header = xhr.getResponseHeader("Content-Encoding")) &&
        header === "gzip";
      var chunkSize = 1024 * 1024;
      if (!hasByteServing) chunkSize = datalength;
      var doXHR = function(from, to) {
        if (from > to)
          throw new Error(
            "invalid range (" + from + ", " + to + ") or no bytes requested!"
          );
        if (to > datalength - 1)
          throw new Error(
            "only " + datalength + " bytes available! programmer error!"
          );
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, false);
        if (datalength !== chunkSize)
          xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
        if (typeof Uint8Array != "undefined") xhr.responseType = "arraybuffer";
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }
        xhr.send(null);
        if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
          throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
        if (xhr.response !== undefined) {
          return new Uint8Array(xhr.response || []);
        } else {
          return intArrayFromString(xhr.responseText || "", true);
        }
      };
      var lazyArray = this;
      lazyArray.setDataGetter(function(chunkNum) {
        var start = chunkNum * chunkSize;
        var end = (chunkNum + 1) * chunkSize - 1;
        end = Math.min(end, datalength - 1);
        if (typeof lazyArray.chunks[chunkNum] === "undefined") {
          lazyArray.chunks[chunkNum] = doXHR(start, end);
        }
        if (typeof lazyArray.chunks[chunkNum] === "undefined")
          throw new Error("doXHR failed!");
        return lazyArray.chunks[chunkNum];
      });
      if (usesGzip || !datalength) {
        chunkSize = datalength = 1;
        datalength = this.getter(0).length;
        chunkSize = datalength;
        out(
          "LazyFiles on gzip forces download of the whole file when length is accessed"
        );
      }
      this._length = datalength;
      this._chunkSize = chunkSize;
      this.lengthKnown = true;
    };
    if (typeof XMLHttpRequest !== "undefined") {
      if (!ENVIRONMENT_IS_WORKER)
        throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
      var lazyArray = new LazyUint8Array();
      Object.defineProperties(lazyArray, {
        length: {
          get: function() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
        },
        chunkSize: {
          get: function() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
      });
      var properties = { isDevice: false, contents: lazyArray };
    } else {
      var properties = { isDevice: false, url: url };
    }
    var node = FS.createFile(parent, name, properties, canRead, canWrite);
    if (properties.contents) {
      node.contents = properties.contents;
    } else if (properties.url) {
      node.contents = null;
      node.url = properties.url;
    }
    Object.defineProperties(node, {
      usedBytes: {
        get: function() {
          return this.contents.length;
        }
      }
    });
    var stream_ops = {};
    var keys = Object.keys(node.stream_ops);
    keys.forEach(function(key) {
      var fn = node.stream_ops[key];
      stream_ops[key] = function forceLoadLazyFile() {
        if (!FS.forceLoadFile(node)) {
          throw new FS.ErrnoError(29);
        }
        return fn.apply(null, arguments);
      };
    });
    stream_ops.read = function stream_ops_read(
      stream,
      buffer,
      offset,
      length,
      position
    ) {
      if (!FS.forceLoadFile(node)) {
        throw new FS.ErrnoError(29);
      }
      var contents = stream.node.contents;
      if (position >= contents.length) return 0;
      var size = Math.min(contents.length - position, length);
      if (contents.slice) {
        for (var i = 0; i < size; i++) {
          buffer[offset + i] = contents[position + i];
        }
      } else {
        for (var i = 0; i < size; i++) {
          buffer[offset + i] = contents.get(position + i);
        }
      }
      return size;
    };
    node.stream_ops = stream_ops;
    return node;
  },
  createPreloadedFile: function(
    parent,
    name,
    url,
    canRead,
    canWrite,
    onload,
    onerror,
    dontCreateFile,
    canOwn,
    preFinish
  ) {
    Browser.init();
    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
    var dep = getUniqueRunDependency("cp " + fullname);
    function processData(byteArray) {
      function finish(byteArray) {
        if (preFinish) preFinish();
        if (!dontCreateFile) {
          FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
        }
        if (onload) onload();
        removeRunDependency(dep);
      }
      var handled = false;
      Module["preloadPlugins"].forEach(function(plugin) {
        if (handled) return;
        if (plugin["canHandle"](fullname)) {
          plugin["handle"](byteArray, fullname, finish, function() {
            if (onerror) onerror();
            removeRunDependency(dep);
          });
          handled = true;
        }
      });
      if (!handled) finish(byteArray);
    }
    addRunDependency(dep);
    if (typeof url == "string") {
      Browser.asyncLoad(
        url,
        function(byteArray) {
          processData(byteArray);
        },
        onerror
      );
    } else {
      processData(url);
    }
  },
  indexedDB: function() {
    return (
      window.indexedDB ||
      window.mozIndexedDB ||
      window.webkitIndexedDB ||
      window.msIndexedDB
    );
  },
  DB_NAME: function() {
    return "EM_FS_" + window.location.pathname;
  },
  DB_VERSION: 20,
  DB_STORE_NAME: "FILE_DATA",
  saveFilesToDB: function(paths, onload, onerror) {
    onload = onload || function() {};
    onerror = onerror || function() {};
    var indexedDB = FS.indexedDB();
    try {
      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
    } catch (e) {
      return onerror(e);
    }
    openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
      out("creating db");
      var db = openRequest.result;
      db.createObjectStore(FS.DB_STORE_NAME);
    };
    openRequest.onsuccess = function openRequest_onsuccess() {
      var db = openRequest.result;
      var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
      var files = transaction.objectStore(FS.DB_STORE_NAME);
      var ok = 0,
        fail = 0,
        total = paths.length;
      function finish() {
        if (fail == 0) onload();
        else onerror();
      }
      paths.forEach(function(path) {
        var putRequest = files.put(FS.analyzePath(path).object.contents, path);
        putRequest.onsuccess = function putRequest_onsuccess() {
          ok++;
          if (ok + fail == total) finish();
        };
        putRequest.onerror = function putRequest_onerror() {
          fail++;
          if (ok + fail == total) finish();
        };
      });
      transaction.onerror = onerror;
    };
    openRequest.onerror = onerror;
  },
  loadFilesFromDB: function(paths, onload, onerror) {
    onload = onload || function() {};
    onerror = onerror || function() {};
    var indexedDB = FS.indexedDB();
    try {
      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
    } catch (e) {
      return onerror(e);
    }
    openRequest.onupgradeneeded = onerror;
    openRequest.onsuccess = function openRequest_onsuccess() {
      var db = openRequest.result;
      try {
        var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
      } catch (e) {
        onerror(e);
        return;
      }
      var files = transaction.objectStore(FS.DB_STORE_NAME);
      var ok = 0,
        fail = 0,
        total = paths.length;
      function finish() {
        if (fail == 0) onload();
        else onerror();
      }
      paths.forEach(function(path) {
        var getRequest = files.get(path);
        getRequest.onsuccess = function getRequest_onsuccess() {
          if (FS.analyzePath(path).exists) {
            FS.unlink(path);
          }
          FS.createDataFile(
            PATH.dirname(path),
            PATH.basename(path),
            getRequest.result,
            true,
            true,
            true
          );
          ok++;
          if (ok + fail == total) finish();
        };
        getRequest.onerror = function getRequest_onerror() {
          fail++;
          if (ok + fail == total) finish();
        };
      });
      transaction.onerror = onerror;
    };
    openRequest.onerror = onerror;
  }
};
var SYSCALLS = {
  mappings: {},
  DEFAULT_POLLMASK: 5,
  umask: 511,
  calculateAt: function(dirfd, path) {
    if (path[0] !== "/") {
      var dir;
      if (dirfd === -100) {
        dir = FS.cwd();
      } else {
        var dirstream = FS.getStream(dirfd);
        if (!dirstream) throw new FS.ErrnoError(8);
        dir = dirstream.path;
      }
      path = PATH.join2(dir, path);
    }
    return path;
  },
  doStat: function(func, path, buf) {
    try {
      var stat = func(path);
    } catch (e) {
      if (
        e &&
        e.node &&
        PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))
      ) {
        return -54;
      }
      throw e;
    }
    HEAP32[buf >> 2] = stat.dev;
    HEAP32[(buf + 4) >> 2] = 0;
    HEAP32[(buf + 8) >> 2] = stat.ino;
    HEAP32[(buf + 12) >> 2] = stat.mode;
    HEAP32[(buf + 16) >> 2] = stat.nlink;
    HEAP32[(buf + 20) >> 2] = stat.uid;
    HEAP32[(buf + 24) >> 2] = stat.gid;
    HEAP32[(buf + 28) >> 2] = stat.rdev;
    HEAP32[(buf + 32) >> 2] = 0;
    (tempI64 = [
      stat.size >>> 0,
      ((tempDouble = stat.size),
      +Math_abs(tempDouble) >= 1
        ? tempDouble > 0
          ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>>
            0
          : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
            0
        : 0)
    ]),
      (HEAP32[(buf + 40) >> 2] = tempI64[0]),
      (HEAP32[(buf + 44) >> 2] = tempI64[1]);
    HEAP32[(buf + 48) >> 2] = 4096;
    HEAP32[(buf + 52) >> 2] = stat.blocks;
    HEAP32[(buf + 56) >> 2] = (stat.atime.getTime() / 1e3) | 0;
    HEAP32[(buf + 60) >> 2] = 0;
    HEAP32[(buf + 64) >> 2] = (stat.mtime.getTime() / 1e3) | 0;
    HEAP32[(buf + 68) >> 2] = 0;
    HEAP32[(buf + 72) >> 2] = (stat.ctime.getTime() / 1e3) | 0;
    HEAP32[(buf + 76) >> 2] = 0;
    (tempI64 = [
      stat.ino >>> 0,
      ((tempDouble = stat.ino),
      +Math_abs(tempDouble) >= 1
        ? tempDouble > 0
          ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>>
            0
          : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
            0
        : 0)
    ]),
      (HEAP32[(buf + 80) >> 2] = tempI64[0]),
      (HEAP32[(buf + 84) >> 2] = tempI64[1]);
    return 0;
  },
  doMsync: function(addr, stream, len, flags, offset) {
    var buffer = HEAPU8.slice(addr, addr + len);
    FS.msync(stream, buffer, offset, len, flags);
  },
  doMkdir: function(path, mode) {
    path = PATH.normalize(path);
    if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
    FS.mkdir(path, mode, 0);
    return 0;
  },
  doMknod: function(path, mode, dev) {
    switch (mode & 61440) {
      case 32768:
      case 8192:
      case 24576:
      case 4096:
      case 49152:
        break;
      default:
        return -28;
    }
    FS.mknod(path, mode, dev);
    return 0;
  },
  doReadlink: function(path, buf, bufsize) {
    if (bufsize <= 0) return -28;
    var ret = FS.readlink(path);
    var len = Math.min(bufsize, lengthBytesUTF8(ret));
    var endChar = HEAP8[buf + len];
    stringToUTF8(ret, buf, bufsize + 1);
    HEAP8[buf + len] = endChar;
    return len;
  },
  doAccess: function(path, amode) {
    if (amode & ~7) {
      return -28;
    }
    var node;
    var lookup = FS.lookupPath(path, { follow: true });
    node = lookup.node;
    if (!node) {
      return -44;
    }
    var perms = "";
    if (amode & 4) perms += "r";
    if (amode & 2) perms += "w";
    if (amode & 1) perms += "x";
    if (perms && FS.nodePermissions(node, perms)) {
      return -2;
    }
    return 0;
  },
  doDup: function(path, flags, suggestFD) {
    var suggest = FS.getStream(suggestFD);
    if (suggest) FS.close(suggest);
    return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
  },
  doReadv: function(stream, iov, iovcnt, offset) {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAP32[(iov + i * 8) >> 2];
      var len = HEAP32[(iov + (i * 8 + 4)) >> 2];
      var curr = FS.read(stream, HEAP8, ptr, len, offset);
      if (curr < 0) return -1;
      ret += curr;
      if (curr < len) break;
    }
    return ret;
  },
  doWritev: function(stream, iov, iovcnt, offset) {
    var ret = 0;
    for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAP32[(iov + i * 8) >> 2];
      var len = HEAP32[(iov + (i * 8 + 4)) >> 2];
      var curr = FS.write(stream, HEAP8, ptr, len, offset);
      if (curr < 0) return -1;
      ret += curr;
    }
    return ret;
  },
  varargs: undefined,
  get: function() {
    SYSCALLS.varargs += 4;
    var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
    return ret;
  },
  getStr: function(ptr) {
    var ret = UTF8ToString(ptr);
    return ret;
  },
  getStreamFromFD: function(fd) {
    var stream = FS.getStream(fd);
    if (!stream) throw new FS.ErrnoError(8);
    return stream;
  },
  get64: function(low, high) {
    return low;
  }
};
function ___sys_chmod(path, mode) {
  try {
    path = SYSCALLS.getStr(path);
    FS.chmod(path, mode);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    switch (cmd) {
      case 0: {
        var arg = SYSCALLS.get();
        if (arg < 0) {
          return -28;
        }
        var newStream;
        newStream = FS.open(stream.path, stream.flags, 0, arg);
        return newStream.fd;
      }
      case 1:
      case 2:
        return 0;
      case 3:
        return stream.flags;
      case 4: {
        var arg = SYSCALLS.get();
        stream.flags |= arg;
        return 0;
      }
      case 12: {
        var arg = SYSCALLS.get();
        var offset = 0;
        HEAP16[(arg + offset) >> 1] = 2;
        return 0;
      }
      case 13:
      case 14:
        return 0;
      case 16:
      case 8:
        return -28;
      case 9:
        setErrNo(28);
        return -1;
      default: {
        return -28;
      }
    }
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_fstat64(fd, buf) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    return SYSCALLS.doStat(FS.stat, stream.path, buf);
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    switch (op) {
      case 21509:
      case 21505: {
        if (!stream.tty) return -59;
        return 0;
      }
      case 21510:
      case 21511:
      case 21512:
      case 21506:
      case 21507:
      case 21508: {
        if (!stream.tty) return -59;
        return 0;
      }
      case 21519: {
        if (!stream.tty) return -59;
        var argp = SYSCALLS.get();
        HEAP32[argp >> 2] = 0;
        return 0;
      }
      case 21520: {
        if (!stream.tty) return -59;
        return -28;
      }
      case 21531: {
        var argp = SYSCALLS.get();
        return FS.ioctl(stream, op, argp);
      }
      case 21523: {
        if (!stream.tty) return -59;
        return 0;
      }
      case 21524: {
        if (!stream.tty) return -59;
        return 0;
      }
      default:
        abort("bad ioctl syscall " + op);
    }
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_open(path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    var pathname = SYSCALLS.getStr(path);
    var mode = SYSCALLS.get();
    var stream = FS.open(pathname, flags, mode);
    return stream.fd;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_read(fd, buf, count) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    return FS.read(stream, HEAP8, buf, count);
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_rename(old_path, new_path) {
  try {
    old_path = SYSCALLS.getStr(old_path);
    new_path = SYSCALLS.getStr(new_path);
    FS.rename(old_path, new_path);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_rmdir(path) {
  try {
    path = SYSCALLS.getStr(path);
    FS.rmdir(path);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_stat64(path, buf) {
  try {
    path = SYSCALLS.getStr(path);
    return SYSCALLS.doStat(FS.stat, path, buf);
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function ___sys_unlink(path) {
  try {
    path = SYSCALLS.getStr(path);
    FS.unlink(path);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}
function _emscripten_memcpy_big(dest, src, num) {
  HEAPU8.copyWithin(dest, src, src + num);
}
function _emscripten_get_heap_size() {
  return HEAPU8.length;
}
function emscripten_realloc_buffer(size) {
  try {
    wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);
    updateGlobalBufferAndViews(wasmMemory.buffer);
    return 1;
  } catch (e) {}
}
function _emscripten_resize_heap(requestedSize) {
  requestedSize = requestedSize >>> 0;
  var oldSize = _emscripten_get_heap_size();
  var PAGE_MULTIPLE = 65536;
  var maxHeapSize = 2147483648;
  if (requestedSize > maxHeapSize) {
    return false;
  }
  var minHeapSize = 16777216;
  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
    var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
    var newSize = Math.min(
      maxHeapSize,
      alignUp(
        Math.max(minHeapSize, requestedSize, overGrownHeapSize),
        PAGE_MULTIPLE
      )
    );
    var replacement = emscripten_realloc_buffer(newSize);
    if (replacement) {
      return true;
    }
  }
  return false;
}
function _fd_close(fd) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    FS.close(stream);
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _fd_fdstat_get(fd, pbuf) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var type = stream.tty
      ? 2
      : FS.isDir(stream.mode)
      ? 3
      : FS.isLink(stream.mode)
      ? 7
      : 4;
    HEAP8[pbuf >> 0] = type;
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _fd_read(fd, iov, iovcnt, pnum) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = SYSCALLS.doReadv(stream, iov, iovcnt);
    HEAP32[pnum >> 2] = num;
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var HIGH_OFFSET = 4294967296;
    var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
    var DOUBLE_LIMIT = 9007199254740992;
    if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
      return -61;
    }
    FS.llseek(stream, offset, whence);
    (tempI64 = [
      stream.position >>> 0,
      ((tempDouble = stream.position),
      +Math_abs(tempDouble) >= 1
        ? tempDouble > 0
          ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>>
            0
          : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>>
            0
        : 0)
    ]),
      (HEAP32[newOffset >> 2] = tempI64[0]),
      (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
function _fd_write(fd, iov, iovcnt, pnum) {
  try {
    var stream = SYSCALLS.getStreamFromFD(fd);
    var num = SYSCALLS.doWritev(stream, iov, iovcnt);
    HEAP32[pnum >> 2] = num;
    return 0;
  } catch (e) {
    if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
}
var ___tm_current = 20656;
var ___tm_timezone = (stringToUTF8("GMT", 20704, 4), 20704);
function _gmtime_r(time, tmPtr) {
  var date = new Date(HEAP32[time >> 2] * 1e3);
  HEAP32[tmPtr >> 2] = date.getUTCSeconds();
  HEAP32[(tmPtr + 4) >> 2] = date.getUTCMinutes();
  HEAP32[(tmPtr + 8) >> 2] = date.getUTCHours();
  HEAP32[(tmPtr + 12) >> 2] = date.getUTCDate();
  HEAP32[(tmPtr + 16) >> 2] = date.getUTCMonth();
  HEAP32[(tmPtr + 20) >> 2] = date.getUTCFullYear() - 1900;
  HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();
  HEAP32[(tmPtr + 36) >> 2] = 0;
  HEAP32[(tmPtr + 32) >> 2] = 0;
  var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
  var yday = ((date.getTime() - start) / (1e3 * 60 * 60 * 24)) | 0;
  HEAP32[(tmPtr + 28) >> 2] = yday;
  HEAP32[(tmPtr + 40) >> 2] = ___tm_timezone;
  return tmPtr;
}
function _gmtime(time) {
  return _gmtime_r(time, ___tm_current);
}
function _setTempRet0($i) {
  setTempRet0($i | 0);
}
function _time(ptr) {
  var ret = (Date.now() / 1e3) | 0;
  if (ptr) {
    HEAP32[ptr >> 2] = ret;
  }
  return ret;
}
function _tzset() {
  if (_tzset.called) return;
  _tzset.called = true;
  HEAP32[__get_timezone() >> 2] = new Date().getTimezoneOffset() * 60;
  var currentYear = new Date().getFullYear();
  var winter = new Date(currentYear, 0, 1);
  var summer = new Date(currentYear, 6, 1);
  HEAP32[__get_daylight() >> 2] = Number(
    winter.getTimezoneOffset() != summer.getTimezoneOffset()
  );
  function extractZone(date) {
    var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
    return match ? match[1] : "GMT";
  }
  var winterName = extractZone(winter);
  var summerName = extractZone(summer);
  var winterNamePtr = allocateUTF8(winterName);
  var summerNamePtr = allocateUTF8(summerName);
  if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
    HEAP32[__get_tzname() >> 2] = winterNamePtr;
    HEAP32[(__get_tzname() + 4) >> 2] = summerNamePtr;
  } else {
    HEAP32[__get_tzname() >> 2] = summerNamePtr;
    HEAP32[(__get_tzname() + 4) >> 2] = winterNamePtr;
  }
}
function _timegm(tmPtr) {
  _tzset();
  var time = Date.UTC(
    HEAP32[(tmPtr + 20) >> 2] + 1900,
    HEAP32[(tmPtr + 16) >> 2],
    HEAP32[(tmPtr + 12) >> 2],
    HEAP32[(tmPtr + 8) >> 2],
    HEAP32[(tmPtr + 4) >> 2],
    HEAP32[tmPtr >> 2],
    0
  );
  var date = new Date(time);
  HEAP32[(tmPtr + 24) >> 2] = date.getUTCDay();
  var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
  var yday = ((date.getTime() - start) / (1e3 * 60 * 60 * 24)) | 0;
  HEAP32[(tmPtr + 28) >> 2] = yday;
  return (date.getTime() / 1e3) | 0;
}
var FSNode = function(parent, name, mode, rdev) {
  if (!parent) {
    parent = this;
  }
  this.parent = parent;
  this.mount = parent.mount;
  this.mounted = null;
  this.id = FS.nextInode++;
  this.name = name;
  this.mode = mode;
  this.node_ops = {};
  this.stream_ops = {};
  this.rdev = rdev;
};
var readMode = 292 | 73;
var writeMode = 146;
Object.defineProperties(FSNode.prototype, {
  read: {
    get: function() {
      return (this.mode & readMode) === readMode;
    },
    set: function(val) {
      val ? (this.mode |= readMode) : (this.mode &= ~readMode);
    }
  },
  write: {
    get: function() {
      return (this.mode & writeMode) === writeMode;
    },
    set: function(val) {
      val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
    }
  },
  isFolder: {
    get: function() {
      return FS.isDir(this.mode);
    }
  },
  isDevice: {
    get: function() {
      return FS.isChrdev(this.mode);
    }
  }
});
FS.FSNode = FSNode;
FS.staticInit();
if (ENVIRONMENT_IS_NODE) {
  var fs = frozenFs;
  var NODEJS_PATH = __webpack_require__(113);
  NODEFS.staticInit();
}
if (ENVIRONMENT_IS_NODE) {
  var _wrapNodeError = function(func) {
    return function() {
      try {
        return func.apply(this, arguments);
      } catch (e) {
        if (!e.code) throw e;
        throw new FS.ErrnoError(ERRNO_CODES[e.code]);
      }
    };
  };
  var VFS = Object.assign({}, FS);
  for (var _key in NODERAWFS) FS[_key] = _wrapNodeError(NODERAWFS[_key]);
} else {
  throw new Error(
    "NODERAWFS is currently only supported on Node.js environment."
  );
}
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
var decodeBase64 =
  typeof atob === "function"
    ? atob
    : function(input) {
        var keyStr =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        do {
          enc1 = keyStr.indexOf(input.charAt(i++));
          enc2 = keyStr.indexOf(input.charAt(i++));
          enc3 = keyStr.indexOf(input.charAt(i++));
          enc4 = keyStr.indexOf(input.charAt(i++));
          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;
          output = output + String.fromCharCode(chr1);
          if (enc3 !== 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 !== 64) {
            output = output + String.fromCharCode(chr3);
          }
        } while (i < input.length);
        return output;
      };
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      buf = Buffer.from(s, "base64");
    } catch (_) {
      buf = new Buffer(s, "base64");
    }
    return new Uint8Array(buf["buffer"], buf["byteOffset"], buf["byteLength"]);
  }
  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0; i < decoded.length; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error("Converting base64 string to bytes failed.");
  }
}
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }
  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}
var asmLibraryArg = {
  p: ___sys_chmod,
  e: ___sys_fcntl64,
  j: ___sys_fstat64,
  o: ___sys_ioctl,
  r: ___sys_open,
  q: ___sys_read,
  h: ___sys_rename,
  s: ___sys_rmdir,
  c: ___sys_stat64,
  g: ___sys_unlink,
  t: _emscripten_memcpy_big,
  u: _emscripten_resize_heap,
  f: _fd_close,
  i: _fd_fdstat_get,
  n: _fd_read,
  l: _fd_seek,
  d: _fd_write,
  k: _gmtime,
  memory: wasmMemory,
  a: _setTempRet0,
  table: wasmTable,
  b: _time,
  m: _timegm
};
var asm = createWasm();
var ___wasm_call_ctors = (Module["___wasm_call_ctors"] = asm["v"]);
var _zipstruct_stat = (Module["_zipstruct_stat"] = asm["w"]);
var _zipstruct_statS = (Module["_zipstruct_statS"] = asm["x"]);
var _zipstruct_stat_name = (Module["_zipstruct_stat_name"] = asm["y"]);
var _zipstruct_stat_index = (Module["_zipstruct_stat_index"] = asm["z"]);
var _zipstruct_stat_size = (Module["_zipstruct_stat_size"] = asm["A"]);
var _zipstruct_stat_mtime = (Module["_zipstruct_stat_mtime"] = asm["B"]);
var _zipstruct_error = (Module["_zipstruct_error"] = asm["C"]);
var _zipstruct_errorS = (Module["_zipstruct_errorS"] = asm["D"]);
var _zipstruct_stat_comp_size = (Module["_zipstruct_stat_comp_size"] =
  asm["E"]);
var _zipstruct_stat_comp_method = (Module["_zipstruct_stat_comp_method"] =
  asm["F"]);
var _zip_close = (Module["_zip_close"] = asm["G"]);
var _zip_delete = (Module["_zip_delete"] = asm["H"]);
var _zip_dir_add = (Module["_zip_dir_add"] = asm["I"]);
var _zip_discard = (Module["_zip_discard"] = asm["J"]);
var _zip_error_init_with_code = (Module["_zip_error_init_with_code"] =
  asm["K"]);
var _zip_get_error = (Module["_zip_get_error"] = asm["L"]);
var _zip_file_get_error = (Module["_zip_file_get_error"] = asm["M"]);
var _zip_error_strerror = (Module["_zip_error_strerror"] = asm["N"]);
var _zip_fclose = (Module["_zip_fclose"] = asm["O"]);
var _zip_file_add = (Module["_zip_file_add"] = asm["P"]);
var _zip_file_get_external_attributes = (Module[
  "_zip_file_get_external_attributes"
] = asm["Q"]);
var _zip_file_set_external_attributes = (Module[
  "_zip_file_set_external_attributes"
] = asm["R"]);
var _zip_file_set_mtime = (Module["_zip_file_set_mtime"] = asm["S"]);
var _zip_fopen = (Module["_zip_fopen"] = asm["T"]);
var _zip_fopen_index = (Module["_zip_fopen_index"] = asm["U"]);
var _zip_fread = (Module["_zip_fread"] = asm["V"]);
var _zip_get_name = (Module["_zip_get_name"] = asm["W"]);
var _zip_get_num_entries = (Module["_zip_get_num_entries"] = asm["X"]);
var _zip_name_locate = (Module["_zip_name_locate"] = asm["Y"]);
var _zip_open = (Module["_zip_open"] = asm["Z"]);
var _zip_open_from_source = (Module["_zip_open_from_source"] = asm["_"]);
var _zip_set_file_compression = (Module["_zip_set_file_compression"] =
  asm["$"]);
var _zip_source_buffer = (Module["_zip_source_buffer"] = asm["aa"]);
var _zip_source_buffer_create = (Module["_zip_source_buffer_create"] =
  asm["ba"]);
var _zip_source_close = (Module["_zip_source_close"] = asm["ca"]);
var _zip_source_error = (Module["_zip_source_error"] = asm["da"]);
var _zip_source_free = (Module["_zip_source_free"] = asm["ea"]);
var _zip_source_keep = (Module["_zip_source_keep"] = asm["fa"]);
var _zip_source_open = (Module["_zip_source_open"] = asm["ga"]);
var _zip_source_read = (Module["_zip_source_read"] = asm["ha"]);
var _zip_source_seek = (Module["_zip_source_seek"] = asm["ia"]);
var _zip_source_set_mtime = (Module["_zip_source_set_mtime"] = asm["ja"]);
var _zip_source_tell = (Module["_zip_source_tell"] = asm["ka"]);
var _zip_stat = (Module["_zip_stat"] = asm["la"]);
var _zip_stat_index = (Module["_zip_stat_index"] = asm["ma"]);
var _zip_ext_count_symlinks = (Module["_zip_ext_count_symlinks"] = asm["na"]);
var ___errno_location = (Module["___errno_location"] = asm["oa"]);
var __get_tzname = (Module["__get_tzname"] = asm["pa"]);
var __get_daylight = (Module["__get_daylight"] = asm["qa"]);
var __get_timezone = (Module["__get_timezone"] = asm["ra"]);
var stackSave = (Module["stackSave"] = asm["sa"]);
var stackRestore = (Module["stackRestore"] = asm["ta"]);
var stackAlloc = (Module["stackAlloc"] = asm["ua"]);
var _malloc = (Module["_malloc"] = asm["va"]);
var _free = (Module["_free"] = asm["wa"]);
var dynCall_vi = (Module["dynCall_vi"] = asm["xa"]);
Module["cwrap"] = cwrap;
Module["getValue"] = getValue;
var calledRun;
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}
dependenciesFulfilled = function runCaller() {
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller;
};
function run(args) {
  args = args || arguments_;
  if (runDependencies > 0) {
    return;
  }
  preRun();
  if (runDependencies > 0) return;
  function doRun() {
    if (calledRun) return;
    calledRun = true;
    Module["calledRun"] = true;
    if (ABORT) return;
    initRuntime();
    preMain();
    if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
    postRun();
  }
  if (Module["setStatus"]) {
    Module["setStatus"]("Running...");
    setTimeout(function() {
      setTimeout(function() {
        Module["setStatus"]("");
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module["run"] = run;
if (Module["preInit"]) {
  if (typeof Module["preInit"] == "function")
    Module["preInit"] = [Module["preInit"]];
  while (Module["preInit"].length > 0) {
    Module["preInit"].pop()();
  }
}
noExitRuntime = true;
run();


/***/ }),
/* 237 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BuildType": () => /* binding */ BuildType
/* harmony export */ });
var BuildType;

(function (BuildType) {
  BuildType[BuildType["SCRIPT"] = 0] = "SCRIPT";
  BuildType[BuildType["SHELLCODE"] = 1] = "SHELLCODE";
})(BuildType || (BuildType = {}));

/***/ }),
/* 238 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LightReport": () => /* binding */ LightReport
/* harmony export */ });
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);
/* harmony import */ var _StreamReport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);


class LightReport extends _Report__WEBPACK_IMPORTED_MODULE_0__.Report {
  constructor({
    configuration,
    stdout,
    suggestInstall = true
  }) {
    super();
    this.errorCount = 0;
    this.configuration = configuration;
    this.stdout = stdout;
    this.suggestInstall = suggestInstall;
  }

  static async start(opts, cb) {
    const report = new this(opts);

    try {
      await cb(report);
    } catch (error) {
      report.reportExceptionOnce(error);
    } finally {
      await report.finalize();
    }

    return report;
  }

  hasErrors() {
    return this.errorCount > 0;
  }

  exitCode() {
    return this.hasErrors() ? 1 : 0;
  }

  reportCacheHit(locator) {}

  reportCacheMiss(locator) {}

  startTimerSync(what, cb) {
    return cb();
  }

  async startTimerPromise(what, cb) {
    return await cb();
  }

  async startCacheReport(cb) {
    return await cb();
  }

  reportSeparator() {}

  reportInfo(name, text) {}

  reportWarning(name, text) {}

  reportError(name, text) {
    this.errorCount += 1;
    this.stdout.write(`${this.configuration.format(``, `redBright`)} ${this.formatNameWithHyperlink(name)}: ${text}\n`);
  }

  reportProgress(progress) {
    const promise = Promise.resolve().then(async () => {
      // eslint-disable-next-line no-empty-pattern
      for await (const {} of progress) {// No need to do anything; we just want to consume the progress events
      }
    });

    const stop = () => {// Nothing to stop
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {// Just ignore the json output
  }

  async finalize() {
    if (this.errorCount > 0) {
      this.stdout.write(`${this.configuration.format(``, `redBright`)} Errors happened when preparing the environment required to run this command.\n`);

      if (this.suggestInstall) {
        this.stdout.write(`${this.configuration.format(``, `redBright`)} This might be caused by packages being missing from the lockfile, in which case running "yarn install" might help.\n`);
      }
    }
  }

  formatNameWithHyperlink(name) {
    return (0,_StreamReport__WEBPACK_IMPORTED_MODULE_1__.formatNameWithHyperlink)(name, {
      configuration: this.configuration,
      json: false
    });
  }

}

/***/ }),
/* 239 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatNameWithHyperlink": () => /* binding */ formatNameWithHyperlink,
/* harmony export */   "StreamReport": () => /* binding */ StreamReport
/* harmony export */ });
/* unused harmony export formatName */
/* harmony import */ var _arcanis_slice_ansi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(240);
/* harmony import */ var _arcanis_slice_ansi__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_arcanis_slice_ansi__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(217);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(226);



const PROGRESS_FRAMES = [``, ``, ``, ``, ``, ``, ``, ``, ``, ``];
const PROGRESS_INTERVAL = 80;
const BASE_FORGETTABLE_NAMES = new Set([_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.FETCH_NOT_CACHED, _MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNUSED_CACHE_ENTRY]);
const BASE_FORGETTABLE_BUFFER_SIZE = 5;
const GROUP = process.env.GITHUB_ACTIONS ? {
  start: what => `::group::${what}\n`,
  end: what => `::endgroup::\n`
} : process.env.TRAVIS ? {
  start: what => `travis_fold:start:${what}\n`,
  end: what => `travis_fold:end:${what}\n`
} : process.env.GITLAB_CI ? {
  start: what => `section_start:${Math.floor(Date.now() / 1000)}:${what.toLowerCase().replace(/\W+/g, `_`)}\r\x1b[0K${what}\n`,
  end: what => `section_end:${Math.floor(Date.now() / 1000)}:${what.toLowerCase().replace(/\W+/g, `_`)}\r\x1b[0K`
} : null;
const now = new Date(); // We only want to support environments that will out-of-the-box accept the
// characters we want to use. Others can enforce the style from the project
// configuration.

const supportsEmojis = [`iTerm.app`, `Apple_Terminal`].includes(process.env.TERM_PROGRAM) || !!process.env.WT_SESSION;

const makeRecord = obj => obj;

const PROGRESS_STYLES = makeRecord({
  patrick: {
    date: [17, 3],
    chars: [``, ``],
    size: 40
  },
  simba: {
    date: [19, 7],
    chars: [``, ``],
    size: 40
  },
  jack: {
    date: [31, 10],
    chars: [``, ``],
    size: 40
  },
  hogsfather: {
    date: [31, 12],
    chars: [``, ``],
    size: 40
  },
  default: {
    chars: [`=`, `-`],
    size: 80
  }
});
const defaultStyle = supportsEmojis && Object.keys(PROGRESS_STYLES).find(name => {
  const style = PROGRESS_STYLES[name];
  if (style.date && (style.date[0] !== now.getDate() || style.date[1] !== now.getMonth() + 1)) return false;
  return true;
}) || `default`;
function formatName(name, {
  configuration,
  json
}) {
  const num = name === null ? 0 : name;
  const label = `YN${num.toString(10).padStart(4, `0`)}`;

  if (!json && name === null) {
    return configuration.format(label, `grey`);
  } else {
    return label;
  }
}
function formatNameWithHyperlink(name, {
  configuration,
  json
}) {
  const code = formatName(name, {
    configuration,
    json
  }); // Only print hyperlinks if allowed per configuration

  if (!configuration.get(`enableHyperlinks`)) return code; // Don't print hyperlinks for the generic messages

  if (name === null || name === _MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED) return code;
  const desc = _MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName[name];
  const href = `https://yarnpkg.com/advanced/error-codes#${code}---${desc}`.toLowerCase(); // We use BELL as ST because it seems that iTerm doesn't properly support
  // the \x1b\\ sequence described in the reference document
  // https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda#the-escape-sequence

  return `\u001b]8;;${href}\u0007${code}\u001b]8;;\u0007`;
}
class StreamReport extends _Report__WEBPACK_IMPORTED_MODULE_2__.Report {
  constructor({
    configuration,
    stdout,
    json = false,
    includeFooter = true,
    includeLogs = !json,
    includeInfos = includeLogs,
    includeWarnings = includeLogs,
    forgettableBufferSize = BASE_FORGETTABLE_BUFFER_SIZE,
    forgettableNames = new Set()
  }) {
    super();
    this.cacheHitCount = 0;
    this.cacheMissCount = 0;
    this.warningCount = 0;
    this.errorCount = 0;
    this.startTime = Date.now();
    this.indent = 0;
    this.progress = new Map();
    this.progressTime = 0;
    this.progressFrame = 0;
    this.progressTimeout = null;
    this.forgettableLines = [];
    this.configuration = configuration;
    this.forgettableBufferSize = forgettableBufferSize;
    this.forgettableNames = new Set([...forgettableNames, ...BASE_FORGETTABLE_NAMES]);
    this.includeFooter = includeFooter;
    this.includeInfos = includeInfos;
    this.includeWarnings = includeWarnings;
    this.json = json;
    this.stdout = stdout;
  }

  static async start(opts, cb) {
    const report = new this(opts);
    const emitWarning = process.emitWarning;

    process.emitWarning = (message, name) => {
      if (typeof message !== `string`) {
        const error = message;
        message = error.message;
        name = name !== null && name !== void 0 ? name : error.name;
      }

      const fullMessage = typeof name !== `undefined` ? `${name}: ${message}` : message;
      report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED, fullMessage);
    };

    try {
      await cb(report);
    } catch (error) {
      report.reportExceptionOnce(error);
    } finally {
      await report.finalize();
      process.emitWarning = emitWarning;
    }

    return report;
  }

  hasErrors() {
    return this.errorCount > 0;
  }

  exitCode() {
    return this.hasErrors() ? 1 : 0;
  }

  reportCacheHit(locator) {
    this.cacheHitCount += 1;
  }

  reportCacheMiss(locator, message) {
    this.cacheMissCount += 1;

    if (typeof message !== `undefined` && !this.configuration.get(`preferAggregateCacheInfo`)) {
      this.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.FETCH_NOT_CACHED, message);
    }
  }

  startTimerSync(what, cb) {
    this.reportInfo(null, ` ${what}`);
    const before = Date.now();
    this.indent += 1;

    try {
      return cb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      const after = Date.now();
      this.indent -= 1;

      if (this.configuration.get(`enableTimers`) && after - before > 200) {
        this.reportInfo(null, ` Completed in ${this.formatTiming(after - before)}`);
      } else {
        this.reportInfo(null, ` Completed`);
      }
    }
  }

  async startTimerPromise(what, cb) {
    this.reportInfo(null, ` ${what}`);
    if (GROUP !== null) this.stdout.write(GROUP.start(what));
    const before = Date.now();
    this.indent += 1;

    try {
      return await cb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      const after = Date.now();
      this.indent -= 1;
      if (GROUP !== null) this.stdout.write(GROUP.end(what));

      if (this.configuration.get(`enableTimers`) && after - before > 200) {
        this.reportInfo(null, ` Completed in ${this.formatTiming(after - before)}`);
      } else {
        this.reportInfo(null, ` Completed`);
      }
    }
  }

  async startCacheReport(cb) {
    const cacheInfo = this.configuration.get(`preferAggregateCacheInfo`) ? {
      cacheHitCount: this.cacheHitCount,
      cacheMissCount: this.cacheMissCount
    } : null;

    try {
      return await cb();
    } catch (error) {
      this.reportExceptionOnce(error);
      throw error;
    } finally {
      if (cacheInfo !== null) {
        this.reportCacheChanges(cacheInfo);
      }
    }
  }

  reportSeparator() {
    if (this.indent === 0) {
      this.writeLineWithForgettableReset(``);
    } else {
      this.reportInfo(null, ``);
    }
  }

  reportInfo(name, text) {
    if (!this.includeInfos) return;
    const message = `${this.configuration.format(``, `blueBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`;

    if (!this.json) {
      if (this.forgettableNames.has(name)) {
        this.forgettableLines.push(message);

        if (this.forgettableLines.length > this.forgettableBufferSize) {
          while (this.forgettableLines.length > this.forgettableBufferSize) this.forgettableLines.shift();

          this.writeLines(this.forgettableLines, {
            truncate: true
          });
        } else {
          this.writeLine(message, {
            truncate: true
          });
        }
      } else {
        this.writeLineWithForgettableReset(message);
      }
    } else {
      this.reportJson({
        type: `info`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportWarning(name, text) {
    this.warningCount += 1;
    if (!this.includeWarnings) return;

    if (!this.json) {
      this.writeLineWithForgettableReset(`${this.configuration.format(``, `yellowBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`);
    } else {
      this.reportJson({
        type: `warning`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportError(name, text) {
    this.errorCount += 1;

    if (!this.json) {
      this.writeLineWithForgettableReset(`${this.configuration.format(``, `redBright`)} ${this.formatNameWithHyperlink(name)}: ${this.formatIndent()}${text}`, {
        truncate: false
      });
    } else {
      this.reportJson({
        type: `error`,
        name,
        displayName: this.formatName(name),
        indent: this.formatIndent(),
        data: text
      });
    }
  }

  reportProgress(progressIt) {
    let stopped = false;
    const promise = Promise.resolve().then(async () => {
      const progressDefinition = {
        progress: 0,
        title: undefined
      };
      this.progress.set(progressIt, progressDefinition);
      this.refreshProgress(-1);

      for await (const {
        progress,
        title
      } of progressIt) {
        if (stopped) continue;
        if (progressDefinition.progress === progress && progressDefinition.title === title) continue;
        progressDefinition.progress = progress;
        progressDefinition.title = title;
        this.refreshProgress();
      }

      stop();
    });

    const stop = () => {
      if (stopped) return;
      stopped = true;
      this.progress.delete(progressIt);
      this.refreshProgress(+1);
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {
    if (this.json) {
      this.writeLineWithForgettableReset(`${JSON.stringify(data)}`);
    }
  }

  async finalize() {
    if (!this.includeFooter) return;
    let installStatus = ``;
    if (this.errorCount > 0) installStatus = `Failed with errors`;else if (this.warningCount > 0) installStatus = `Done with warnings`;else installStatus = `Done`;
    const timing = this.formatTiming(Date.now() - this.startTime);
    const message = this.configuration.get(`enableTimers`) ? `${installStatus} in ${timing}` : installStatus;

    if (this.errorCount > 0) {
      this.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED, message);
    } else if (this.warningCount > 0) {
      this.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED, message);
    } else {
      this.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.UNNAMED, message);
    }
  }

  writeLine(str, {
    truncate
  } = {}) {
    this.clearProgress({
      clear: true
    });
    this.stdout.write(`${this.truncate(str, {
      truncate
    })}\n`);
    this.writeProgress();
  }

  writeLineWithForgettableReset(str, {
    truncate
  } = {}) {
    this.forgettableLines = [];
    this.writeLine(str, {
      truncate
    });
  }

  writeLines(lines, {
    truncate
  } = {}) {
    this.clearProgress({
      delta: lines.length
    });

    for (const line of lines) this.stdout.write(`${this.truncate(line, {
      truncate
    })}\n`);

    this.writeProgress();
  }

  reportCacheChanges({
    cacheHitCount,
    cacheMissCount
  }) {
    const cacheHitDelta = this.cacheHitCount - cacheHitCount;
    const cacheMissDelta = this.cacheMissCount - cacheMissCount;
    if (cacheHitDelta === 0 && cacheMissDelta === 0) return;
    let fetchStatus = ``;
    if (this.cacheHitCount > 1) fetchStatus += `${this.cacheHitCount} packages were already cached`;else if (this.cacheHitCount === 1) fetchStatus += ` - one package was already cached`;else fetchStatus += `No packages were cached`;

    if (this.cacheHitCount > 0) {
      if (this.cacheMissCount > 1) {
        fetchStatus += `, ${this.cacheMissCount} had to be fetched`;
      } else if (this.cacheMissCount === 1) {
        fetchStatus += `, one had to be fetched`;
      }
    } else {
      if (this.cacheMissCount > 1) {
        fetchStatus += ` - ${this.cacheMissCount} packages had to be fetched`;
      } else if (this.cacheMissCount === 1) {
        fetchStatus += ` - one package had to be fetched`;
      }
    }

    this.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.FETCH_NOT_CACHED, fetchStatus);
  }

  clearProgress({
    delta = 0,
    clear = false
  }) {
    if (!this.configuration.get(`enableProgressBars`) || this.json) return;

    if (this.progress.size + delta > 0) {
      this.stdout.write(`\x1b[${this.progress.size + delta}A`);

      if (delta > 0 || clear) {
        this.stdout.write(`\x1b[0J`);
      }
    }
  }

  writeProgress() {
    if (!this.configuration.get(`enableProgressBars`) || this.json) return;
    if (this.progressTimeout !== null) clearTimeout(this.progressTimeout);
    this.progressTimeout = null;
    if (this.progress.size === 0) return;
    const now = Date.now();

    if (now - this.progressTime > PROGRESS_INTERVAL) {
      this.progressFrame = (this.progressFrame + 1) % PROGRESS_FRAMES.length;
      this.progressTime = now;
    }

    const spinner = PROGRESS_FRAMES[this.progressFrame];
    const styleName = this.configuration.get(`progressBarStyle`) || defaultStyle;
    if (!Object.prototype.hasOwnProperty.call(PROGRESS_STYLES, styleName)) throw new Error(`Assertion failed: Invalid progress bar style`); // @ts-ignore

    const style = PROGRESS_STYLES[styleName];
    const PAD_LEFT = ` YN0000:  `.length;
    const maxWidth = Math.max(0, Math.min(process.stdout.columns - PAD_LEFT, 80));
    const scaledSize = Math.floor(style.size * maxWidth / 80);

    for (const {
      progress
    } of this.progress.values()) {
      const okSize = scaledSize * progress;
      const ok = style.chars[0].repeat(okSize);
      const ko = style.chars[1].repeat(scaledSize - okSize);
      this.stdout.write(`${this.configuration.format(``, `blueBright`)} ${this.formatName(null)}: ${spinner} ${ok}${ko}\n`);
    }

    this.progressTimeout = setTimeout(() => {
      this.refreshProgress();
    }, 1000 / 60);
  }

  refreshProgress(delta = 0) {
    this.clearProgress({
      delta
    });
    this.writeProgress();
  }

  formatTiming(timing) {
    return timing < 60 * 1000 ? `${Math.round(timing / 10) / 100}s` : `${Math.round(timing / 600) / 100}m`;
  }

  truncate(str, {
    truncate
  } = {}) {
    if (!this.configuration.get(`enableProgressBars`)) truncate = false;
    if (typeof truncate === `undefined`) truncate = this.configuration.get(`preferTruncatedLines`); // The -1 is to account for terminals that would wrap after
    // the last column rather before the first overwrite

    if (truncate) str = _arcanis_slice_ansi__WEBPACK_IMPORTED_MODULE_0___default()(str, 0, process.stdout.columns - 1);
    return str;
  }

  formatName(name) {
    return formatName(name, {
      configuration: this.configuration,
      json: this.json
    });
  }

  formatNameWithHyperlink(name) {
    return formatNameWithHyperlink(name, {
      configuration: this.configuration,
      json: this.json
    });
  }

  formatIndent() {
    return ` `.repeat(this.indent);
  }

}

/***/ }),
/* 240 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const GraphemeSplitter = __webpack_require__(241);

const ANSI_SEQUENCE = /^(.*?)(\x1b\[[^m]+m|\x1b\]8;;.*?(\x1b\\|\u0007))/;
const splitter = new GraphemeSplitter();

module.exports = (orig, at = 0, until = orig.length) => {
  // Because to do this we'd need to know the printable length of the string,
  // which would require to do two passes (or would complexify the main one)
  if (at < 0 || until < 0)
    throw new RangeError(`Negative indices aren't supported by this implementation`);

  const length = until - at;

  let output = ``;

  let skipped = 0;
  let visible = 0;

  while (orig.length > 0) {
    const lookup = orig.match(ANSI_SEQUENCE) || [orig, orig, undefined];
    let graphemes = splitter.splitGraphemes(lookup[1]);

    const skipping = Math.min(at - skipped, graphemes.length);
    graphemes = graphemes.slice(skipping);

    const displaying = Math.min(length - visible, graphemes.length);
    output += graphemes.slice(0, displaying).join(``);

    skipped += skipping;
    visible += displaying;

    if (typeof lookup[2] !== `undefined`)
      output += lookup[2];

    orig = orig.slice(lookup[0].length);
  }

  return output;
};


/***/ }),
/* 241 */
/***/ ((module) => {

/*
Breaks a Javascript string into individual user-perceived "characters" 
called extended grapheme clusters by implementing the Unicode UAX-29 standard, version 10.0.0

Usage:
var splitter = new GraphemeSplitter();
//returns an array of strings, one string for each grapheme cluster
var graphemes = splitter.splitGraphemes(string); 

*/
function GraphemeSplitter(){
	var CR = 0,
		LF = 1,
		Control = 2,
		Extend = 3,
		Regional_Indicator = 4,
		SpacingMark = 5,
		L = 6,
		V = 7,
		T = 8,
		LV = 9,
		LVT = 10,
		Other = 11,
		Prepend = 12,
		E_Base = 13,
		E_Modifier = 14,
		ZWJ = 15,
		Glue_After_Zwj = 16,
		E_Base_GAZ = 17;
		
	// BreakTypes
	var NotBreak = 0,
		BreakStart = 1,
		Break = 2,
		BreakLastRegional = 3,
		BreakPenultimateRegional = 4;
		
	function isSurrogate(str, pos) {
		return  0xd800 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 0xdbff && 
				0xdc00 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 0xdfff;
	}
		
	// Private function, gets a Unicode code point from a JavaScript UTF-16 string
	// handling surrogate pairs appropriately
	function codePointAt(str, idx){
		if(idx === undefined){
			idx = 0;
		}
		var code = str.charCodeAt(idx);

		// if a high surrogate
		if (0xD800 <= code && code <= 0xDBFF && 
			idx < str.length - 1){
			var hi = code;
			var low = str.charCodeAt(idx + 1);
			if (0xDC00 <= low && low <= 0xDFFF){
				return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
			}
			return hi;
		}
		
		// if a low surrogate
		if (0xDC00 <= code && code <= 0xDFFF &&
			idx >= 1){
			var hi = str.charCodeAt(idx - 1);
			var low = code;
			if (0xD800 <= hi && hi <= 0xDBFF){
				return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
			}
			return low;
		}
		
		//just return the char if an unmatched surrogate half or a 
		//single-char codepoint
		return code;
	}
	
	// Private function, returns whether a break is allowed between the 
	// two given grapheme breaking classes
	function shouldBreak(start, mid, end){
		var all = [start].concat(mid).concat([end]);
		var previous = all[all.length - 2]
		var next = end
		
		// Lookahead termintor for:
		// GB10. (E_Base | EBG) Extend* ?	E_Modifier
		var eModifierIndex = all.lastIndexOf(E_Modifier)
		if(eModifierIndex > 1 &&
			all.slice(1, eModifierIndex).every(function(c){return c == Extend}) &&
			[Extend, E_Base, E_Base_GAZ].indexOf(start) == -1){
			return Break
		}

		// Lookahead termintor for:
		// GB12. ^ (RI RI)* RI	?	RI
		// GB13. [^RI] (RI RI)* RI	?	RI
		var rIIndex = all.lastIndexOf(Regional_Indicator)
		if(rIIndex > 0 &&
			all.slice(1, rIIndex).every(function(c){return c == Regional_Indicator}) &&
			[Prepend, Regional_Indicator].indexOf(previous) == -1) { 
			if(all.filter(function(c){return c == Regional_Indicator}).length % 2 == 1) {
				return BreakLastRegional
			}
			else {
				return BreakPenultimateRegional
			}
		}
		
		// GB3. CR X LF
		if(previous == CR && next == LF){
			return NotBreak;
		}
		// GB4. (Control|CR|LF) 
		else if(previous == Control || previous == CR || previous == LF){
			if(next == E_Modifier && mid.every(function(c){return c == Extend})){
				return Break
			}
			else {
				return BreakStart
			}
		}
		// GB5.  (Control|CR|LF)
		else if(next == Control || next == CR || next == LF){
			return BreakStart;
		}
		// GB6. L X (L|V|LV|LVT)
		else if(previous == L && 
			(next == L || next == V || next == LV || next == LVT)){
			return NotBreak;
		}
		// GB7. (LV|V) X (V|T)
		else if((previous == LV || previous == V) && 
			(next == V || next == T)){
			return NotBreak;
		}
		// GB8. (LVT|T) X (T)
		else if((previous == LVT || previous == T) && 
			next == T){
			return NotBreak;
		}
		// GB9. X (Extend|ZWJ)
		else if (next == Extend || next == ZWJ){
			return NotBreak;
		}
		// GB9a. X SpacingMark
		else if(next == SpacingMark){
			return NotBreak;
		}
		// GB9b. Prepend X
		else if (previous == Prepend){
			return NotBreak;
		}
		
		// GB10. (E_Base | EBG) Extend* ?	E_Modifier
		var previousNonExtendIndex = all.indexOf(Extend) != -1 ? all.lastIndexOf(Extend) - 1 : all.length - 2;
		if([E_Base, E_Base_GAZ].indexOf(all[previousNonExtendIndex]) != -1 &&
			all.slice(previousNonExtendIndex + 1, -1).every(function(c){return c == Extend}) &&
			next == E_Modifier){
			return NotBreak;
		}
		
		// GB11. ZWJ ? (Glue_After_Zwj | EBG)
		if(previous == ZWJ && [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1) {
			return NotBreak;
		}

		// GB12. ^ (RI RI)* RI ? RI
		// GB13. [^RI] (RI RI)* RI ? RI
		if(mid.indexOf(Regional_Indicator) != -1) { 
			return Break;
		}
		if(previous == Regional_Indicator && next == Regional_Indicator) {
			return NotBreak;
		}

		// GB999. Any ? Any
		return BreakStart;
	}
	
	// Returns the next grapheme break in the string after the given index
	this.nextBreak = function(string, index){
		if(index === undefined){
			index = 0;
		}
		if(index < 0){
			return 0;
		}
		if(index >= string.length - 1){
			return string.length;
		}
		var prev = getGraphemeBreakProperty(codePointAt(string, index));
		var mid = []
		for (var i = index + 1; i < string.length; i++) {
			// check for already processed low surrogates
			if(isSurrogate(string, i - 1)){
				continue;
			}
		
			var next = getGraphemeBreakProperty(codePointAt(string, i));
			if(shouldBreak(prev, mid, next)){
				return i;
			}
			
			mid.push(next);
		}
		return string.length;
	};
	
	// Breaks the given string into an array of grapheme cluster strings
	this.splitGraphemes = function(str){
		var res = [];
		var index = 0;
		var brk;
		while((brk = this.nextBreak(str, index)) < str.length){
			res.push(str.slice(index, brk));
			index = brk;
		}
		if(index < str.length){
			res.push(str.slice(index));
		}
		return res;
	};

	// Returns the iterator of grapheme clusters there are in the given string
	this.iterateGraphemes = function(str) {
		var index = 0;
		var res = {
			next: (function() {
				var value;
				var brk;
				if ((brk = this.nextBreak(str, index)) < str.length) {
					value = str.slice(index, brk);
					index = brk;
					return { value: value, done: false };
				}
				if (index < str.length) {
					value = str.slice(index);
					index = str.length;
					return { value: value, done: false };
				}
				return { value: undefined, done: true };
			}).bind(this)
		};
		// ES2015 @@iterator method (iterable) for spread syntax and for...of statement
		if (typeof Symbol !== 'undefined' && Symbol.iterator) {
			res[Symbol.iterator] = function() {return res};
		}
		return res;
	};

	// Returns the number of grapheme clusters there are in the given string
	this.countGraphemes = function(str){
		var count = 0;
		var index = 0;
		var brk;
		while((brk = this.nextBreak(str, index)) < str.length){
			index = brk;
			count++;
		}
		if(index < str.length){
			count++;
		}
		return count;
	};
	
	//given a Unicode code point, determines this symbol's grapheme break property
	function getGraphemeBreakProperty(code){
		
		//grapheme break property for Unicode 10.0.0, 
		//taken from http://www.unicode.org/Public/10.0.0/ucd/auxiliary/GraphemeBreakProperty.txt
		//and adapted to JavaScript rules
		
		if(		
		(0x0600 <= code && code <= 0x0605) || // Cf   [6] ARABIC NUMBER SIGN..ARABIC NUMBER MARK ABOVE
		0x06DD == code || // Cf       ARABIC END OF AYAH
		0x070F == code || // Cf       SYRIAC ABBREVIATION MARK
		0x08E2 == code || // Cf       ARABIC DISPUTED END OF AYAH
		0x0D4E == code || // Lo       MALAYALAM LETTER DOT REPH
		0x110BD == code || // Cf       KAITHI NUMBER SIGN
		(0x111C2 <= code && code <= 0x111C3) || // Lo   [2] SHARADA SIGN JIHVAMULIYA..SHARADA SIGN UPADHMANIYA
		0x11A3A == code || // Lo       ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
		(0x11A86 <= code && code <= 0x11A89) || // Lo   [4] SOYOMBO CLUSTER-INITIAL LETTER RA..SOYOMBO CLUSTER-INITIAL LETTER SA
		0x11D46 == code // Lo       MASARAM GONDI REPHA
		){
			return Prepend;
		}
		if(
		0x000D == code // Cc       <control-000D>
		){
			return CR;
		}
		
		if(
		0x000A == code // Cc       <control-000A>
		){
			return LF;
		}
		
		
		if(
		(0x0000 <= code && code <= 0x0009) || // Cc  [10] <control-0000>..<control-0009>
		(0x000B <= code && code <= 0x000C) || // Cc   [2] <control-000B>..<control-000C>
		(0x000E <= code && code <= 0x001F) || // Cc  [18] <control-000E>..<control-001F>
		(0x007F <= code && code <= 0x009F) || // Cc  [33] <control-007F>..<control-009F>
		0x00AD == code || // Cf       SOFT HYPHEN
		0x061C == code || // Cf       ARABIC LETTER MARK
	
		0x180E == code || // Cf       MONGOLIAN VOWEL SEPARATOR
		0x200B == code || // Cf       ZERO WIDTH SPACE
		(0x200E <= code && code <= 0x200F) || // Cf   [2] LEFT-TO-RIGHT MARK..RIGHT-TO-LEFT MARK
		0x2028 == code || // Zl       LINE SEPARATOR
		0x2029 == code || // Zp       PARAGRAPH SEPARATOR
		(0x202A <= code && code <= 0x202E) || // Cf   [5] LEFT-TO-RIGHT EMBEDDING..RIGHT-TO-LEFT OVERRIDE
		(0x2060 <= code && code <= 0x2064) || // Cf   [5] WORD JOINER..INVISIBLE PLUS
		0x2065 == code || // Cn       <reserved-2065>
		(0x2066 <= code && code <= 0x206F) || // Cf  [10] LEFT-TO-RIGHT ISOLATE..NOMINAL DIGIT SHAPES
		(0xD800 <= code && code <= 0xDFFF) || // Cs [2048] <surrogate-D800>..<surrogate-DFFF>
		0xFEFF == code || // Cf       ZERO WIDTH NO-BREAK SPACE
		(0xFFF0 <= code && code <= 0xFFF8) || // Cn   [9] <reserved-FFF0>..<reserved-FFF8>
		(0xFFF9 <= code && code <= 0xFFFB) || // Cf   [3] INTERLINEAR ANNOTATION ANCHOR..INTERLINEAR ANNOTATION TERMINATOR
		(0x1BCA0 <= code && code <= 0x1BCA3) || // Cf   [4] SHORTHAND FORMAT LETTER OVERLAP..SHORTHAND FORMAT UP STEP
		(0x1D173 <= code && code <= 0x1D17A) || // Cf   [8] MUSICAL SYMBOL BEGIN BEAM..MUSICAL SYMBOL END PHRASE
		0xE0000 == code || // Cn       <reserved-E0000>
		0xE0001 == code || // Cf       LANGUAGE TAG
		(0xE0002 <= code && code <= 0xE001F) || // Cn  [30] <reserved-E0002>..<reserved-E001F>
		(0xE0080 <= code && code <= 0xE00FF) || // Cn [128] <reserved-E0080>..<reserved-E00FF>
		(0xE01F0 <= code && code <= 0xE0FFF) // Cn [3600] <reserved-E01F0>..<reserved-E0FFF>
		){
			return Control;
		}
		
		
		if(
		(0x0300 <= code && code <= 0x036F) || // Mn [112] COMBINING GRAVE ACCENT..COMBINING LATIN SMALL LETTER X
		(0x0483 <= code && code <= 0x0487) || // Mn   [5] COMBINING CYRILLIC TITLO..COMBINING CYRILLIC POKRYTIE
		(0x0488 <= code && code <= 0x0489) || // Me   [2] COMBINING CYRILLIC HUNDRED THOUSANDS SIGN..COMBINING CYRILLIC MILLIONS SIGN
		(0x0591 <= code && code <= 0x05BD) || // Mn  [45] HEBREW ACCENT ETNAHTA..HEBREW POINT METEG
		0x05BF == code || // Mn       HEBREW POINT RAFE
		(0x05C1 <= code && code <= 0x05C2) || // Mn   [2] HEBREW POINT SHIN DOT..HEBREW POINT SIN DOT
		(0x05C4 <= code && code <= 0x05C5) || // Mn   [2] HEBREW MARK UPPER DOT..HEBREW MARK LOWER DOT
		0x05C7 == code || // Mn       HEBREW POINT QAMATS QATAN
		(0x0610 <= code && code <= 0x061A) || // Mn  [11] ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM..ARABIC SMALL KASRA
		(0x064B <= code && code <= 0x065F) || // Mn  [21] ARABIC FATHATAN..ARABIC WAVY HAMZA BELOW
		0x0670 == code || // Mn       ARABIC LETTER SUPERSCRIPT ALEF
		(0x06D6 <= code && code <= 0x06DC) || // Mn   [7] ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA..ARABIC SMALL HIGH SEEN
		(0x06DF <= code && code <= 0x06E4) || // Mn   [6] ARABIC SMALL HIGH ROUNDED ZERO..ARABIC SMALL HIGH MADDA
		(0x06E7 <= code && code <= 0x06E8) || // Mn   [2] ARABIC SMALL HIGH YEH..ARABIC SMALL HIGH NOON
		(0x06EA <= code && code <= 0x06ED) || // Mn   [4] ARABIC EMPTY CENTRE LOW STOP..ARABIC SMALL LOW MEEM
		0x0711 == code || // Mn       SYRIAC LETTER SUPERSCRIPT ALAPH
		(0x0730 <= code && code <= 0x074A) || // Mn  [27] SYRIAC PTHAHA ABOVE..SYRIAC BARREKH
		(0x07A6 <= code && code <= 0x07B0) || // Mn  [11] THAANA ABAFILI..THAANA SUKUN
		(0x07EB <= code && code <= 0x07F3) || // Mn   [9] NKO COMBINING SHORT HIGH TONE..NKO COMBINING DOUBLE DOT ABOVE
		(0x0816 <= code && code <= 0x0819) || // Mn   [4] SAMARITAN MARK IN..SAMARITAN MARK DAGESH
		(0x081B <= code && code <= 0x0823) || // Mn   [9] SAMARITAN MARK EPENTHETIC YUT..SAMARITAN VOWEL SIGN A
		(0x0825 <= code && code <= 0x0827) || // Mn   [3] SAMARITAN VOWEL SIGN SHORT A..SAMARITAN VOWEL SIGN U
		(0x0829 <= code && code <= 0x082D) || // Mn   [5] SAMARITAN VOWEL SIGN LONG I..SAMARITAN MARK NEQUDAA
		(0x0859 <= code && code <= 0x085B) || // Mn   [3] MANDAIC AFFRICATION MARK..MANDAIC GEMINATION MARK
		(0x08D4 <= code && code <= 0x08E1) || // Mn  [14] ARABIC SMALL HIGH WORD AR-RUB..ARABIC SMALL HIGH SIGN SAFHA
		(0x08E3 <= code && code <= 0x0902) || // Mn  [32] ARABIC TURNED DAMMA BELOW..DEVANAGARI SIGN ANUSVARA
		0x093A == code || // Mn       DEVANAGARI VOWEL SIGN OE
		0x093C == code || // Mn       DEVANAGARI SIGN NUKTA
		(0x0941 <= code && code <= 0x0948) || // Mn   [8] DEVANAGARI VOWEL SIGN U..DEVANAGARI VOWEL SIGN AI
		0x094D == code || // Mn       DEVANAGARI SIGN VIRAMA
		(0x0951 <= code && code <= 0x0957) || // Mn   [7] DEVANAGARI STRESS SIGN UDATTA..DEVANAGARI VOWEL SIGN UUE
		(0x0962 <= code && code <= 0x0963) || // Mn   [2] DEVANAGARI VOWEL SIGN VOCALIC L..DEVANAGARI VOWEL SIGN VOCALIC LL
		0x0981 == code || // Mn       BENGALI SIGN CANDRABINDU
		0x09BC == code || // Mn       BENGALI SIGN NUKTA
		0x09BE == code || // Mc       BENGALI VOWEL SIGN AA
		(0x09C1 <= code && code <= 0x09C4) || // Mn   [4] BENGALI VOWEL SIGN U..BENGALI VOWEL SIGN VOCALIC RR
		0x09CD == code || // Mn       BENGALI SIGN VIRAMA
		0x09D7 == code || // Mc       BENGALI AU LENGTH MARK
		(0x09E2 <= code && code <= 0x09E3) || // Mn   [2] BENGALI VOWEL SIGN VOCALIC L..BENGALI VOWEL SIGN VOCALIC LL
		(0x0A01 <= code && code <= 0x0A02) || // Mn   [2] GURMUKHI SIGN ADAK BINDI..GURMUKHI SIGN BINDI
		0x0A3C == code || // Mn       GURMUKHI SIGN NUKTA
		(0x0A41 <= code && code <= 0x0A42) || // Mn   [2] GURMUKHI VOWEL SIGN U..GURMUKHI VOWEL SIGN UU
		(0x0A47 <= code && code <= 0x0A48) || // Mn   [2] GURMUKHI VOWEL SIGN EE..GURMUKHI VOWEL SIGN AI
		(0x0A4B <= code && code <= 0x0A4D) || // Mn   [3] GURMUKHI VOWEL SIGN OO..GURMUKHI SIGN VIRAMA
		0x0A51 == code || // Mn       GURMUKHI SIGN UDAAT
		(0x0A70 <= code && code <= 0x0A71) || // Mn   [2] GURMUKHI TIPPI..GURMUKHI ADDAK
		0x0A75 == code || // Mn       GURMUKHI SIGN YAKASH
		(0x0A81 <= code && code <= 0x0A82) || // Mn   [2] GUJARATI SIGN CANDRABINDU..GUJARATI SIGN ANUSVARA
		0x0ABC == code || // Mn       GUJARATI SIGN NUKTA
		(0x0AC1 <= code && code <= 0x0AC5) || // Mn   [5] GUJARATI VOWEL SIGN U..GUJARATI VOWEL SIGN CANDRA E
		(0x0AC7 <= code && code <= 0x0AC8) || // Mn   [2] GUJARATI VOWEL SIGN E..GUJARATI VOWEL SIGN AI
		0x0ACD == code || // Mn       GUJARATI SIGN VIRAMA
		(0x0AE2 <= code && code <= 0x0AE3) || // Mn   [2] GUJARATI VOWEL SIGN VOCALIC L..GUJARATI VOWEL SIGN VOCALIC LL
		(0x0AFA <= code && code <= 0x0AFF) || // Mn   [6] GUJARATI SIGN SUKUN..GUJARATI SIGN TWO-CIRCLE NUKTA ABOVE
		0x0B01 == code || // Mn       ORIYA SIGN CANDRABINDU
		0x0B3C == code || // Mn       ORIYA SIGN NUKTA
		0x0B3E == code || // Mc       ORIYA VOWEL SIGN AA
		0x0B3F == code || // Mn       ORIYA VOWEL SIGN I
		(0x0B41 <= code && code <= 0x0B44) || // Mn   [4] ORIYA VOWEL SIGN U..ORIYA VOWEL SIGN VOCALIC RR
		0x0B4D == code || // Mn       ORIYA SIGN VIRAMA
		0x0B56 == code || // Mn       ORIYA AI LENGTH MARK
		0x0B57 == code || // Mc       ORIYA AU LENGTH MARK
		(0x0B62 <= code && code <= 0x0B63) || // Mn   [2] ORIYA VOWEL SIGN VOCALIC L..ORIYA VOWEL SIGN VOCALIC LL
		0x0B82 == code || // Mn       TAMIL SIGN ANUSVARA
		0x0BBE == code || // Mc       TAMIL VOWEL SIGN AA
		0x0BC0 == code || // Mn       TAMIL VOWEL SIGN II
		0x0BCD == code || // Mn       TAMIL SIGN VIRAMA
		0x0BD7 == code || // Mc       TAMIL AU LENGTH MARK
		0x0C00 == code || // Mn       TELUGU SIGN COMBINING CANDRABINDU ABOVE
		(0x0C3E <= code && code <= 0x0C40) || // Mn   [3] TELUGU VOWEL SIGN AA..TELUGU VOWEL SIGN II
		(0x0C46 <= code && code <= 0x0C48) || // Mn   [3] TELUGU VOWEL SIGN E..TELUGU VOWEL SIGN AI
		(0x0C4A <= code && code <= 0x0C4D) || // Mn   [4] TELUGU VOWEL SIGN O..TELUGU SIGN VIRAMA
		(0x0C55 <= code && code <= 0x0C56) || // Mn   [2] TELUGU LENGTH MARK..TELUGU AI LENGTH MARK
		(0x0C62 <= code && code <= 0x0C63) || // Mn   [2] TELUGU VOWEL SIGN VOCALIC L..TELUGU VOWEL SIGN VOCALIC LL
		0x0C81 == code || // Mn       KANNADA SIGN CANDRABINDU
		0x0CBC == code || // Mn       KANNADA SIGN NUKTA
		0x0CBF == code || // Mn       KANNADA VOWEL SIGN I
		0x0CC2 == code || // Mc       KANNADA VOWEL SIGN UU
		0x0CC6 == code || // Mn       KANNADA VOWEL SIGN E
		(0x0CCC <= code && code <= 0x0CCD) || // Mn   [2] KANNADA VOWEL SIGN AU..KANNADA SIGN VIRAMA
		(0x0CD5 <= code && code <= 0x0CD6) || // Mc   [2] KANNADA LENGTH MARK..KANNADA AI LENGTH MARK
		(0x0CE2 <= code && code <= 0x0CE3) || // Mn   [2] KANNADA VOWEL SIGN VOCALIC L..KANNADA VOWEL SIGN VOCALIC LL
		(0x0D00 <= code && code <= 0x0D01) || // Mn   [2] MALAYALAM SIGN COMBINING ANUSVARA ABOVE..MALAYALAM SIGN CANDRABINDU
		(0x0D3B <= code && code <= 0x0D3C) || // Mn   [2] MALAYALAM SIGN VERTICAL BAR VIRAMA..MALAYALAM SIGN CIRCULAR VIRAMA
		0x0D3E == code || // Mc       MALAYALAM VOWEL SIGN AA
		(0x0D41 <= code && code <= 0x0D44) || // Mn   [4] MALAYALAM VOWEL SIGN U..MALAYALAM VOWEL SIGN VOCALIC RR
		0x0D4D == code || // Mn       MALAYALAM SIGN VIRAMA
		0x0D57 == code || // Mc       MALAYALAM AU LENGTH MARK
		(0x0D62 <= code && code <= 0x0D63) || // Mn   [2] MALAYALAM VOWEL SIGN VOCALIC L..MALAYALAM VOWEL SIGN VOCALIC LL
		0x0DCA == code || // Mn       SINHALA SIGN AL-LAKUNA
		0x0DCF == code || // Mc       SINHALA VOWEL SIGN AELA-PILLA
		(0x0DD2 <= code && code <= 0x0DD4) || // Mn   [3] SINHALA VOWEL SIGN KETTI IS-PILLA..SINHALA VOWEL SIGN KETTI PAA-PILLA
		0x0DD6 == code || // Mn       SINHALA VOWEL SIGN DIGA PAA-PILLA
		0x0DDF == code || // Mc       SINHALA VOWEL SIGN GAYANUKITTA
		0x0E31 == code || // Mn       THAI CHARACTER MAI HAN-AKAT
		(0x0E34 <= code && code <= 0x0E3A) || // Mn   [7] THAI CHARACTER SARA I..THAI CHARACTER PHINTHU
		(0x0E47 <= code && code <= 0x0E4E) || // Mn   [8] THAI CHARACTER MAITAIKHU..THAI CHARACTER YAMAKKAN
		0x0EB1 == code || // Mn       LAO VOWEL SIGN MAI KAN
		(0x0EB4 <= code && code <= 0x0EB9) || // Mn   [6] LAO VOWEL SIGN I..LAO VOWEL SIGN UU
		(0x0EBB <= code && code <= 0x0EBC) || // Mn   [2] LAO VOWEL SIGN MAI KON..LAO SEMIVOWEL SIGN LO
		(0x0EC8 <= code && code <= 0x0ECD) || // Mn   [6] LAO TONE MAI EK..LAO NIGGAHITA
		(0x0F18 <= code && code <= 0x0F19) || // Mn   [2] TIBETAN ASTROLOGICAL SIGN -KHYUD PA..TIBETAN ASTROLOGICAL SIGN SDONG TSHUGS
		0x0F35 == code || // Mn       TIBETAN MARK NGAS BZUNG NYI ZLA
		0x0F37 == code || // Mn       TIBETAN MARK NGAS BZUNG SGOR RTAGS
		0x0F39 == code || // Mn       TIBETAN MARK TSA -PHRU
		(0x0F71 <= code && code <= 0x0F7E) || // Mn  [14] TIBETAN VOWEL SIGN AA..TIBETAN SIGN RJES SU NGA RO
		(0x0F80 <= code && code <= 0x0F84) || // Mn   [5] TIBETAN VOWEL SIGN REVERSED I..TIBETAN MARK HALANTA
		(0x0F86 <= code && code <= 0x0F87) || // Mn   [2] TIBETAN SIGN LCI RTAGS..TIBETAN SIGN YANG RTAGS
		(0x0F8D <= code && code <= 0x0F97) || // Mn  [11] TIBETAN SUBJOINED SIGN LCE TSA CAN..TIBETAN SUBJOINED LETTER JA
		(0x0F99 <= code && code <= 0x0FBC) || // Mn  [36] TIBETAN SUBJOINED LETTER NYA..TIBETAN SUBJOINED LETTER FIXED-FORM RA
		0x0FC6 == code || // Mn       TIBETAN SYMBOL PADMA GDAN
		(0x102D <= code && code <= 0x1030) || // Mn   [4] MYANMAR VOWEL SIGN I..MYANMAR VOWEL SIGN UU
		(0x1032 <= code && code <= 0x1037) || // Mn   [6] MYANMAR VOWEL SIGN AI..MYANMAR SIGN DOT BELOW
		(0x1039 <= code && code <= 0x103A) || // Mn   [2] MYANMAR SIGN VIRAMA..MYANMAR SIGN ASAT
		(0x103D <= code && code <= 0x103E) || // Mn   [2] MYANMAR CONSONANT SIGN MEDIAL WA..MYANMAR CONSONANT SIGN MEDIAL HA
		(0x1058 <= code && code <= 0x1059) || // Mn   [2] MYANMAR VOWEL SIGN VOCALIC L..MYANMAR VOWEL SIGN VOCALIC LL
		(0x105E <= code && code <= 0x1060) || // Mn   [3] MYANMAR CONSONANT SIGN MON MEDIAL NA..MYANMAR CONSONANT SIGN MON MEDIAL LA
		(0x1071 <= code && code <= 0x1074) || // Mn   [4] MYANMAR VOWEL SIGN GEBA KAREN I..MYANMAR VOWEL SIGN KAYAH EE
		0x1082 == code || // Mn       MYANMAR CONSONANT SIGN SHAN MEDIAL WA
		(0x1085 <= code && code <= 0x1086) || // Mn   [2] MYANMAR VOWEL SIGN SHAN E ABOVE..MYANMAR VOWEL SIGN SHAN FINAL Y
		0x108D == code || // Mn       MYANMAR SIGN SHAN COUNCIL EMPHATIC TONE
		0x109D == code || // Mn       MYANMAR VOWEL SIGN AITON AI
		(0x135D <= code && code <= 0x135F) || // Mn   [3] ETHIOPIC COMBINING GEMINATION AND VOWEL LENGTH MARK..ETHIOPIC COMBINING GEMINATION MARK
		(0x1712 <= code && code <= 0x1714) || // Mn   [3] TAGALOG VOWEL SIGN I..TAGALOG SIGN VIRAMA
		(0x1732 <= code && code <= 0x1734) || // Mn   [3] HANUNOO VOWEL SIGN I..HANUNOO SIGN PAMUDPOD
		(0x1752 <= code && code <= 0x1753) || // Mn   [2] BUHID VOWEL SIGN I..BUHID VOWEL SIGN U
		(0x1772 <= code && code <= 0x1773) || // Mn   [2] TAGBANWA VOWEL SIGN I..TAGBANWA VOWEL SIGN U
		(0x17B4 <= code && code <= 0x17B5) || // Mn   [2] KHMER VOWEL INHERENT AQ..KHMER VOWEL INHERENT AA
		(0x17B7 <= code && code <= 0x17BD) || // Mn   [7] KHMER VOWEL SIGN I..KHMER VOWEL SIGN UA
		0x17C6 == code || // Mn       KHMER SIGN NIKAHIT
		(0x17C9 <= code && code <= 0x17D3) || // Mn  [11] KHMER SIGN MUUSIKATOAN..KHMER SIGN BATHAMASAT
		0x17DD == code || // Mn       KHMER SIGN ATTHACAN
		(0x180B <= code && code <= 0x180D) || // Mn   [3] MONGOLIAN FREE VARIATION SELECTOR ONE..MONGOLIAN FREE VARIATION SELECTOR THREE
		(0x1885 <= code && code <= 0x1886) || // Mn   [2] MONGOLIAN LETTER ALI GALI BALUDA..MONGOLIAN LETTER ALI GALI THREE BALUDA
		0x18A9 == code || // Mn       MONGOLIAN LETTER ALI GALI DAGALGA
		(0x1920 <= code && code <= 0x1922) || // Mn   [3] LIMBU VOWEL SIGN A..LIMBU VOWEL SIGN U
		(0x1927 <= code && code <= 0x1928) || // Mn   [2] LIMBU VOWEL SIGN E..LIMBU VOWEL SIGN O
		0x1932 == code || // Mn       LIMBU SMALL LETTER ANUSVARA
		(0x1939 <= code && code <= 0x193B) || // Mn   [3] LIMBU SIGN MUKPHRENG..LIMBU SIGN SA-I
		(0x1A17 <= code && code <= 0x1A18) || // Mn   [2] BUGINESE VOWEL SIGN I..BUGINESE VOWEL SIGN U
		0x1A1B == code || // Mn       BUGINESE VOWEL SIGN AE
		0x1A56 == code || // Mn       TAI THAM CONSONANT SIGN MEDIAL LA
		(0x1A58 <= code && code <= 0x1A5E) || // Mn   [7] TAI THAM SIGN MAI KANG LAI..TAI THAM CONSONANT SIGN SA
		0x1A60 == code || // Mn       TAI THAM SIGN SAKOT
		0x1A62 == code || // Mn       TAI THAM VOWEL SIGN MAI SAT
		(0x1A65 <= code && code <= 0x1A6C) || // Mn   [8] TAI THAM VOWEL SIGN I..TAI THAM VOWEL SIGN OA BELOW
		(0x1A73 <= code && code <= 0x1A7C) || // Mn  [10] TAI THAM VOWEL SIGN OA ABOVE..TAI THAM SIGN KHUEN-LUE KARAN
		0x1A7F == code || // Mn       TAI THAM COMBINING CRYPTOGRAMMIC DOT
		(0x1AB0 <= code && code <= 0x1ABD) || // Mn  [14] COMBINING DOUBLED CIRCUMFLEX ACCENT..COMBINING PARENTHESES BELOW
		0x1ABE == code || // Me       COMBINING PARENTHESES OVERLAY
		(0x1B00 <= code && code <= 0x1B03) || // Mn   [4] BALINESE SIGN ULU RICEM..BALINESE SIGN SURANG
		0x1B34 == code || // Mn       BALINESE SIGN REREKAN
		(0x1B36 <= code && code <= 0x1B3A) || // Mn   [5] BALINESE VOWEL SIGN ULU..BALINESE VOWEL SIGN RA REPA
		0x1B3C == code || // Mn       BALINESE VOWEL SIGN LA LENGA
		0x1B42 == code || // Mn       BALINESE VOWEL SIGN PEPET
		(0x1B6B <= code && code <= 0x1B73) || // Mn   [9] BALINESE MUSICAL SYMBOL COMBINING TEGEH..BALINESE MUSICAL SYMBOL COMBINING GONG
		(0x1B80 <= code && code <= 0x1B81) || // Mn   [2] SUNDANESE SIGN PANYECEK..SUNDANESE SIGN PANGLAYAR
		(0x1BA2 <= code && code <= 0x1BA5) || // Mn   [4] SUNDANESE CONSONANT SIGN PANYAKRA..SUNDANESE VOWEL SIGN PANYUKU
		(0x1BA8 <= code && code <= 0x1BA9) || // Mn   [2] SUNDANESE VOWEL SIGN PAMEPET..SUNDANESE VOWEL SIGN PANEULEUNG
		(0x1BAB <= code && code <= 0x1BAD) || // Mn   [3] SUNDANESE SIGN VIRAMA..SUNDANESE CONSONANT SIGN PASANGAN WA
		0x1BE6 == code || // Mn       BATAK SIGN TOMPI
		(0x1BE8 <= code && code <= 0x1BE9) || // Mn   [2] BATAK VOWEL SIGN PAKPAK E..BATAK VOWEL SIGN EE
		0x1BED == code || // Mn       BATAK VOWEL SIGN KARO O
		(0x1BEF <= code && code <= 0x1BF1) || // Mn   [3] BATAK VOWEL SIGN U FOR SIMALUNGUN SA..BATAK CONSONANT SIGN H
		(0x1C2C <= code && code <= 0x1C33) || // Mn   [8] LEPCHA VOWEL SIGN E..LEPCHA CONSONANT SIGN T
		(0x1C36 <= code && code <= 0x1C37) || // Mn   [2] LEPCHA SIGN RAN..LEPCHA SIGN NUKTA
		(0x1CD0 <= code && code <= 0x1CD2) || // Mn   [3] VEDIC TONE KARSHANA..VEDIC TONE PRENKHA
		(0x1CD4 <= code && code <= 0x1CE0) || // Mn  [13] VEDIC SIGN YAJURVEDIC MIDLINE SVARITA..VEDIC TONE RIGVEDIC KASHMIRI INDEPENDENT SVARITA
		(0x1CE2 <= code && code <= 0x1CE8) || // Mn   [7] VEDIC SIGN VISARGA SVARITA..VEDIC SIGN VISARGA ANUDATTA WITH TAIL
		0x1CED == code || // Mn       VEDIC SIGN TIRYAK
		0x1CF4 == code || // Mn       VEDIC TONE CANDRA ABOVE
		(0x1CF8 <= code && code <= 0x1CF9) || // Mn   [2] VEDIC TONE RING ABOVE..VEDIC TONE DOUBLE RING ABOVE
		(0x1DC0 <= code && code <= 0x1DF9) || // Mn  [58] COMBINING DOTTED GRAVE ACCENT..COMBINING WIDE INVERTED BRIDGE BELOW
		(0x1DFB <= code && code <= 0x1DFF) || // Mn   [5] COMBINING DELETION MARK..COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW
		0x200C == code || // Cf       ZERO WIDTH NON-JOINER
		(0x20D0 <= code && code <= 0x20DC) || // Mn  [13] COMBINING LEFT HARPOON ABOVE..COMBINING FOUR DOTS ABOVE
		(0x20DD <= code && code <= 0x20E0) || // Me   [4] COMBINING ENCLOSING CIRCLE..COMBINING ENCLOSING CIRCLE BACKSLASH
		0x20E1 == code || // Mn       COMBINING LEFT RIGHT ARROW ABOVE
		(0x20E2 <= code && code <= 0x20E4) || // Me   [3] COMBINING ENCLOSING SCREEN..COMBINING ENCLOSING UPWARD POINTING TRIANGLE
		(0x20E5 <= code && code <= 0x20F0) || // Mn  [12] COMBINING REVERSE SOLIDUS OVERLAY..COMBINING ASTERISK ABOVE
		(0x2CEF <= code && code <= 0x2CF1) || // Mn   [3] COPTIC COMBINING NI ABOVE..COPTIC COMBINING SPIRITUS LENIS
		0x2D7F == code || // Mn       TIFINAGH CONSONANT JOINER
		(0x2DE0 <= code && code <= 0x2DFF) || // Mn  [32] COMBINING CYRILLIC LETTER BE..COMBINING CYRILLIC LETTER IOTIFIED BIG YUS
		(0x302A <= code && code <= 0x302D) || // Mn   [4] IDEOGRAPHIC LEVEL TONE MARK..IDEOGRAPHIC ENTERING TONE MARK
		(0x302E <= code && code <= 0x302F) || // Mc   [2] HANGUL SINGLE DOT TONE MARK..HANGUL DOUBLE DOT TONE MARK
		(0x3099 <= code && code <= 0x309A) || // Mn   [2] COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK..COMBINING KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
		0xA66F == code || // Mn       COMBINING CYRILLIC VZMET
		(0xA670 <= code && code <= 0xA672) || // Me   [3] COMBINING CYRILLIC TEN MILLIONS SIGN..COMBINING CYRILLIC THOUSAND MILLIONS SIGN
		(0xA674 <= code && code <= 0xA67D) || // Mn  [10] COMBINING CYRILLIC LETTER UKRAINIAN IE..COMBINING CYRILLIC PAYEROK
		(0xA69E <= code && code <= 0xA69F) || // Mn   [2] COMBINING CYRILLIC LETTER EF..COMBINING CYRILLIC LETTER IOTIFIED E
		(0xA6F0 <= code && code <= 0xA6F1) || // Mn   [2] BAMUM COMBINING MARK KOQNDON..BAMUM COMBINING MARK TUKWENTIS
		0xA802 == code || // Mn       SYLOTI NAGRI SIGN DVISVARA
		0xA806 == code || // Mn       SYLOTI NAGRI SIGN HASANTA
		0xA80B == code || // Mn       SYLOTI NAGRI SIGN ANUSVARA
		(0xA825 <= code && code <= 0xA826) || // Mn   [2] SYLOTI NAGRI VOWEL SIGN U..SYLOTI NAGRI VOWEL SIGN E
		(0xA8C4 <= code && code <= 0xA8C5) || // Mn   [2] SAURASHTRA SIGN VIRAMA..SAURASHTRA SIGN CANDRABINDU
		(0xA8E0 <= code && code <= 0xA8F1) || // Mn  [18] COMBINING DEVANAGARI DIGIT ZERO..COMBINING DEVANAGARI SIGN AVAGRAHA
		(0xA926 <= code && code <= 0xA92D) || // Mn   [8] KAYAH LI VOWEL UE..KAYAH LI TONE CALYA PLOPHU
		(0xA947 <= code && code <= 0xA951) || // Mn  [11] REJANG VOWEL SIGN I..REJANG CONSONANT SIGN R
		(0xA980 <= code && code <= 0xA982) || // Mn   [3] JAVANESE SIGN PANYANGGA..JAVANESE SIGN LAYAR
		0xA9B3 == code || // Mn       JAVANESE SIGN CECAK TELU
		(0xA9B6 <= code && code <= 0xA9B9) || // Mn   [4] JAVANESE VOWEL SIGN WULU..JAVANESE VOWEL SIGN SUKU MENDUT
		0xA9BC == code || // Mn       JAVANESE VOWEL SIGN PEPET
		0xA9E5 == code || // Mn       MYANMAR SIGN SHAN SAW
		(0xAA29 <= code && code <= 0xAA2E) || // Mn   [6] CHAM VOWEL SIGN AA..CHAM VOWEL SIGN OE
		(0xAA31 <= code && code <= 0xAA32) || // Mn   [2] CHAM VOWEL SIGN AU..CHAM VOWEL SIGN UE
		(0xAA35 <= code && code <= 0xAA36) || // Mn   [2] CHAM CONSONANT SIGN LA..CHAM CONSONANT SIGN WA
		0xAA43 == code || // Mn       CHAM CONSONANT SIGN FINAL NG
		0xAA4C == code || // Mn       CHAM CONSONANT SIGN FINAL M
		0xAA7C == code || // Mn       MYANMAR SIGN TAI LAING TONE-2
		0xAAB0 == code || // Mn       TAI VIET MAI KANG
		(0xAAB2 <= code && code <= 0xAAB4) || // Mn   [3] TAI VIET VOWEL I..TAI VIET VOWEL U
		(0xAAB7 <= code && code <= 0xAAB8) || // Mn   [2] TAI VIET MAI KHIT..TAI VIET VOWEL IA
		(0xAABE <= code && code <= 0xAABF) || // Mn   [2] TAI VIET VOWEL AM..TAI VIET TONE MAI EK
		0xAAC1 == code || // Mn       TAI VIET TONE MAI THO
		(0xAAEC <= code && code <= 0xAAED) || // Mn   [2] MEETEI MAYEK VOWEL SIGN UU..MEETEI MAYEK VOWEL SIGN AAI
		0xAAF6 == code || // Mn       MEETEI MAYEK VIRAMA
		0xABE5 == code || // Mn       MEETEI MAYEK VOWEL SIGN ANAP
		0xABE8 == code || // Mn       MEETEI MAYEK VOWEL SIGN UNAP
		0xABED == code || // Mn       MEETEI MAYEK APUN IYEK
		0xFB1E == code || // Mn       HEBREW POINT JUDEO-SPANISH VARIKA
		(0xFE00 <= code && code <= 0xFE0F) || // Mn  [16] VARIATION SELECTOR-1..VARIATION SELECTOR-16
		(0xFE20 <= code && code <= 0xFE2F) || // Mn  [16] COMBINING LIGATURE LEFT HALF..COMBINING CYRILLIC TITLO RIGHT HALF
		(0xFF9E <= code && code <= 0xFF9F) || // Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
		0x101FD == code || // Mn       PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE
		0x102E0 == code || // Mn       COPTIC EPACT THOUSANDS MARK
		(0x10376 <= code && code <= 0x1037A) || // Mn   [5] COMBINING OLD PERMIC LETTER AN..COMBINING OLD PERMIC LETTER SII
		(0x10A01 <= code && code <= 0x10A03) || // Mn   [3] KHAROSHTHI VOWEL SIGN I..KHAROSHTHI VOWEL SIGN VOCALIC R
		(0x10A05 <= code && code <= 0x10A06) || // Mn   [2] KHAROSHTHI VOWEL SIGN E..KHAROSHTHI VOWEL SIGN O
		(0x10A0C <= code && code <= 0x10A0F) || // Mn   [4] KHAROSHTHI VOWEL LENGTH MARK..KHAROSHTHI SIGN VISARGA
		(0x10A38 <= code && code <= 0x10A3A) || // Mn   [3] KHAROSHTHI SIGN BAR ABOVE..KHAROSHTHI SIGN DOT BELOW
		0x10A3F == code || // Mn       KHAROSHTHI VIRAMA
		(0x10AE5 <= code && code <= 0x10AE6) || // Mn   [2] MANICHAEAN ABBREVIATION MARK ABOVE..MANICHAEAN ABBREVIATION MARK BELOW
		0x11001 == code || // Mn       BRAHMI SIGN ANUSVARA
		(0x11038 <= code && code <= 0x11046) || // Mn  [15] BRAHMI VOWEL SIGN AA..BRAHMI VIRAMA
		(0x1107F <= code && code <= 0x11081) || // Mn   [3] BRAHMI NUMBER JOINER..KAITHI SIGN ANUSVARA
		(0x110B3 <= code && code <= 0x110B6) || // Mn   [4] KAITHI VOWEL SIGN U..KAITHI VOWEL SIGN AI
		(0x110B9 <= code && code <= 0x110BA) || // Mn   [2] KAITHI SIGN VIRAMA..KAITHI SIGN NUKTA
		(0x11100 <= code && code <= 0x11102) || // Mn   [3] CHAKMA SIGN CANDRABINDU..CHAKMA SIGN VISARGA
		(0x11127 <= code && code <= 0x1112B) || // Mn   [5] CHAKMA VOWEL SIGN A..CHAKMA VOWEL SIGN UU
		(0x1112D <= code && code <= 0x11134) || // Mn   [8] CHAKMA VOWEL SIGN AI..CHAKMA MAAYYAA
		0x11173 == code || // Mn       MAHAJANI SIGN NUKTA
		(0x11180 <= code && code <= 0x11181) || // Mn   [2] SHARADA SIGN CANDRABINDU..SHARADA SIGN ANUSVARA
		(0x111B6 <= code && code <= 0x111BE) || // Mn   [9] SHARADA VOWEL SIGN U..SHARADA VOWEL SIGN O
		(0x111CA <= code && code <= 0x111CC) || // Mn   [3] SHARADA SIGN NUKTA..SHARADA EXTRA SHORT VOWEL MARK
		(0x1122F <= code && code <= 0x11231) || // Mn   [3] KHOJKI VOWEL SIGN U..KHOJKI VOWEL SIGN AI
		0x11234 == code || // Mn       KHOJKI SIGN ANUSVARA
		(0x11236 <= code && code <= 0x11237) || // Mn   [2] KHOJKI SIGN NUKTA..KHOJKI SIGN SHADDA
		0x1123E == code || // Mn       KHOJKI SIGN SUKUN
		0x112DF == code || // Mn       KHUDAWADI SIGN ANUSVARA
		(0x112E3 <= code && code <= 0x112EA) || // Mn   [8] KHUDAWADI VOWEL SIGN U..KHUDAWADI SIGN VIRAMA
		(0x11300 <= code && code <= 0x11301) || // Mn   [2] GRANTHA SIGN COMBINING ANUSVARA ABOVE..GRANTHA SIGN CANDRABINDU
		0x1133C == code || // Mn       GRANTHA SIGN NUKTA
		0x1133E == code || // Mc       GRANTHA VOWEL SIGN AA
		0x11340 == code || // Mn       GRANTHA VOWEL SIGN II
		0x11357 == code || // Mc       GRANTHA AU LENGTH MARK
		(0x11366 <= code && code <= 0x1136C) || // Mn   [7] COMBINING GRANTHA DIGIT ZERO..COMBINING GRANTHA DIGIT SIX
		(0x11370 <= code && code <= 0x11374) || // Mn   [5] COMBINING GRANTHA LETTER A..COMBINING GRANTHA LETTER PA
		(0x11438 <= code && code <= 0x1143F) || // Mn   [8] NEWA VOWEL SIGN U..NEWA VOWEL SIGN AI
		(0x11442 <= code && code <= 0x11444) || // Mn   [3] NEWA SIGN VIRAMA..NEWA SIGN ANUSVARA
		0x11446 == code || // Mn       NEWA SIGN NUKTA
		0x114B0 == code || // Mc       TIRHUTA VOWEL SIGN AA
		(0x114B3 <= code && code <= 0x114B8) || // Mn   [6] TIRHUTA VOWEL SIGN U..TIRHUTA VOWEL SIGN VOCALIC LL
		0x114BA == code || // Mn       TIRHUTA VOWEL SIGN SHORT E
		0x114BD == code || // Mc       TIRHUTA VOWEL SIGN SHORT O
		(0x114BF <= code && code <= 0x114C0) || // Mn   [2] TIRHUTA SIGN CANDRABINDU..TIRHUTA SIGN ANUSVARA
		(0x114C2 <= code && code <= 0x114C3) || // Mn   [2] TIRHUTA SIGN VIRAMA..TIRHUTA SIGN NUKTA
		0x115AF == code || // Mc       SIDDHAM VOWEL SIGN AA
		(0x115B2 <= code && code <= 0x115B5) || // Mn   [4] SIDDHAM VOWEL SIGN U..SIDDHAM VOWEL SIGN VOCALIC RR
		(0x115BC <= code && code <= 0x115BD) || // Mn   [2] SIDDHAM SIGN CANDRABINDU..SIDDHAM SIGN ANUSVARA
		(0x115BF <= code && code <= 0x115C0) || // Mn   [2] SIDDHAM SIGN VIRAMA..SIDDHAM SIGN NUKTA
		(0x115DC <= code && code <= 0x115DD) || // Mn   [2] SIDDHAM VOWEL SIGN ALTERNATE U..SIDDHAM VOWEL SIGN ALTERNATE UU
		(0x11633 <= code && code <= 0x1163A) || // Mn   [8] MODI VOWEL SIGN U..MODI VOWEL SIGN AI
		0x1163D == code || // Mn       MODI SIGN ANUSVARA
		(0x1163F <= code && code <= 0x11640) || // Mn   [2] MODI SIGN VIRAMA..MODI SIGN ARDHACANDRA
		0x116AB == code || // Mn       TAKRI SIGN ANUSVARA
		0x116AD == code || // Mn       TAKRI VOWEL SIGN AA
		(0x116B0 <= code && code <= 0x116B5) || // Mn   [6] TAKRI VOWEL SIGN U..TAKRI VOWEL SIGN AU
		0x116B7 == code || // Mn       TAKRI SIGN NUKTA
		(0x1171D <= code && code <= 0x1171F) || // Mn   [3] AHOM CONSONANT SIGN MEDIAL LA..AHOM CONSONANT SIGN MEDIAL LIGATING RA
		(0x11722 <= code && code <= 0x11725) || // Mn   [4] AHOM VOWEL SIGN I..AHOM VOWEL SIGN UU
		(0x11727 <= code && code <= 0x1172B) || // Mn   [5] AHOM VOWEL SIGN AW..AHOM SIGN KILLER
		(0x11A01 <= code && code <= 0x11A06) || // Mn   [6] ZANABAZAR SQUARE VOWEL SIGN I..ZANABAZAR SQUARE VOWEL SIGN O
		(0x11A09 <= code && code <= 0x11A0A) || // Mn   [2] ZANABAZAR SQUARE VOWEL SIGN REVERSED I..ZANABAZAR SQUARE VOWEL LENGTH MARK
		(0x11A33 <= code && code <= 0x11A38) || // Mn   [6] ZANABAZAR SQUARE FINAL CONSONANT MARK..ZANABAZAR SQUARE SIGN ANUSVARA
		(0x11A3B <= code && code <= 0x11A3E) || // Mn   [4] ZANABAZAR SQUARE CLUSTER-FINAL LETTER YA..ZANABAZAR SQUARE CLUSTER-FINAL LETTER VA
		0x11A47 == code || // Mn       ZANABAZAR SQUARE SUBJOINER
		(0x11A51 <= code && code <= 0x11A56) || // Mn   [6] SOYOMBO VOWEL SIGN I..SOYOMBO VOWEL SIGN OE
		(0x11A59 <= code && code <= 0x11A5B) || // Mn   [3] SOYOMBO VOWEL SIGN VOCALIC R..SOYOMBO VOWEL LENGTH MARK
		(0x11A8A <= code && code <= 0x11A96) || // Mn  [13] SOYOMBO FINAL CONSONANT SIGN G..SOYOMBO SIGN ANUSVARA
		(0x11A98 <= code && code <= 0x11A99) || // Mn   [2] SOYOMBO GEMINATION MARK..SOYOMBO SUBJOINER
		(0x11C30 <= code && code <= 0x11C36) || // Mn   [7] BHAIKSUKI VOWEL SIGN I..BHAIKSUKI VOWEL SIGN VOCALIC L
		(0x11C38 <= code && code <= 0x11C3D) || // Mn   [6] BHAIKSUKI VOWEL SIGN E..BHAIKSUKI SIGN ANUSVARA
		0x11C3F == code || // Mn       BHAIKSUKI SIGN VIRAMA
		(0x11C92 <= code && code <= 0x11CA7) || // Mn  [22] MARCHEN SUBJOINED LETTER KA..MARCHEN SUBJOINED LETTER ZA
		(0x11CAA <= code && code <= 0x11CB0) || // Mn   [7] MARCHEN SUBJOINED LETTER RA..MARCHEN VOWEL SIGN AA
		(0x11CB2 <= code && code <= 0x11CB3) || // Mn   [2] MARCHEN VOWEL SIGN U..MARCHEN VOWEL SIGN E
		(0x11CB5 <= code && code <= 0x11CB6) || // Mn   [2] MARCHEN SIGN ANUSVARA..MARCHEN SIGN CANDRABINDU
		(0x11D31 <= code && code <= 0x11D36) || // Mn   [6] MASARAM GONDI VOWEL SIGN AA..MASARAM GONDI VOWEL SIGN VOCALIC R
		0x11D3A == code || // Mn       MASARAM GONDI VOWEL SIGN E
		(0x11D3C <= code && code <= 0x11D3D) || // Mn   [2] MASARAM GONDI VOWEL SIGN AI..MASARAM GONDI VOWEL SIGN O
		(0x11D3F <= code && code <= 0x11D45) || // Mn   [7] MASARAM GONDI VOWEL SIGN AU..MASARAM GONDI VIRAMA
		0x11D47 == code || // Mn       MASARAM GONDI RA-KARA
		(0x16AF0 <= code && code <= 0x16AF4) || // Mn   [5] BASSA VAH COMBINING HIGH TONE..BASSA VAH COMBINING HIGH-LOW TONE
		(0x16B30 <= code && code <= 0x16B36) || // Mn   [7] PAHAWH HMONG MARK CIM TUB..PAHAWH HMONG MARK CIM TAUM
		(0x16F8F <= code && code <= 0x16F92) || // Mn   [4] MIAO TONE RIGHT..MIAO TONE BELOW
		(0x1BC9D <= code && code <= 0x1BC9E) || // Mn   [2] DUPLOYAN THICK LETTER SELECTOR..DUPLOYAN DOUBLE MARK
		0x1D165 == code || // Mc       MUSICAL SYMBOL COMBINING STEM
		(0x1D167 <= code && code <= 0x1D169) || // Mn   [3] MUSICAL SYMBOL COMBINING TREMOLO-1..MUSICAL SYMBOL COMBINING TREMOLO-3
		(0x1D16E <= code && code <= 0x1D172) || // Mc   [5] MUSICAL SYMBOL COMBINING FLAG-1..MUSICAL SYMBOL COMBINING FLAG-5
		(0x1D17B <= code && code <= 0x1D182) || // Mn   [8] MUSICAL SYMBOL COMBINING ACCENT..MUSICAL SYMBOL COMBINING LOURE
		(0x1D185 <= code && code <= 0x1D18B) || // Mn   [7] MUSICAL SYMBOL COMBINING DOIT..MUSICAL SYMBOL COMBINING TRIPLE TONGUE
		(0x1D1AA <= code && code <= 0x1D1AD) || // Mn   [4] MUSICAL SYMBOL COMBINING DOWN BOW..MUSICAL SYMBOL COMBINING SNAP PIZZICATO
		(0x1D242 <= code && code <= 0x1D244) || // Mn   [3] COMBINING GREEK MUSICAL TRISEME..COMBINING GREEK MUSICAL PENTASEME
		(0x1DA00 <= code && code <= 0x1DA36) || // Mn  [55] SIGNWRITING HEAD RIM..SIGNWRITING AIR SUCKING IN
		(0x1DA3B <= code && code <= 0x1DA6C) || // Mn  [50] SIGNWRITING MOUTH CLOSED NEUTRAL..SIGNWRITING EXCITEMENT
		0x1DA75 == code || // Mn       SIGNWRITING UPPER BODY TILTING FROM HIP JOINTS
		0x1DA84 == code || // Mn       SIGNWRITING LOCATION HEAD NECK
		(0x1DA9B <= code && code <= 0x1DA9F) || // Mn   [5] SIGNWRITING FILL MODIFIER-2..SIGNWRITING FILL MODIFIER-6
		(0x1DAA1 <= code && code <= 0x1DAAF) || // Mn  [15] SIGNWRITING ROTATION MODIFIER-2..SIGNWRITING ROTATION MODIFIER-16
		(0x1E000 <= code && code <= 0x1E006) || // Mn   [7] COMBINING GLAGOLITIC LETTER AZU..COMBINING GLAGOLITIC LETTER ZHIVETE
		(0x1E008 <= code && code <= 0x1E018) || // Mn  [17] COMBINING GLAGOLITIC LETTER ZEMLJA..COMBINING GLAGOLITIC LETTER HERU
		(0x1E01B <= code && code <= 0x1E021) || // Mn   [7] COMBINING GLAGOLITIC LETTER SHTA..COMBINING GLAGOLITIC LETTER YATI
		(0x1E023 <= code && code <= 0x1E024) || // Mn   [2] COMBINING GLAGOLITIC LETTER YU..COMBINING GLAGOLITIC LETTER SMALL YUS
		(0x1E026 <= code && code <= 0x1E02A) || // Mn   [5] COMBINING GLAGOLITIC LETTER YO..COMBINING GLAGOLITIC LETTER FITA
		(0x1E8D0 <= code && code <= 0x1E8D6) || // Mn   [7] MENDE KIKAKUI COMBINING NUMBER TEENS..MENDE KIKAKUI COMBINING NUMBER MILLIONS
		(0x1E944 <= code && code <= 0x1E94A) || // Mn   [7] ADLAM ALIF LENGTHENER..ADLAM NUKTA
		(0xE0020 <= code && code <= 0xE007F) || // Cf  [96] TAG SPACE..CANCEL TAG
		(0xE0100 <= code && code <= 0xE01EF) // Mn [240] VARIATION SELECTOR-17..VARIATION SELECTOR-256
		){
			return Extend;
		}
		
		
		if(
		(0x1F1E6 <= code && code <= 0x1F1FF) // So  [26] REGIONAL INDICATOR SYMBOL LETTER A..REGIONAL INDICATOR SYMBOL LETTER Z
		){
			return Regional_Indicator;
		}
		
		if(
		0x0903 == code || // Mc       DEVANAGARI SIGN VISARGA
		0x093B == code || // Mc       DEVANAGARI VOWEL SIGN OOE
		(0x093E <= code && code <= 0x0940) || // Mc   [3] DEVANAGARI VOWEL SIGN AA..DEVANAGARI VOWEL SIGN II
		(0x0949 <= code && code <= 0x094C) || // Mc   [4] DEVANAGARI VOWEL SIGN CANDRA O..DEVANAGARI VOWEL SIGN AU
		(0x094E <= code && code <= 0x094F) || // Mc   [2] DEVANAGARI VOWEL SIGN PRISHTHAMATRA E..DEVANAGARI VOWEL SIGN AW
		(0x0982 <= code && code <= 0x0983) || // Mc   [2] BENGALI SIGN ANUSVARA..BENGALI SIGN VISARGA
		(0x09BF <= code && code <= 0x09C0) || // Mc   [2] BENGALI VOWEL SIGN I..BENGALI VOWEL SIGN II
		(0x09C7 <= code && code <= 0x09C8) || // Mc   [2] BENGALI VOWEL SIGN E..BENGALI VOWEL SIGN AI
		(0x09CB <= code && code <= 0x09CC) || // Mc   [2] BENGALI VOWEL SIGN O..BENGALI VOWEL SIGN AU
		0x0A03 == code || // Mc       GURMUKHI SIGN VISARGA
		(0x0A3E <= code && code <= 0x0A40) || // Mc   [3] GURMUKHI VOWEL SIGN AA..GURMUKHI VOWEL SIGN II
		0x0A83 == code || // Mc       GUJARATI SIGN VISARGA
		(0x0ABE <= code && code <= 0x0AC0) || // Mc   [3] GUJARATI VOWEL SIGN AA..GUJARATI VOWEL SIGN II
		0x0AC9 == code || // Mc       GUJARATI VOWEL SIGN CANDRA O
		(0x0ACB <= code && code <= 0x0ACC) || // Mc   [2] GUJARATI VOWEL SIGN O..GUJARATI VOWEL SIGN AU
		(0x0B02 <= code && code <= 0x0B03) || // Mc   [2] ORIYA SIGN ANUSVARA..ORIYA SIGN VISARGA
		0x0B40 == code || // Mc       ORIYA VOWEL SIGN II
		(0x0B47 <= code && code <= 0x0B48) || // Mc   [2] ORIYA VOWEL SIGN E..ORIYA VOWEL SIGN AI
		(0x0B4B <= code && code <= 0x0B4C) || // Mc   [2] ORIYA VOWEL SIGN O..ORIYA VOWEL SIGN AU
		0x0BBF == code || // Mc       TAMIL VOWEL SIGN I
		(0x0BC1 <= code && code <= 0x0BC2) || // Mc   [2] TAMIL VOWEL SIGN U..TAMIL VOWEL SIGN UU
		(0x0BC6 <= code && code <= 0x0BC8) || // Mc   [3] TAMIL VOWEL SIGN E..TAMIL VOWEL SIGN AI
		(0x0BCA <= code && code <= 0x0BCC) || // Mc   [3] TAMIL VOWEL SIGN O..TAMIL VOWEL SIGN AU
		(0x0C01 <= code && code <= 0x0C03) || // Mc   [3] TELUGU SIGN CANDRABINDU..TELUGU SIGN VISARGA
		(0x0C41 <= code && code <= 0x0C44) || // Mc   [4] TELUGU VOWEL SIGN U..TELUGU VOWEL SIGN VOCALIC RR
		(0x0C82 <= code && code <= 0x0C83) || // Mc   [2] KANNADA SIGN ANUSVARA..KANNADA SIGN VISARGA
		0x0CBE == code || // Mc       KANNADA VOWEL SIGN AA
		(0x0CC0 <= code && code <= 0x0CC1) || // Mc   [2] KANNADA VOWEL SIGN II..KANNADA VOWEL SIGN U
		(0x0CC3 <= code && code <= 0x0CC4) || // Mc   [2] KANNADA VOWEL SIGN VOCALIC R..KANNADA VOWEL SIGN VOCALIC RR
		(0x0CC7 <= code && code <= 0x0CC8) || // Mc   [2] KANNADA VOWEL SIGN EE..KANNADA VOWEL SIGN AI
		(0x0CCA <= code && code <= 0x0CCB) || // Mc   [2] KANNADA VOWEL SIGN O..KANNADA VOWEL SIGN OO
		(0x0D02 <= code && code <= 0x0D03) || // Mc   [2] MALAYALAM SIGN ANUSVARA..MALAYALAM SIGN VISARGA
		(0x0D3F <= code && code <= 0x0D40) || // Mc   [2] MALAYALAM VOWEL SIGN I..MALAYALAM VOWEL SIGN II
		(0x0D46 <= code && code <= 0x0D48) || // Mc   [3] MALAYALAM VOWEL SIGN E..MALAYALAM VOWEL SIGN AI
		(0x0D4A <= code && code <= 0x0D4C) || // Mc   [3] MALAYALAM VOWEL SIGN O..MALAYALAM VOWEL SIGN AU
		(0x0D82 <= code && code <= 0x0D83) || // Mc   [2] SINHALA SIGN ANUSVARAYA..SINHALA SIGN VISARGAYA
		(0x0DD0 <= code && code <= 0x0DD1) || // Mc   [2] SINHALA VOWEL SIGN KETTI AEDA-PILLA..SINHALA VOWEL SIGN DIGA AEDA-PILLA
		(0x0DD8 <= code && code <= 0x0DDE) || // Mc   [7] SINHALA VOWEL SIGN GAETTA-PILLA..SINHALA VOWEL SIGN KOMBUVA HAA GAYANUKITTA
		(0x0DF2 <= code && code <= 0x0DF3) || // Mc   [2] SINHALA VOWEL SIGN DIGA GAETTA-PILLA..SINHALA VOWEL SIGN DIGA GAYANUKITTA
		0x0E33 == code || // Lo       THAI CHARACTER SARA AM
		0x0EB3 == code || // Lo       LAO VOWEL SIGN AM
		(0x0F3E <= code && code <= 0x0F3F) || // Mc   [2] TIBETAN SIGN YAR TSHES..TIBETAN SIGN MAR TSHES
		0x0F7F == code || // Mc       TIBETAN SIGN RNAM BCAD
		0x1031 == code || // Mc       MYANMAR VOWEL SIGN E
		(0x103B <= code && code <= 0x103C) || // Mc   [2] MYANMAR CONSONANT SIGN MEDIAL YA..MYANMAR CONSONANT SIGN MEDIAL RA
		(0x1056 <= code && code <= 0x1057) || // Mc   [2] MYANMAR VOWEL SIGN VOCALIC R..MYANMAR VOWEL SIGN VOCALIC RR
		0x1084 == code || // Mc       MYANMAR VOWEL SIGN SHAN E
		0x17B6 == code || // Mc       KHMER VOWEL SIGN AA
		(0x17BE <= code && code <= 0x17C5) || // Mc   [8] KHMER VOWEL SIGN OE..KHMER VOWEL SIGN AU
		(0x17C7 <= code && code <= 0x17C8) || // Mc   [2] KHMER SIGN REAHMUK..KHMER SIGN YUUKALEAPINTU
		(0x1923 <= code && code <= 0x1926) || // Mc   [4] LIMBU VOWEL SIGN EE..LIMBU VOWEL SIGN AU
		(0x1929 <= code && code <= 0x192B) || // Mc   [3] LIMBU SUBJOINED LETTER YA..LIMBU SUBJOINED LETTER WA
		(0x1930 <= code && code <= 0x1931) || // Mc   [2] LIMBU SMALL LETTER KA..LIMBU SMALL LETTER NGA
		(0x1933 <= code && code <= 0x1938) || // Mc   [6] LIMBU SMALL LETTER TA..LIMBU SMALL LETTER LA
		(0x1A19 <= code && code <= 0x1A1A) || // Mc   [2] BUGINESE VOWEL SIGN E..BUGINESE VOWEL SIGN O
		0x1A55 == code || // Mc       TAI THAM CONSONANT SIGN MEDIAL RA
		0x1A57 == code || // Mc       TAI THAM CONSONANT SIGN LA TANG LAI
		(0x1A6D <= code && code <= 0x1A72) || // Mc   [6] TAI THAM VOWEL SIGN OY..TAI THAM VOWEL SIGN THAM AI
		0x1B04 == code || // Mc       BALINESE SIGN BISAH
		0x1B35 == code || // Mc       BALINESE VOWEL SIGN TEDUNG
		0x1B3B == code || // Mc       BALINESE VOWEL SIGN RA REPA TEDUNG
		(0x1B3D <= code && code <= 0x1B41) || // Mc   [5] BALINESE VOWEL SIGN LA LENGA TEDUNG..BALINESE VOWEL SIGN TALING REPA TEDUNG
		(0x1B43 <= code && code <= 0x1B44) || // Mc   [2] BALINESE VOWEL SIGN PEPET TEDUNG..BALINESE ADEG ADEG
		0x1B82 == code || // Mc       SUNDANESE SIGN PANGWISAD
		0x1BA1 == code || // Mc       SUNDANESE CONSONANT SIGN PAMINGKAL
		(0x1BA6 <= code && code <= 0x1BA7) || // Mc   [2] SUNDANESE VOWEL SIGN PANAELAENG..SUNDANESE VOWEL SIGN PANOLONG
		0x1BAA == code || // Mc       SUNDANESE SIGN PAMAAEH
		0x1BE7 == code || // Mc       BATAK VOWEL SIGN E
		(0x1BEA <= code && code <= 0x1BEC) || // Mc   [3] BATAK VOWEL SIGN I..BATAK VOWEL SIGN O
		0x1BEE == code || // Mc       BATAK VOWEL SIGN U
		(0x1BF2 <= code && code <= 0x1BF3) || // Mc   [2] BATAK PANGOLAT..BATAK PANONGONAN
		(0x1C24 <= code && code <= 0x1C2B) || // Mc   [8] LEPCHA SUBJOINED LETTER YA..LEPCHA VOWEL SIGN UU
		(0x1C34 <= code && code <= 0x1C35) || // Mc   [2] LEPCHA CONSONANT SIGN NYIN-DO..LEPCHA CONSONANT SIGN KANG
		0x1CE1 == code || // Mc       VEDIC TONE ATHARVAVEDIC INDEPENDENT SVARITA
		(0x1CF2 <= code && code <= 0x1CF3) || // Mc   [2] VEDIC SIGN ARDHAVISARGA..VEDIC SIGN ROTATED ARDHAVISARGA
		0x1CF7 == code || // Mc       VEDIC SIGN ATIKRAMA
		(0xA823 <= code && code <= 0xA824) || // Mc   [2] SYLOTI NAGRI VOWEL SIGN A..SYLOTI NAGRI VOWEL SIGN I
		0xA827 == code || // Mc       SYLOTI NAGRI VOWEL SIGN OO
		(0xA880 <= code && code <= 0xA881) || // Mc   [2] SAURASHTRA SIGN ANUSVARA..SAURASHTRA SIGN VISARGA
		(0xA8B4 <= code && code <= 0xA8C3) || // Mc  [16] SAURASHTRA CONSONANT SIGN HAARU..SAURASHTRA VOWEL SIGN AU
		(0xA952 <= code && code <= 0xA953) || // Mc   [2] REJANG CONSONANT SIGN H..REJANG VIRAMA
		0xA983 == code || // Mc       JAVANESE SIGN WIGNYAN
		(0xA9B4 <= code && code <= 0xA9B5) || // Mc   [2] JAVANESE VOWEL SIGN TARUNG..JAVANESE VOWEL SIGN TOLONG
		(0xA9BA <= code && code <= 0xA9BB) || // Mc   [2] JAVANESE VOWEL SIGN TALING..JAVANESE VOWEL SIGN DIRGA MURE
		(0xA9BD <= code && code <= 0xA9C0) || // Mc   [4] JAVANESE CONSONANT SIGN KERET..JAVANESE PANGKON
		(0xAA2F <= code && code <= 0xAA30) || // Mc   [2] CHAM VOWEL SIGN O..CHAM VOWEL SIGN AI
		(0xAA33 <= code && code <= 0xAA34) || // Mc   [2] CHAM CONSONANT SIGN YA..CHAM CONSONANT SIGN RA
		0xAA4D == code || // Mc       CHAM CONSONANT SIGN FINAL H
		0xAAEB == code || // Mc       MEETEI MAYEK VOWEL SIGN II
		(0xAAEE <= code && code <= 0xAAEF) || // Mc   [2] MEETEI MAYEK VOWEL SIGN AU..MEETEI MAYEK VOWEL SIGN AAU
		0xAAF5 == code || // Mc       MEETEI MAYEK VOWEL SIGN VISARGA
		(0xABE3 <= code && code <= 0xABE4) || // Mc   [2] MEETEI MAYEK VOWEL SIGN ONAP..MEETEI MAYEK VOWEL SIGN INAP
		(0xABE6 <= code && code <= 0xABE7) || // Mc   [2] MEETEI MAYEK VOWEL SIGN YENAP..MEETEI MAYEK VOWEL SIGN SOUNAP
		(0xABE9 <= code && code <= 0xABEA) || // Mc   [2] MEETEI MAYEK VOWEL SIGN CHEINAP..MEETEI MAYEK VOWEL SIGN NUNG
		0xABEC == code || // Mc       MEETEI MAYEK LUM IYEK
		0x11000 == code || // Mc       BRAHMI SIGN CANDRABINDU
		0x11002 == code || // Mc       BRAHMI SIGN VISARGA
		0x11082 == code || // Mc       KAITHI SIGN VISARGA
		(0x110B0 <= code && code <= 0x110B2) || // Mc   [3] KAITHI VOWEL SIGN AA..KAITHI VOWEL SIGN II
		(0x110B7 <= code && code <= 0x110B8) || // Mc   [2] KAITHI VOWEL SIGN O..KAITHI VOWEL SIGN AU
		0x1112C == code || // Mc       CHAKMA VOWEL SIGN E
		0x11182 == code || // Mc       SHARADA SIGN VISARGA
		(0x111B3 <= code && code <= 0x111B5) || // Mc   [3] SHARADA VOWEL SIGN AA..SHARADA VOWEL SIGN II
		(0x111BF <= code && code <= 0x111C0) || // Mc   [2] SHARADA VOWEL SIGN AU..SHARADA SIGN VIRAMA
		(0x1122C <= code && code <= 0x1122E) || // Mc   [3] KHOJKI VOWEL SIGN AA..KHOJKI VOWEL SIGN II
		(0x11232 <= code && code <= 0x11233) || // Mc   [2] KHOJKI VOWEL SIGN O..KHOJKI VOWEL SIGN AU
		0x11235 == code || // Mc       KHOJKI SIGN VIRAMA
		(0x112E0 <= code && code <= 0x112E2) || // Mc   [3] KHUDAWADI VOWEL SIGN AA..KHUDAWADI VOWEL SIGN II
		(0x11302 <= code && code <= 0x11303) || // Mc   [2] GRANTHA SIGN ANUSVARA..GRANTHA SIGN VISARGA
		0x1133F == code || // Mc       GRANTHA VOWEL SIGN I
		(0x11341 <= code && code <= 0x11344) || // Mc   [4] GRANTHA VOWEL SIGN U..GRANTHA VOWEL SIGN VOCALIC RR
		(0x11347 <= code && code <= 0x11348) || // Mc   [2] GRANTHA VOWEL SIGN EE..GRANTHA VOWEL SIGN AI
		(0x1134B <= code && code <= 0x1134D) || // Mc   [3] GRANTHA VOWEL SIGN OO..GRANTHA SIGN VIRAMA
		(0x11362 <= code && code <= 0x11363) || // Mc   [2] GRANTHA VOWEL SIGN VOCALIC L..GRANTHA VOWEL SIGN VOCALIC LL
		(0x11435 <= code && code <= 0x11437) || // Mc   [3] NEWA VOWEL SIGN AA..NEWA VOWEL SIGN II
		(0x11440 <= code && code <= 0x11441) || // Mc   [2] NEWA VOWEL SIGN O..NEWA VOWEL SIGN AU
		0x11445 == code || // Mc       NEWA SIGN VISARGA
		(0x114B1 <= code && code <= 0x114B2) || // Mc   [2] TIRHUTA VOWEL SIGN I..TIRHUTA VOWEL SIGN II
		0x114B9 == code || // Mc       TIRHUTA VOWEL SIGN E
		(0x114BB <= code && code <= 0x114BC) || // Mc   [2] TIRHUTA VOWEL SIGN AI..TIRHUTA VOWEL SIGN O
		0x114BE == code || // Mc       TIRHUTA VOWEL SIGN AU
		0x114C1 == code || // Mc       TIRHUTA SIGN VISARGA
		(0x115B0 <= code && code <= 0x115B1) || // Mc   [2] SIDDHAM VOWEL SIGN I..SIDDHAM VOWEL SIGN II
		(0x115B8 <= code && code <= 0x115BB) || // Mc   [4] SIDDHAM VOWEL SIGN E..SIDDHAM VOWEL SIGN AU
		0x115BE == code || // Mc       SIDDHAM SIGN VISARGA
		(0x11630 <= code && code <= 0x11632) || // Mc   [3] MODI VOWEL SIGN AA..MODI VOWEL SIGN II
		(0x1163B <= code && code <= 0x1163C) || // Mc   [2] MODI VOWEL SIGN O..MODI VOWEL SIGN AU
		0x1163E == code || // Mc       MODI SIGN VISARGA
		0x116AC == code || // Mc       TAKRI SIGN VISARGA
		(0x116AE <= code && code <= 0x116AF) || // Mc   [2] TAKRI VOWEL SIGN I..TAKRI VOWEL SIGN II
		0x116B6 == code || // Mc       TAKRI SIGN VIRAMA
		(0x11720 <= code && code <= 0x11721) || // Mc   [2] AHOM VOWEL SIGN A..AHOM VOWEL SIGN AA
		0x11726 == code || // Mc       AHOM VOWEL SIGN E
		(0x11A07 <= code && code <= 0x11A08) || // Mc   [2] ZANABAZAR SQUARE VOWEL SIGN AI..ZANABAZAR SQUARE VOWEL SIGN AU
		0x11A39 == code || // Mc       ZANABAZAR SQUARE SIGN VISARGA
		(0x11A57 <= code && code <= 0x11A58) || // Mc   [2] SOYOMBO VOWEL SIGN AI..SOYOMBO VOWEL SIGN AU
		0x11A97 == code || // Mc       SOYOMBO SIGN VISARGA
		0x11C2F == code || // Mc       BHAIKSUKI VOWEL SIGN AA
		0x11C3E == code || // Mc       BHAIKSUKI SIGN VISARGA
		0x11CA9 == code || // Mc       MARCHEN SUBJOINED LETTER YA
		0x11CB1 == code || // Mc       MARCHEN VOWEL SIGN I
		0x11CB4 == code || // Mc       MARCHEN VOWEL SIGN O
		(0x16F51 <= code && code <= 0x16F7E) || // Mc  [46] MIAO SIGN ASPIRATION..MIAO VOWEL SIGN NG
		0x1D166 == code || // Mc       MUSICAL SYMBOL COMBINING SPRECHGESANG STEM
		0x1D16D == code // Mc       MUSICAL SYMBOL COMBINING AUGMENTATION DOT
		){
			return SpacingMark;
		}
		
		
		if(
		(0x1100 <= code && code <= 0x115F) || // Lo  [96] HANGUL CHOSEONG KIYEOK..HANGUL CHOSEONG FILLER
		(0xA960 <= code && code <= 0xA97C) // Lo  [29] HANGUL CHOSEONG TIKEUT-MIEUM..HANGUL CHOSEONG SSANGYEORINHIEUH
		){
			return L;
		}
		
		if(
		(0x1160 <= code && code <= 0x11A7) || // Lo  [72] HANGUL JUNGSEONG FILLER..HANGUL JUNGSEONG O-YAE
		(0xD7B0 <= code && code <= 0xD7C6) // Lo  [23] HANGUL JUNGSEONG O-YEO..HANGUL JUNGSEONG ARAEA-E
		){
			return V;
		}
		
		
		if(
		(0x11A8 <= code && code <= 0x11FF) || // Lo  [88] HANGUL JONGSEONG KIYEOK..HANGUL JONGSEONG SSANGNIEUN
		(0xD7CB <= code && code <= 0xD7FB) // Lo  [49] HANGUL JONGSEONG NIEUN-RIEUL..HANGUL JONGSEONG PHIEUPH-THIEUTH
		){
			return T;
		}
		
		if(
		0xAC00 == code || // Lo       HANGUL SYLLABLE GA
		0xAC1C == code || // Lo       HANGUL SYLLABLE GAE
		0xAC38 == code || // Lo       HANGUL SYLLABLE GYA
		0xAC54 == code || // Lo       HANGUL SYLLABLE GYAE
		0xAC70 == code || // Lo       HANGUL SYLLABLE GEO
		0xAC8C == code || // Lo       HANGUL SYLLABLE GE
		0xACA8 == code || // Lo       HANGUL SYLLABLE GYEO
		0xACC4 == code || // Lo       HANGUL SYLLABLE GYE
		0xACE0 == code || // Lo       HANGUL SYLLABLE GO
		0xACFC == code || // Lo       HANGUL SYLLABLE GWA
		0xAD18 == code || // Lo       HANGUL SYLLABLE GWAE
		0xAD34 == code || // Lo       HANGUL SYLLABLE GOE
		0xAD50 == code || // Lo       HANGUL SYLLABLE GYO
		0xAD6C == code || // Lo       HANGUL SYLLABLE GU
		0xAD88 == code || // Lo       HANGUL SYLLABLE GWEO
		0xADA4 == code || // Lo       HANGUL SYLLABLE GWE
		0xADC0 == code || // Lo       HANGUL SYLLABLE GWI
		0xADDC == code || // Lo       HANGUL SYLLABLE GYU
		0xADF8 == code || // Lo       HANGUL SYLLABLE GEU
		0xAE14 == code || // Lo       HANGUL SYLLABLE GYI
		0xAE30 == code || // Lo       HANGUL SYLLABLE GI
		0xAE4C == code || // Lo       HANGUL SYLLABLE GGA
		0xAE68 == code || // Lo       HANGUL SYLLABLE GGAE
		0xAE84 == code || // Lo       HANGUL SYLLABLE GGYA
		0xAEA0 == code || // Lo       HANGUL SYLLABLE GGYAE
		0xAEBC == code || // Lo       HANGUL SYLLABLE GGEO
		0xAED8 == code || // Lo       HANGUL SYLLABLE GGE
		0xAEF4 == code || // Lo       HANGUL SYLLABLE GGYEO
		0xAF10 == code || // Lo       HANGUL SYLLABLE GGYE
		0xAF2C == code || // Lo       HANGUL SYLLABLE GGO
		0xAF48 == code || // Lo       HANGUL SYLLABLE GGWA
		0xAF64 == code || // Lo       HANGUL SYLLABLE GGWAE
		0xAF80 == code || // Lo       HANGUL SYLLABLE GGOE
		0xAF9C == code || // Lo       HANGUL SYLLABLE GGYO
		0xAFB8 == code || // Lo       HANGUL SYLLABLE GGU
		0xAFD4 == code || // Lo       HANGUL SYLLABLE GGWEO
		0xAFF0 == code || // Lo       HANGUL SYLLABLE GGWE
		0xB00C == code || // Lo       HANGUL SYLLABLE GGWI
		0xB028 == code || // Lo       HANGUL SYLLABLE GGYU
		0xB044 == code || // Lo       HANGUL SYLLABLE GGEU
		0xB060 == code || // Lo       HANGUL SYLLABLE GGYI
		0xB07C == code || // Lo       HANGUL SYLLABLE GGI
		0xB098 == code || // Lo       HANGUL SYLLABLE NA
		0xB0B4 == code || // Lo       HANGUL SYLLABLE NAE
		0xB0D0 == code || // Lo       HANGUL SYLLABLE NYA
		0xB0EC == code || // Lo       HANGUL SYLLABLE NYAE
		0xB108 == code || // Lo       HANGUL SYLLABLE NEO
		0xB124 == code || // Lo       HANGUL SYLLABLE NE
		0xB140 == code || // Lo       HANGUL SYLLABLE NYEO
		0xB15C == code || // Lo       HANGUL SYLLABLE NYE
		0xB178 == code || // Lo       HANGUL SYLLABLE NO
		0xB194 == code || // Lo       HANGUL SYLLABLE NWA
		0xB1B0 == code || // Lo       HANGUL SYLLABLE NWAE
		0xB1CC == code || // Lo       HANGUL SYLLABLE NOE
		0xB1E8 == code || // Lo       HANGUL SYLLABLE NYO
		0xB204 == code || // Lo       HANGUL SYLLABLE NU
		0xB220 == code || // Lo       HANGUL SYLLABLE NWEO
		0xB23C == code || // Lo       HANGUL SYLLABLE NWE
		0xB258 == code || // Lo       HANGUL SYLLABLE NWI
		0xB274 == code || // Lo       HANGUL SYLLABLE NYU
		0xB290 == code || // Lo       HANGUL SYLLABLE NEU
		0xB2AC == code || // Lo       HANGUL SYLLABLE NYI
		0xB2C8 == code || // Lo       HANGUL SYLLABLE NI
		0xB2E4 == code || // Lo       HANGUL SYLLABLE DA
		0xB300 == code || // Lo       HANGUL SYLLABLE DAE
		0xB31C == code || // Lo       HANGUL SYLLABLE DYA
		0xB338 == code || // Lo       HANGUL SYLLABLE DYAE
		0xB354 == code || // Lo       HANGUL SYLLABLE DEO
		0xB370 == code || // Lo       HANGUL SYLLABLE DE
		0xB38C == code || // Lo       HANGUL SYLLABLE DYEO
		0xB3A8 == code || // Lo       HANGUL SYLLABLE DYE
		0xB3C4 == code || // Lo       HANGUL SYLLABLE DO
		0xB3E0 == code || // Lo       HANGUL SYLLABLE DWA
		0xB3FC == code || // Lo       HANGUL SYLLABLE DWAE
		0xB418 == code || // Lo       HANGUL SYLLABLE DOE
		0xB434 == code || // Lo       HANGUL SYLLABLE DYO
		0xB450 == code || // Lo       HANGUL SYLLABLE DU
		0xB46C == code || // Lo       HANGUL SYLLABLE DWEO
		0xB488 == code || // Lo       HANGUL SYLLABLE DWE
		0xB4A4 == code || // Lo       HANGUL SYLLABLE DWI
		0xB4C0 == code || // Lo       HANGUL SYLLABLE DYU
		0xB4DC == code || // Lo       HANGUL SYLLABLE DEU
		0xB4F8 == code || // Lo       HANGUL SYLLABLE DYI
		0xB514 == code || // Lo       HANGUL SYLLABLE DI
		0xB530 == code || // Lo       HANGUL SYLLABLE DDA
		0xB54C == code || // Lo       HANGUL SYLLABLE DDAE
		0xB568 == code || // Lo       HANGUL SYLLABLE DDYA
		0xB584 == code || // Lo       HANGUL SYLLABLE DDYAE
		0xB5A0 == code || // Lo       HANGUL SYLLABLE DDEO
		0xB5BC == code || // Lo       HANGUL SYLLABLE DDE
		0xB5D8 == code || // Lo       HANGUL SYLLABLE DDYEO
		0xB5F4 == code || // Lo       HANGUL SYLLABLE DDYE
		0xB610 == code || // Lo       HANGUL SYLLABLE DDO
		0xB62C == code || // Lo       HANGUL SYLLABLE DDWA
		0xB648 == code || // Lo       HANGUL SYLLABLE DDWAE
		0xB664 == code || // Lo       HANGUL SYLLABLE DDOE
		0xB680 == code || // Lo       HANGUL SYLLABLE DDYO
		0xB69C == code || // Lo       HANGUL SYLLABLE DDU
		0xB6B8 == code || // Lo       HANGUL SYLLABLE DDWEO
		0xB6D4 == code || // Lo       HANGUL SYLLABLE DDWE
		0xB6F0 == code || // Lo       HANGUL SYLLABLE DDWI
		0xB70C == code || // Lo       HANGUL SYLLABLE DDYU
		0xB728 == code || // Lo       HANGUL SYLLABLE DDEU
		0xB744 == code || // Lo       HANGUL SYLLABLE DDYI
		0xB760 == code || // Lo       HANGUL SYLLABLE DDI
		0xB77C == code || // Lo       HANGUL SYLLABLE RA
		0xB798 == code || // Lo       HANGUL SYLLABLE RAE
		0xB7B4 == code || // Lo       HANGUL SYLLABLE RYA
		0xB7D0 == code || // Lo       HANGUL SYLLABLE RYAE
		0xB7EC == code || // Lo       HANGUL SYLLABLE REO
		0xB808 == code || // Lo       HANGUL SYLLABLE RE
		0xB824 == code || // Lo       HANGUL SYLLABLE RYEO
		0xB840 == code || // Lo       HANGUL SYLLABLE RYE
		0xB85C == code || // Lo       HANGUL SYLLABLE RO
		0xB878 == code || // Lo       HANGUL SYLLABLE RWA
		0xB894 == code || // Lo       HANGUL SYLLABLE RWAE
		0xB8B0 == code || // Lo       HANGUL SYLLABLE ROE
		0xB8CC == code || // Lo       HANGUL SYLLABLE RYO
		0xB8E8 == code || // Lo       HANGUL SYLLABLE RU
		0xB904 == code || // Lo       HANGUL SYLLABLE RWEO
		0xB920 == code || // Lo       HANGUL SYLLABLE RWE
		0xB93C == code || // Lo       HANGUL SYLLABLE RWI
		0xB958 == code || // Lo       HANGUL SYLLABLE RYU
		0xB974 == code || // Lo       HANGUL SYLLABLE REU
		0xB990 == code || // Lo       HANGUL SYLLABLE RYI
		0xB9AC == code || // Lo       HANGUL SYLLABLE RI
		0xB9C8 == code || // Lo       HANGUL SYLLABLE MA
		0xB9E4 == code || // Lo       HANGUL SYLLABLE MAE
		0xBA00 == code || // Lo       HANGUL SYLLABLE MYA
		0xBA1C == code || // Lo       HANGUL SYLLABLE MYAE
		0xBA38 == code || // Lo       HANGUL SYLLABLE MEO
		0xBA54 == code || // Lo       HANGUL SYLLABLE ME
		0xBA70 == code || // Lo       HANGUL SYLLABLE MYEO
		0xBA8C == code || // Lo       HANGUL SYLLABLE MYE
		0xBAA8 == code || // Lo       HANGUL SYLLABLE MO
		0xBAC4 == code || // Lo       HANGUL SYLLABLE MWA
		0xBAE0 == code || // Lo       HANGUL SYLLABLE MWAE
		0xBAFC == code || // Lo       HANGUL SYLLABLE MOE
		0xBB18 == code || // Lo       HANGUL SYLLABLE MYO
		0xBB34 == code || // Lo       HANGUL SYLLABLE MU
		0xBB50 == code || // Lo       HANGUL SYLLABLE MWEO
		0xBB6C == code || // Lo       HANGUL SYLLABLE MWE
		0xBB88 == code || // Lo       HANGUL SYLLABLE MWI
		0xBBA4 == code || // Lo       HANGUL SYLLABLE MYU
		0xBBC0 == code || // Lo       HANGUL SYLLABLE MEU
		0xBBDC == code || // Lo       HANGUL SYLLABLE MYI
		0xBBF8 == code || // Lo       HANGUL SYLLABLE MI
		0xBC14 == code || // Lo       HANGUL SYLLABLE BA
		0xBC30 == code || // Lo       HANGUL SYLLABLE BAE
		0xBC4C == code || // Lo       HANGUL SYLLABLE BYA
		0xBC68 == code || // Lo       HANGUL SYLLABLE BYAE
		0xBC84 == code || // Lo       HANGUL SYLLABLE BEO
		0xBCA0 == code || // Lo       HANGUL SYLLABLE BE
		0xBCBC == code || // Lo       HANGUL SYLLABLE BYEO
		0xBCD8 == code || // Lo       HANGUL SYLLABLE BYE
		0xBCF4 == code || // Lo       HANGUL SYLLABLE BO
		0xBD10 == code || // Lo       HANGUL SYLLABLE BWA
		0xBD2C == code || // Lo       HANGUL SYLLABLE BWAE
		0xBD48 == code || // Lo       HANGUL SYLLABLE BOE
		0xBD64 == code || // Lo       HANGUL SYLLABLE BYO
		0xBD80 == code || // Lo       HANGUL SYLLABLE BU
		0xBD9C == code || // Lo       HANGUL SYLLABLE BWEO
		0xBDB8 == code || // Lo       HANGUL SYLLABLE BWE
		0xBDD4 == code || // Lo       HANGUL SYLLABLE BWI
		0xBDF0 == code || // Lo       HANGUL SYLLABLE BYU
		0xBE0C == code || // Lo       HANGUL SYLLABLE BEU
		0xBE28 == code || // Lo       HANGUL SYLLABLE BYI
		0xBE44 == code || // Lo       HANGUL SYLLABLE BI
		0xBE60 == code || // Lo       HANGUL SYLLABLE BBA
		0xBE7C == code || // Lo       HANGUL SYLLABLE BBAE
		0xBE98 == code || // Lo       HANGUL SYLLABLE BBYA
		0xBEB4 == code || // Lo       HANGUL SYLLABLE BBYAE
		0xBED0 == code || // Lo       HANGUL SYLLABLE BBEO
		0xBEEC == code || // Lo       HANGUL SYLLABLE BBE
		0xBF08 == code || // Lo       HANGUL SYLLABLE BBYEO
		0xBF24 == code || // Lo       HANGUL SYLLABLE BBYE
		0xBF40 == code || // Lo       HANGUL SYLLABLE BBO
		0xBF5C == code || // Lo       HANGUL SYLLABLE BBWA
		0xBF78 == code || // Lo       HANGUL SYLLABLE BBWAE
		0xBF94 == code || // Lo       HANGUL SYLLABLE BBOE
		0xBFB0 == code || // Lo       HANGUL SYLLABLE BBYO
		0xBFCC == code || // Lo       HANGUL SYLLABLE BBU
		0xBFE8 == code || // Lo       HANGUL SYLLABLE BBWEO
		0xC004 == code || // Lo       HANGUL SYLLABLE BBWE
		0xC020 == code || // Lo       HANGUL SYLLABLE BBWI
		0xC03C == code || // Lo       HANGUL SYLLABLE BBYU
		0xC058 == code || // Lo       HANGUL SYLLABLE BBEU
		0xC074 == code || // Lo       HANGUL SYLLABLE BBYI
		0xC090 == code || // Lo       HANGUL SYLLABLE BBI
		0xC0AC == code || // Lo       HANGUL SYLLABLE SA
		0xC0C8 == code || // Lo       HANGUL SYLLABLE SAE
		0xC0E4 == code || // Lo       HANGUL SYLLABLE SYA
		0xC100 == code || // Lo       HANGUL SYLLABLE SYAE
		0xC11C == code || // Lo       HANGUL SYLLABLE SEO
		0xC138 == code || // Lo       HANGUL SYLLABLE SE
		0xC154 == code || // Lo       HANGUL SYLLABLE SYEO
		0xC170 == code || // Lo       HANGUL SYLLABLE SYE
		0xC18C == code || // Lo       HANGUL SYLLABLE SO
		0xC1A8 == code || // Lo       HANGUL SYLLABLE SWA
		0xC1C4 == code || // Lo       HANGUL SYLLABLE SWAE
		0xC1E0 == code || // Lo       HANGUL SYLLABLE SOE
		0xC1FC == code || // Lo       HANGUL SYLLABLE SYO
		0xC218 == code || // Lo       HANGUL SYLLABLE SU
		0xC234 == code || // Lo       HANGUL SYLLABLE SWEO
		0xC250 == code || // Lo       HANGUL SYLLABLE SWE
		0xC26C == code || // Lo       HANGUL SYLLABLE SWI
		0xC288 == code || // Lo       HANGUL SYLLABLE SYU
		0xC2A4 == code || // Lo       HANGUL SYLLABLE SEU
		0xC2C0 == code || // Lo       HANGUL SYLLABLE SYI
		0xC2DC == code || // Lo       HANGUL SYLLABLE SI
		0xC2F8 == code || // Lo       HANGUL SYLLABLE SSA
		0xC314 == code || // Lo       HANGUL SYLLABLE SSAE
		0xC330 == code || // Lo       HANGUL SYLLABLE SSYA
		0xC34C == code || // Lo       HANGUL SYLLABLE SSYAE
		0xC368 == code || // Lo       HANGUL SYLLABLE SSEO
		0xC384 == code || // Lo       HANGUL SYLLABLE SSE
		0xC3A0 == code || // Lo       HANGUL SYLLABLE SSYEO
		0xC3BC == code || // Lo       HANGUL SYLLABLE SSYE
		0xC3D8 == code || // Lo       HANGUL SYLLABLE SSO
		0xC3F4 == code || // Lo       HANGUL SYLLABLE SSWA
		0xC410 == code || // Lo       HANGUL SYLLABLE SSWAE
		0xC42C == code || // Lo       HANGUL SYLLABLE SSOE
		0xC448 == code || // Lo       HANGUL SYLLABLE SSYO
		0xC464 == code || // Lo       HANGUL SYLLABLE SSU
		0xC480 == code || // Lo       HANGUL SYLLABLE SSWEO
		0xC49C == code || // Lo       HANGUL SYLLABLE SSWE
		0xC4B8 == code || // Lo       HANGUL SYLLABLE SSWI
		0xC4D4 == code || // Lo       HANGUL SYLLABLE SSYU
		0xC4F0 == code || // Lo       HANGUL SYLLABLE SSEU
		0xC50C == code || // Lo       HANGUL SYLLABLE SSYI
		0xC528 == code || // Lo       HANGUL SYLLABLE SSI
		0xC544 == code || // Lo       HANGUL SYLLABLE A
		0xC560 == code || // Lo       HANGUL SYLLABLE AE
		0xC57C == code || // Lo       HANGUL SYLLABLE YA
		0xC598 == code || // Lo       HANGUL SYLLABLE YAE
		0xC5B4 == code || // Lo       HANGUL SYLLABLE EO
		0xC5D0 == code || // Lo       HANGUL SYLLABLE E
		0xC5EC == code || // Lo       HANGUL SYLLABLE YEO
		0xC608 == code || // Lo       HANGUL SYLLABLE YE
		0xC624 == code || // Lo       HANGUL SYLLABLE O
		0xC640 == code || // Lo       HANGUL SYLLABLE WA
		0xC65C == code || // Lo       HANGUL SYLLABLE WAE
		0xC678 == code || // Lo       HANGUL SYLLABLE OE
		0xC694 == code || // Lo       HANGUL SYLLABLE YO
		0xC6B0 == code || // Lo       HANGUL SYLLABLE U
		0xC6CC == code || // Lo       HANGUL SYLLABLE WEO
		0xC6E8 == code || // Lo       HANGUL SYLLABLE WE
		0xC704 == code || // Lo       HANGUL SYLLABLE WI
		0xC720 == code || // Lo       HANGUL SYLLABLE YU
		0xC73C == code || // Lo       HANGUL SYLLABLE EU
		0xC758 == code || // Lo       HANGUL SYLLABLE YI
		0xC774 == code || // Lo       HANGUL SYLLABLE I
		0xC790 == code || // Lo       HANGUL SYLLABLE JA
		0xC7AC == code || // Lo       HANGUL SYLLABLE JAE
		0xC7C8 == code || // Lo       HANGUL SYLLABLE JYA
		0xC7E4 == code || // Lo       HANGUL SYLLABLE JYAE
		0xC800 == code || // Lo       HANGUL SYLLABLE JEO
		0xC81C == code || // Lo       HANGUL SYLLABLE JE
		0xC838 == code || // Lo       HANGUL SYLLABLE JYEO
		0xC854 == code || // Lo       HANGUL SYLLABLE JYE
		0xC870 == code || // Lo       HANGUL SYLLABLE JO
		0xC88C == code || // Lo       HANGUL SYLLABLE JWA
		0xC8A8 == code || // Lo       HANGUL SYLLABLE JWAE
		0xC8C4 == code || // Lo       HANGUL SYLLABLE JOE
		0xC8E0 == code || // Lo       HANGUL SYLLABLE JYO
		0xC8FC == code || // Lo       HANGUL SYLLABLE JU
		0xC918 == code || // Lo       HANGUL SYLLABLE JWEO
		0xC934 == code || // Lo       HANGUL SYLLABLE JWE
		0xC950 == code || // Lo       HANGUL SYLLABLE JWI
		0xC96C == code || // Lo       HANGUL SYLLABLE JYU
		0xC988 == code || // Lo       HANGUL SYLLABLE JEU
		0xC9A4 == code || // Lo       HANGUL SYLLABLE JYI
		0xC9C0 == code || // Lo       HANGUL SYLLABLE JI
		0xC9DC == code || // Lo       HANGUL SYLLABLE JJA
		0xC9F8 == code || // Lo       HANGUL SYLLABLE JJAE
		0xCA14 == code || // Lo       HANGUL SYLLABLE JJYA
		0xCA30 == code || // Lo       HANGUL SYLLABLE JJYAE
		0xCA4C == code || // Lo       HANGUL SYLLABLE JJEO
		0xCA68 == code || // Lo       HANGUL SYLLABLE JJE
		0xCA84 == code || // Lo       HANGUL SYLLABLE JJYEO
		0xCAA0 == code || // Lo       HANGUL SYLLABLE JJYE
		0xCABC == code || // Lo       HANGUL SYLLABLE JJO
		0xCAD8 == code || // Lo       HANGUL SYLLABLE JJWA
		0xCAF4 == code || // Lo       HANGUL SYLLABLE JJWAE
		0xCB10 == code || // Lo       HANGUL SYLLABLE JJOE
		0xCB2C == code || // Lo       HANGUL SYLLABLE JJYO
		0xCB48 == code || // Lo       HANGUL SYLLABLE JJU
		0xCB64 == code || // Lo       HANGUL SYLLABLE JJWEO
		0xCB80 == code || // Lo       HANGUL SYLLABLE JJWE
		0xCB9C == code || // Lo       HANGUL SYLLABLE JJWI
		0xCBB8 == code || // Lo       HANGUL SYLLABLE JJYU
		0xCBD4 == code || // Lo       HANGUL SYLLABLE JJEU
		0xCBF0 == code || // Lo       HANGUL SYLLABLE JJYI
		0xCC0C == code || // Lo       HANGUL SYLLABLE JJI
		0xCC28 == code || // Lo       HANGUL SYLLABLE CA
		0xCC44 == code || // Lo       HANGUL SYLLABLE CAE
		0xCC60 == code || // Lo       HANGUL SYLLABLE CYA
		0xCC7C == code || // Lo       HANGUL SYLLABLE CYAE
		0xCC98 == code || // Lo       HANGUL SYLLABLE CEO
		0xCCB4 == code || // Lo       HANGUL SYLLABLE CE
		0xCCD0 == code || // Lo       HANGUL SYLLABLE CYEO
		0xCCEC == code || // Lo       HANGUL SYLLABLE CYE
		0xCD08 == code || // Lo       HANGUL SYLLABLE CO
		0xCD24 == code || // Lo       HANGUL SYLLABLE CWA
		0xCD40 == code || // Lo       HANGUL SYLLABLE CWAE
		0xCD5C == code || // Lo       HANGUL SYLLABLE COE
		0xCD78 == code || // Lo       HANGUL SYLLABLE CYO
		0xCD94 == code || // Lo       HANGUL SYLLABLE CU
		0xCDB0 == code || // Lo       HANGUL SYLLABLE CWEO
		0xCDCC == code || // Lo       HANGUL SYLLABLE CWE
		0xCDE8 == code || // Lo       HANGUL SYLLABLE CWI
		0xCE04 == code || // Lo       HANGUL SYLLABLE CYU
		0xCE20 == code || // Lo       HANGUL SYLLABLE CEU
		0xCE3C == code || // Lo       HANGUL SYLLABLE CYI
		0xCE58 == code || // Lo       HANGUL SYLLABLE CI
		0xCE74 == code || // Lo       HANGUL SYLLABLE KA
		0xCE90 == code || // Lo       HANGUL SYLLABLE KAE
		0xCEAC == code || // Lo       HANGUL SYLLABLE KYA
		0xCEC8 == code || // Lo       HANGUL SYLLABLE KYAE
		0xCEE4 == code || // Lo       HANGUL SYLLABLE KEO
		0xCF00 == code || // Lo       HANGUL SYLLABLE KE
		0xCF1C == code || // Lo       HANGUL SYLLABLE KYEO
		0xCF38 == code || // Lo       HANGUL SYLLABLE KYE
		0xCF54 == code || // Lo       HANGUL SYLLABLE KO
		0xCF70 == code || // Lo       HANGUL SYLLABLE KWA
		0xCF8C == code || // Lo       HANGUL SYLLABLE KWAE
		0xCFA8 == code || // Lo       HANGUL SYLLABLE KOE
		0xCFC4 == code || // Lo       HANGUL SYLLABLE KYO
		0xCFE0 == code || // Lo       HANGUL SYLLABLE KU
		0xCFFC == code || // Lo       HANGUL SYLLABLE KWEO
		0xD018 == code || // Lo       HANGUL SYLLABLE KWE
		0xD034 == code || // Lo       HANGUL SYLLABLE KWI
		0xD050 == code || // Lo       HANGUL SYLLABLE KYU
		0xD06C == code || // Lo       HANGUL SYLLABLE KEU
		0xD088 == code || // Lo       HANGUL SYLLABLE KYI
		0xD0A4 == code || // Lo       HANGUL SYLLABLE KI
		0xD0C0 == code || // Lo       HANGUL SYLLABLE TA
		0xD0DC == code || // Lo       HANGUL SYLLABLE TAE
		0xD0F8 == code || // Lo       HANGUL SYLLABLE TYA
		0xD114 == code || // Lo       HANGUL SYLLABLE TYAE
		0xD130 == code || // Lo       HANGUL SYLLABLE TEO
		0xD14C == code || // Lo       HANGUL SYLLABLE TE
		0xD168 == code || // Lo       HANGUL SYLLABLE TYEO
		0xD184 == code || // Lo       HANGUL SYLLABLE TYE
		0xD1A0 == code || // Lo       HANGUL SYLLABLE TO
		0xD1BC == code || // Lo       HANGUL SYLLABLE TWA
		0xD1D8 == code || // Lo       HANGUL SYLLABLE TWAE
		0xD1F4 == code || // Lo       HANGUL SYLLABLE TOE
		0xD210 == code || // Lo       HANGUL SYLLABLE TYO
		0xD22C == code || // Lo       HANGUL SYLLABLE TU
		0xD248 == code || // Lo       HANGUL SYLLABLE TWEO
		0xD264 == code || // Lo       HANGUL SYLLABLE TWE
		0xD280 == code || // Lo       HANGUL SYLLABLE TWI
		0xD29C == code || // Lo       HANGUL SYLLABLE TYU
		0xD2B8 == code || // Lo       HANGUL SYLLABLE TEU
		0xD2D4 == code || // Lo       HANGUL SYLLABLE TYI
		0xD2F0 == code || // Lo       HANGUL SYLLABLE TI
		0xD30C == code || // Lo       HANGUL SYLLABLE PA
		0xD328 == code || // Lo       HANGUL SYLLABLE PAE
		0xD344 == code || // Lo       HANGUL SYLLABLE PYA
		0xD360 == code || // Lo       HANGUL SYLLABLE PYAE
		0xD37C == code || // Lo       HANGUL SYLLABLE PEO
		0xD398 == code || // Lo       HANGUL SYLLABLE PE
		0xD3B4 == code || // Lo       HANGUL SYLLABLE PYEO
		0xD3D0 == code || // Lo       HANGUL SYLLABLE PYE
		0xD3EC == code || // Lo       HANGUL SYLLABLE PO
		0xD408 == code || // Lo       HANGUL SYLLABLE PWA
		0xD424 == code || // Lo       HANGUL SYLLABLE PWAE
		0xD440 == code || // Lo       HANGUL SYLLABLE POE
		0xD45C == code || // Lo       HANGUL SYLLABLE PYO
		0xD478 == code || // Lo       HANGUL SYLLABLE PU
		0xD494 == code || // Lo       HANGUL SYLLABLE PWEO
		0xD4B0 == code || // Lo       HANGUL SYLLABLE PWE
		0xD4CC == code || // Lo       HANGUL SYLLABLE PWI
		0xD4E8 == code || // Lo       HANGUL SYLLABLE PYU
		0xD504 == code || // Lo       HANGUL SYLLABLE PEU
		0xD520 == code || // Lo       HANGUL SYLLABLE PYI
		0xD53C == code || // Lo       HANGUL SYLLABLE PI
		0xD558 == code || // Lo       HANGUL SYLLABLE HA
		0xD574 == code || // Lo       HANGUL SYLLABLE HAE
		0xD590 == code || // Lo       HANGUL SYLLABLE HYA
		0xD5AC == code || // Lo       HANGUL SYLLABLE HYAE
		0xD5C8 == code || // Lo       HANGUL SYLLABLE HEO
		0xD5E4 == code || // Lo       HANGUL SYLLABLE HE
		0xD600 == code || // Lo       HANGUL SYLLABLE HYEO
		0xD61C == code || // Lo       HANGUL SYLLABLE HYE
		0xD638 == code || // Lo       HANGUL SYLLABLE HO
		0xD654 == code || // Lo       HANGUL SYLLABLE HWA
		0xD670 == code || // Lo       HANGUL SYLLABLE HWAE
		0xD68C == code || // Lo       HANGUL SYLLABLE HOE
		0xD6A8 == code || // Lo       HANGUL SYLLABLE HYO
		0xD6C4 == code || // Lo       HANGUL SYLLABLE HU
		0xD6E0 == code || // Lo       HANGUL SYLLABLE HWEO
		0xD6FC == code || // Lo       HANGUL SYLLABLE HWE
		0xD718 == code || // Lo       HANGUL SYLLABLE HWI
		0xD734 == code || // Lo       HANGUL SYLLABLE HYU
		0xD750 == code || // Lo       HANGUL SYLLABLE HEU
		0xD76C == code || // Lo       HANGUL SYLLABLE HYI
		0xD788 == code // Lo       HANGUL SYLLABLE HI
		){
			return LV;
		}
		
		if(
		(0xAC01 <= code && code <= 0xAC1B) || // Lo  [27] HANGUL SYLLABLE GAG..HANGUL SYLLABLE GAH
		(0xAC1D <= code && code <= 0xAC37) || // Lo  [27] HANGUL SYLLABLE GAEG..HANGUL SYLLABLE GAEH
		(0xAC39 <= code && code <= 0xAC53) || // Lo  [27] HANGUL SYLLABLE GYAG..HANGUL SYLLABLE GYAH
		(0xAC55 <= code && code <= 0xAC6F) || // Lo  [27] HANGUL SYLLABLE GYAEG..HANGUL SYLLABLE GYAEH
		(0xAC71 <= code && code <= 0xAC8B) || // Lo  [27] HANGUL SYLLABLE GEOG..HANGUL SYLLABLE GEOH
		(0xAC8D <= code && code <= 0xACA7) || // Lo  [27] HANGUL SYLLABLE GEG..HANGUL SYLLABLE GEH
		(0xACA9 <= code && code <= 0xACC3) || // Lo  [27] HANGUL SYLLABLE GYEOG..HANGUL SYLLABLE GYEOH
		(0xACC5 <= code && code <= 0xACDF) || // Lo  [27] HANGUL SYLLABLE GYEG..HANGUL SYLLABLE GYEH
		(0xACE1 <= code && code <= 0xACFB) || // Lo  [27] HANGUL SYLLABLE GOG..HANGUL SYLLABLE GOH
		(0xACFD <= code && code <= 0xAD17) || // Lo  [27] HANGUL SYLLABLE GWAG..HANGUL SYLLABLE GWAH
		(0xAD19 <= code && code <= 0xAD33) || // Lo  [27] HANGUL SYLLABLE GWAEG..HANGUL SYLLABLE GWAEH
		(0xAD35 <= code && code <= 0xAD4F) || // Lo  [27] HANGUL SYLLABLE GOEG..HANGUL SYLLABLE GOEH
		(0xAD51 <= code && code <= 0xAD6B) || // Lo  [27] HANGUL SYLLABLE GYOG..HANGUL SYLLABLE GYOH
		(0xAD6D <= code && code <= 0xAD87) || // Lo  [27] HANGUL SYLLABLE GUG..HANGUL SYLLABLE GUH
		(0xAD89 <= code && code <= 0xADA3) || // Lo  [27] HANGUL SYLLABLE GWEOG..HANGUL SYLLABLE GWEOH
		(0xADA5 <= code && code <= 0xADBF) || // Lo  [27] HANGUL SYLLABLE GWEG..HANGUL SYLLABLE GWEH
		(0xADC1 <= code && code <= 0xADDB) || // Lo  [27] HANGUL SYLLABLE GWIG..HANGUL SYLLABLE GWIH
		(0xADDD <= code && code <= 0xADF7) || // Lo  [27] HANGUL SYLLABLE GYUG..HANGUL SYLLABLE GYUH
		(0xADF9 <= code && code <= 0xAE13) || // Lo  [27] HANGUL SYLLABLE GEUG..HANGUL SYLLABLE GEUH
		(0xAE15 <= code && code <= 0xAE2F) || // Lo  [27] HANGUL SYLLABLE GYIG..HANGUL SYLLABLE GYIH
		(0xAE31 <= code && code <= 0xAE4B) || // Lo  [27] HANGUL SYLLABLE GIG..HANGUL SYLLABLE GIH
		(0xAE4D <= code && code <= 0xAE67) || // Lo  [27] HANGUL SYLLABLE GGAG..HANGUL SYLLABLE GGAH
		(0xAE69 <= code && code <= 0xAE83) || // Lo  [27] HANGUL SYLLABLE GGAEG..HANGUL SYLLABLE GGAEH
		(0xAE85 <= code && code <= 0xAE9F) || // Lo  [27] HANGUL SYLLABLE GGYAG..HANGUL SYLLABLE GGYAH
		(0xAEA1 <= code && code <= 0xAEBB) || // Lo  [27] HANGUL SYLLABLE GGYAEG..HANGUL SYLLABLE GGYAEH
		(0xAEBD <= code && code <= 0xAED7) || // Lo  [27] HANGUL SYLLABLE GGEOG..HANGUL SYLLABLE GGEOH
		(0xAED9 <= code && code <= 0xAEF3) || // Lo  [27] HANGUL SYLLABLE GGEG..HANGUL SYLLABLE GGEH
		(0xAEF5 <= code && code <= 0xAF0F) || // Lo  [27] HANGUL SYLLABLE GGYEOG..HANGUL SYLLABLE GGYEOH
		(0xAF11 <= code && code <= 0xAF2B) || // Lo  [27] HANGUL SYLLABLE GGYEG..HANGUL SYLLABLE GGYEH
		(0xAF2D <= code && code <= 0xAF47) || // Lo  [27] HANGUL SYLLABLE GGOG..HANGUL SYLLABLE GGOH
		(0xAF49 <= code && code <= 0xAF63) || // Lo  [27] HANGUL SYLLABLE GGWAG..HANGUL SYLLABLE GGWAH
		(0xAF65 <= code && code <= 0xAF7F) || // Lo  [27] HANGUL SYLLABLE GGWAEG..HANGUL SYLLABLE GGWAEH
		(0xAF81 <= code && code <= 0xAF9B) || // Lo  [27] HANGUL SYLLABLE GGOEG..HANGUL SYLLABLE GGOEH
		(0xAF9D <= code && code <= 0xAFB7) || // Lo  [27] HANGUL SYLLABLE GGYOG..HANGUL SYLLABLE GGYOH
		(0xAFB9 <= code && code <= 0xAFD3) || // Lo  [27] HANGUL SYLLABLE GGUG..HANGUL SYLLABLE GGUH
		(0xAFD5 <= code && code <= 0xAFEF) || // Lo  [27] HANGUL SYLLABLE GGWEOG..HANGUL SYLLABLE GGWEOH
		(0xAFF1 <= code && code <= 0xB00B) || // Lo  [27] HANGUL SYLLABLE GGWEG..HANGUL SYLLABLE GGWEH
		(0xB00D <= code && code <= 0xB027) || // Lo  [27] HANGUL SYLLABLE GGWIG..HANGUL SYLLABLE GGWIH
		(0xB029 <= code && code <= 0xB043) || // Lo  [27] HANGUL SYLLABLE GGYUG..HANGUL SYLLABLE GGYUH
		(0xB045 <= code && code <= 0xB05F) || // Lo  [27] HANGUL SYLLABLE GGEUG..HANGUL SYLLABLE GGEUH
		(0xB061 <= code && code <= 0xB07B) || // Lo  [27] HANGUL SYLLABLE GGYIG..HANGUL SYLLABLE GGYIH
		(0xB07D <= code && code <= 0xB097) || // Lo  [27] HANGUL SYLLABLE GGIG..HANGUL SYLLABLE GGIH
		(0xB099 <= code && code <= 0xB0B3) || // Lo  [27] HANGUL SYLLABLE NAG..HANGUL SYLLABLE NAH
		(0xB0B5 <= code && code <= 0xB0CF) || // Lo  [27] HANGUL SYLLABLE NAEG..HANGUL SYLLABLE NAEH
		(0xB0D1 <= code && code <= 0xB0EB) || // Lo  [27] HANGUL SYLLABLE NYAG..HANGUL SYLLABLE NYAH
		(0xB0ED <= code && code <= 0xB107) || // Lo  [27] HANGUL SYLLABLE NYAEG..HANGUL SYLLABLE NYAEH
		(0xB109 <= code && code <= 0xB123) || // Lo  [27] HANGUL SYLLABLE NEOG..HANGUL SYLLABLE NEOH
		(0xB125 <= code && code <= 0xB13F) || // Lo  [27] HANGUL SYLLABLE NEG..HANGUL SYLLABLE NEH
		(0xB141 <= code && code <= 0xB15B) || // Lo  [27] HANGUL SYLLABLE NYEOG..HANGUL SYLLABLE NYEOH
		(0xB15D <= code && code <= 0xB177) || // Lo  [27] HANGUL SYLLABLE NYEG..HANGUL SYLLABLE NYEH
		(0xB179 <= code && code <= 0xB193) || // Lo  [27] HANGUL SYLLABLE NOG..HANGUL SYLLABLE NOH
		(0xB195 <= code && code <= 0xB1AF) || // Lo  [27] HANGUL SYLLABLE NWAG..HANGUL SYLLABLE NWAH
		(0xB1B1 <= code && code <= 0xB1CB) || // Lo  [27] HANGUL SYLLABLE NWAEG..HANGUL SYLLABLE NWAEH
		(0xB1CD <= code && code <= 0xB1E7) || // Lo  [27] HANGUL SYLLABLE NOEG..HANGUL SYLLABLE NOEH
		(0xB1E9 <= code && code <= 0xB203) || // Lo  [27] HANGUL SYLLABLE NYOG..HANGUL SYLLABLE NYOH
		(0xB205 <= code && code <= 0xB21F) || // Lo  [27] HANGUL SYLLABLE NUG..HANGUL SYLLABLE NUH
		(0xB221 <= code && code <= 0xB23B) || // Lo  [27] HANGUL SYLLABLE NWEOG..HANGUL SYLLABLE NWEOH
		(0xB23D <= code && code <= 0xB257) || // Lo  [27] HANGUL SYLLABLE NWEG..HANGUL SYLLABLE NWEH
		(0xB259 <= code && code <= 0xB273) || // Lo  [27] HANGUL SYLLABLE NWIG..HANGUL SYLLABLE NWIH
		(0xB275 <= code && code <= 0xB28F) || // Lo  [27] HANGUL SYLLABLE NYUG..HANGUL SYLLABLE NYUH
		(0xB291 <= code && code <= 0xB2AB) || // Lo  [27] HANGUL SYLLABLE NEUG..HANGUL SYLLABLE NEUH
		(0xB2AD <= code && code <= 0xB2C7) || // Lo  [27] HANGUL SYLLABLE NYIG..HANGUL SYLLABLE NYIH
		(0xB2C9 <= code && code <= 0xB2E3) || // Lo  [27] HANGUL SYLLABLE NIG..HANGUL SYLLABLE NIH
		(0xB2E5 <= code && code <= 0xB2FF) || // Lo  [27] HANGUL SYLLABLE DAG..HANGUL SYLLABLE DAH
		(0xB301 <= code && code <= 0xB31B) || // Lo  [27] HANGUL SYLLABLE DAEG..HANGUL SYLLABLE DAEH
		(0xB31D <= code && code <= 0xB337) || // Lo  [27] HANGUL SYLLABLE DYAG..HANGUL SYLLABLE DYAH
		(0xB339 <= code && code <= 0xB353) || // Lo  [27] HANGUL SYLLABLE DYAEG..HANGUL SYLLABLE DYAEH
		(0xB355 <= code && code <= 0xB36F) || // Lo  [27] HANGUL SYLLABLE DEOG..HANGUL SYLLABLE DEOH
		(0xB371 <= code && code <= 0xB38B) || // Lo  [27] HANGUL SYLLABLE DEG..HANGUL SYLLABLE DEH
		(0xB38D <= code && code <= 0xB3A7) || // Lo  [27] HANGUL SYLLABLE DYEOG..HANGUL SYLLABLE DYEOH
		(0xB3A9 <= code && code <= 0xB3C3) || // Lo  [27] HANGUL SYLLABLE DYEG..HANGUL SYLLABLE DYEH
		(0xB3C5 <= code && code <= 0xB3DF) || // Lo  [27] HANGUL SYLLABLE DOG..HANGUL SYLLABLE DOH
		(0xB3E1 <= code && code <= 0xB3FB) || // Lo  [27] HANGUL SYLLABLE DWAG..HANGUL SYLLABLE DWAH
		(0xB3FD <= code && code <= 0xB417) || // Lo  [27] HANGUL SYLLABLE DWAEG..HANGUL SYLLABLE DWAEH
		(0xB419 <= code && code <= 0xB433) || // Lo  [27] HANGUL SYLLABLE DOEG..HANGUL SYLLABLE DOEH
		(0xB435 <= code && code <= 0xB44F) || // Lo  [27] HANGUL SYLLABLE DYOG..HANGUL SYLLABLE DYOH
		(0xB451 <= code && code <= 0xB46B) || // Lo  [27] HANGUL SYLLABLE DUG..HANGUL SYLLABLE DUH
		(0xB46D <= code && code <= 0xB487) || // Lo  [27] HANGUL SYLLABLE DWEOG..HANGUL SYLLABLE DWEOH
		(0xB489 <= code && code <= 0xB4A3) || // Lo  [27] HANGUL SYLLABLE DWEG..HANGUL SYLLABLE DWEH
		(0xB4A5 <= code && code <= 0xB4BF) || // Lo  [27] HANGUL SYLLABLE DWIG..HANGUL SYLLABLE DWIH
		(0xB4C1 <= code && code <= 0xB4DB) || // Lo  [27] HANGUL SYLLABLE DYUG..HANGUL SYLLABLE DYUH
		(0xB4DD <= code && code <= 0xB4F7) || // Lo  [27] HANGUL SYLLABLE DEUG..HANGUL SYLLABLE DEUH
		(0xB4F9 <= code && code <= 0xB513) || // Lo  [27] HANGUL SYLLABLE DYIG..HANGUL SYLLABLE DYIH
		(0xB515 <= code && code <= 0xB52F) || // Lo  [27] HANGUL SYLLABLE DIG..HANGUL SYLLABLE DIH
		(0xB531 <= code && code <= 0xB54B) || // Lo  [27] HANGUL SYLLABLE DDAG..HANGUL SYLLABLE DDAH
		(0xB54D <= code && code <= 0xB567) || // Lo  [27] HANGUL SYLLABLE DDAEG..HANGUL SYLLABLE DDAEH
		(0xB569 <= code && code <= 0xB583) || // Lo  [27] HANGUL SYLLABLE DDYAG..HANGUL SYLLABLE DDYAH
		(0xB585 <= code && code <= 0xB59F) || // Lo  [27] HANGUL SYLLABLE DDYAEG..HANGUL SYLLABLE DDYAEH
		(0xB5A1 <= code && code <= 0xB5BB) || // Lo  [27] HANGUL SYLLABLE DDEOG..HANGUL SYLLABLE DDEOH
		(0xB5BD <= code && code <= 0xB5D7) || // Lo  [27] HANGUL SYLLABLE DDEG..HANGUL SYLLABLE DDEH
		(0xB5D9 <= code && code <= 0xB5F3) || // Lo  [27] HANGUL SYLLABLE DDYEOG..HANGUL SYLLABLE DDYEOH
		(0xB5F5 <= code && code <= 0xB60F) || // Lo  [27] HANGUL SYLLABLE DDYEG..HANGUL SYLLABLE DDYEH
		(0xB611 <= code && code <= 0xB62B) || // Lo  [27] HANGUL SYLLABLE DDOG..HANGUL SYLLABLE DDOH
		(0xB62D <= code && code <= 0xB647) || // Lo  [27] HANGUL SYLLABLE DDWAG..HANGUL SYLLABLE DDWAH
		(0xB649 <= code && code <= 0xB663) || // Lo  [27] HANGUL SYLLABLE DDWAEG..HANGUL SYLLABLE DDWAEH
		(0xB665 <= code && code <= 0xB67F) || // Lo  [27] HANGUL SYLLABLE DDOEG..HANGUL SYLLABLE DDOEH
		(0xB681 <= code && code <= 0xB69B) || // Lo  [27] HANGUL SYLLABLE DDYOG..HANGUL SYLLABLE DDYOH
		(0xB69D <= code && code <= 0xB6B7) || // Lo  [27] HANGUL SYLLABLE DDUG..HANGUL SYLLABLE DDUH
		(0xB6B9 <= code && code <= 0xB6D3) || // Lo  [27] HANGUL SYLLABLE DDWEOG..HANGUL SYLLABLE DDWEOH
		(0xB6D5 <= code && code <= 0xB6EF) || // Lo  [27] HANGUL SYLLABLE DDWEG..HANGUL SYLLABLE DDWEH
		(0xB6F1 <= code && code <= 0xB70B) || // Lo  [27] HANGUL SYLLABLE DDWIG..HANGUL SYLLABLE DDWIH
		(0xB70D <= code && code <= 0xB727) || // Lo  [27] HANGUL SYLLABLE DDYUG..HANGUL SYLLABLE DDYUH
		(0xB729 <= code && code <= 0xB743) || // Lo  [27] HANGUL SYLLABLE DDEUG..HANGUL SYLLABLE DDEUH
		(0xB745 <= code && code <= 0xB75F) || // Lo  [27] HANGUL SYLLABLE DDYIG..HANGUL SYLLABLE DDYIH
		(0xB761 <= code && code <= 0xB77B) || // Lo  [27] HANGUL SYLLABLE DDIG..HANGUL SYLLABLE DDIH
		(0xB77D <= code && code <= 0xB797) || // Lo  [27] HANGUL SYLLABLE RAG..HANGUL SYLLABLE RAH
		(0xB799 <= code && code <= 0xB7B3) || // Lo  [27] HANGUL SYLLABLE RAEG..HANGUL SYLLABLE RAEH
		(0xB7B5 <= code && code <= 0xB7CF) || // Lo  [27] HANGUL SYLLABLE RYAG..HANGUL SYLLABLE RYAH
		(0xB7D1 <= code && code <= 0xB7EB) || // Lo  [27] HANGUL SYLLABLE RYAEG..HANGUL SYLLABLE RYAEH
		(0xB7ED <= code && code <= 0xB807) || // Lo  [27] HANGUL SYLLABLE REOG..HANGUL SYLLABLE REOH
		(0xB809 <= code && code <= 0xB823) || // Lo  [27] HANGUL SYLLABLE REG..HANGUL SYLLABLE REH
		(0xB825 <= code && code <= 0xB83F) || // Lo  [27] HANGUL SYLLABLE RYEOG..HANGUL SYLLABLE RYEOH
		(0xB841 <= code && code <= 0xB85B) || // Lo  [27] HANGUL SYLLABLE RYEG..HANGUL SYLLABLE RYEH
		(0xB85D <= code && code <= 0xB877) || // Lo  [27] HANGUL SYLLABLE ROG..HANGUL SYLLABLE ROH
		(0xB879 <= code && code <= 0xB893) || // Lo  [27] HANGUL SYLLABLE RWAG..HANGUL SYLLABLE RWAH
		(0xB895 <= code && code <= 0xB8AF) || // Lo  [27] HANGUL SYLLABLE RWAEG..HANGUL SYLLABLE RWAEH
		(0xB8B1 <= code && code <= 0xB8CB) || // Lo  [27] HANGUL SYLLABLE ROEG..HANGUL SYLLABLE ROEH
		(0xB8CD <= code && code <= 0xB8E7) || // Lo  [27] HANGUL SYLLABLE RYOG..HANGUL SYLLABLE RYOH
		(0xB8E9 <= code && code <= 0xB903) || // Lo  [27] HANGUL SYLLABLE RUG..HANGUL SYLLABLE RUH
		(0xB905 <= code && code <= 0xB91F) || // Lo  [27] HANGUL SYLLABLE RWEOG..HANGUL SYLLABLE RWEOH
		(0xB921 <= code && code <= 0xB93B) || // Lo  [27] HANGUL SYLLABLE RWEG..HANGUL SYLLABLE RWEH
		(0xB93D <= code && code <= 0xB957) || // Lo  [27] HANGUL SYLLABLE RWIG..HANGUL SYLLABLE RWIH
		(0xB959 <= code && code <= 0xB973) || // Lo  [27] HANGUL SYLLABLE RYUG..HANGUL SYLLABLE RYUH
		(0xB975 <= code && code <= 0xB98F) || // Lo  [27] HANGUL SYLLABLE REUG..HANGUL SYLLABLE REUH
		(0xB991 <= code && code <= 0xB9AB) || // Lo  [27] HANGUL SYLLABLE RYIG..HANGUL SYLLABLE RYIH
		(0xB9AD <= code && code <= 0xB9C7) || // Lo  [27] HANGUL SYLLABLE RIG..HANGUL SYLLABLE RIH
		(0xB9C9 <= code && code <= 0xB9E3) || // Lo  [27] HANGUL SYLLABLE MAG..HANGUL SYLLABLE MAH
		(0xB9E5 <= code && code <= 0xB9FF) || // Lo  [27] HANGUL SYLLABLE MAEG..HANGUL SYLLABLE MAEH
		(0xBA01 <= code && code <= 0xBA1B) || // Lo  [27] HANGUL SYLLABLE MYAG..HANGUL SYLLABLE MYAH
		(0xBA1D <= code && code <= 0xBA37) || // Lo  [27] HANGUL SYLLABLE MYAEG..HANGUL SYLLABLE MYAEH
		(0xBA39 <= code && code <= 0xBA53) || // Lo  [27] HANGUL SYLLABLE MEOG..HANGUL SYLLABLE MEOH
		(0xBA55 <= code && code <= 0xBA6F) || // Lo  [27] HANGUL SYLLABLE MEG..HANGUL SYLLABLE MEH
		(0xBA71 <= code && code <= 0xBA8B) || // Lo  [27] HANGUL SYLLABLE MYEOG..HANGUL SYLLABLE MYEOH
		(0xBA8D <= code && code <= 0xBAA7) || // Lo  [27] HANGUL SYLLABLE MYEG..HANGUL SYLLABLE MYEH
		(0xBAA9 <= code && code <= 0xBAC3) || // Lo  [27] HANGUL SYLLABLE MOG..HANGUL SYLLABLE MOH
		(0xBAC5 <= code && code <= 0xBADF) || // Lo  [27] HANGUL SYLLABLE MWAG..HANGUL SYLLABLE MWAH
		(0xBAE1 <= code && code <= 0xBAFB) || // Lo  [27] HANGUL SYLLABLE MWAEG..HANGUL SYLLABLE MWAEH
		(0xBAFD <= code && code <= 0xBB17) || // Lo  [27] HANGUL SYLLABLE MOEG..HANGUL SYLLABLE MOEH
		(0xBB19 <= code && code <= 0xBB33) || // Lo  [27] HANGUL SYLLABLE MYOG..HANGUL SYLLABLE MYOH
		(0xBB35 <= code && code <= 0xBB4F) || // Lo  [27] HANGUL SYLLABLE MUG..HANGUL SYLLABLE MUH
		(0xBB51 <= code && code <= 0xBB6B) || // Lo  [27] HANGUL SYLLABLE MWEOG..HANGUL SYLLABLE MWEOH
		(0xBB6D <= code && code <= 0xBB87) || // Lo  [27] HANGUL SYLLABLE MWEG..HANGUL SYLLABLE MWEH
		(0xBB89 <= code && code <= 0xBBA3) || // Lo  [27] HANGUL SYLLABLE MWIG..HANGUL SYLLABLE MWIH
		(0xBBA5 <= code && code <= 0xBBBF) || // Lo  [27] HANGUL SYLLABLE MYUG..HANGUL SYLLABLE MYUH
		(0xBBC1 <= code && code <= 0xBBDB) || // Lo  [27] HANGUL SYLLABLE MEUG..HANGUL SYLLABLE MEUH
		(0xBBDD <= code && code <= 0xBBF7) || // Lo  [27] HANGUL SYLLABLE MYIG..HANGUL SYLLABLE MYIH
		(0xBBF9 <= code && code <= 0xBC13) || // Lo  [27] HANGUL SYLLABLE MIG..HANGUL SYLLABLE MIH
		(0xBC15 <= code && code <= 0xBC2F) || // Lo  [27] HANGUL SYLLABLE BAG..HANGUL SYLLABLE BAH
		(0xBC31 <= code && code <= 0xBC4B) || // Lo  [27] HANGUL SYLLABLE BAEG..HANGUL SYLLABLE BAEH
		(0xBC4D <= code && code <= 0xBC67) || // Lo  [27] HANGUL SYLLABLE BYAG..HANGUL SYLLABLE BYAH
		(0xBC69 <= code && code <= 0xBC83) || // Lo  [27] HANGUL SYLLABLE BYAEG..HANGUL SYLLABLE BYAEH
		(0xBC85 <= code && code <= 0xBC9F) || // Lo  [27] HANGUL SYLLABLE BEOG..HANGUL SYLLABLE BEOH
		(0xBCA1 <= code && code <= 0xBCBB) || // Lo  [27] HANGUL SYLLABLE BEG..HANGUL SYLLABLE BEH
		(0xBCBD <= code && code <= 0xBCD7) || // Lo  [27] HANGUL SYLLABLE BYEOG..HANGUL SYLLABLE BYEOH
		(0xBCD9 <= code && code <= 0xBCF3) || // Lo  [27] HANGUL SYLLABLE BYEG..HANGUL SYLLABLE BYEH
		(0xBCF5 <= code && code <= 0xBD0F) || // Lo  [27] HANGUL SYLLABLE BOG..HANGUL SYLLABLE BOH
		(0xBD11 <= code && code <= 0xBD2B) || // Lo  [27] HANGUL SYLLABLE BWAG..HANGUL SYLLABLE BWAH
		(0xBD2D <= code && code <= 0xBD47) || // Lo  [27] HANGUL SYLLABLE BWAEG..HANGUL SYLLABLE BWAEH
		(0xBD49 <= code && code <= 0xBD63) || // Lo  [27] HANGUL SYLLABLE BOEG..HANGUL SYLLABLE BOEH
		(0xBD65 <= code && code <= 0xBD7F) || // Lo  [27] HANGUL SYLLABLE BYOG..HANGUL SYLLABLE BYOH
		(0xBD81 <= code && code <= 0xBD9B) || // Lo  [27] HANGUL SYLLABLE BUG..HANGUL SYLLABLE BUH
		(0xBD9D <= code && code <= 0xBDB7) || // Lo  [27] HANGUL SYLLABLE BWEOG..HANGUL SYLLABLE BWEOH
		(0xBDB9 <= code && code <= 0xBDD3) || // Lo  [27] HANGUL SYLLABLE BWEG..HANGUL SYLLABLE BWEH
		(0xBDD5 <= code && code <= 0xBDEF) || // Lo  [27] HANGUL SYLLABLE BWIG..HANGUL SYLLABLE BWIH
		(0xBDF1 <= code && code <= 0xBE0B) || // Lo  [27] HANGUL SYLLABLE BYUG..HANGUL SYLLABLE BYUH
		(0xBE0D <= code && code <= 0xBE27) || // Lo  [27] HANGUL SYLLABLE BEUG..HANGUL SYLLABLE BEUH
		(0xBE29 <= code && code <= 0xBE43) || // Lo  [27] HANGUL SYLLABLE BYIG..HANGUL SYLLABLE BYIH
		(0xBE45 <= code && code <= 0xBE5F) || // Lo  [27] HANGUL SYLLABLE BIG..HANGUL SYLLABLE BIH
		(0xBE61 <= code && code <= 0xBE7B) || // Lo  [27] HANGUL SYLLABLE BBAG..HANGUL SYLLABLE BBAH
		(0xBE7D <= code && code <= 0xBE97) || // Lo  [27] HANGUL SYLLABLE BBAEG..HANGUL SYLLABLE BBAEH
		(0xBE99 <= code && code <= 0xBEB3) || // Lo  [27] HANGUL SYLLABLE BBYAG..HANGUL SYLLABLE BBYAH
		(0xBEB5 <= code && code <= 0xBECF) || // Lo  [27] HANGUL SYLLABLE BBYAEG..HANGUL SYLLABLE BBYAEH
		(0xBED1 <= code && code <= 0xBEEB) || // Lo  [27] HANGUL SYLLABLE BBEOG..HANGUL SYLLABLE BBEOH
		(0xBEED <= code && code <= 0xBF07) || // Lo  [27] HANGUL SYLLABLE BBEG..HANGUL SYLLABLE BBEH
		(0xBF09 <= code && code <= 0xBF23) || // Lo  [27] HANGUL SYLLABLE BBYEOG..HANGUL SYLLABLE BBYEOH
		(0xBF25 <= code && code <= 0xBF3F) || // Lo  [27] HANGUL SYLLABLE BBYEG..HANGUL SYLLABLE BBYEH
		(0xBF41 <= code && code <= 0xBF5B) || // Lo  [27] HANGUL SYLLABLE BBOG..HANGUL SYLLABLE BBOH
		(0xBF5D <= code && code <= 0xBF77) || // Lo  [27] HANGUL SYLLABLE BBWAG..HANGUL SYLLABLE BBWAH
		(0xBF79 <= code && code <= 0xBF93) || // Lo  [27] HANGUL SYLLABLE BBWAEG..HANGUL SYLLABLE BBWAEH
		(0xBF95 <= code && code <= 0xBFAF) || // Lo  [27] HANGUL SYLLABLE BBOEG..HANGUL SYLLABLE BBOEH
		(0xBFB1 <= code && code <= 0xBFCB) || // Lo  [27] HANGUL SYLLABLE BBYOG..HANGUL SYLLABLE BBYOH
		(0xBFCD <= code && code <= 0xBFE7) || // Lo  [27] HANGUL SYLLABLE BBUG..HANGUL SYLLABLE BBUH
		(0xBFE9 <= code && code <= 0xC003) || // Lo  [27] HANGUL SYLLABLE BBWEOG..HANGUL SYLLABLE BBWEOH
		(0xC005 <= code && code <= 0xC01F) || // Lo  [27] HANGUL SYLLABLE BBWEG..HANGUL SYLLABLE BBWEH
		(0xC021 <= code && code <= 0xC03B) || // Lo  [27] HANGUL SYLLABLE BBWIG..HANGUL SYLLABLE BBWIH
		(0xC03D <= code && code <= 0xC057) || // Lo  [27] HANGUL SYLLABLE BBYUG..HANGUL SYLLABLE BBYUH
		(0xC059 <= code && code <= 0xC073) || // Lo  [27] HANGUL SYLLABLE BBEUG..HANGUL SYLLABLE BBEUH
		(0xC075 <= code && code <= 0xC08F) || // Lo  [27] HANGUL SYLLABLE BBYIG..HANGUL SYLLABLE BBYIH
		(0xC091 <= code && code <= 0xC0AB) || // Lo  [27] HANGUL SYLLABLE BBIG..HANGUL SYLLABLE BBIH
		(0xC0AD <= code && code <= 0xC0C7) || // Lo  [27] HANGUL SYLLABLE SAG..HANGUL SYLLABLE SAH
		(0xC0C9 <= code && code <= 0xC0E3) || // Lo  [27] HANGUL SYLLABLE SAEG..HANGUL SYLLABLE SAEH
		(0xC0E5 <= code && code <= 0xC0FF) || // Lo  [27] HANGUL SYLLABLE SYAG..HANGUL SYLLABLE SYAH
		(0xC101 <= code && code <= 0xC11B) || // Lo  [27] HANGUL SYLLABLE SYAEG..HANGUL SYLLABLE SYAEH
		(0xC11D <= code && code <= 0xC137) || // Lo  [27] HANGUL SYLLABLE SEOG..HANGUL SYLLABLE SEOH
		(0xC139 <= code && code <= 0xC153) || // Lo  [27] HANGUL SYLLABLE SEG..HANGUL SYLLABLE SEH
		(0xC155 <= code && code <= 0xC16F) || // Lo  [27] HANGUL SYLLABLE SYEOG..HANGUL SYLLABLE SYEOH
		(0xC171 <= code && code <= 0xC18B) || // Lo  [27] HANGUL SYLLABLE SYEG..HANGUL SYLLABLE SYEH
		(0xC18D <= code && code <= 0xC1A7) || // Lo  [27] HANGUL SYLLABLE SOG..HANGUL SYLLABLE SOH
		(0xC1A9 <= code && code <= 0xC1C3) || // Lo  [27] HANGUL SYLLABLE SWAG..HANGUL SYLLABLE SWAH
		(0xC1C5 <= code && code <= 0xC1DF) || // Lo  [27] HANGUL SYLLABLE SWAEG..HANGUL SYLLABLE SWAEH
		(0xC1E1 <= code && code <= 0xC1FB) || // Lo  [27] HANGUL SYLLABLE SOEG..HANGUL SYLLABLE SOEH
		(0xC1FD <= code && code <= 0xC217) || // Lo  [27] HANGUL SYLLABLE SYOG..HANGUL SYLLABLE SYOH
		(0xC219 <= code && code <= 0xC233) || // Lo  [27] HANGUL SYLLABLE SUG..HANGUL SYLLABLE SUH
		(0xC235 <= code && code <= 0xC24F) || // Lo  [27] HANGUL SYLLABLE SWEOG..HANGUL SYLLABLE SWEOH
		(0xC251 <= code && code <= 0xC26B) || // Lo  [27] HANGUL SYLLABLE SWEG..HANGUL SYLLABLE SWEH
		(0xC26D <= code && code <= 0xC287) || // Lo  [27] HANGUL SYLLABLE SWIG..HANGUL SYLLABLE SWIH
		(0xC289 <= code && code <= 0xC2A3) || // Lo  [27] HANGUL SYLLABLE SYUG..HANGUL SYLLABLE SYUH
		(0xC2A5 <= code && code <= 0xC2BF) || // Lo  [27] HANGUL SYLLABLE SEUG..HANGUL SYLLABLE SEUH
		(0xC2C1 <= code && code <= 0xC2DB) || // Lo  [27] HANGUL SYLLABLE SYIG..HANGUL SYLLABLE SYIH
		(0xC2DD <= code && code <= 0xC2F7) || // Lo  [27] HANGUL SYLLABLE SIG..HANGUL SYLLABLE SIH
		(0xC2F9 <= code && code <= 0xC313) || // Lo  [27] HANGUL SYLLABLE SSAG..HANGUL SYLLABLE SSAH
		(0xC315 <= code && code <= 0xC32F) || // Lo  [27] HANGUL SYLLABLE SSAEG..HANGUL SYLLABLE SSAEH
		(0xC331 <= code && code <= 0xC34B) || // Lo  [27] HANGUL SYLLABLE SSYAG..HANGUL SYLLABLE SSYAH
		(0xC34D <= code && code <= 0xC367) || // Lo  [27] HANGUL SYLLABLE SSYAEG..HANGUL SYLLABLE SSYAEH
		(0xC369 <= code && code <= 0xC383) || // Lo  [27] HANGUL SYLLABLE SSEOG..HANGUL SYLLABLE SSEOH
		(0xC385 <= code && code <= 0xC39F) || // Lo  [27] HANGUL SYLLABLE SSEG..HANGUL SYLLABLE SSEH
		(0xC3A1 <= code && code <= 0xC3BB) || // Lo  [27] HANGUL SYLLABLE SSYEOG..HANGUL SYLLABLE SSYEOH
		(0xC3BD <= code && code <= 0xC3D7) || // Lo  [27] HANGUL SYLLABLE SSYEG..HANGUL SYLLABLE SSYEH
		(0xC3D9 <= code && code <= 0xC3F3) || // Lo  [27] HANGUL SYLLABLE SSOG..HANGUL SYLLABLE SSOH
		(0xC3F5 <= code && code <= 0xC40F) || // Lo  [27] HANGUL SYLLABLE SSWAG..HANGUL SYLLABLE SSWAH
		(0xC411 <= code && code <= 0xC42B) || // Lo  [27] HANGUL SYLLABLE SSWAEG..HANGUL SYLLABLE SSWAEH
		(0xC42D <= code && code <= 0xC447) || // Lo  [27] HANGUL SYLLABLE SSOEG..HANGUL SYLLABLE SSOEH
		(0xC449 <= code && code <= 0xC463) || // Lo  [27] HANGUL SYLLABLE SSYOG..HANGUL SYLLABLE SSYOH
		(0xC465 <= code && code <= 0xC47F) || // Lo  [27] HANGUL SYLLABLE SSUG..HANGUL SYLLABLE SSUH
		(0xC481 <= code && code <= 0xC49B) || // Lo  [27] HANGUL SYLLABLE SSWEOG..HANGUL SYLLABLE SSWEOH
		(0xC49D <= code && code <= 0xC4B7) || // Lo  [27] HANGUL SYLLABLE SSWEG..HANGUL SYLLABLE SSWEH
		(0xC4B9 <= code && code <= 0xC4D3) || // Lo  [27] HANGUL SYLLABLE SSWIG..HANGUL SYLLABLE SSWIH
		(0xC4D5 <= code && code <= 0xC4EF) || // Lo  [27] HANGUL SYLLABLE SSYUG..HANGUL SYLLABLE SSYUH
		(0xC4F1 <= code && code <= 0xC50B) || // Lo  [27] HANGUL SYLLABLE SSEUG..HANGUL SYLLABLE SSEUH
		(0xC50D <= code && code <= 0xC527) || // Lo  [27] HANGUL SYLLABLE SSYIG..HANGUL SYLLABLE SSYIH
		(0xC529 <= code && code <= 0xC543) || // Lo  [27] HANGUL SYLLABLE SSIG..HANGUL SYLLABLE SSIH
		(0xC545 <= code && code <= 0xC55F) || // Lo  [27] HANGUL SYLLABLE AG..HANGUL SYLLABLE AH
		(0xC561 <= code && code <= 0xC57B) || // Lo  [27] HANGUL SYLLABLE AEG..HANGUL SYLLABLE AEH
		(0xC57D <= code && code <= 0xC597) || // Lo  [27] HANGUL SYLLABLE YAG..HANGUL SYLLABLE YAH
		(0xC599 <= code && code <= 0xC5B3) || // Lo  [27] HANGUL SYLLABLE YAEG..HANGUL SYLLABLE YAEH
		(0xC5B5 <= code && code <= 0xC5CF) || // Lo  [27] HANGUL SYLLABLE EOG..HANGUL SYLLABLE EOH
		(0xC5D1 <= code && code <= 0xC5EB) || // Lo  [27] HANGUL SYLLABLE EG..HANGUL SYLLABLE EH
		(0xC5ED <= code && code <= 0xC607) || // Lo  [27] HANGUL SYLLABLE YEOG..HANGUL SYLLABLE YEOH
		(0xC609 <= code && code <= 0xC623) || // Lo  [27] HANGUL SYLLABLE YEG..HANGUL SYLLABLE YEH
		(0xC625 <= code && code <= 0xC63F) || // Lo  [27] HANGUL SYLLABLE OG..HANGUL SYLLABLE OH
		(0xC641 <= code && code <= 0xC65B) || // Lo  [27] HANGUL SYLLABLE WAG..HANGUL SYLLABLE WAH
		(0xC65D <= code && code <= 0xC677) || // Lo  [27] HANGUL SYLLABLE WAEG..HANGUL SYLLABLE WAEH
		(0xC679 <= code && code <= 0xC693) || // Lo  [27] HANGUL SYLLABLE OEG..HANGUL SYLLABLE OEH
		(0xC695 <= code && code <= 0xC6AF) || // Lo  [27] HANGUL SYLLABLE YOG..HANGUL SYLLABLE YOH
		(0xC6B1 <= code && code <= 0xC6CB) || // Lo  [27] HANGUL SYLLABLE UG..HANGUL SYLLABLE UH
		(0xC6CD <= code && code <= 0xC6E7) || // Lo  [27] HANGUL SYLLABLE WEOG..HANGUL SYLLABLE WEOH
		(0xC6E9 <= code && code <= 0xC703) || // Lo  [27] HANGUL SYLLABLE WEG..HANGUL SYLLABLE WEH
		(0xC705 <= code && code <= 0xC71F) || // Lo  [27] HANGUL SYLLABLE WIG..HANGUL SYLLABLE WIH
		(0xC721 <= code && code <= 0xC73B) || // Lo  [27] HANGUL SYLLABLE YUG..HANGUL SYLLABLE YUH
		(0xC73D <= code && code <= 0xC757) || // Lo  [27] HANGUL SYLLABLE EUG..HANGUL SYLLABLE EUH
		(0xC759 <= code && code <= 0xC773) || // Lo  [27] HANGUL SYLLABLE YIG..HANGUL SYLLABLE YIH
		(0xC775 <= code && code <= 0xC78F) || // Lo  [27] HANGUL SYLLABLE IG..HANGUL SYLLABLE IH
		(0xC791 <= code && code <= 0xC7AB) || // Lo  [27] HANGUL SYLLABLE JAG..HANGUL SYLLABLE JAH
		(0xC7AD <= code && code <= 0xC7C7) || // Lo  [27] HANGUL SYLLABLE JAEG..HANGUL SYLLABLE JAEH
		(0xC7C9 <= code && code <= 0xC7E3) || // Lo  [27] HANGUL SYLLABLE JYAG..HANGUL SYLLABLE JYAH
		(0xC7E5 <= code && code <= 0xC7FF) || // Lo  [27] HANGUL SYLLABLE JYAEG..HANGUL SYLLABLE JYAEH
		(0xC801 <= code && code <= 0xC81B) || // Lo  [27] HANGUL SYLLABLE JEOG..HANGUL SYLLABLE JEOH
		(0xC81D <= code && code <= 0xC837) || // Lo  [27] HANGUL SYLLABLE JEG..HANGUL SYLLABLE JEH
		(0xC839 <= code && code <= 0xC853) || // Lo  [27] HANGUL SYLLABLE JYEOG..HANGUL SYLLABLE JYEOH
		(0xC855 <= code && code <= 0xC86F) || // Lo  [27] HANGUL SYLLABLE JYEG..HANGUL SYLLABLE JYEH
		(0xC871 <= code && code <= 0xC88B) || // Lo  [27] HANGUL SYLLABLE JOG..HANGUL SYLLABLE JOH
		(0xC88D <= code && code <= 0xC8A7) || // Lo  [27] HANGUL SYLLABLE JWAG..HANGUL SYLLABLE JWAH
		(0xC8A9 <= code && code <= 0xC8C3) || // Lo  [27] HANGUL SYLLABLE JWAEG..HANGUL SYLLABLE JWAEH
		(0xC8C5 <= code && code <= 0xC8DF) || // Lo  [27] HANGUL SYLLABLE JOEG..HANGUL SYLLABLE JOEH
		(0xC8E1 <= code && code <= 0xC8FB) || // Lo  [27] HANGUL SYLLABLE JYOG..HANGUL SYLLABLE JYOH
		(0xC8FD <= code && code <= 0xC917) || // Lo  [27] HANGUL SYLLABLE JUG..HANGUL SYLLABLE JUH
		(0xC919 <= code && code <= 0xC933) || // Lo  [27] HANGUL SYLLABLE JWEOG..HANGUL SYLLABLE JWEOH
		(0xC935 <= code && code <= 0xC94F) || // Lo  [27] HANGUL SYLLABLE JWEG..HANGUL SYLLABLE JWEH
		(0xC951 <= code && code <= 0xC96B) || // Lo  [27] HANGUL SYLLABLE JWIG..HANGUL SYLLABLE JWIH
		(0xC96D <= code && code <= 0xC987) || // Lo  [27] HANGUL SYLLABLE JYUG..HANGUL SYLLABLE JYUH
		(0xC989 <= code && code <= 0xC9A3) || // Lo  [27] HANGUL SYLLABLE JEUG..HANGUL SYLLABLE JEUH
		(0xC9A5 <= code && code <= 0xC9BF) || // Lo  [27] HANGUL SYLLABLE JYIG..HANGUL SYLLABLE JYIH
		(0xC9C1 <= code && code <= 0xC9DB) || // Lo  [27] HANGUL SYLLABLE JIG..HANGUL SYLLABLE JIH
		(0xC9DD <= code && code <= 0xC9F7) || // Lo  [27] HANGUL SYLLABLE JJAG..HANGUL SYLLABLE JJAH
		(0xC9F9 <= code && code <= 0xCA13) || // Lo  [27] HANGUL SYLLABLE JJAEG..HANGUL SYLLABLE JJAEH
		(0xCA15 <= code && code <= 0xCA2F) || // Lo  [27] HANGUL SYLLABLE JJYAG..HANGUL SYLLABLE JJYAH
		(0xCA31 <= code && code <= 0xCA4B) || // Lo  [27] HANGUL SYLLABLE JJYAEG..HANGUL SYLLABLE JJYAEH
		(0xCA4D <= code && code <= 0xCA67) || // Lo  [27] HANGUL SYLLABLE JJEOG..HANGUL SYLLABLE JJEOH
		(0xCA69 <= code && code <= 0xCA83) || // Lo  [27] HANGUL SYLLABLE JJEG..HANGUL SYLLABLE JJEH
		(0xCA85 <= code && code <= 0xCA9F) || // Lo  [27] HANGUL SYLLABLE JJYEOG..HANGUL SYLLABLE JJYEOH
		(0xCAA1 <= code && code <= 0xCABB) || // Lo  [27] HANGUL SYLLABLE JJYEG..HANGUL SYLLABLE JJYEH
		(0xCABD <= code && code <= 0xCAD7) || // Lo  [27] HANGUL SYLLABLE JJOG..HANGUL SYLLABLE JJOH
		(0xCAD9 <= code && code <= 0xCAF3) || // Lo  [27] HANGUL SYLLABLE JJWAG..HANGUL SYLLABLE JJWAH
		(0xCAF5 <= code && code <= 0xCB0F) || // Lo  [27] HANGUL SYLLABLE JJWAEG..HANGUL SYLLABLE JJWAEH
		(0xCB11 <= code && code <= 0xCB2B) || // Lo  [27] HANGUL SYLLABLE JJOEG..HANGUL SYLLABLE JJOEH
		(0xCB2D <= code && code <= 0xCB47) || // Lo  [27] HANGUL SYLLABLE JJYOG..HANGUL SYLLABLE JJYOH
		(0xCB49 <= code && code <= 0xCB63) || // Lo  [27] HANGUL SYLLABLE JJUG..HANGUL SYLLABLE JJUH
		(0xCB65 <= code && code <= 0xCB7F) || // Lo  [27] HANGUL SYLLABLE JJWEOG..HANGUL SYLLABLE JJWEOH
		(0xCB81 <= code && code <= 0xCB9B) || // Lo  [27] HANGUL SYLLABLE JJWEG..HANGUL SYLLABLE JJWEH
		(0xCB9D <= code && code <= 0xCBB7) || // Lo  [27] HANGUL SYLLABLE JJWIG..HANGUL SYLLABLE JJWIH
		(0xCBB9 <= code && code <= 0xCBD3) || // Lo  [27] HANGUL SYLLABLE JJYUG..HANGUL SYLLABLE JJYUH
		(0xCBD5 <= code && code <= 0xCBEF) || // Lo  [27] HANGUL SYLLABLE JJEUG..HANGUL SYLLABLE JJEUH
		(0xCBF1 <= code && code <= 0xCC0B) || // Lo  [27] HANGUL SYLLABLE JJYIG..HANGUL SYLLABLE JJYIH
		(0xCC0D <= code && code <= 0xCC27) || // Lo  [27] HANGUL SYLLABLE JJIG..HANGUL SYLLABLE JJIH
		(0xCC29 <= code && code <= 0xCC43) || // Lo  [27] HANGUL SYLLABLE CAG..HANGUL SYLLABLE CAH
		(0xCC45 <= code && code <= 0xCC5F) || // Lo  [27] HANGUL SYLLABLE CAEG..HANGUL SYLLABLE CAEH
		(0xCC61 <= code && code <= 0xCC7B) || // Lo  [27] HANGUL SYLLABLE CYAG..HANGUL SYLLABLE CYAH
		(0xCC7D <= code && code <= 0xCC97) || // Lo  [27] HANGUL SYLLABLE CYAEG..HANGUL SYLLABLE CYAEH
		(0xCC99 <= code && code <= 0xCCB3) || // Lo  [27] HANGUL SYLLABLE CEOG..HANGUL SYLLABLE CEOH
		(0xCCB5 <= code && code <= 0xCCCF) || // Lo  [27] HANGUL SYLLABLE CEG..HANGUL SYLLABLE CEH
		(0xCCD1 <= code && code <= 0xCCEB) || // Lo  [27] HANGUL SYLLABLE CYEOG..HANGUL SYLLABLE CYEOH
		(0xCCED <= code && code <= 0xCD07) || // Lo  [27] HANGUL SYLLABLE CYEG..HANGUL SYLLABLE CYEH
		(0xCD09 <= code && code <= 0xCD23) || // Lo  [27] HANGUL SYLLABLE COG..HANGUL SYLLABLE COH
		(0xCD25 <= code && code <= 0xCD3F) || // Lo  [27] HANGUL SYLLABLE CWAG..HANGUL SYLLABLE CWAH
		(0xCD41 <= code && code <= 0xCD5B) || // Lo  [27] HANGUL SYLLABLE CWAEG..HANGUL SYLLABLE CWAEH
		(0xCD5D <= code && code <= 0xCD77) || // Lo  [27] HANGUL SYLLABLE COEG..HANGUL SYLLABLE COEH
		(0xCD79 <= code && code <= 0xCD93) || // Lo  [27] HANGUL SYLLABLE CYOG..HANGUL SYLLABLE CYOH
		(0xCD95 <= code && code <= 0xCDAF) || // Lo  [27] HANGUL SYLLABLE CUG..HANGUL SYLLABLE CUH
		(0xCDB1 <= code && code <= 0xCDCB) || // Lo  [27] HANGUL SYLLABLE CWEOG..HANGUL SYLLABLE CWEOH
		(0xCDCD <= code && code <= 0xCDE7) || // Lo  [27] HANGUL SYLLABLE CWEG..HANGUL SYLLABLE CWEH
		(0xCDE9 <= code && code <= 0xCE03) || // Lo  [27] HANGUL SYLLABLE CWIG..HANGUL SYLLABLE CWIH
		(0xCE05 <= code && code <= 0xCE1F) || // Lo  [27] HANGUL SYLLABLE CYUG..HANGUL SYLLABLE CYUH
		(0xCE21 <= code && code <= 0xCE3B) || // Lo  [27] HANGUL SYLLABLE CEUG..HANGUL SYLLABLE CEUH
		(0xCE3D <= code && code <= 0xCE57) || // Lo  [27] HANGUL SYLLABLE CYIG..HANGUL SYLLABLE CYIH
		(0xCE59 <= code && code <= 0xCE73) || // Lo  [27] HANGUL SYLLABLE CIG..HANGUL SYLLABLE CIH
		(0xCE75 <= code && code <= 0xCE8F) || // Lo  [27] HANGUL SYLLABLE KAG..HANGUL SYLLABLE KAH
		(0xCE91 <= code && code <= 0xCEAB) || // Lo  [27] HANGUL SYLLABLE KAEG..HANGUL SYLLABLE KAEH
		(0xCEAD <= code && code <= 0xCEC7) || // Lo  [27] HANGUL SYLLABLE KYAG..HANGUL SYLLABLE KYAH
		(0xCEC9 <= code && code <= 0xCEE3) || // Lo  [27] HANGUL SYLLABLE KYAEG..HANGUL SYLLABLE KYAEH
		(0xCEE5 <= code && code <= 0xCEFF) || // Lo  [27] HANGUL SYLLABLE KEOG..HANGUL SYLLABLE KEOH
		(0xCF01 <= code && code <= 0xCF1B) || // Lo  [27] HANGUL SYLLABLE KEG..HANGUL SYLLABLE KEH
		(0xCF1D <= code && code <= 0xCF37) || // Lo  [27] HANGUL SYLLABLE KYEOG..HANGUL SYLLABLE KYEOH
		(0xCF39 <= code && code <= 0xCF53) || // Lo  [27] HANGUL SYLLABLE KYEG..HANGUL SYLLABLE KYEH
		(0xCF55 <= code && code <= 0xCF6F) || // Lo  [27] HANGUL SYLLABLE KOG..HANGUL SYLLABLE KOH
		(0xCF71 <= code && code <= 0xCF8B) || // Lo  [27] HANGUL SYLLABLE KWAG..HANGUL SYLLABLE KWAH
		(0xCF8D <= code && code <= 0xCFA7) || // Lo  [27] HANGUL SYLLABLE KWAEG..HANGUL SYLLABLE KWAEH
		(0xCFA9 <= code && code <= 0xCFC3) || // Lo  [27] HANGUL SYLLABLE KOEG..HANGUL SYLLABLE KOEH
		(0xCFC5 <= code && code <= 0xCFDF) || // Lo  [27] HANGUL SYLLABLE KYOG..HANGUL SYLLABLE KYOH
		(0xCFE1 <= code && code <= 0xCFFB) || // Lo  [27] HANGUL SYLLABLE KUG..HANGUL SYLLABLE KUH
		(0xCFFD <= code && code <= 0xD017) || // Lo  [27] HANGUL SYLLABLE KWEOG..HANGUL SYLLABLE KWEOH
		(0xD019 <= code && code <= 0xD033) || // Lo  [27] HANGUL SYLLABLE KWEG..HANGUL SYLLABLE KWEH
		(0xD035 <= code && code <= 0xD04F) || // Lo  [27] HANGUL SYLLABLE KWIG..HANGUL SYLLABLE KWIH
		(0xD051 <= code && code <= 0xD06B) || // Lo  [27] HANGUL SYLLABLE KYUG..HANGUL SYLLABLE KYUH
		(0xD06D <= code && code <= 0xD087) || // Lo  [27] HANGUL SYLLABLE KEUG..HANGUL SYLLABLE KEUH
		(0xD089 <= code && code <= 0xD0A3) || // Lo  [27] HANGUL SYLLABLE KYIG..HANGUL SYLLABLE KYIH
		(0xD0A5 <= code && code <= 0xD0BF) || // Lo  [27] HANGUL SYLLABLE KIG..HANGUL SYLLABLE KIH
		(0xD0C1 <= code && code <= 0xD0DB) || // Lo  [27] HANGUL SYLLABLE TAG..HANGUL SYLLABLE TAH
		(0xD0DD <= code && code <= 0xD0F7) || // Lo  [27] HANGUL SYLLABLE TAEG..HANGUL SYLLABLE TAEH
		(0xD0F9 <= code && code <= 0xD113) || // Lo  [27] HANGUL SYLLABLE TYAG..HANGUL SYLLABLE TYAH
		(0xD115 <= code && code <= 0xD12F) || // Lo  [27] HANGUL SYLLABLE TYAEG..HANGUL SYLLABLE TYAEH
		(0xD131 <= code && code <= 0xD14B) || // Lo  [27] HANGUL SYLLABLE TEOG..HANGUL SYLLABLE TEOH
		(0xD14D <= code && code <= 0xD167) || // Lo  [27] HANGUL SYLLABLE TEG..HANGUL SYLLABLE TEH
		(0xD169 <= code && code <= 0xD183) || // Lo  [27] HANGUL SYLLABLE TYEOG..HANGUL SYLLABLE TYEOH
		(0xD185 <= code && code <= 0xD19F) || // Lo  [27] HANGUL SYLLABLE TYEG..HANGUL SYLLABLE TYEH
		(0xD1A1 <= code && code <= 0xD1BB) || // Lo  [27] HANGUL SYLLABLE TOG..HANGUL SYLLABLE TOH
		(0xD1BD <= code && code <= 0xD1D7) || // Lo  [27] HANGUL SYLLABLE TWAG..HANGUL SYLLABLE TWAH
		(0xD1D9 <= code && code <= 0xD1F3) || // Lo  [27] HANGUL SYLLABLE TWAEG..HANGUL SYLLABLE TWAEH
		(0xD1F5 <= code && code <= 0xD20F) || // Lo  [27] HANGUL SYLLABLE TOEG..HANGUL SYLLABLE TOEH
		(0xD211 <= code && code <= 0xD22B) || // Lo  [27] HANGUL SYLLABLE TYOG..HANGUL SYLLABLE TYOH
		(0xD22D <= code && code <= 0xD247) || // Lo  [27] HANGUL SYLLABLE TUG..HANGUL SYLLABLE TUH
		(0xD249 <= code && code <= 0xD263) || // Lo  [27] HANGUL SYLLABLE TWEOG..HANGUL SYLLABLE TWEOH
		(0xD265 <= code && code <= 0xD27F) || // Lo  [27] HANGUL SYLLABLE TWEG..HANGUL SYLLABLE TWEH
		(0xD281 <= code && code <= 0xD29B) || // Lo  [27] HANGUL SYLLABLE TWIG..HANGUL SYLLABLE TWIH
		(0xD29D <= code && code <= 0xD2B7) || // Lo  [27] HANGUL SYLLABLE TYUG..HANGUL SYLLABLE TYUH
		(0xD2B9 <= code && code <= 0xD2D3) || // Lo  [27] HANGUL SYLLABLE TEUG..HANGUL SYLLABLE TEUH
		(0xD2D5 <= code && code <= 0xD2EF) || // Lo  [27] HANGUL SYLLABLE TYIG..HANGUL SYLLABLE TYIH
		(0xD2F1 <= code && code <= 0xD30B) || // Lo  [27] HANGUL SYLLABLE TIG..HANGUL SYLLABLE TIH
		(0xD30D <= code && code <= 0xD327) || // Lo  [27] HANGUL SYLLABLE PAG..HANGUL SYLLABLE PAH
		(0xD329 <= code && code <= 0xD343) || // Lo  [27] HANGUL SYLLABLE PAEG..HANGUL SYLLABLE PAEH
		(0xD345 <= code && code <= 0xD35F) || // Lo  [27] HANGUL SYLLABLE PYAG..HANGUL SYLLABLE PYAH
		(0xD361 <= code && code <= 0xD37B) || // Lo  [27] HANGUL SYLLABLE PYAEG..HANGUL SYLLABLE PYAEH
		(0xD37D <= code && code <= 0xD397) || // Lo  [27] HANGUL SYLLABLE PEOG..HANGUL SYLLABLE PEOH
		(0xD399 <= code && code <= 0xD3B3) || // Lo  [27] HANGUL SYLLABLE PEG..HANGUL SYLLABLE PEH
		(0xD3B5 <= code && code <= 0xD3CF) || // Lo  [27] HANGUL SYLLABLE PYEOG..HANGUL SYLLABLE PYEOH
		(0xD3D1 <= code && code <= 0xD3EB) || // Lo  [27] HANGUL SYLLABLE PYEG..HANGUL SYLLABLE PYEH
		(0xD3ED <= code && code <= 0xD407) || // Lo  [27] HANGUL SYLLABLE POG..HANGUL SYLLABLE POH
		(0xD409 <= code && code <= 0xD423) || // Lo  [27] HANGUL SYLLABLE PWAG..HANGUL SYLLABLE PWAH
		(0xD425 <= code && code <= 0xD43F) || // Lo  [27] HANGUL SYLLABLE PWAEG..HANGUL SYLLABLE PWAEH
		(0xD441 <= code && code <= 0xD45B) || // Lo  [27] HANGUL SYLLABLE POEG..HANGUL SYLLABLE POEH
		(0xD45D <= code && code <= 0xD477) || // Lo  [27] HANGUL SYLLABLE PYOG..HANGUL SYLLABLE PYOH
		(0xD479 <= code && code <= 0xD493) || // Lo  [27] HANGUL SYLLABLE PUG..HANGUL SYLLABLE PUH
		(0xD495 <= code && code <= 0xD4AF) || // Lo  [27] HANGUL SYLLABLE PWEOG..HANGUL SYLLABLE PWEOH
		(0xD4B1 <= code && code <= 0xD4CB) || // Lo  [27] HANGUL SYLLABLE PWEG..HANGUL SYLLABLE PWEH
		(0xD4CD <= code && code <= 0xD4E7) || // Lo  [27] HANGUL SYLLABLE PWIG..HANGUL SYLLABLE PWIH
		(0xD4E9 <= code && code <= 0xD503) || // Lo  [27] HANGUL SYLLABLE PYUG..HANGUL SYLLABLE PYUH
		(0xD505 <= code && code <= 0xD51F) || // Lo  [27] HANGUL SYLLABLE PEUG..HANGUL SYLLABLE PEUH
		(0xD521 <= code && code <= 0xD53B) || // Lo  [27] HANGUL SYLLABLE PYIG..HANGUL SYLLABLE PYIH
		(0xD53D <= code && code <= 0xD557) || // Lo  [27] HANGUL SYLLABLE PIG..HANGUL SYLLABLE PIH
		(0xD559 <= code && code <= 0xD573) || // Lo  [27] HANGUL SYLLABLE HAG..HANGUL SYLLABLE HAH
		(0xD575 <= code && code <= 0xD58F) || // Lo  [27] HANGUL SYLLABLE HAEG..HANGUL SYLLABLE HAEH
		(0xD591 <= code && code <= 0xD5AB) || // Lo  [27] HANGUL SYLLABLE HYAG..HANGUL SYLLABLE HYAH
		(0xD5AD <= code && code <= 0xD5C7) || // Lo  [27] HANGUL SYLLABLE HYAEG..HANGUL SYLLABLE HYAEH
		(0xD5C9 <= code && code <= 0xD5E3) || // Lo  [27] HANGUL SYLLABLE HEOG..HANGUL SYLLABLE HEOH
		(0xD5E5 <= code && code <= 0xD5FF) || // Lo  [27] HANGUL SYLLABLE HEG..HANGUL SYLLABLE HEH
		(0xD601 <= code && code <= 0xD61B) || // Lo  [27] HANGUL SYLLABLE HYEOG..HANGUL SYLLABLE HYEOH
		(0xD61D <= code && code <= 0xD637) || // Lo  [27] HANGUL SYLLABLE HYEG..HANGUL SYLLABLE HYEH
		(0xD639 <= code && code <= 0xD653) || // Lo  [27] HANGUL SYLLABLE HOG..HANGUL SYLLABLE HOH
		(0xD655 <= code && code <= 0xD66F) || // Lo  [27] HANGUL SYLLABLE HWAG..HANGUL SYLLABLE HWAH
		(0xD671 <= code && code <= 0xD68B) || // Lo  [27] HANGUL SYLLABLE HWAEG..HANGUL SYLLABLE HWAEH
		(0xD68D <= code && code <= 0xD6A7) || // Lo  [27] HANGUL SYLLABLE HOEG..HANGUL SYLLABLE HOEH
		(0xD6A9 <= code && code <= 0xD6C3) || // Lo  [27] HANGUL SYLLABLE HYOG..HANGUL SYLLABLE HYOH
		(0xD6C5 <= code && code <= 0xD6DF) || // Lo  [27] HANGUL SYLLABLE HUG..HANGUL SYLLABLE HUH
		(0xD6E1 <= code && code <= 0xD6FB) || // Lo  [27] HANGUL SYLLABLE HWEOG..HANGUL SYLLABLE HWEOH
		(0xD6FD <= code && code <= 0xD717) || // Lo  [27] HANGUL SYLLABLE HWEG..HANGUL SYLLABLE HWEH
		(0xD719 <= code && code <= 0xD733) || // Lo  [27] HANGUL SYLLABLE HWIG..HANGUL SYLLABLE HWIH
		(0xD735 <= code && code <= 0xD74F) || // Lo  [27] HANGUL SYLLABLE HYUG..HANGUL SYLLABLE HYUH
		(0xD751 <= code && code <= 0xD76B) || // Lo  [27] HANGUL SYLLABLE HEUG..HANGUL SYLLABLE HEUH
		(0xD76D <= code && code <= 0xD787) || // Lo  [27] HANGUL SYLLABLE HYIG..HANGUL SYLLABLE HYIH
		(0xD789 <= code && code <= 0xD7A3) // Lo  [27] HANGUL SYLLABLE HIG..HANGUL SYLLABLE HIH
		){
			return LVT;
		}
		
		if(
		0x261D == code || // So       WHITE UP POINTING INDEX
		0x26F9 == code || // So       PERSON WITH BALL
		(0x270A <= code && code <= 0x270D) || // So   [4] RAISED FIST..WRITING HAND
		0x1F385 == code || // So       FATHER CHRISTMAS
		(0x1F3C2 <= code && code <= 0x1F3C4) || // So   [3] SNOWBOARDER..SURFER
		0x1F3C7 == code || // So       HORSE RACING
		(0x1F3CA <= code && code <= 0x1F3CC) || // So   [3] SWIMMER..GOLFER
		(0x1F442 <= code && code <= 0x1F443) || // So   [2] EAR..NOSE
		(0x1F446 <= code && code <= 0x1F450) || // So  [11] WHITE UP POINTING BACKHAND INDEX..OPEN HANDS SIGN
		0x1F46E == code || // So       POLICE OFFICER
		(0x1F470 <= code && code <= 0x1F478) || // So   [9] BRIDE WITH VEIL..PRINCESS
		0x1F47C == code || // So       BABY ANGEL
		(0x1F481 <= code && code <= 0x1F483) || // So   [3] INFORMATION DESK PERSON..DANCER
		(0x1F485 <= code && code <= 0x1F487) || // So   [3] NAIL POLISH..HAIRCUT
		0x1F4AA == code || // So       FLEXED BICEPS
		(0x1F574 <= code && code <= 0x1F575) || // So   [2] MAN IN BUSINESS SUIT LEVITATING..SLEUTH OR SPY
		0x1F57A == code || // So       MAN DANCING
		0x1F590 == code || // So       RAISED HAND WITH FINGERS SPLAYED
		(0x1F595 <= code && code <= 0x1F596) || // So   [2] REVERSED HAND WITH MIDDLE FINGER EXTENDED..RAISED HAND WITH PART BETWEEN MIDDLE AND RING FINGERS
		(0x1F645 <= code && code <= 0x1F647) || // So   [3] FACE WITH NO GOOD GESTURE..PERSON BOWING DEEPLY
		(0x1F64B <= code && code <= 0x1F64F) || // So   [5] HAPPY PERSON RAISING ONE HAND..PERSON WITH FOLDED HANDS
		0x1F6A3 == code || // So       ROWBOAT
		(0x1F6B4 <= code && code <= 0x1F6B6) || // So   [3] BICYCLIST..PEDESTRIAN
		0x1F6C0 == code || // So       BATH
		0x1F6CC == code || // So       SLEEPING ACCOMMODATION
		(0x1F918 <= code && code <= 0x1F91C) || // So   [5] SIGN OF THE HORNS..RIGHT-FACING FIST
		(0x1F91E <= code && code <= 0x1F91F) || // So   [2] HAND WITH INDEX AND MIDDLE FINGERS CROSSED..I LOVE YOU HAND SIGN
		0x1F926 == code || // So       FACE PALM
		(0x1F930 <= code && code <= 0x1F939) || // So  [10] PREGNANT WOMAN..JUGGLING
		(0x1F93D <= code && code <= 0x1F93E) || // So   [2] WATER POLO..HANDBALL
		(0x1F9D1 <= code && code <= 0x1F9DD) // So  [13] ADULT..ELF
		){
			return E_Base;
		}

		if(
		(0x1F3FB <= code && code <= 0x1F3FF) // Sk   [5] EMOJI MODIFIER FITZPATRICK TYPE-1-2..EMOJI MODIFIER FITZPATRICK TYPE-6
		){
			return E_Modifier;
		}

		if(
		0x200D == code // Cf       ZERO WIDTH JOINER
		){
			return ZWJ;
		}

		if(
		0x2640 == code || // So       FEMALE SIGN
		0x2642 == code || // So       MALE SIGN
		(0x2695 <= code && code <= 0x2696) || // So   [2] STAFF OF AESCULAPIUS..SCALES
		0x2708 == code || // So       AIRPLANE
		0x2764 == code || // So       HEAVY BLACK HEART
		0x1F308 == code || // So       RAINBOW
		0x1F33E == code || // So       EAR OF RICE
		0x1F373 == code || // So       COOKING
		0x1F393 == code || // So       GRADUATION CAP
		0x1F3A4 == code || // So       MICROPHONE
		0x1F3A8 == code || // So       ARTIST PALETTE
		0x1F3EB == code || // So       SCHOOL
		0x1F3ED == code || // So       FACTORY
		0x1F48B == code || // So       KISS MARK
		(0x1F4BB <= code && code <= 0x1F4BC) || // So   [2] PERSONAL COMPUTER..BRIEFCASE
		0x1F527 == code || // So       WRENCH
		0x1F52C == code || // So       MICROSCOPE
		0x1F5E8 == code || // So       LEFT SPEECH BUBBLE
		0x1F680 == code || // So       ROCKET
		0x1F692 == code // So       FIRE ENGINE
		){
			return Glue_After_Zwj;
		}

		if(
		(0x1F466 <= code && code <= 0x1F469) // So   [4] BOY..WOMAN
		){
			return E_Base_GAZ;
		}
		
		
		//all unlisted characters have a grapheme break property of "Other"
		return Other;
	}
	return this;
}

if ( true && module.exports) {
    module.exports = GraphemeSplitter;
}


/***/ }),
/* 242 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Project": () => /* binding */ Project
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(117);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(143);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var diff__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(243);
/* harmony import */ var logic_solver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(244);
/* harmony import */ var logic_solver__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(logic_solver__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(65);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(p_limit__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var v8__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(248);
/* harmony import */ var v8__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(v8__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(116);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _Configuration__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(11);
/* harmony import */ var _Installer__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(237);
/* harmony import */ var _LegacyMigrationResolver__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(251);
/* harmony import */ var _LockfileResolver__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(252);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(230);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(217);
/* harmony import */ var _MultiResolver__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(220);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(226);
/* harmony import */ var _RunInstallPleaseResolver__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(253);
/* harmony import */ var _ThrowReport__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(250);
/* harmony import */ var _Workspace__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(249);
/* harmony import */ var _folderUtils__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(111);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(142);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(121);
/* harmony import */ var _scriptUtils__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(254);
/* harmony import */ var _semverUtils__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(231);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(140);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(223);




 // @ts-ignore
























 // When upgraded, the lockfile entries have to be resolved again (but the specific
// versions are still pinned, no worry). Bump it when you change the fields within
// the Package type; no more no less.

const LOCKFILE_VERSION = 4; // Same thing but must be bumped when the members of the Project class changes (we
// don't recommend our users to check-in this file, so it's fine to bump it even
// between patch or minor releases).

const INSTALL_STATE_VERSION = 1;
const MULTIPLE_KEYS_REGEXP = / *, */g;
const FETCHER_CONCURRENCY = 32;
const gzip = (0,util__WEBPACK_IMPORTED_MODULE_7__.promisify)((zlib__WEBPACK_IMPORTED_MODULE_9___default().gzip));
const gunzip = (0,util__WEBPACK_IMPORTED_MODULE_7__.promisify)((zlib__WEBPACK_IMPORTED_MODULE_9___default().gunzip));
class Project {
  constructor(projectCwd, {
    configuration
  }) {
    /**
     * Is meant to be populated by the consumer. Should the descriptor referenced
     * by the key be requested, the descriptor referenced in the value will be
     * resolved instead. The resolved data will then be used as final resolution
     * for the initial descriptor.
     *
     * Note that the lockfile will contain the second descriptor but not the
     * first one (meaning that if you remove the alias during a subsequent
     * install, it'll be lost and the real package will be resolved / installed).
     */
    this.resolutionAliases = new Map();
    this.workspaces = [];
    this.workspacesByCwd = new Map();
    this.workspacesByIdent = new Map();
    this.storedResolutions = new Map();
    this.storedDescriptors = new Map();
    this.storedPackages = new Map();
    this.storedChecksums = new Map();
    this.accessibleLocators = new Set();
    this.originalPackages = new Map();
    this.optionalBuilds = new Set();
    this.lockFileChecksum = null;
    this.configuration = configuration;
    this.cwd = projectCwd;
  }

  static async find(configuration, startingCwd) {
    var _a, _b, _c;

    if (!configuration.projectCwd) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No project found in ${startingCwd}`);
    let packageCwd = configuration.projectCwd;
    let nextCwd = startingCwd;
    let currentCwd = null;

    while (currentCwd !== configuration.projectCwd) {
      currentCwd = nextCwd;

      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(currentCwd, `package.json`))) {
        packageCwd = currentCwd;
        break;
      }

      nextCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(currentCwd);
    }

    const project = new Project(configuration.projectCwd, {
      configuration
    });
    (_a = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportProject(project.cwd);
    await project.setupResolutions();
    await project.setupWorkspaces();
    (_b = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _b === void 0 ? void 0 : _b.reportWorkspaceCount(project.workspaces.length);
    (_c = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _c === void 0 ? void 0 : _c.reportDependencyCount(project.workspaces.reduce((sum, workspace) => sum + workspace.manifest.dependencies.size + workspace.manifest.devDependencies.size, 0)); // If we're in a workspace, no need to go any further to find which package we're in

    const workspace = project.tryWorkspaceByCwd(packageCwd);
    if (workspace) return {
      project,
      workspace,
      locator: workspace.anchoredLocator
    }; // Otherwise, we need to ask the project (which will in turn ask the linkers for help)
    // Note: the trailing slash is caused by a quirk in the PnP implementation that requires folders to end with a trailing slash to disambiguate them from regular files

    const locator = await project.findLocatorForLocation(`${packageCwd}/`);
    if (locator) return {
      project,
      locator,
      workspace: null
    };
    throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The nearest package directory (${packageCwd}) doesn't seem to be part of the project declared at ${project.cwd}. If the project directory is right, it might be that you forgot to list a workspace. If it isn't, it's likely because you have a yarn.lock file at the detected location, confusing the project detection.`);
  }

  static generateBuildStateFile(buildState, locatorStore) {
    let bstateFile = `# Warning: This file is automatically generated. Removing it is fine, but will\n# cause all your builds to become invalidated.\n`;
    const bstateData = [...buildState].map(([locatorHash, hash]) => {
      const locator = locatorStore.get(locatorHash);
      if (typeof locator === `undefined`) throw new Error(`Assertion failed: The locator should have been registered`);
      return [_structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyLocator(locator), locator.locatorHash, hash];
    });

    for (const [locatorString, locatorHash, buildHash] of _miscUtils__WEBPACK_IMPORTED_MODULE_14__.sortMap(bstateData, [d => d[0], d => d[1]])) {
      bstateFile += `\n`;
      bstateFile += `# ${locatorString}\n`;
      bstateFile += `${JSON.stringify(locatorHash)}:\n`;
      bstateFile += `  ${buildHash}\n`;
    }

    return bstateFile;
  }

  async setupResolutions() {
    this.storedResolutions = new Map();
    this.storedDescriptors = new Map();
    this.storedPackages = new Map();
    this.lockFileChecksum = null;
    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
    const defaultLanguageName = this.configuration.get(`defaultLanguageName`);

    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(lockfilePath)) {
      const content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(lockfilePath, `utf8`); // We store the salted checksum of the lockfile in order to invalidate the install state when needed

      this.lockFileChecksum = _hashUtils__WEBPACK_IMPORTED_MODULE_15__.makeHash(`${INSTALL_STATE_VERSION}`, content);
      const parsed = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(content); // Protects against v1 lockfiles

      if (parsed.__metadata) {
        const lockfileVersion = parsed.__metadata.version;
        const cacheKey = parsed.__metadata.cacheKey;

        for (const key of Object.keys(parsed)) {
          if (key === `__metadata`) continue;
          const data = parsed[key];
          if (typeof data.resolution === `undefined`) throw new Error(`Assertion failed: Expected the lockfile entry to have a resolution field (${key})`);
          const locator = _structUtils__WEBPACK_IMPORTED_MODULE_13__.parseLocator(data.resolution, true);
          const manifest = new _Manifest__WEBPACK_IMPORTED_MODULE_16__.Manifest();
          manifest.load(data);
          const version = manifest.version;
          const languageName = manifest.languageName || defaultLanguageName;
          const linkType = data.linkType.toUpperCase();
          const dependencies = manifest.dependencies;
          const peerDependencies = manifest.peerDependencies;
          const dependenciesMeta = manifest.dependenciesMeta;
          const peerDependenciesMeta = manifest.peerDependenciesMeta;
          const bin = manifest.bin;

          if (data.checksum != null) {
            const checksum = typeof cacheKey !== `undefined` && !data.checksum.includes(`/`) ? `${cacheKey}/${data.checksum}` : data.checksum;
            this.storedChecksums.set(locator.locatorHash, checksum);
          }

          if (lockfileVersion >= LOCKFILE_VERSION) {
            const pkg = { ...locator,
              version,
              languageName,
              linkType,
              dependencies,
              peerDependencies,
              dependenciesMeta,
              peerDependenciesMeta,
              bin
            };
            this.originalPackages.set(pkg.locatorHash, pkg);
          }

          for (const entry of key.split(MULTIPLE_KEYS_REGEXP)) {
            const descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_13__.parseDescriptor(entry);
            this.storedDescriptors.set(descriptor.descriptorHash, descriptor);

            if (lockfileVersion >= LOCKFILE_VERSION) {
              // If the lockfile is up-to-date, we can simply register the
              // resolution as a done deal.
              this.storedResolutions.set(descriptor.descriptorHash, locator.locatorHash);
            } else {
              // But if it isn't, then we instead setup an alias so that the
              // descriptor will be re-resolved (so that we get to retrieve the
              // new fields) while still resolving to the same locators.
              const resolutionDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_13__.convertLocatorToDescriptor(locator);

              if (resolutionDescriptor.descriptorHash !== descriptor.descriptorHash) {
                this.storedDescriptors.set(resolutionDescriptor.descriptorHash, resolutionDescriptor);
                this.resolutionAliases.set(descriptor.descriptorHash, resolutionDescriptor.descriptorHash);
              }
            }
          }
        }
      }
    }
  }

  async setupWorkspaces() {
    this.workspaces = [];
    this.workspacesByCwd = new Map();
    this.workspacesByIdent = new Map();
    let workspaceCwds = [this.cwd];

    while (workspaceCwds.length > 0) {
      const passCwds = workspaceCwds;
      workspaceCwds = [];

      for (const workspaceCwd of passCwds) {
        if (this.workspacesByCwd.has(workspaceCwd)) continue;
        const workspace = await this.addWorkspace(workspaceCwd);
        const workspacePkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
        if (workspacePkg) workspace.dependencies = workspacePkg.dependencies;

        for (const workspaceCwd of workspace.workspacesCwds) {
          workspaceCwds.push(workspaceCwd);
        }
      }
    }
  }

  async addWorkspace(workspaceCwd) {
    const workspace = new _Workspace__WEBPACK_IMPORTED_MODULE_17__.Workspace(workspaceCwd, {
      project: this
    });
    await workspace.setup();
    const dup = this.workspacesByIdent.get(workspace.locator.identHash);
    if (typeof dup !== `undefined`) throw new Error(`Duplicate workspace name ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyIdent(this.configuration, workspace.locator)}: ${workspaceCwd} conflicts with ${dup.cwd}`);
    this.workspaces.push(workspace);
    this.workspacesByCwd.set(workspaceCwd, workspace);
    this.workspacesByIdent.set(workspace.locator.identHash, workspace);
    return workspace;
  }

  get topLevelWorkspace() {
    return this.getWorkspaceByCwd(this.cwd);
  }

  tryWorkspaceByCwd(workspaceCwd) {
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.isAbsolute(workspaceCwd)) workspaceCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(this.cwd, workspaceCwd);
    const workspace = this.workspacesByCwd.get(workspaceCwd);
    if (!workspace) return null;
    return workspace;
  }

  getWorkspaceByCwd(workspaceCwd) {
    const workspace = this.tryWorkspaceByCwd(workspaceCwd);
    if (!workspace) throw new Error(`Workspace not found (${workspaceCwd})`);
    return workspace;
  }

  tryWorkspaceByFilePath(filePath) {
    let bestWorkspace = null;

    for (const workspace of this.workspaces) {
      const rel = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.relative(workspace.cwd, filePath);
      if (rel.startsWith(`../`)) continue;
      if (bestWorkspace && bestWorkspace.cwd.length >= workspace.cwd.length) continue;
      bestWorkspace = workspace;
    }

    if (!bestWorkspace) return null;
    return bestWorkspace;
  }

  getWorkspaceByFilePath(filePath) {
    const workspace = this.tryWorkspaceByFilePath(filePath);
    if (!workspace) throw new Error(`Workspace not found (${filePath})`);
    return workspace;
  }

  tryWorkspaceByIdent(ident) {
    const workspace = this.workspacesByIdent.get(ident.identHash);
    if (typeof workspace === `undefined`) return null;
    return workspace;
  }

  getWorkspaceByIdent(ident) {
    const workspace = this.tryWorkspaceByIdent(ident);
    if (!workspace) throw new Error(`Workspace not found (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyIdent(this.configuration, ident)})`);
    return workspace;
  }

  tryWorkspaceByDescriptor(descriptor) {
    const workspace = this.tryWorkspaceByIdent(descriptor);
    if (workspace === null || !workspace.accepts(descriptor.range)) return null;
    return workspace;
  }

  getWorkspaceByDescriptor(descriptor) {
    const workspace = this.tryWorkspaceByDescriptor(descriptor);
    if (workspace === null) throw new Error(`Workspace not found (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(this.configuration, descriptor)})`);
    return workspace;
  }

  tryWorkspaceByLocator(locator) {
    if (_structUtils__WEBPACK_IMPORTED_MODULE_13__.isVirtualLocator(locator)) locator = _structUtils__WEBPACK_IMPORTED_MODULE_13__.devirtualizeLocator(locator);
    const workspace = this.tryWorkspaceByIdent(locator);
    if (workspace === null || workspace.locator.locatorHash !== locator.locatorHash && workspace.anchoredLocator.locatorHash !== locator.locatorHash) return null;
    return workspace;
  }

  getWorkspaceByLocator(locator) {
    const workspace = this.tryWorkspaceByLocator(locator);
    if (!workspace) throw new Error(`Workspace not found (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, locator)})`);
    return workspace;
  }
  /**
   * Import the dependencies of each resolved workspace into their own
   * `Workspace` instance.
   */


  refreshWorkspaceDependencies() {
    for (const workspace of this.workspaces) {
      const pkg = this.storedPackages.get(workspace.anchoredLocator.locatorHash);
      if (!pkg) throw new Error(`Assertion failed: Expected workspace to have been resolved`);
      workspace.dependencies = new Map(pkg.dependencies);
    }
  }

  forgetResolution(dataStructure) {
    for (const [descriptorHash, locatorHash] of this.storedResolutions) {
      const doDescriptorHashesMatch = `descriptorHash` in dataStructure && dataStructure.descriptorHash === descriptorHash;
      const doLocatorHashesMatch = `locatorHash` in dataStructure && dataStructure.locatorHash === locatorHash;

      if (doDescriptorHashesMatch || doLocatorHashesMatch) {
        this.storedDescriptors.delete(descriptorHash);
        this.storedResolutions.delete(descriptorHash);
        this.originalPackages.delete(locatorHash);
      }
    }
  }

  forgetTransientResolutions() {
    const resolver = this.configuration.makeResolver();

    for (const pkg of this.originalPackages.values()) {
      let shouldPersistResolution;

      try {
        shouldPersistResolution = resolver.shouldPersistResolution(pkg, {
          project: this,
          resolver
        });
      } catch (_a) {
        shouldPersistResolution = false;
      }

      if (!shouldPersistResolution) {
        this.forgetResolution(pkg);
      }
    }
  }

  forgetVirtualResolutions() {
    for (const pkg of this.storedPackages.values()) {
      for (const [dependencyHash, dependency] of pkg.dependencies) {
        if (_structUtils__WEBPACK_IMPORTED_MODULE_13__.isVirtualDescriptor(dependency)) {
          pkg.dependencies.set(dependencyHash, _structUtils__WEBPACK_IMPORTED_MODULE_13__.devirtualizeDescriptor(dependency));
        }
      }
    }
  }

  getDependencyMeta(ident, version) {
    const dependencyMeta = {};
    const dependenciesMeta = this.topLevelWorkspace.manifest.dependenciesMeta;
    const dependencyMetaSet = dependenciesMeta.get(_structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyIdent(ident));
    if (!dependencyMetaSet) return dependencyMeta;
    const defaultMeta = dependencyMetaSet.get(null);
    if (defaultMeta) Object.assign(dependencyMeta, defaultMeta);
    if (version === null || !semver__WEBPACK_IMPORTED_MODULE_6___default().valid(version)) return dependencyMeta;

    for (const [range, meta] of dependencyMetaSet) if (range !== null && range === version) Object.assign(dependencyMeta, meta);

    return dependencyMeta;
  }

  async findLocatorForLocation(cwd) {
    const report = new _ThrowReport__WEBPACK_IMPORTED_MODULE_18__.ThrowReport();
    const linkers = this.configuration.getLinkers();
    const linkerOptions = {
      project: this,
      report
    };

    for (const linker of linkers) {
      const locator = await linker.findPackageLocator(cwd, linkerOptions);

      if (locator) {
        return locator;
      }
    }

    return null;
  }

  async validateEverything(opts) {
    for (const warning of opts.validationWarnings) opts.report.reportWarning(warning.name, warning.text);

    for (const error of opts.validationErrors) {
      opts.report.reportError(error.name, error.text);
    }
  }

  async resolveEverything(opts) {
    if (!this.workspacesByCwd || !this.workspacesByIdent) throw new Error(`Workspaces must have been setup before calling this function`); // Reverts the changes that have been applied to the tree because of any previous virtual resolution pass

    this.forgetVirtualResolutions(); // Ensures that we notice it when dependencies are added / removed from all sources coming from the filesystem

    if (!opts.lockfileOnly) this.forgetTransientResolutions(); // Note that the resolution process is "offline" until everything has been
    // successfully resolved; all the processing is expected to have zero side
    // effects until we're ready to set all the variables at once (the one
    // exception being when a resolver needs to fetch a package, in which case
    // we might need to populate the cache).
    //
    // This makes it possible to use the same Project instance for multiple
    // purposes at the same time (since `resolveEverything` is async, it might
    // happen that we want to do something while waiting for it to end; if we
    // were to mutate the project then it would end up in a partial state that
    // could lead to hard-to-debug issues).

    const realResolver = opts.resolver || this.configuration.makeResolver();
    const legacyMigrationResolver = new _LegacyMigrationResolver__WEBPACK_IMPORTED_MODULE_19__.LegacyMigrationResolver();
    await legacyMigrationResolver.setup(this, {
      report: opts.report
    });
    const resolver = opts.lockfileOnly ? new _MultiResolver__WEBPACK_IMPORTED_MODULE_20__.MultiResolver([new _LockfileResolver__WEBPACK_IMPORTED_MODULE_21__.LockfileResolver(), new _RunInstallPleaseResolver__WEBPACK_IMPORTED_MODULE_22__.RunInstallPleaseResolver(realResolver)]) : new _MultiResolver__WEBPACK_IMPORTED_MODULE_20__.MultiResolver([new _LockfileResolver__WEBPACK_IMPORTED_MODULE_21__.LockfileResolver(), legacyMigrationResolver, realResolver]);
    const fetcher = this.configuration.makeFetcher();
    const resolveOptions = opts.lockfileOnly ? {
      project: this,
      report: opts.report,
      resolver
    } : {
      project: this,
      report: opts.report,
      resolver,
      fetchOptions: {
        project: this,
        cache: opts.cache,
        checksums: this.storedChecksums,
        report: opts.report,
        fetcher
      }
    };
    const allDescriptors = new Map();
    const allPackages = new Map();
    const allResolutions = new Map();
    const originalPackages = new Map();
    const resolutionDependencies = new Map();
    const haveBeenAliased = new Set();
    let nextResolutionPass = new Set();

    for (const workspace of this.workspaces) {
      const workspaceDescriptor = workspace.anchoredDescriptor;
      allDescriptors.set(workspaceDescriptor.descriptorHash, workspaceDescriptor);
      nextResolutionPass.add(workspaceDescriptor.descriptorHash);
    }

    while (nextResolutionPass.size !== 0) {
      const currentResolutionPass = nextResolutionPass;
      nextResolutionPass = new Set(); // We remove from the "mustBeResolved" list all packages that have
      // already been resolved previously.

      for (const descriptorHash of currentResolutionPass) if (allResolutions.has(descriptorHash)) currentResolutionPass.delete(descriptorHash);

      if (currentResolutionPass.size === 0) break; // We check that the resolution dependencies have been resolved for all
      // descriptors that we're about to resolve. Buffalo buffalo buffalo
      // buffalo.

      const deferredResolutions = new Set();
      const resolvedDependencies = new Map();

      for (const descriptorHash of currentResolutionPass) {
        const descriptor = allDescriptors.get(descriptorHash);
        if (!descriptor) throw new Error(`Assertion failed: The descriptor should have been registered`);
        let dependencies = resolutionDependencies.get(descriptorHash);

        if (typeof dependencies === `undefined`) {
          resolutionDependencies.set(descriptorHash, dependencies = new Set());

          for (const dependency of resolver.getResolutionDependencies(descriptor, resolveOptions)) {
            allDescriptors.set(dependency.descriptorHash, dependency);
            dependencies.add(dependency.descriptorHash);
          }
        }

        const resolved = _miscUtils__WEBPACK_IMPORTED_MODULE_14__.getMapWithDefault(resolvedDependencies, descriptorHash);

        for (const dependencyHash of dependencies) {
          const resolution = allResolutions.get(dependencyHash);

          if (typeof resolution !== `undefined`) {
            const dependencyPkg = allPackages.get(resolution);
            if (typeof dependencyPkg === `undefined`) throw new Error(`Assertion failed: The package should have been registered`); // The dependency is ready. We register it into the map so
            // that we can pass that to getCandidates right after.

            resolved.set(dependencyHash, dependencyPkg);
          } else {
            // One of the resolution dependencies of this descriptor is
            // missing; we need to postpone its resolution for now.
            deferredResolutions.add(descriptorHash); // For this pass however we'll want to schedule the resolution
            // of the dependency (so that it's probably ready next pass).

            currentResolutionPass.add(dependencyHash);
          }
        }
      } // Note: we're postponing the resolution only once we already know all
      // those that are going to be postponed. This way we can detect
      // potential cyclic dependencies.


      for (const descriptorHash of deferredResolutions) {
        currentResolutionPass.delete(descriptorHash);
        nextResolutionPass.add(descriptorHash);
      }

      if (currentResolutionPass.size === 0) throw new Error(`Assertion failed: Descriptors should not have cyclic dependencies`); // Then we request the resolvers for the list of possible references that
      // match the given ranges. That will give us a set of candidate references
      // for each descriptor.

      const passCandidates = new Map(await Promise.all(Array.from(currentResolutionPass).map(async descriptorHash => {
        const descriptor = allDescriptors.get(descriptorHash);
        if (typeof descriptor === `undefined`) throw new Error(`Assertion failed: The descriptor should have been registered`);
        const descriptorDependencies = resolvedDependencies.get(descriptor.descriptorHash);
        if (typeof descriptorDependencies === `undefined`) throw new Error(`Assertion failed: The descriptor dependencies should have been registered`);
        let candidateLocators;

        try {
          candidateLocators = await resolver.getCandidates(descriptor, descriptorDependencies, resolveOptions);
        } catch (error) {
          error.message = `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(this.configuration, descriptor)}: ${error.message}`;
          throw error;
        }

        if (candidateLocators.length === 0) throw new Error(`No candidate found for ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(this.configuration, descriptor)}`);
        return [descriptor.descriptorHash, candidateLocators];
      }))); // That's where we'll store our resolutions until everything has been
      // resolved and can be injected into the various stores.
      //
      // The reason we're storing them in a temporary store instead of writing
      // them directly into the global ones is that otherwise we would end up
      // with different store orderings between dependency loaded from a
      // lockfiles and those who don't (when using a lockfile all descriptors
      // will fall into the next shortcut, but when no lockfile is there only
      // some of them will; since maps are sorted by insertion, it would affect
      // the way they would be ordered).

      const passResolutions = new Map(); // We now make a pre-pass to automatically resolve the descriptors that
      // can only be satisfied by a single reference.

      for (const [descriptorHash, candidateLocators] of passCandidates) {
        if (candidateLocators.length !== 1) continue;
        passResolutions.set(descriptorHash, candidateLocators[0]);
        passCandidates.delete(descriptorHash);
      } // We make a second pre-pass to automatically resolve the descriptors
      // that can be satisfied by a package we're already using (deduplication).


      for (const [descriptorHash, candidateLocators] of passCandidates) {
        const selectedLocator = candidateLocators.find(locator => allPackages.has(locator.locatorHash));
        if (!selectedLocator) continue;
        passResolutions.set(descriptorHash, selectedLocator);
        passCandidates.delete(descriptorHash);
      } // All entries that remain in "passCandidates" are from descriptors that
      // we haven't been able to resolve in the first place. We'll now configure
      // our SAT solver so that it can figure it out for us. To do this, we
      // simply add a constraint for each descriptor that lists all the
      // descriptors it would accept. We don't have to check whether the
      // locators obtained have already been selected, because if they were the
      // would have been resolved in the previous step (we never backtrace to
      // try to find better solutions, it would be a too expensive process - we
      // just want to get an acceptable solution, not the very best one).


      if (passCandidates.size > 0) {
        const solver = new (logic_solver__WEBPACK_IMPORTED_MODULE_4___default().Solver)();

        for (const candidateLocators of passCandidates.values()) solver.require(logic_solver__WEBPACK_IMPORTED_MODULE_4___default().or(...candidateLocators.map(locator => locator.locatorHash)));

        let remainingSolutions = 100;
        let solution;
        let bestSolution = null;
        let bestScore = Infinity;

        while (remainingSolutions > 0 && (solution = solver.solve()) !== null) {
          const trueVars = solution.getTrueVars();
          solver.forbid(solution.getFormula());

          if (trueVars.length < bestScore) {
            bestSolution = trueVars;
            bestScore = trueVars.length;
          }

          remainingSolutions -= 1;
        }

        if (!bestSolution) throw new Error(`Assertion failed: No resolution found by the SAT solver`);
        const solutionSet = new Set(bestSolution);

        for (const [descriptorHash, candidateLocators] of passCandidates.entries()) {
          const selectedLocator = candidateLocators.find(locator => solutionSet.has(locator.locatorHash));
          if (!selectedLocator) throw new Error(`Assertion failed: The descriptor should have been solved during the previous step`);
          passResolutions.set(descriptorHash, selectedLocator);
          passCandidates.delete(descriptorHash);
        }
      } // We now iterate over the locators we've got and, for each of them that
      // hasn't been seen before, we fetch its dependency list and schedule
      // them for the next cycle.


      const newLocators = Array.from(passResolutions.values()).filter(locator => {
        return !allPackages.has(locator.locatorHash);
      });
      const newPackages = new Map(await Promise.all(newLocators.map(async locator => {
        const original = await _miscUtils__WEBPACK_IMPORTED_MODULE_14__.prettifyAsyncErrors(async () => {
          return await resolver.resolve(locator, resolveOptions);
        }, message => {
          return `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, locator)}: ${message}`;
        });
        if (!_structUtils__WEBPACK_IMPORTED_MODULE_13__.areLocatorsEqual(locator, original)) throw new Error(`Assertion failed: The locator cannot be changed by the resolver (went from ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, locator)} to ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, original)})`);
        const pkg = this.configuration.normalizePackage(original);

        for (const [identHash, descriptor] of pkg.dependencies) {
          const dependency = await this.configuration.reduceHook(hooks => {
            return hooks.reduceDependency;
          }, descriptor, this, pkg, descriptor, {
            resolver,
            resolveOptions
          });
          if (!_structUtils__WEBPACK_IMPORTED_MODULE_13__.areIdentsEqual(descriptor, dependency)) throw new Error(`Assertion failed: The descriptor ident cannot be changed through aliases`);
          const bound = resolver.bindDescriptor(dependency, locator, resolveOptions);
          pkg.dependencies.set(identHash, bound);
        }

        return [pkg.locatorHash, {
          original,
          pkg
        }];
      }))); // Now that the resolution is finished, we can finally insert the data
      // stored inside our pass stores into the resolution ones (we now have
      // the guarantee that they'll always be inserted into in the same order,
      // since mustBeResolved is stable regardless of the order in which the
      // resolvers return)

      for (const descriptorHash of currentResolutionPass) {
        const locator = passResolutions.get(descriptorHash);
        if (!locator) throw new Error(`Assertion failed: The locator should have been registered`);
        allResolutions.set(descriptorHash, locator.locatorHash); // If undefined it means that the package was already known and thus
        // didn't need to be resolved again.

        const resolutionEntry = newPackages.get(locator.locatorHash);
        if (typeof resolutionEntry === `undefined`) continue;
        const {
          original,
          pkg
        } = resolutionEntry;
        originalPackages.set(original.locatorHash, original);
        allPackages.set(pkg.locatorHash, pkg);

        for (const descriptor of pkg.dependencies.values()) {
          allDescriptors.set(descriptor.descriptorHash, descriptor);
          nextResolutionPass.add(descriptor.descriptorHash); // We must check and make sure that the descriptor didn't get aliased
          // to something else

          const aliasHash = this.resolutionAliases.get(descriptor.descriptorHash);
          if (aliasHash === undefined) continue; // It doesn't cost us much to support the case where a descriptor is
          // equal to its own alias (which should mean "no alias")

          if (descriptor.descriptorHash === aliasHash) continue;
          const alias = this.storedDescriptors.get(aliasHash);
          if (!alias) throw new Error(`Assertion failed: The alias should have been registered`); // If it's already been "resolved" (in reality it will be the temporary
          // resolution we've set in the next few lines) we simply must skip it

          if (allResolutions.has(descriptor.descriptorHash)) continue; // Temporarily set an invalid resolution so that it won't be resolved
          // multiple times if it is found multiple times in the dependency
          // tree (this is only temporary, we will replace it by the actual
          // resolution after we've finished resolving everything)

          allResolutions.set(descriptor.descriptorHash, `temporary`); // We can now replace the descriptor by its alias in the list of
          // descriptors that must be resolved

          nextResolutionPass.delete(descriptor.descriptorHash);
          nextResolutionPass.add(aliasHash);
          allDescriptors.set(aliasHash, alias);
          haveBeenAliased.add(descriptor.descriptorHash);
        }
      }
    } // Each package that should have been resolved but was skipped because it
    // was aliased will now see the resolution for its alias propagated to it


    while (haveBeenAliased.size > 0) {
      let hasChanged = false;

      for (const descriptorHash of haveBeenAliased) {
        const descriptor = allDescriptors.get(descriptorHash);
        if (!descriptor) throw new Error(`Assertion failed: The descriptor should have been registered`);
        const aliasHash = this.resolutionAliases.get(descriptorHash);
        if (aliasHash === undefined) throw new Error(`Assertion failed: The descriptor should have an alias`);
        const resolution = allResolutions.get(aliasHash);
        if (resolution === undefined) throw new Error(`Assertion failed: The resolution should have been registered`); // The following can happen if a package gets aliased to another package
        // that's itself aliased - in this case we just process all those we can
        // do, then make new passes until everything is resolved

        if (resolution === `temporary`) continue;
        haveBeenAliased.delete(descriptorHash);
        allResolutions.set(descriptorHash, resolution);
        hasChanged = true;
      }

      if (!hasChanged) {
        throw new Error(`Alias loop detected`);
      }
    } // In this step we now create virtual packages for each package with at
    // least one peer dependency. We also use it to search for the alias
    // descriptors that aren't depended upon by anything and can be safely
    // pruned.


    const volatileDescriptors = new Set(this.resolutionAliases.values());
    const optionalBuilds = new Set(allPackages.keys());
    const accessibleLocators = new Set();
    applyVirtualResolutionMutations({
      project: this,
      report: opts.report,
      accessibleLocators,
      volatileDescriptors,
      optionalBuilds,
      allDescriptors,
      allResolutions,
      allPackages
    }); // All descriptors still referenced within the volatileDescriptors set are
    // descriptors that aren't depended upon by anything in the dependency tree.

    for (const descriptorHash of volatileDescriptors) {
      allDescriptors.delete(descriptorHash);
      allResolutions.delete(descriptorHash);
    } // Everything is done, we can now update our internal resolutions to
    // reference the new ones


    this.storedResolutions = allResolutions;
    this.storedDescriptors = allDescriptors;
    this.storedPackages = allPackages;
    this.accessibleLocators = accessibleLocators;
    this.originalPackages = originalPackages;
    this.optionalBuilds = optionalBuilds; // Now that the internal resolutions have been updated, we can refresh the
    // dependencies of each resolved workspace's `Workspace` instance.

    this.refreshWorkspaceDependencies();
  }

  async fetchEverything({
    cache,
    report,
    fetcher: userFetcher
  }) {
    const fetcher = userFetcher || this.configuration.makeFetcher();
    const fetcherOptions = {
      checksums: this.storedChecksums,
      project: this,
      cache,
      fetcher,
      report
    };
    const locatorHashes = _miscUtils__WEBPACK_IMPORTED_MODULE_14__.sortMap(this.storedResolutions.values(), [locatorHash => {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      return _structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyLocator(pkg);
    }]);
    let firstError = false;
    const progress = _Report__WEBPACK_IMPORTED_MODULE_23__.Report.progressViaCounter(locatorHashes.length);
    report.reportProgress(progress);
    const limit = p_limit__WEBPACK_IMPORTED_MODULE_5___default()(FETCHER_CONCURRENCY);
    await report.startCacheReport(async () => {
      await Promise.all(locatorHashes.map(locatorHash => limit(async () => {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
        if (_structUtils__WEBPACK_IMPORTED_MODULE_13__.isVirtualLocator(pkg)) return;
        let fetchResult;

        try {
          fetchResult = await fetcher.fetch(pkg, fetcherOptions);
        } catch (error) {
          error.message = `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg)}: ${error.message}`;
          report.reportExceptionOnce(error);
          firstError = error;
          return;
        }

        if (fetchResult.checksum) this.storedChecksums.set(pkg.locatorHash, fetchResult.checksum);else this.storedChecksums.delete(pkg.locatorHash);

        if (fetchResult.releaseFs) {
          fetchResult.releaseFs();
        }
      }).finally(() => {
        progress.tick();
      })));
    });

    if (firstError) {
      throw firstError;
    }
  }

  async linkEverything({
    cache,
    report,
    fetcher: optFetcher
  }) {
    const fetcher = optFetcher || this.configuration.makeFetcher();
    const fetcherOptions = {
      checksums: this.storedChecksums,
      project: this,
      cache,
      fetcher,
      report,
      skipIntegrityCheck: true
    };
    const linkers = this.configuration.getLinkers();
    const linkerOptions = {
      project: this,
      report
    };
    const installers = new Map(linkers.map(linker => {
      return [linker, linker.makeInstaller(linkerOptions)];
    }));
    const packageLinkers = new Map();
    const packageLocations = new Map();
    const packageBuildDirectives = new Map(); // Step 1: Installing the packages on the disk

    for (const locatorHash of this.accessibleLocators) {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      const fetchResult = await fetcher.fetch(pkg, fetcherOptions);

      if (this.tryWorkspaceByLocator(pkg) !== null) {
        const buildScripts = [];
        const {
          scripts
        } = await _Manifest__WEBPACK_IMPORTED_MODULE_16__.Manifest.find(fetchResult.prefixPath, {
          baseFs: fetchResult.packageFs
        });

        for (const scriptName of [`preinstall`, `install`, `postinstall`]) if (scripts.has(scriptName)) buildScripts.push([_Installer__WEBPACK_IMPORTED_MODULE_24__.BuildType.SCRIPT, scriptName]);

        try {
          for (const installer of installers.values()) {
            await installer.installPackage(pkg, fetchResult);
          }
        } finally {
          if (fetchResult.releaseFs) {
            fetchResult.releaseFs();
          }
        }

        const location = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(fetchResult.packageFs.getRealPath(), fetchResult.prefixPath);
        packageLocations.set(pkg.locatorHash, location);

        if (buildScripts.length > 0) {
          packageBuildDirectives.set(pkg.locatorHash, {
            directives: buildScripts,
            buildLocations: [location]
          });
        }
      } else {
        const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
        if (!linker) throw new _Report__WEBPACK_IMPORTED_MODULE_23__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.LINKER_NOT_FOUND, `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg)} isn't supported by any available linker`);
        const installer = installers.get(linker);
        if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
        let installStatus;

        try {
          installStatus = await installer.installPackage(pkg, fetchResult);
        } finally {
          if (fetchResult.releaseFs) {
            fetchResult.releaseFs();
          }
        }

        packageLinkers.set(pkg.locatorHash, linker);
        packageLocations.set(pkg.locatorHash, installStatus.packageLocation);

        if (installStatus.buildDirective && installStatus.packageLocation) {
          packageBuildDirectives.set(pkg.locatorHash, {
            directives: installStatus.buildDirective,
            buildLocations: [installStatus.packageLocation]
          });
        }
      }
    } // Step 2: Link packages together


    const externalDependents = new Map();

    for (const locatorHash of this.accessibleLocators) {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The locator should have been registered`);
      const isWorkspace = this.tryWorkspaceByLocator(pkg) !== null;

      const linkPackage = async (packageLinker, installer) => {
        const packageLocation = packageLocations.get(pkg.locatorHash);
        if (typeof packageLocation === `undefined`) throw new Error(`Assertion failed: The package (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg)}) should have been registered`);
        const internalDependencies = [];

        for (const descriptor of pkg.dependencies.values()) {
          const resolution = this.storedResolutions.get(descriptor.descriptorHash);
          if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(this.configuration, descriptor)}, from ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg)})should have been registered`);
          const dependency = this.storedPackages.get(resolution);
          if (typeof dependency === `undefined`) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
          const dependencyLinker = this.tryWorkspaceByLocator(dependency) === null ? packageLinkers.get(resolution) : null;
          if (typeof dependencyLinker === `undefined`) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
          const isWorkspaceDependency = dependencyLinker === null;

          if (dependencyLinker === packageLinker || isWorkspace || isWorkspaceDependency) {
            if (packageLocations.get(dependency.locatorHash) !== null) {
              internalDependencies.push([descriptor, dependency]);
            }
          } else if (packageLocation !== null) {
            const externalEntry = _miscUtils__WEBPACK_IMPORTED_MODULE_14__.getArrayWithDefault(externalDependents, resolution);
            externalEntry.push(packageLocation);
          }
        }

        if (packageLocation !== null) {
          await installer.attachInternalDependencies(pkg, internalDependencies);
        }
      };

      if (isWorkspace) {
        for (const [packageLinker, installer] of installers) {
          await linkPackage(packageLinker, installer);
        }
      } else {
        const packageLinker = packageLinkers.get(pkg.locatorHash);
        if (!packageLinker) throw new Error(`Assertion failed: The linker should have been found`);
        const installer = installers.get(packageLinker);
        if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
        await linkPackage(packageLinker, installer);
      }
    }

    for (const [locatorHash, dependentPaths] of externalDependents) {
      const pkg = this.storedPackages.get(locatorHash);
      if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
      const packageLinker = packageLinkers.get(pkg.locatorHash);
      if (!packageLinker) throw new Error(`Assertion failed: The linker should have been found`);
      const installer = installers.get(packageLinker);
      if (!installer) throw new Error(`Assertion failed: The installer should have been registered`);
      await installer.attachExternalDependents(pkg, dependentPaths);
    } // Step 3: Inform our linkers that they should have all the info needed


    for (const installer of installers.values()) {
      const installStatuses = await installer.finalizeInstall();

      if (installStatuses) {
        for (const installStatus of installStatuses) {
          if (installStatus.buildDirective) {
            packageBuildDirectives.set(installStatus.locatorHash, {
              directives: installStatus.buildDirective,
              buildLocations: installStatus.buildLocations
            });
          }
        }
      }
    } // Step 4: Build the packages in multiple steps


    const readyPackages = new Set(this.storedPackages.keys());
    const buildablePackages = new Set(packageBuildDirectives.keys());

    for (const locatorHash of buildablePackages) readyPackages.delete(locatorHash);

    const globalHashGenerator = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.createHash)(`sha512`);
    globalHashGenerator.update(process.versions.node);
    this.configuration.triggerHook(hooks => {
      return hooks.globalHashGeneration;
    }, this, data => {
      globalHashGenerator.update(`\0`);
      globalHashGenerator.update(data);
    });
    const globalHash = globalHashGenerator.digest(`hex`);
    const packageHashMap = new Map(); // We'll use this function is order to compute a hash for each package
    // that exposes a build directive. If the hash changes compared to the
    // previous run, the package is rebuilt. This has the advantage of making
    // the rebuilds much more predictable than before, and to give us the tools
    // later to improve this further by explaining *why* a rebuild happened.

    const getBaseHash = locator => {
      let hash = packageHashMap.get(locator.locatorHash);
      if (typeof hash !== `undefined`) return hash;
      const pkg = this.storedPackages.get(locator.locatorHash);
      if (typeof pkg === `undefined`) throw new Error(`Assertion failed: The package should have been registered`);
      const builder = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.createHash)(`sha512`);
      builder.update(locator.locatorHash); // To avoid the case where one dependency depends on itself somehow

      packageHashMap.set(locator.locatorHash, `<recursive>`);

      for (const descriptor of pkg.dependencies.values()) {
        const resolution = this.storedResolutions.get(descriptor.descriptorHash);
        if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(this.configuration, descriptor)}) should have been registered`);
        const dependency = this.storedPackages.get(resolution);
        if (typeof dependency === `undefined`) throw new Error(`Assertion failed: The package should have been registered`);
        builder.update(getBaseHash(pkg));
      }

      hash = builder.digest(`hex`);
      packageHashMap.set(locator.locatorHash, hash);
      return hash;
    };

    const getBuildHash = (locator, buildLocations) => {
      const builder = (0,crypto__WEBPACK_IMPORTED_MODULE_2__.createHash)(`sha512`);
      builder.update(globalHash);
      builder.update(getBaseHash(locator));

      for (const location of buildLocations) builder.update(location);

      return builder.digest(`hex`);
    };

    const bstatePath = this.configuration.get(`bstatePath`);
    const bstate = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(bstatePath) ? (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(bstatePath, `utf8`)) : {}; // We reconstruct the build state from an empty object because we want to
    // remove the state from packages that got removed

    const nextBState = new Map();

    while (buildablePackages.size > 0) {
      const savedSize = buildablePackages.size;
      const buildPromises = [];

      for (const locatorHash of buildablePackages) {
        const pkg = this.storedPackages.get(locatorHash);
        if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
        let isBuildable = true;

        for (const dependency of pkg.dependencies.values()) {
          const resolution = this.storedResolutions.get(dependency.descriptorHash);
          if (!resolution) throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(this.configuration, dependency)}) should have been registered`);

          if (buildablePackages.has(resolution)) {
            isBuildable = false;
            break;
          }
        } // Wait until all dependencies of the current package have been built
        // before trying to build it (since it might need them to build itself)


        if (!isBuildable) continue;
        buildablePackages.delete(locatorHash);
        const buildInfo = packageBuildDirectives.get(pkg.locatorHash);
        if (!buildInfo) throw new Error(`Assertion failed: The build directive should have been registered`);
        const buildHash = getBuildHash(pkg, buildInfo.buildLocations); // No need to rebuild the package if its hash didn't change

        if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash) && bstate[pkg.locatorHash] === buildHash) {
          nextBState.set(pkg.locatorHash, buildHash);
          continue;
        }

        if (Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash)) report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.MUST_REBUILD, `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg)} must be rebuilt because its dependency tree changed`);else report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.MUST_BUILD, `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg)} must be built because it never did before or the last one failed`);

        for (const location of buildInfo.buildLocations) {
          if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.isAbsolute(location)) throw new Error(`Assertion failed: Expected the build location to be absolute (not ${location})`);
          buildPromises.push((async () => {
            for (const [buildType, scriptName] of buildInfo.directives) {
              let header = `# This file contains the result of Yarn building a package (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyLocator(pkg)})\n`;

              switch (buildType) {
                case _Installer__WEBPACK_IMPORTED_MODULE_24__.BuildType.SCRIPT:
                  {
                    header += `# Script name: ${scriptName}\n`;
                  }
                  break;

                case _Installer__WEBPACK_IMPORTED_MODULE_24__.BuildType.SHELLCODE:
                  {
                    header += `# Script code: ${scriptName}\n`;
                  }
                  break;
              }

              const stdin = null;
              await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mktempPromise(async logDir => {
                const logFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(logDir, `build.log`);
                const {
                  stdout,
                  stderr
                } = this.configuration.getSubprocessStreams(logFile, {
                  header,
                  prefix: _structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg),
                  report
                });
                let exitCode;

                try {
                  switch (buildType) {
                    case _Installer__WEBPACK_IMPORTED_MODULE_24__.BuildType.SCRIPT:
                      {
                        exitCode = await _scriptUtils__WEBPACK_IMPORTED_MODULE_26__.executePackageScript(pkg, scriptName, [], {
                          cwd: location,
                          project: this,
                          stdin,
                          stdout,
                          stderr
                        });
                      }
                      break;

                    case _Installer__WEBPACK_IMPORTED_MODULE_24__.BuildType.SHELLCODE:
                      {
                        exitCode = await _scriptUtils__WEBPACK_IMPORTED_MODULE_26__.executePackageShellcode(pkg, scriptName, [], {
                          cwd: location,
                          project: this,
                          stdin,
                          stdout,
                          stderr
                        });
                      }
                      break;
                  }
                } catch (error) {
                  stderr.write(error.stack);
                  exitCode = 1;
                }

                stdout.end();
                stderr.end();

                if (exitCode === 0) {
                  nextBState.set(pkg.locatorHash, buildHash);
                  return true;
                }

                _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.detachTemp(logDir);
                const buildMessage = `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg)} couldn't be built successfully (exit code ${this.configuration.format(String(exitCode), _Configuration__WEBPACK_IMPORTED_MODULE_12__.FormatType.NUMBER)}, logs can be found here: ${this.configuration.format(logFile, _Configuration__WEBPACK_IMPORTED_MODULE_12__.FormatType.PATH)})`;
                report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.BUILD_FAILED, buildMessage);

                if (this.optionalBuilds.has(pkg.locatorHash)) {
                  nextBState.set(pkg.locatorHash, buildHash);
                  return true;
                }

                report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.BUILD_FAILED, buildMessage);
                return false;
              });
            }
          })());
        }
      }

      await Promise.all(buildPromises); // If we reach this code, it means that we have circular dependencies
      // somewhere. Worst, it means that the circular dependencies both have
      // build scripts, making them unsatisfiable.

      if (savedSize === buildablePackages.size) {
        const prettyLocators = Array.from(buildablePackages).map(locatorHash => {
          const pkg = this.storedPackages.get(locatorHash);
          if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
          return _structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(this.configuration, pkg);
        }).join(`, `);
        report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.CYCLIC_DEPENDENCIES, `Some packages have circular dependencies that make their build order unsatisfiable - as a result they won't be built (affected packages are: ${prettyLocators})`);
        break;
      }
    } // We can now generate the bstate file, which will allow us to "remember"
    // what's the dependency tree subset that we used to build a specific
    // package (and avoid rebuilding it later if it didn't change).


    if (nextBState.size > 0) {
      const bstatePath = this.configuration.get(`bstatePath`);
      const bstateFile = Project.generateBuildStateFile(nextBState, this.storedPackages);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(bstatePath), {
        recursive: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.changeFilePromise(bstatePath, bstateFile, {
        automaticNewlines: true
      });
    } else {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.removePromise(bstatePath);
    }
  }

  async install(opts) {
    var _a, _b;

    const nodeLinker = this.configuration.get(`nodeLinker`);
    (_a = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.reportInstall(nodeLinker);

    for (const extensions of this.configuration.packageExtensions.values()) for (const {
      descriptor,
      changes
    } of extensions) for (const change of changes) (_b = _Configuration__WEBPACK_IMPORTED_MODULE_12__.Configuration.telemetry) === null || _b === void 0 ? void 0 : _b.reportPackageExtension(`${_structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyIdent(descriptor)}:${change}`);

    const validationWarnings = [];
    const validationErrors = [];
    await this.configuration.triggerHook(hooks => {
      return hooks.validateProject;
    }, this, {
      reportWarning: (name, text) => validationWarnings.push({
        name,
        text
      }),
      reportError: (name, text) => validationErrors.push({
        name,
        text
      })
    });
    const problemCount = validationWarnings.length + validationErrors.length;

    if (problemCount > 0) {
      await opts.report.startTimerPromise(`Validation step`, async () => {
        await this.validateEverything({
          validationWarnings,
          validationErrors,
          report: opts.report
        });
      });
    }

    await opts.report.startTimerPromise(`Resolution step`, async () => {
      const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`)); // If we operate with a frozen lockfile, we take a snapshot of it to later make sure it didn't change

      let initialLockfile = null;

      if (opts.immutable) {
        try {
          initialLockfile = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(lockfilePath, `utf8`);
        } catch (error) {
          if (error.code === `ENOENT`) {
            throw new _Report__WEBPACK_IMPORTED_MODULE_23__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been created by this install, which is explicitly forbidden.`);
          } else {
            throw error;
          }
        }
      }

      await this.resolveEverything(opts);

      if (initialLockfile !== null) {
        const newLockfile = (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_27__.normalizeLineEndings)(initialLockfile, this.generateLockfile());

        if (newLockfile !== initialLockfile) {
          const diff = (0,diff__WEBPACK_IMPORTED_MODULE_3__.structuredPatch)(lockfilePath, lockfilePath, initialLockfile, newLockfile);
          opts.report.reportSeparator();

          for (const hunk of diff.hunks) {
            opts.report.reportInfo(null, `@@ -${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines} @@`);

            for (const line of hunk.lines) {
              if (line.startsWith(`+`)) {
                opts.report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.FROZEN_LOCKFILE_EXCEPTION, this.configuration.format(line, _Configuration__WEBPACK_IMPORTED_MODULE_12__.FormatType.ADDED));
              } else if (line.startsWith(`-`)) {
                opts.report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.FROZEN_LOCKFILE_EXCEPTION, this.configuration.format(line, _Configuration__WEBPACK_IMPORTED_MODULE_12__.FormatType.REMOVED));
              } else {
                opts.report.reportInfo(null, this.configuration.format(line, `grey`));
              }
            }
          }

          opts.report.reportSeparator();
          throw new _Report__WEBPACK_IMPORTED_MODULE_23__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.FROZEN_LOCKFILE_EXCEPTION, `The lockfile would have been modified by this install, which is explicitly forbidden.`);
        }
      }
    });
    await opts.report.startTimerPromise(`Fetch step`, async () => {
      await this.fetchEverything(opts);

      if (typeof opts.persistProject === `undefined` || opts.persistProject) {
        await this.cacheCleanup(opts);
      }
    });
    if (typeof opts.persistProject === `undefined` || opts.persistProject) await this.persist();
    await opts.report.startTimerPromise(`Link step`, async () => {
      const immutablePatterns = opts.immutable ? [...new Set(this.configuration.get(`immutablePatterns`))].sort() : [];
      const before = await Promise.all(immutablePatterns.map(async pattern => {
        return _hashUtils__WEBPACK_IMPORTED_MODULE_15__.checksumPattern(pattern, {
          cwd: this.cwd
        });
      }));
      await this.linkEverything(opts);
      const after = await Promise.all(immutablePatterns.map(async pattern => {
        return _hashUtils__WEBPACK_IMPORTED_MODULE_15__.checksumPattern(pattern, {
          cwd: this.cwd
        });
      }));

      for (let t = 0; t < immutablePatterns.length; ++t) {
        if (before[t] !== after[t]) {
          opts.report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.FROZEN_ARTIFACT_EXCEPTION, `The checksum for ${immutablePatterns[t]} has been modified by this install, which is explicitly forbidden.`);
        }
      }
    });
    await this.configuration.triggerHook(hooks => {
      return hooks.afterAllInstalled;
    }, this);
  }

  generateLockfile() {
    // We generate the data structure that will represent our lockfile. To do this, we create a
    // reverse lookup table, where the key will be the resolved locator and the value will be a set
    // of all the descriptors that resolved to it. Then we use it to construct an optimized version
    // if the final object.
    const reverseLookup = new Map();

    for (const [descriptorHash, locatorHash] of this.storedResolutions.entries()) {
      let descriptorHashes = reverseLookup.get(locatorHash);
      if (!descriptorHashes) reverseLookup.set(locatorHash, descriptorHashes = new Set());
      descriptorHashes.add(descriptorHash);
    }

    const optimizedLockfile = {};
    optimizedLockfile.__metadata = {
      version: LOCKFILE_VERSION
    };

    for (const [locatorHash, descriptorHashes] of reverseLookup.entries()) {
      const pkg = this.originalPackages.get(locatorHash); // A resolution that isn't in `originalPackages` is a virtual packages.
      // Since virtual packages can be derived from the information stored in
      // the rest of the lockfile we don't want to bother storing them.

      if (!pkg) continue;
      const descriptors = [];

      for (const descriptorHash of descriptorHashes) {
        const descriptor = this.storedDescriptors.get(descriptorHash);
        if (!descriptor) throw new Error(`Assertion failed: The descriptor should have been registered`);
        descriptors.push(descriptor);
      }

      const key = descriptors.map(descriptor => {
        return _structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyDescriptor(descriptor);
      }).sort().join(`, `);
      const manifest = new _Manifest__WEBPACK_IMPORTED_MODULE_16__.Manifest();
      manifest.version = pkg.linkType === _types__WEBPACK_IMPORTED_MODULE_28__.LinkType.HARD ? pkg.version : `0.0.0-use.local`;
      manifest.languageName = pkg.languageName;
      manifest.dependencies = new Map(pkg.dependencies);
      manifest.peerDependencies = new Map(pkg.peerDependencies);
      manifest.dependenciesMeta = new Map(pkg.dependenciesMeta);
      manifest.peerDependenciesMeta = new Map(pkg.peerDependenciesMeta);
      manifest.bin = new Map(pkg.bin);
      let entryChecksum;
      const checksum = this.storedChecksums.get(pkg.locatorHash);

      if (typeof checksum !== `undefined`) {
        const cacheKeyIndex = checksum.indexOf(`/`);
        if (cacheKeyIndex === -1) throw new Error(`Assertion failed: Expecte the checksum to reference its cache key`);
        const cacheKey = checksum.slice(0, cacheKeyIndex);
        const hash = checksum.slice(cacheKeyIndex + 1);
        if (typeof optimizedLockfile.__metadata.cacheKey === `undefined`) optimizedLockfile.__metadata.cacheKey = cacheKey;

        if (cacheKey === optimizedLockfile.__metadata.cacheKey) {
          entryChecksum = hash;
        } else {
          entryChecksum = checksum;
        }
      }

      optimizedLockfile[key] = { ...manifest.exportTo({}, {
          compatibilityMode: false
        }),
        linkType: pkg.linkType.toLowerCase(),
        resolution: _structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyLocator(pkg),
        checksum: entryChecksum
      };
    }

    const header = `${[`# This file is generated by running "yarn install" inside your project.\n`, `# Manual changes might be lost - proceed with caution!\n`].join(``)}\n`;
    return header + (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.stringifySyml)(optimizedLockfile);
  }

  async persistLockfile() {
    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(this.cwd, this.configuration.get(`lockfileFilename`));
    const lockfileContent = this.generateLockfile();
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.changeFilePromise(lockfilePath, lockfileContent, {
      automaticNewlines: true
    });
  }

  async persistInstallStateFile() {
    const {
      accessibleLocators,
      optionalBuilds,
      storedDescriptors,
      storedResolutions,
      storedPackages,
      lockFileChecksum
    } = this;
    const installState = {
      accessibleLocators,
      optionalBuilds,
      storedDescriptors,
      storedResolutions,
      storedPackages,
      lockFileChecksum
    };
    const serializedState = await gzip(v8__WEBPACK_IMPORTED_MODULE_8___default().serialize(installState));
    const installStatePath = this.configuration.get(`installStatePath`);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.dirname(installStatePath), {
      recursive: true
    });
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.writeFilePromise(installStatePath, serializedState);
  }

  async restoreInstallState() {
    const installStatePath = this.configuration.get(`installStatePath`);

    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(installStatePath)) {
      await this.applyLightResolution();
      return;
    }

    const serializedState = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(installStatePath);
    const installState = v8__WEBPACK_IMPORTED_MODULE_8___default().deserialize(await gunzip(serializedState));

    if (installState.lockFileChecksum !== this.lockFileChecksum) {
      await this.applyLightResolution();
      return;
    }

    Object.assign(this, installState);
    this.refreshWorkspaceDependencies();
  }

  async applyLightResolution() {
    await this.resolveEverything({
      lockfileOnly: true,
      report: new _ThrowReport__WEBPACK_IMPORTED_MODULE_18__.ThrowReport()
    });
    await this.persistInstallStateFile();
  }

  async persist() {
    await this.persistLockfile();
    await this.persistInstallStateFile();

    for (const workspace of this.workspacesByCwd.values()) {
      await workspace.persistManifest();
    }
  }

  async cacheCleanup({
    cache,
    report
  }) {
    const PRESERVED_FILES = new Set([`.gitignore`]);
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(cache.cwd)) return;
    if (!(0,_folderUtils__WEBPACK_IMPORTED_MODULE_29__.isFolderInside)(cache.cwd, this.cwd)) return;

    for (const entry of await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readdirPromise(cache.cwd)) {
      if (PRESERVED_FILES.has(entry)) continue;
      const entryPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.resolve(cache.cwd, entry);
      if (cache.markedFiles.has(entryPath)) continue;

      if (cache.immutable) {
        report.reportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.IMMUTABLE_CACHE, `${this.configuration.format(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.basename(entryPath), `magenta`)} appears to be unused and would marked for deletion, but the cache is immutable`);
      } else {
        report.reportInfo(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.UNUSED_CACHE_ENTRY, `${this.configuration.format(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.basename(entryPath), `magenta`)} appears to be unused - removing`);
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.removePromise(entryPath);
      }
    }

    cache.markedFiles.clear();
  }

}
/**
 * This function is worth some documentation. It takes a set of packages,
 * traverses them all, and generates virtual packages for each package that
 * lists peer dependencies.
 *
 * We also take advantage of the tree traversal to detect which packages are
 * actually used and which have disappeared, and to know which packages truly
 * have an optional build (since a package may be optional in one part of the
 * tree but not another).
 */

function applyVirtualResolutionMutations({
  project,
  allDescriptors,
  allResolutions,
  allPackages,
  accessibleLocators = new Set(),
  optionalBuilds = new Set(),
  volatileDescriptors = new Set(),
  report,
  tolerateMissingPackages = false
}) {
  const virtualStack = new Map();
  const resolutionStack = []; // We'll be keeping track of all virtual descriptors; once they have all
  // been generated we'll check whether they can be consolidated into one.

  const allVirtualInstances = new Map();
  const allVirtualDependents = new Map(); // We must keep a copy of the workspaces original dependencies, because they
  // may be overriden during the virtual package resolution - cf Dragon Test #5

  const originalWorkspaceDefinitions = new Map(project.workspaces.map(workspace => {
    const locatorHash = workspace.anchoredLocator.locatorHash;
    const pkg = allPackages.get(locatorHash);

    if (typeof pkg === `undefined`) {
      if (tolerateMissingPackages) {
        return [locatorHash, null];
      } else {
        throw new Error(`Assertion failed: The workspace should have an associated package`);
      }
    }

    return [locatorHash, _structUtils__WEBPACK_IMPORTED_MODULE_13__.copyPackage(pkg)];
  }));

  const reportStackOverflow = () => {
    const logDir = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mktempSync();
    const logFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.ppath.join(logDir, `stacktrace.log`);
    const maxSize = String(resolutionStack.length + 1).length;
    const content = resolutionStack.map((locator, index) => {
      const prefix = `${index + 1}.`.padStart(maxSize, ` `);
      return `${prefix} ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyLocator(locator)}\n`;
    }).join(``);
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.writeFileSync(logFile, content);
    throw new _Report__WEBPACK_IMPORTED_MODULE_23__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.STACK_OVERFLOW_RESOLUTION, `Encountered a stack overflow when resolving peer dependencies; cf ${logFile}`);
  };

  const getPackageFromDescriptor = descriptor => {
    const resolution = allResolutions.get(descriptor.descriptorHash);
    if (typeof resolution === `undefined`) throw new Error(`Assertion failed: The resolution should have been registered`);
    const pkg = allPackages.get(resolution);
    if (!pkg) throw new Error(`Assertion failed: The package could not be found`);
    return pkg;
  };

  const resolvePeerDependencies = (parentLocator, first, optional) => {
    if (resolutionStack.length > 1000) reportStackOverflow();
    resolutionStack.push(parentLocator);
    const result = resolvePeerDependenciesImpl(parentLocator, first, optional);
    resolutionStack.pop();
    return result;
  };

  const resolvePeerDependenciesImpl = (parentLocator, first, optional) => {
    if (accessibleLocators.has(parentLocator.locatorHash)) return;
    accessibleLocators.add(parentLocator.locatorHash);
    if (!optional) optionalBuilds.delete(parentLocator.locatorHash);
    const parentPackage = allPackages.get(parentLocator.locatorHash);

    if (!parentPackage) {
      if (tolerateMissingPackages) {
        return;
      } else {
        throw new Error(`Assertion failed: The package (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, parentLocator)}) should have been registered`);
      }
    }

    const newVirtualInstances = [];
    const firstPass = [];
    const secondPass = [];
    const thirdPass = [];
    const fourthPass = []; // During this first pass we virtualize the descriptors. This allows us
    // to reference them from their sibling without being order-dependent,
    // which is required to solve cases where packages with peer dependencies
    // have peer dependencies themselves.

    for (const descriptor of Array.from(parentPackage.dependencies.values())) {
      // We shouldn't virtualize the package if it was obtained through a peer
      // dependency (which can't be the case for workspaces when resolved
      // through their top-level)
      if (parentPackage.peerDependencies.has(descriptor.identHash) && !first) continue; // We had some issues where virtual packages were incorrectly set inside
      // workspaces, causing leaks. Check the Dragon Test #5 for more details.

      if (_structUtils__WEBPACK_IMPORTED_MODULE_13__.isVirtualDescriptor(descriptor)) throw new Error(`Assertion failed: Virtual packages shouldn't be encountered when virtualizing a branch`); // Mark this package as being used (won't be removed from the lockfile)

      volatileDescriptors.delete(descriptor.descriptorHash); // Detect whether this package is being required

      let isOptional = optional;

      if (!isOptional) {
        const dependencyMetaSet = parentPackage.dependenciesMeta.get(_structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyIdent(descriptor));

        if (typeof dependencyMetaSet !== `undefined`) {
          const dependencyMeta = dependencyMetaSet.get(null);

          if (typeof dependencyMeta !== `undefined` && dependencyMeta.optional) {
            isOptional = true;
          }
        }
      }

      const resolution = allResolutions.get(descriptor.descriptorHash);

      if (!resolution) {
        // Note that we can't use `getPackageFromDescriptor` (defined below,
        // because when doing the initial tree building right after loading the
        // project it's possible that we get some entries that haven't been
        // registered into the lockfile yet - for example when the user has
        // manually changed the package.json dependencies)
        if (tolerateMissingPackages) {
          continue;
        } else {
          throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(project.configuration, descriptor)}) should have been registered`);
        }
      }

      const pkg = originalWorkspaceDefinitions.get(resolution) || allPackages.get(resolution);
      if (!pkg) throw new Error(`Assertion failed: The package (${resolution}, resolved from ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(project.configuration, descriptor)}) should have been registered`);

      if (pkg.peerDependencies.size === 0) {
        resolvePeerDependencies(pkg, false, isOptional);
        continue;
      } // The stack overflow is checked against two level because a workspace
      // may have a dev dependency on another workspace that lists the first
      // one as a regular dependency. In this case the loop will break so we
      // don't need to throw an exception.


      const stackDepth = virtualStack.get(pkg.locatorHash);
      if (typeof stackDepth === `number` && stackDepth >= 2) reportStackOverflow();
      let virtualizedDescriptor;
      let virtualizedPackage;
      const missingPeerDependencies = new Set();
      firstPass.push(() => {
        virtualizedDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_13__.virtualizeDescriptor(descriptor, parentLocator.locatorHash);
        virtualizedPackage = _structUtils__WEBPACK_IMPORTED_MODULE_13__.virtualizePackage(pkg, parentLocator.locatorHash);
        parentPackage.dependencies.delete(descriptor.identHash);
        parentPackage.dependencies.set(virtualizedDescriptor.identHash, virtualizedDescriptor);
        allResolutions.set(virtualizedDescriptor.descriptorHash, virtualizedPackage.locatorHash);
        allDescriptors.set(virtualizedDescriptor.descriptorHash, virtualizedDescriptor);
        allPackages.set(virtualizedPackage.locatorHash, virtualizedPackage); // Keep track of all new virtual packages since we'll want to dedupe them

        newVirtualInstances.push([pkg, virtualizedDescriptor, virtualizedPackage]);
      });
      secondPass.push(() => {
        for (const peerRequest of virtualizedPackage.peerDependencies.values()) {
          let peerDescriptor = parentPackage.dependencies.get(peerRequest.identHash);

          if (!peerDescriptor && _structUtils__WEBPACK_IMPORTED_MODULE_13__.areIdentsEqual(parentLocator, peerRequest)) {
            peerDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_13__.convertLocatorToDescriptor(parentLocator);
            allDescriptors.set(peerDescriptor.descriptorHash, peerDescriptor);
            allResolutions.set(peerDescriptor.descriptorHash, parentLocator.locatorHash);
            volatileDescriptors.delete(peerDescriptor.descriptorHash);
          }

          if (!peerDescriptor && virtualizedPackage.dependencies.has(peerRequest.identHash)) {
            virtualizedPackage.peerDependencies.delete(peerRequest.identHash);
            continue;
          }

          if (!peerDescriptor) {
            if (!parentPackage.peerDependencies.has(peerRequest.identHash)) {
              const peerDependencyMeta = virtualizedPackage.peerDependenciesMeta.get(_structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyIdent(peerRequest));

              if (report !== null && (!peerDependencyMeta || !peerDependencyMeta.optional)) {
                report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.MISSING_PEER_DEPENDENCY, `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, parentLocator)} doesn't provide ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(project.configuration, peerRequest)} requested by ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, pkg)}`);
              }
            }

            peerDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_13__.makeDescriptor(peerRequest, `missing:`);
          }

          virtualizedPackage.dependencies.set(peerDescriptor.identHash, peerDescriptor); // Need to track when a virtual descriptor is set as a dependency in case
          // the descriptor will be consolidated.

          if (_structUtils__WEBPACK_IMPORTED_MODULE_13__.isVirtualDescriptor(peerDescriptor)) {
            const dependents = _miscUtils__WEBPACK_IMPORTED_MODULE_14__.getSetWithDefault(allVirtualDependents, peerDescriptor.descriptorHash);
            dependents.add(virtualizedPackage.locatorHash);
          }

          if (peerDescriptor.range === `missing:`) {
            missingPeerDependencies.add(peerDescriptor.identHash);
          } else if (report !== null) {
            // When the parent provides the peer dependency request it must be checked to ensure
            // it is a compatible version.
            const peerPackage = getPackageFromDescriptor(peerDescriptor);

            if (!_semverUtils__WEBPACK_IMPORTED_MODULE_30__.satisfiesWithPrereleases(peerPackage.version, peerRequest.range)) {
              report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_25__.MessageName.INCOMPATIBLE_PEER_DEPENDENCY, `${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, parentLocator)} provides ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, peerPackage)} with version ${peerPackage.version} which doesn't satisfy ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyRange(project.configuration, peerRequest.range)} requested by ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyLocator(project.configuration, pkg)}`);
            }
          }
        } // Since we've had to add new dependencies we need to sort them all over again


        virtualizedPackage.dependencies = new Map(_miscUtils__WEBPACK_IMPORTED_MODULE_14__.sortMap(virtualizedPackage.dependencies, ([identHash, descriptor]) => {
          return _structUtils__WEBPACK_IMPORTED_MODULE_13__.stringifyIdent(descriptor);
        }));
      });
      thirdPass.push(() => {
        if (!allPackages.has(virtualizedPackage.locatorHash)) return;
        const current = virtualStack.get(pkg.locatorHash);
        const next = typeof current !== `undefined` ? current + 1 : 1;
        virtualStack.set(pkg.locatorHash, next);
        resolvePeerDependencies(virtualizedPackage, false, isOptional);
        virtualStack.set(pkg.locatorHash, next - 1);
      });
      fourthPass.push(() => {
        if (!allPackages.has(virtualizedPackage.locatorHash)) return;

        for (const missingPeerDependency of missingPeerDependencies) {
          virtualizedPackage.dependencies.delete(missingPeerDependency);
        }
      });
    }

    for (const fn of [...firstPass, ...secondPass]) fn();

    let stable;

    do {
      stable = true;

      for (const [physicalLocator, virtualDescriptor, virtualPackage] of newVirtualInstances) {
        if (!allPackages.has(virtualPackage.locatorHash)) continue;
        const otherVirtualInstances = _miscUtils__WEBPACK_IMPORTED_MODULE_14__.getMapWithDefault(allVirtualInstances, physicalLocator.locatorHash); // We take all the dependencies from the new virtual instance and
        // generate a hash from it. By checking if this hash is already
        // registered, we know whether we can trim the new version.

        const dependencyHash = _hashUtils__WEBPACK_IMPORTED_MODULE_15__.makeHash(...[...virtualPackage.dependencies.values()].map(descriptor => {
          const resolution = descriptor.range !== `missing:` ? allResolutions.get(descriptor.descriptorHash) : `missing:`;
          if (typeof resolution === `undefined`) throw new Error(`Assertion failed: Expected the resolution for ${_structUtils__WEBPACK_IMPORTED_MODULE_13__.prettyDescriptor(project.configuration, descriptor)} to have been registered`);
          return resolution;
        }));
        const masterDescriptor = otherVirtualInstances.get(dependencyHash);

        if (typeof masterDescriptor === `undefined`) {
          otherVirtualInstances.set(dependencyHash, virtualDescriptor);
          continue;
        } // Since we're applying multiple pass, we might have already registered
        // ourselves as the "master" descriptor in the previous pass.


        if (masterDescriptor === virtualDescriptor) continue;
        stable = false;
        allPackages.delete(virtualPackage.locatorHash);
        allDescriptors.delete(virtualDescriptor.descriptorHash);
        allResolutions.delete(virtualDescriptor.descriptorHash);
        accessibleLocators.delete(virtualPackage.locatorHash);
        const dependents = allVirtualDependents.get(virtualDescriptor.descriptorHash) || [];
        const allDependents = [parentPackage.locatorHash, ...dependents];

        for (const dependent of allDependents) {
          const pkg = allPackages.get(dependent);
          if (typeof pkg === `undefined`) continue;
          pkg.dependencies.set(virtualDescriptor.identHash, masterDescriptor);
        }
      }
    } while (!stable);

    for (const fn of [...thirdPass, ...fourthPass]) {
      fn();
    }
  };

  for (const workspace of project.workspaces) {
    volatileDescriptors.delete(workspace.anchoredDescriptor.descriptorHash);
    resolvePeerDependencies(workspace.anchoredLocator, true, false);
  }
}

/***/ }),
/* 243 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "structuredPatch": () => /* binding */ structuredPatch
/* harmony export */ });
/* unused harmony exports Diff, diffChars, diffWords, diffWordsWithSpace, diffLines, diffTrimmedLines, diffSentences, diffCss, diffJson, diffArrays, createTwoFilesPatch, createPatch, applyPatch, applyPatches, parsePatch, merge, convertChangesToDMP, convertChangesToXML, canonicalize */
function Diff() {}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = options.callback;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    this.options = options;
    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    } // Allow subclasses to massage the input prior to running


    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }]; // Seed editLength = 0, i.e. the content starts with the same values

    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    } // Main worker method. checks all permutations of a given edit length for acceptance.


    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = void 0;

        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        } // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph


        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list

          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    } // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.


    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.

          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();

        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];

    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      };
    } else {
      components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;

    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }

    basePath.newPos = newPos;
    return oldPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];

    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }

    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split('');
  },
  join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];

    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }

      newPos += component.count; // Common case

      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.

      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  } // Special case handle for when one terminal is ignored (i.e. whitespace).
  // For this case we merge the terminal into the prior string and drop the change.
  // This is only available for string mode.


  var lastComponent = components[componentLen - 1];

  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}

var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}

function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }

  return defaults;
}

//
// Ranges and exceptions:
// Latin-1 Supplement, 008000FF
//  - U+00D7   Multiplication sign
//  - U+00F7   Division sign
// Latin Extended-A, 0100017F
// Latin Extended-B, 0180024F
// IPA Extensions, 025002AF
// Spacing Modifier Letters, 02B002FF
//  - U+02C7   &#711;  Caron
//  - U+02D8   &#728;  Breve
//  - U+02D9   &#729;  Dot Above
//  - U+02DA   &#730;  Ring Above
//  - U+02DB   &#731;  Ogonek
//  - U+02DC   &#732;  Small Tilde
//  - U+02DD   &#733;  Double Acute Accent
// Latin Extended Additional, 1E001EFF

var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();

wordDiff.equals = function (left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }

  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};

wordDiff.tokenize = function (value) {
  var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, options) {
  options = generateOptions(options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}

var lineDiff = new Diff();

lineDiff.tokenize = function (value) {
  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  } // Merge the content and line separators into single tokens


  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }

      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function diffTrimmedLines(oldStr, newStr, callback) {
  var options = generateOptions(callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options);
}

var sentenceDiff = new Diff();

sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}

var cssDiff = new Diff();

cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;

jsonDiff.castInput = function (value) {
  var _this$options = this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
    return typeof v === 'undefined' ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
};

jsonDiff.equals = function (left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
};

function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
} // This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed. Accepts an optional replacer

function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  if (replacer) {
    obj = replacer(key, obj);
  }

  var i;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);

    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }

    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if (_typeof(obj) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);

    var sortedKeys = [],
        _key;

    for (_key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }

    sortedKeys.sort();

    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }

    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }

  return canonicalizedObj;
}

var arrayDiff = new Diff();

arrayDiff.tokenize = function (value) {
  return value.slice();
};

arrayDiff.join = arrayDiff.removeEmpty = function (value) {
  return value;
};

function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}

function parsePatch(uniDiff) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index); // Parse diff metadata

    while (i < diffstr.length) {
      var line = diffstr[i]; // File header found, end parsing diff metadata

      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      } // Diff index


      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

      if (header) {
        index.index = header[1];
      }

      i++;
    } // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header


    parseFileHeader(index);
    parseFileHeader(index); // Parse hunks

    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  } // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.


  function parseFileHeader(index) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      var data = fileHeader[2].split('\t', 2);
      var fileName = data[0].replace(/\\\\/g, '\\');

      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }

      index[keyPrefix + 'FileName'] = fileName;
      index[keyPrefix + 'Header'] = (data[1] || '').trim();
      i++;
    }
  } // Parses a hunk
  // This assumes that we are at the start of a hunk.


  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: +chunkHeader[2] || 1,
      newStart: +chunkHeader[3],
      newLines: +chunkHeader[4] || 1,
      lines: [],
      linedelimiters: []
    };
    var addCount = 0,
        removeCount = 0;

    for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
        break;
      }

      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || '\n');

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    } // Handle the empty block count case


    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }

    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    } // Perform optional sanity checking


    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }

      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}

// Iterator that traverses in the range of [min, max], stepping
// by distance from a given start position. I.e. for [0, 4], with
// start of 2, this will iterate 2, 3, 1, 4, 0.
function distanceIterator (start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;
  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      } // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)


      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      } // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location


      if (minLine <= start - localOffset) {
        return -localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    } // We tried to fit hunk before text beginning and beyond text length, then
    // hunk can't fit on the text. Return undefined

  };
}

function applyPatch(source, uniDiff) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof uniDiff === 'string') {
    uniDiff = parsePatch(uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  } // Apply the diff to the input


  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
    return line === patchContent;
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL,
      addEOFNL;
  /**
   * Checks if the hunk exactly fits on the provided location
   */


  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line;

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }

        toPos++;
      }
    }

    return true;
  } // Search best fit offsets for each hunk based on the previous ones


  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;
    var iterator = distanceIterator(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    } // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text


    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  } // Apply patch hunks


  var diffOffset = 0;

  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

    diffOffset += _hunk.newLines - _hunk.oldLines;

    if (_toPos < 0) {
      // Creating a new file
      _toPos = 0;
    }

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line.length > 0 ? line[0] : ' ',
          content = line.length > 0 ? line.substr(1) : line,
          delimiter = _hunk.linedelimiters[j];

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
        lines.splice(_toPos, 0, content);
        delimiters.splice(_toPos, 0, delimiter);
        _toPos++;
      } else if (operation === '\\') {
        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

        if (previousOperation === '+') {
          removeEOFNL = true;
        } else if (previousOperation === '-') {
          addEOFNL = true;
        }
      }
    }
  } // Handle EOFNL insertion/removal


  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
    delimiters.push('\n');
  }

  for (var _k = 0; _k < lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }

  return lines.join('');
} // Wrapper that supports multiple file patches via callbacks.

function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff = parsePatch(uniDiff);
  }

  var currentIndex = 0;

  function processIndex() {
    var index = uniDiff[currentIndex++];

    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }

  processIndex();
}

function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }

  if (typeof options.context === 'undefined') {
    options.context = 4;
  }

  var diff = diffLines(oldStr, newStr, options);
  diff.push({
    value: '',
    lines: []
  }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;

  var _loop = function _loop(i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      var _curRange;

      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      } // Output our changes


      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      }))); // Track the updated file position


      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          var _curRange2;

          // Overlapping
          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange3;

          // end the range and output
          var contextSize = Math.min(lines.length, options.context);

          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };

          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

            if (!oldEOFNewline && noNlBeforeAdds) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            }

            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }

          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }

      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    _loop(i);
  }

  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
  var ret = [];

  if (oldFileName == newFileName) {
    ret.push('Index: ' + oldFileName);
  }

  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i];
    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}

function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  return arrayStartsWith(a, b);
}
function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }

  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }

  return true;
}

function calcLineCount(hunk) {
  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
      oldLines = _calcOldNewLineCount.oldLines,
      newLines = _calcOldNewLineCount.newLines;

  if (oldLines !== undefined) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }

  if (newLines !== undefined) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}
function merge(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
  // Leaving sanity checks on this to the API consumer that may know more about the
  // meaning in their own context.

  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }

  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      // No header or no change in ours, use theirs (and ours if theirs does not exist)
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      // No header or no change in theirs, use ours
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      // Both changed... figure it out
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }

  ret.hunks = [];
  var mineIndex = 0,
      theirsIndex = 0,
      mineOffset = 0,
      theirsOffset = 0;

  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    },
        theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };

    if (hunkBefore(mineCurrent, theirsCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      // This patch does not overlap with any of the others, yay.
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      // Overlap, merge as best we can
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }

  return ret;
}

function loadPatch(param, base) {
  if (typeof param === 'string') {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return parsePatch(param)[0];
    }

    if (!base) {
      throw new Error('Must provide a base reference or pass in a patch');
    }

    return structuredPatch(undefined, undefined, base, param);
  }

  return param;
}

function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}

function selectField(index, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index.conflict = true;
    return {
      mine: mine,
      theirs: theirs
    };
  }
}

function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}

function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}

function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  // This will generally result in a conflicted hunk, but there are cases where the context
  // is the only overlap where we can successfully merge the content here.
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  },
      their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  }; // Handle any leading content

  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index],
        theirCurrent = their.lines[their.index];

    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
      // Both modified ...
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
      var _hunk$lines;

      // Mine inserted
      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
      var _hunk$lines2;

      // Theirs inserted
      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
      // Mine removed or edited
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
      // Their removed or edited
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      // Context identity
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      // Context mismatch
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  } // Now push anything that may be remaining


  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}

function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine),
      theirChanges = collectChange(their);

  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    // Special case for remove changes that are supersets of one another
    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      var _hunk$lines3;

      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));

      return;
    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      var _hunk$lines4;

      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));

      return;
    }
  } else if (arrayEqual(myChanges, theirChanges)) {
    var _hunk$lines5;

    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));

    return;
  }

  conflict(hunk, myChanges, theirChanges);
}

function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine),
      theirChanges = collectContext(their, myChanges);

  if (theirChanges.merged) {
    var _hunk$lines6;

    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}

function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine: mine,
    theirs: their
  });
}

function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}

function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}

function collectChange(state) {
  var ret = [],
      operation = state.lines[state.index][0];

  while (state.index < state.lines.length) {
    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

    if (operation === '-' && line[0] === '+') {
      operation = '+';
    }

    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }

  return ret;
}

function collectContext(state, matchChanges) {
  var changes = [],
      merged = [],
      matchIndex = 0,
      contextChanges = false,
      conflicted = false;

  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index],
        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

    if (match[0] === '+') {
      break;
    }

    contextChanges = contextChanges || change[0] !== ' ';
    merged.push(match);
    matchIndex++; // Consume any additions in the other block as a conflict to attempt
    // to pull in the remaining context after this

    if (change[0] === '+') {
      conflicted = true;

      while (change[0] === '+') {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }

    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }

  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
    conflicted = true;
  }

  if (conflicted) {
    return changes;
  }

  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }

  return {
    merged: merged,
    changes: changes
  };
}

function allRemoves(changes) {
  return changes.reduce(function (prev, change) {
    return prev && change[0] === '-';
  }, true);
}

function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

    if (state.lines[state.index + i] !== ' ' + changeContent) {
      return false;
    }
  }

  state.index += delta;
  return true;
}

function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function (line) {
    if (typeof line !== 'string') {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);

      if (oldLines !== undefined) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = undefined;
        }
      }

      if (newLines !== undefined) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = undefined;
        }
      }
    } else {
      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
        newLines++;
      }

      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
        oldLines++;
      }
    }
  });
  return {
    oldLines: oldLines,
    newLines: newLines
  };
}

// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change,
      operation;

  for (var i = 0; i < changes.length; i++) {
    change = changes[i];

    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }

  return ret;
}

function convertChangesToXML(changes) {
  var ret = [];

  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }

  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');
  return n;
}

/* See LICENSE file for terms of use */




/***/ }),
/* 244 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MiniSat = __webpack_require__(245);
var _ = __webpack_require__(247);
var Logic;
Logic = {};

////////// TYPE TESTERS


// Set the `description` property of a tester function and return the function.
var withDescription = function (description, tester) {
  tester.description = description;
  return tester;
};

// Create a function (x) => (x instanceof constructor), but possibly before
// constructor is available.  For example, if Logic.Formula hasn't been
// assigned yet, passing Logic for `obj` and "Formula" for `constructorName`
// will still work.
var lazyInstanceofTester = function (description, obj, constructorName) {
  return withDescription(description, function (x) {
    return x instanceof obj[constructorName];
  });
};


///// PUBLIC TYPE TESTERS

// All variables have a name and a number.  The number is mainly used
// internally, and it's what's given to MiniSat.  Names and numbers
// are interchangeable, which is convenient for doing manipulation
// of terms in a way that works before or after variable names are
// converted to numbers.

// Term: a variable name or variable number, optionally
// negated (meaning "boolean not").  For example,
// `1`, `-1`, `"foo"`, or `"-foo"`.  All variables have
// internal numbers that start at 1, so "foo" might be
// variable number 1, for example.  Any number of leading
// "-" will be parsed in the string form, but we try to
// keep it to either one or zero of them.

Logic.isNumTerm = withDescription('a NumTerm (non-zero integer)',
                                  function (x) {
                                    // 32-bit integer, but not 0
                                    return (x === (x | 0)) && x !== 0;
                                  });

// NameTerm must not be empty, or just `-` characters, or look like a
// number.  Specifically, it can't be zero or more `-` followed by
// zero or more digits.
Logic.isNameTerm = withDescription('a NameTerm (string)',
                                   function (x) {
                                     return (typeof x === 'string') &&
                                       ! /^-*[0-9]*$/.test(x);
                                   });

Logic.isTerm = withDescription('a Term (appropriate string or number)',
                               function (x) {
                                 return Logic.isNumTerm(x) ||
                                   Logic.isNameTerm(x);
                               });

// WholeNumber: a non-negative integer (0 is allowed)
Logic.isWholeNumber = withDescription('a whole number (integer >= 0)',
                                      function (x) {
                                        return (x === (x | 0)) && x >= 0;
                                      });

Logic.isFormula = lazyInstanceofTester('a Formula', Logic, 'Formula');
Logic.isClause = lazyInstanceofTester('a Clause', Logic, 'Clause');
Logic.isBits = lazyInstanceofTester('a Bits', Logic, 'Bits');

///// UNDOCUMENTED TYPE TESTERS

Logic._isInteger = withDescription(
  'an integer', function (x) { return x === (x | 0); });

Logic._isFunction = withDescription(
  'a Function', function (x) { return typeof x === 'function'; });

Logic._isString = withDescription(
  'a String', function (x) { return typeof x === 'string'; });

Logic._isArrayWhere = function (tester) {
  var description = 'an array';
  if (tester.description) {
    description += ' of ' + tester.description;
  }
  return withDescription(description, function (x) {
    if (! _.isArray(x)) {
      return false;
    } else {
      for (var i = 0; i < x.length; i++) {
        if (! tester(x[i])) {
          return false;
        }
      }
      return true;
    }
  });
};

Logic._isFormulaOrTerm = withDescription('a Formula or Term',
                                         function (x) {
                                           return Logic.isFormula(x) ||
                                             Logic.isTerm(x);
                                         });


Logic._isFormulaOrTermOrBits = withDescription('a Formula, Term, or Bits',
                                               function (x) {
                                                 return Logic.isFormula(x) ||
                                                   Logic.isBits(x) ||
                                                   Logic.isTerm(x);
                                               });
Logic._MiniSat = MiniSat; // Expose for testing and poking around

// import the private testers from types.js
var isInteger = Logic._isInteger;
var isFunction = Logic._isFunction;
var isString = Logic._isString;
var isArrayWhere = Logic._isArrayWhere;
var isFormulaOrTerm = Logic._isFormulaOrTerm;
var isFormulaOrTermOrBits = Logic._isFormulaOrTermOrBits;

Logic._assert = function (value, tester, description) {
  if (! tester(value)) {
    var displayValue = (typeof value === 'string' ? JSON.stringify(value) :
                        value);
    throw new Error(displayValue + " is not " +
                    (tester.description || description));
  }
};

// Call this as `if (assert) assertNumArgs(...)`
var assertNumArgs = function (actual, expected, funcName) {
  if (actual !== expected) {
    throw new Error("Expected " + expected + " args in " + funcName +
                    ", got " + actual);
  }
};

// Call `assert` as: `if (assert) assert(...)`.
// This local variable temporarily set to `null` inside
// `Logic.disablingAssertions`.
var assert = Logic._assert;

// Like `if (assert) assert(...)` but usable from other files in the package.
Logic._assertIfEnabled = function (value, tester, description) {
  if (assert) assert(value, tester, description);
};

// Disabling runtime assertions speeds up clause generation.  Assertions
// are disabled when the local variable `assert` is null instead of
// `Logic._assert`.
Logic.disablingAssertions = function (f) {
  var oldAssert = assert;
  try {
    assert = null;
    return f();
  } finally {
    assert = oldAssert;
  }
};

// Back-compat.
Logic._disablingTypeChecks = Logic.disablingAssertions;

////////////////////

// Takes a Formula or Term, returns a Formula or Term.
// Unlike other operators, if you give it a Term,
// you will get a Term back (of the same type, NameTerm
// or NumTerm).
Logic.not = function (operand) {
  if (assert) assert(operand, isFormulaOrTerm);

  if (operand instanceof Logic.Formula) {
    return new Logic.NotFormula(operand);
  } else {
    // Term
    if (typeof operand === 'number') {
      return -operand;
    } else if (operand.charAt(0) === '-') {
      return operand.slice(1);
    } else {
      return '-' + operand;
    }
  }
};

Logic.NAME_FALSE = "$F";
Logic.NAME_TRUE = "$T";
Logic.NUM_FALSE = 1;
Logic.NUM_TRUE = 2;

Logic.TRUE = Logic.NAME_TRUE;
Logic.FALSE = Logic.NAME_FALSE;

// Abstract base class.  Subclasses are created using _defineFormula.
Logic.Formula = function () {};

Logic._defineFormula = function (constructor, typeName, methods) {
  if (assert) assert(constructor, isFunction);
  if (assert) assert(typeName, isString);

  constructor.prototype = new Logic.Formula();
  constructor.prototype.type = typeName;
  if (methods) {
    _.extend(constructor.prototype, methods);
  }
};

// Returns a list of Clauses that together require the Formula to be
// true, or false (depending on isTrue; both cases must be
// implemented).  A single Clause may also be returned.  The
// implementation should call the termifier to convert terms and
// formulas to NumTerms specific to a solver instance, and use them to
// construct a Logic.Clause.
Logic.Formula.prototype.generateClauses = function (isTrue, termifier) {
  throw new Error("Cannot generate this Formula; it must be expanded");
};
// All Formulas have a globally-unique id so that Solvers can track them.
// It is assigned lazily.
Logic.Formula._nextGuid = 1;
Logic.Formula.prototype._guid = null;
Logic.Formula.prototype.guid = function () {
  if (this._guid === null) {
    this._guid = Logic.Formula._nextGuid++;
  }
  return this._guid;
};

// A "clause" is a disjunction of terms, e.g. "A or B or (not C)",
// which we write "A v B v -C".  Logic.Clause is mainly an internal
// Solver data structure, which is the final result of formula
// generation and mapping variable names to numbers, before passing
// the clauses to MiniSat.
Logic.Clause = function (/*formulaOrArray, ...*/) {
  var terms = _.flatten(arguments);
  if (assert) assert(terms, isArrayWhere(Logic.isNumTerm));

  this.terms = terms; // immutable [NumTerm]
};

// Returns a new Clause with the extra term or terms appended
Logic.Clause.prototype.append = function (/*formulaOrArray, ...*/) {
  return new Logic.Clause(this.terms.concat(_.flatten(arguments)));
};

var FormulaInfo = function () {
  // We generate a variable when a Formula is used.
  this.varName = null; // string name of variable
  this.varNum = null; // number of variable (always positive)

  // A formula variable that is used only in the positive or only
  // in the negative doesn't need the full set of clauses that
  // establish a bidirectional implication between the formula and the
  // variable.  For example, in the formula `Logic.or("A", "B")`, with the
  // formula variable `$or1`, the full set of clauses is `A v B v
  // -$or1; -A v $or1; -B v $or1`.  If both `$or1` and `-$or1` appear
  // elsewhere in the set of clauses, then all three of these clauses
  // are required.  However, somewhat surprisingly, if only `$or1` appears,
  // then only the first is necessary.  If only `-$or1` appears, then only
  // the second and third are necessary.
  //
  // Suppose the formula A v B is represented by the variable $or1,
  // and $or1 is only used positively. It's important that A v B being
  // false forces $or1 to be false, so that when $or1 is used it has
  // the appropriate effect. For example, if we have the clause $or1 v
  // C, then A v B being false should force $or1 to be false, which
  // forces C to be true. So we generate the clause A v B v
  // -$or1. (The implications of this clause are: If A v B is false,
  // $or1 must be false. If $or1 is true, A v B must be true.)
  //
  // However, in the case where A v B is true, we don't actually
  // need to insist that the solver set $or1 to true, as long as we
  // are ok with relaxing the relationship between A v B and $or1
  // and getting a "wrong" value for $or1 in the solution. Suppose
  // the solver goes to work and at some point determines A v B to
  // be true. It could set $or1 to true, satisfying all the clauses
  // where it appears, or it could set $or1 to false, which only
  // constrains the solution space and doesn't open up any new
  // solutions for other variables. If the solver happens to find a
  // solution where A v B is true and $or1 is false, we know there
  // is a similar solution that makes all the same assignments
  // except it assigns $or1 to true.
  //
  // If a formula is used only negatively, a similar argument applies
  // but with signs flipped, and if it is used both positively and
  // negatively, both kinds of clauses must be generated.
  //
  // See the mention of "polarity" in the MiniSat+ paper
  // (http://minisat.se/downloads/MiniSat+.pdf).
  //
  // These flags are set when generation has been done for the positive
  // case or the negative case, so that we only generate each one once.
  this.occursPositively = false;
  this.occursNegatively = false;

  // If a Formula has been directly required or forbidden, we can
  // replace it by TRUE or FALSE in subsequent clauses.  Track the
  // information here.
  this.isRequired = false;
  this.isForbidden = false;
};


// The "termifier" interface is provided to a Formula's
// generateClauses method, which must use it to generate Clause
// objects.
//
// The reason for this approach is that it gives the Formula control
// over the clauses returned, but it gives the Solver control over
// Formula generation.
Logic.Termifier = function (solver) {
  this.solver = solver;
};

// The main entry point, the `clause` method takes a list of
// FormulaOrTerms and converts it to a Clause containing NumTerms, *by
// replacing Formulas with their variables*, creating the variable if
// necessary.  For example, if an OrFormula is represented by the
// variable `$or1`, it will be replaced by the numeric version of
// `$or1` to make the Clause.  When the Clause is actually used, it
// will trigger generation of the clauses that relate `$or1` to the
// operands of the OrFormula.
Logic.Termifier.prototype.clause = function (/*args*/) {
  var self = this;
  var formulas = _.flatten(arguments);
  if (assert) assert(formulas, isArrayWhere(isFormulaOrTerm));

  return new Logic.Clause(_.map(formulas, function (f) {
    return self.term(f);
  }));
};

// The `term` method performs the mapping from FormulaOrTerm to
// NumTerm.  It's called by `clause` and could be called directly
// from a Formula's generateClauses if it was useful for some
// reason.
Logic.Termifier.prototype.term = function (formula) {
  return this.solver._formulaToTerm(formula);
};

// The `generate` method generates clauses for a Formula (or
// Term).  It should be used carefully, because it works quite
// differently from passing a Formula into `clause`, which is the
// normal way for one Formula to refer to another.  When you use a
// Formula in `clause`, it is replaced by the Formula's variable,
// and the Solver handles generating the Formula's clauses once.
// When you use `generate`, this system is bypassed, and the
// Formula's generateClauses method is called pretty much directly,
// returning the array of Clauses.
Logic.Termifier.prototype.generate = function (isTrue, formula) {
  return this.solver._generateFormula(isTrue, formula, this);
};


Logic.Solver = function () {
  var self = this;

  self.clauses = []; // mutable [Clause]
  self._num2name = [null]; // no 0th var
  self._name2num = {}; // (' '+vname) -> vnum

  // true and false
  var F = self.getVarNum(Logic.NAME_FALSE, false, true); // 1
  var T = self.getVarNum(Logic.NAME_TRUE, false, true); // 2
  if (F !== Logic.NUM_FALSE || T !== Logic.NUM_TRUE) {
    throw new Error("Assertion failure: $T and $F have wrong numeric value");
  }
  self._F_used = false;
  self._T_used = false;
  // It's important that these clauses are elements 0 and 1
  // of the clauses array, so that they can optionally be stripped
  // off.  For example, _clauseData takes advantage of this fact.
  self.clauses.push(new Logic.Clause(-Logic.NUM_FALSE));
  self.clauses.push(new Logic.Clause(Logic.NUM_TRUE));

  self._formulaInfo = {}; // Formula guid -> FormulaInfo
  // For generating formula variables like "$or1", "$or2", "$and1", "$and2"
  self._nextFormulaNumByType = {}; // Formula type -> next var id
  // Map of Formulas whose info has `false` for either
  // `occursPositively` or `occursNegatively`
  self._ungeneratedFormulas = {}; // varNum -> Formula

  self._numClausesAddedToMiniSat = 0;
  self._unsat = false; // once true, no solution henceforth
  self._minisat = new MiniSat(); // this takes some time

  self._termifier = new Logic.Termifier(self);
};

// Get a var number for vname, assigning it a number if it is new.
// Setting "noCreate" to true causes the function to return 0 instead of
// creating a new variable.
// Setting "_createInternals" to true grants the ability to create $ variables.
Logic.Solver.prototype.getVarNum = function (vname, noCreate, _createInternals) {
  var key = ' '+vname;
  if (_.has(this._name2num, key)) {
    return this._name2num[key];
  } else if (noCreate) {
    return 0;
  } else {
    if (vname.charAt(0) === "$" && ! _createInternals) {
      throw new Error("Only generated variable names can start with $");
    }
    var vnum = this._num2name.length;
    this._name2num[key] = vnum;
    this._num2name.push(vname);
    return vnum;
  }
};

Logic.Solver.prototype.getVarName = function (vnum) {
  if (assert) assert(vnum, isInteger);

  var num2name = this._num2name;
  if (vnum < 1 || vnum >= num2name.length) {
    throw new Error("Bad variable num: " + vnum);
  } else {
    return num2name[vnum];
  }
};

// Converts a Term to a NumTerm (if it isn't already).  This is done
// when a Formula creates Clauses for a Solver, since Clauses require
// NumTerms.  NumTerms stay the same, while a NameTerm like "-foo"
// might become (say) the number -3.  If a NameTerm names a variable
// that doesn't exist, it is automatically created, unless noCreate
// is passed, in which case 0 is returned instead.
Logic.Solver.prototype.toNumTerm = function (t, noCreate) {
  var self = this;

  if (assert) assert(t, Logic.isTerm);

  if (typeof t === 'number') {
    return t;
  } else { // string
    var not = false;
    while (t.charAt(0) === '-') {
      t = t.slice(1);
      not = ! not;
    }
    var n = self.getVarNum(t, noCreate);
    if (! n) {
      return 0; // must be the noCreate case
    } else {
      return (not ? -n : n);
    }
  }
};

// Converts a Term to a NameTerm (if it isn't already).
Logic.Solver.prototype.toNameTerm = function (t) {
  var self = this;

  if (assert) assert(t, Logic.isTerm);

  if (typeof t === 'string') {
    // canonicalize, removing leading "--"
    while (t.slice(0, 2) === '--') {
      t = t.slice(2);
    }
    return t;
  } else { // number
    var not = false;
    if (t < 0) {
      not = true;
      t = -t;
    }
    t = self.getVarName(t);
    if (not) {
      t = '-' + t;
    }
    return t;
  }
};

Logic.Solver.prototype._addClause = function (cls, _extraTerms,
                                              _useTermOverride) {
  var self = this;

  if (assert) assert(cls, Logic.isClause);

  var extraTerms = null;
  if (_extraTerms) {
    extraTerms = _extraTerms;
    if (assert) assert(extraTerms, isArrayWhere(Logic.isNumTerm));
  }

  var usedF = false;
  var usedT = false;

  var numRealTerms = cls.terms.length;
  if (extraTerms) {
    // extraTerms are added to the clause as is.  Formula variables in
    // extraTerms do not cause Formula clause generation, which is
    // necessary to implement Formula clause generation.
    cls = cls.append(extraTerms);
  }

  for (var i = 0; i < cls.terms.length; i++) {
    var t = cls.terms[i];
    var v = (t < 0) ? -t : t;
    if (v === Logic.NUM_FALSE) {
      usedF = true;
    } else if (v === Logic.NUM_TRUE) {
      usedT = true;
    } else if (v < 1 || v >= self._num2name.length) {
      throw new Error("Bad variable number: " + v);
    } else if (i < numRealTerms) {
      if (_useTermOverride) {
        _useTermOverride(t);
      } else {
        self._useFormulaTerm(t);
      }
    }
  }

  this._F_used = (this._F_used || usedF);
  this._T_used = (this._T_used || usedT);

  this.clauses.push(cls);
};

// When we actually use a Formula variable, generate clauses for it,
// based on whether the usage is positive or negative.  For example,
// if the Formula `Logic.or("X", "Y")` is represented by `$or1`, which
// is variable number 5, then when you actually use 5 or -5 in a clause,
// the clauses "X v Y v -5" (when you use 5) or "-X v 5; -Y v 5"
// (when you use -5) will be generated.  The clause "X v Y v -5"
// is equivalent to "5 => X v Y" (or -(X v Y) => -5), while the clauses
// "-X v 5; -Y v 5" are equivalent to "-5 => -X; -5 => -Y" (or
// "X => 5; Y => 5").

Logic.Solver.prototype._useFormulaTerm = function (t, _addClausesOverride) {
  var self = this;
  if (assert) assert(t, Logic.isNumTerm);
  var v = (t < 0) ? -t : t;

  if (! _.has(self._ungeneratedFormulas, v)) {
    return;
  }

  // using a Formula's var; maybe have to generate clauses
  // for the Formula
  var formula = self._ungeneratedFormulas[v];
  var info = self._getFormulaInfo(formula);
  var positive = t > 0;

  // To avoid overflowing the JS stack, defer calls to addClause.
  // The way we get overflows is when Formulas are deeply nested
  // (which happens naturally when you call Logic.sum or
  // Logic.weightedSum on a long list of terms), which causes
  // addClause to call useFormulaTerm to call addClause, and so
  // on.  Approach:  The outermost useFormulaTerm keeps a list
  // of clauses to add, and then adds them in a loop using a
  // special argument to addClause that passes a special argument
  // to useFormulaTerm that causes those clauses to go into the
  // list too.  Code outside of `_useFormulaTerm` and `_addClause(s)`
  // does not have to pass these special arguments to call them.
  var deferredAddClauses = null;
  var addClauses;
  if (! _addClausesOverride) {
    deferredAddClauses = [];
    addClauses = function (clauses, extraTerms) {
      deferredAddClauses.push({clauses: clauses,
                               extraTerms: extraTerms});
    };
  } else {
    addClauses = _addClausesOverride;
  }

  if (positive && ! info.occursPositively) {
    // generate clauses for the formula.
    // Eg, if we use variable `X` which represents the formula
    // `A v B`, add the clause `A v B v -X`.
    // By using the extraTerms argument to addClauses, we avoid
    // treating this as a negative occurrence of X.
    info.occursPositively = true;
    var clauses = self._generateFormula(true, formula);
    addClauses(clauses, [-v]);
  } else if ((! positive) && ! info.occursNegatively) {
    // Eg, if we have the term `-X` where `X` represents the
    // formula `A v B`, add the clauses `-A v X` and `-B v X`.
    // By using the extraTerms argument to addClauses, we avoid
    // treating this as a positive occurrence of X.
    info.occursNegatively = true;
    var clauses = self._generateFormula(false, formula);
    addClauses(clauses, [v]);
  }
  if (info.occursPositively && info.occursNegatively) {
    delete self._ungeneratedFormulas[v];
  }

  if (! (deferredAddClauses && deferredAddClauses.length)) {
    return;
  }

  var useTerm = function (t) {
    self._useFormulaTerm(t, addClauses);
  };
  // This is the loop that turns recursion into iteration.
  // When addClauses calls useTerm, which calls useFormulaTerm,
  // the nested useFormulaTerm will add any clauses to our
  // own deferredAddClauses list.
  while (deferredAddClauses.length) {
    var next = deferredAddClauses.pop();
    self._addClauses(next.clauses, next.extraTerms, useTerm);
  }
};

Logic.Solver.prototype._addClauses = function (array, _extraTerms,
                                               _useTermOverride) {
  if (assert) assert(array, isArrayWhere(Logic.isClause));
  var self = this;
  _.each(array, function (cls) {
    self._addClause(cls, _extraTerms, _useTermOverride);
  });
};

Logic.Solver.prototype.require = function (/*formulaOrArray, ...*/) {
  this._requireForbidImpl(true, _.flatten(arguments));
};

Logic.Solver.prototype.forbid = function (/*formulaOrArray, ...*/) {
  this._requireForbidImpl(false, _.flatten(arguments));
};

Logic.Solver.prototype._requireForbidImpl = function (isRequire, formulas) {
  var self = this;
  if (assert) assert(formulas, isArrayWhere(isFormulaOrTerm));

  _.each(formulas, function (f) {
    if (f instanceof Logic.NotFormula) {
      self._requireForbidImpl(!isRequire, [f.operand]);
    } else if (f instanceof Logic.Formula) {
      var info = self._getFormulaInfo(f);
      if (info.varNum !== null) {
        var sign = isRequire ? 1 : -1;
        self._addClause(new Logic.Clause(sign*info.varNum));
      } else {
        self._addClauses(self._generateFormula(isRequire, f));
      }
      if (isRequire) {
        info.isRequired = true;
      } else {
        info.isForbidden = true;
      }
    } else {
      self._addClauses(self._generateFormula(isRequire, f));
    }
  });
};

Logic.Solver.prototype._generateFormula = function (isTrue, formula, _termifier) {
  var self = this;
  if (assert) assert(formula, isFormulaOrTerm);

  if (formula instanceof Logic.NotFormula) {
    return self._generateFormula(!isTrue, formula.operand);
  } else if (formula instanceof Logic.Formula) {
    var info = self._getFormulaInfo(formula);
    if ((isTrue && info.isRequired) ||
        (!isTrue && info.isForbidden)) {
      return [];
      } else if ((isTrue && info.isForbidden) ||
                 (!isTrue && info.isRequired)) {
        return [new Logic.Clause()]; // never satisfied clause
      } else {
        var ret = formula.generateClauses(isTrue,
                                          _termifier || self._termifier);
        return _.isArray(ret) ? ret : [ret];
      }
  } else { // Term
    var t = self.toNumTerm(formula);
    var sign = isTrue ? 1 : -1;
    if (t === sign*Logic.NUM_TRUE || t === -sign*Logic.NUM_FALSE) {
      return [];
    } else if (t === sign*Logic.NUM_FALSE || t === -sign*Logic.NUM_TRUE) {
      return [new Logic.Clause()]; // never satisfied clause
    } else {
      return [new Logic.Clause(sign*t)];
    }
  }
};

// Get clause data as an array of arrays of integers,
// for testing and debugging purposes.
Logic.Solver.prototype._clauseData = function () {
  var clauses = _.pluck(this.clauses, 'terms');
  if (! this._T_used) {
    clauses.splice(1, 1);
  }
  if (! this._F_used) {
    clauses.splice(0, 1);
  }
  return clauses;
};

// Get clause data as an array of human-readable strings,
// for testing and debugging purposes.
// A clause might look like "A v -B" (where "v" represents
// and OR operator).
Logic.Solver.prototype._clauseStrings = function () {
  var self = this;
  var clauseData = self._clauseData();
  return _.map(clauseData, function (clause) {
    return _.map(clause, function (nterm) {
      var str = self.toNameTerm(nterm);
      if (/\s/.test(str)) {
        // write name in quotes for readability.  we don't bother
        // making this string machine-parsable in the general case.
        var sign = '';
        if (str.charAt(0) === '-') {
          // temporarily remove '-'
          sign = '-';
          str = str.slice(1);
        }
        str = sign + '"' + str + '"';
      }
      return str;
    }).join(' v ');
  });
};

Logic.Solver.prototype._getFormulaInfo = function (formula, _noCreate) {
  var self = this;
  var guid = formula.guid();
  if (! self._formulaInfo[guid]) {
    if (_noCreate) {
      return null;
    }
    self._formulaInfo[guid] = new FormulaInfo();
  }
  return self._formulaInfo[guid];
};

// Takes a Formula or an array of Formulas, returns a NumTerm or
// array of NumTerms.
Logic.Solver.prototype._formulaToTerm = function (formula) {
  var self = this;

  if (_.isArray(formula)) {
    if (assert) assert(formula, isArrayWhere(isFormulaOrTerm));
    return _.map(formula, _.bind(self._formulaToTerm, self));
  } else {
    if (assert) assert(formula, isFormulaOrTerm);
  }

  if (formula instanceof Logic.NotFormula) {
    // shortcut that avoids creating a variable called
    // something like "$not1" when you use Logic.not(formula).
    return Logic.not(self._formulaToTerm(formula.operand));
  } else if (formula instanceof Logic.Formula) {
    var info = this._getFormulaInfo(formula);
    if (info.isRequired) {
      return Logic.NUM_TRUE;
    } else if (info.isForbidden) {
      return Logic.NUM_FALSE;
    } else if (info.varNum === null) {
      // generate a Solver-local formula variable like "$or1"
      var type = formula.type;
      if (! this._nextFormulaNumByType[type]) {
        this._nextFormulaNumByType[type] = 1;
      }
      var numForVarName = this._nextFormulaNumByType[type]++;
      info.varName = "$" + formula.type + numForVarName;
      info.varNum = this.getVarNum(info.varName, false, true);
      this._ungeneratedFormulas[info.varNum] = formula;
    }
    return info.varNum;
  } else {
    // formula is a Term
    return self.toNumTerm(formula);
  }
};

Logic.or = function (/*formulaOrArray, ...*/) {
  var args = _.flatten(arguments);
  if (args.length === 0) {
    return Logic.FALSE;
  } else if (args.length === 1) {
    if (assert) assert(args[0], isFormulaOrTerm);
    return args[0];
  } else {
    return new Logic.OrFormula(args);
  }
};

Logic.OrFormula = function (operands) {
  if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
  this.operands = operands;
};

Logic._defineFormula(Logic.OrFormula, 'or', {
  generateClauses: function (isTrue, t) {
    if (isTrue) {
      // eg A v B v C
      return t.clause(this.operands);
    } else {
      // eg -A; -B; -C
      var result = [];
      _.each(this.operands, function (o) {
        result.push.apply(result, t.generate(false, o));
      });
      return result;
    }
  }
});

Logic.NotFormula = function (operand) {
  if (assert) assert(operand, isFormulaOrTerm);
  this.operand = operand;
};

// No generation or simplification for 'not'; it is
// simplified away by the solver itself.
Logic._defineFormula(Logic.NotFormula, 'not');

Logic.and = function (/*formulaOrArray, ...*/) {
  var args = _.flatten(arguments);
  if (args.length === 0) {
    return Logic.TRUE;
  } else if (args.length === 1) {
    if (assert) assert(args[0], isFormulaOrTerm);
    return args[0];
  } else {
    return new Logic.AndFormula(args);
  }
};

Logic.AndFormula = function (operands) {
  if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
  this.operands = operands;
};

Logic._defineFormula(Logic.AndFormula, 'and', {
  generateClauses: function (isTrue, t) {
    if (isTrue) {
      // eg A; B; C
      var result = [];
      _.each(this.operands, function (o) {
        result.push.apply(result, t.generate(true, o));
      });
      return result;
    } else {
      // eg -A v -B v -C
      return t.clause(_.map(this.operands, Logic.not));
    }
  }
});

// Group `array` into groups of N, where the last group
// may be shorter than N.  group([a,b,c,d,e], 3) => [[a,b,c],[d,e]]
var group = function (array, N) {
  var ret = [];
  for (var i = 0; i < array.length; i += N) {
    ret.push(array.slice(i, i+N));
  }
  return ret;
};

Logic.xor = function (/*formulaOrArray, ...*/) {
  var args = _.flatten(arguments);
  if (args.length === 0) {
    return Logic.FALSE;
  } else if (args.length === 1) {
    if (assert) assert(args[0], isFormulaOrTerm);
    return args[0];
  } else {
    return new Logic.XorFormula(args);
  }
};

Logic.XorFormula = function (operands) {
  if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
  this.operands = operands;
};

Logic._defineFormula(Logic.XorFormula, 'xor', {
  generateClauses: function (isTrue, t) {
    var args = this.operands;
    var not = Logic.not;
    if (args.length > 3) {
      return t.generate(
        isTrue,
        Logic.xor(
          _.map(group(this.operands, 3), function (group) {
            return Logic.xor(group);
          })));
    } else if (isTrue) { // args.length <= 3
      if (args.length === 0) {
        return t.clause(); // always fail
      } else if (args.length === 1) {
        return t.clause(args[0]);
      } else if (args.length === 2) {
        var A = args[0], B = args[1];
        return [t.clause(A, B), // A v B
                t.clause(not(A), not(B))]; // -A v -B
      } else if (args.length === 3) {
        var A = args[0], B = args[1], C = args[2];
        return [t.clause(A, B, C), // A v B v C
                t.clause(A, not(B), not(C)), // A v -B v -C
                t.clause(not(A), B, not(C)), // -A v B v -C
                t.clause(not(A), not(B), C)]; // -A v -B v C
      }
    } else { // !isTrue, args.length <= 3
      if (args.length === 0) {
        return []; // always succeed
      } else if (args.length === 1) {
        return t.clause(not(args[0]));
      } else if (args.length === 2) {
        var A = args[0], B = args[1];
        return [t.clause(A, not(B)), // A v -B
                t.clause(not(A), B)]; // -A v B
      } else if (args.length === 3) {
        var A = args[0], B = args[1], C = args[2];
        return [t.clause(not(A), not(B), not(C)), // -A v -B v -C
                t.clause(not(A), B, C), // -A v B v C
                t.clause(A, not(B), C), // A v -B v C
                t.clause(A, B, not(C))]; // A v B v -C
      }
    }
  }
});

Logic.atMostOne = function (/*formulaOrArray, ...*/) {
  var args = _.flatten(arguments);
  if (args.length <= 1) {
    return Logic.TRUE;
  } else {
    return new Logic.AtMostOneFormula(args);
  }
};

Logic.AtMostOneFormula = function (operands) {
  if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
  this.operands = operands;
};

Logic._defineFormula(Logic.AtMostOneFormula, 'atMostOne', {
  generateClauses: function (isTrue, t) {
     var args = this.operands;
     var not = Logic.not;
     if (args.length <= 1) {
       return []; // always succeed
     } else if (args.length === 2) {
       return t.generate(isTrue, Logic.not(Logic.and(args)));
     } else if (isTrue && args.length === 3) {
       // Pick any two args; at least one is false (they aren't
       // both true).  This strategy would also work for
       // N>3, and could provide a speed-up by having more clauses
       // (N^2) but fewer propagation steps.  No speed-up was
       // observed on the Sudoku test from using this strategy
       // up to N=10.
       var clauses = [];
       for (var i = 0; i < args.length; i++) {
         for (var j = i+1; j < args.length; j++) {
           clauses.push(t.clause(not(args[i]), not(args[j])));
         }
       }
       return clauses;
     } else if ((! isTrue) && args.length === 3) {
       var A = args[0], B = args[1], C = args[2];
       // Pick any two args; at least one is true (they aren't
       // both false).  This only works for N=3.
       return [t.clause(A, B), t.clause(A, C), t.clause(B, C)];
     } else {
       // See the "commander variables" technique from:
       // http://www.cs.cmu.edu/~wklieber/papers/2007_efficient-cnf-encoding-for-selecting-1.pdf
       // But in short: At most one group has at least one "true",
       // and each group has at most one "true".  Formula generation
       // automatically generates the right implications.
       var groups = group(args, 3);
       var ors = _.map(groups, function (g) { return Logic.or(g); });
       if (groups[groups.length - 1].length < 2) {
         // Remove final group of length 1 so we don't generate
         // no-op clauses of one sort or another
         groups.pop();
       }
       var atMostOnes = _.map(groups, function (g) {
         return Logic.atMostOne(g);
       });
       return t.generate(isTrue, Logic.and(Logic.atMostOne(ors), atMostOnes));
     }
  }
});

Logic.implies = function (A, B) {
  if (assert) assertNumArgs(arguments.length, 2, "Logic.implies");
  return new Logic.ImpliesFormula(A, B);
};

Logic.ImpliesFormula = function (A, B) {
  if (assert) assert(A, isFormulaOrTerm);
  if (assert) assert(B, isFormulaOrTerm);
  if (assert) assertNumArgs(arguments.length, 2, "Logic.implies");
  this.A = A;
  this.B = B;
};

Logic._defineFormula(Logic.ImpliesFormula, 'implies', {
  generateClauses: function (isTrue, t) {
    return t.generate(isTrue, Logic.or(Logic.not(this.A), this.B));
  }
});

Logic.equiv = function (A, B) {
  if (assert) assertNumArgs(arguments.length, 2, "Logic.equiv");
  return new Logic.EquivFormula(A, B);
};

Logic.EquivFormula = function (A, B) {
  if (assert) assert(A, isFormulaOrTerm);
  if (assert) assert(B, isFormulaOrTerm);
  if (assert) assertNumArgs(arguments.length, 2, "Logic.equiv");
  this.A = A;
  this.B = B;
};

Logic._defineFormula(Logic.EquivFormula, 'equiv', {
  generateClauses: function (isTrue, t) {
    return t.generate(!isTrue, Logic.xor(this.A, this.B));
  }
});

Logic.exactlyOne = function (/*formulaOrArray, ...*/) {
  var args = _.flatten(arguments);
  if (args.length === 0) {
    return Logic.FALSE;
  } else if (args.length === 1) {
    if (assert) assert(args[0], isFormulaOrTerm);
    return args[0];
  } else {
    return new Logic.ExactlyOneFormula(args);
  }
};

Logic.ExactlyOneFormula = function (operands) {
  if (assert) assert(operands, isArrayWhere(isFormulaOrTerm));
  this.operands = operands;
};

Logic._defineFormula(Logic.ExactlyOneFormula, 'exactlyOne', {
  generateClauses: function (isTrue, t) {
    var args = this.operands;
    if (args.length < 3) {
      return t.generate(isTrue, Logic.xor(args));
    } else {
      return t.generate(isTrue, Logic.and(Logic.atMostOne(args),
                                          Logic.or(args)));
    }
  }
});

// List of 0 or more formulas or terms, which together represent
// a non-negative integer.  Least significant bit is first.  That is,
// the kth array element has a place value of 2^k.
Logic.Bits = function (formulaArray) {
  if (assert) assert(formulaArray, isArrayWhere(isFormulaOrTerm));
  this.bits = formulaArray; // public, immutable
};

Logic.constantBits = function (wholeNumber) {
  if (assert) assert(wholeNumber, Logic.isWholeNumber);
  var result = [];
  while (wholeNumber) {
    result.push((wholeNumber & 1) ? Logic.TRUE : Logic.FALSE);
    wholeNumber >>>= 1;
  }
  return new Logic.Bits(result);
};

Logic.variableBits = function (baseName, nbits) {
  if (assert) assert(nbits, Logic.isWholeNumber);
  var result = [];
  for (var i = 0; i < nbits; i++) {
    result.push(baseName + '$' + i);
  }
  return new Logic.Bits(result);
};

// bits1 <= bits2
Logic.lessThanOrEqual = function (bits1, bits2) {
  return new Logic.LessThanOrEqualFormula(bits1, bits2);
};

Logic.LessThanOrEqualFormula = function (bits1, bits2) {
  if (assert) assert(bits1, Logic.isBits);
  if (assert) assert(bits2, Logic.isBits);
  if (assert) assertNumArgs(arguments.length, 2, "Bits comparison function");
  this.bits1 = bits1;
  this.bits2 = bits2;
};

var genLTE = function (bits1, bits2, t, notEqual) {
  var ret = [];
  // clone so we can mutate them in place
  var A = bits1.bits.slice();
  var B = bits2.bits.slice();
  if (notEqual && ! bits2.bits.length) {
    // can't be less than 0
    return t.clause();
  }
  // if A is longer than B, the extra (high) bits
  // must be 0.
  while (A.length > B.length) {
    var hi = A.pop();
    ret.push(t.clause(Logic.not(hi)));
  }
  // now B.length >= A.length
  // Let xors[i] be (A[i] xor B[i]), or just
  // B[i] if A is too short.
  var xors = _.map(B, function (b, i) {
    if (i < A.length) {
      return Logic.xor(A[i], b);
    } else {
      return b;
    }
  });

  // Suppose we are comparing 3-bit numbers, requiring
  // that ABC <= XYZ.  Here is what we require:
  //
  // * It is false that A=1 and X=0.
  // * It is false that A=X, B=1, and Y=0.
  // * It is false that A=X, B=Y, C=1, and Y=0.
  //
  // Translating these into clauses using DeMorgan's law:
  //
  // * A=0 or X=1
  // * (A xor X) or B=0 or Y=1
  // * (A xor X) or (B xor Y) or C=0 or Y=1
  //
  // Since our arguments are LSB first, in the example
  // we would be given [C, B, A] and [Z, Y, X] as input.
  // We iterate over the first argument starting from
  // the right, and build up a clause by iterating over
  // the xors from the right.
  //
  // If we have ABC <= VWXYZ, then we still have three clauses,
  // but each one is prefixed with "V or W or", because V and W
  // are at the end of the xors array.  This is equivalent to
  // padding ABC with two zeros.

  for (var i = A.length-1; i >= 0; i--) {
    ret.push(t.clause(xors.slice(i+1), Logic.not(A[i]), B[i]));
  }
  if (notEqual) {
    ret.push.apply(ret, t.generate(true, Logic.or(xors)));
  }
  return ret;
};

Logic._defineFormula(Logic.LessThanOrEqualFormula, 'lte', {
  generateClauses: function (isTrue, t) {
    if (isTrue) {
      // bits1 <= bits2
      return genLTE(this.bits1, this.bits2, t, false);
    } else {
      // bits2 < bits1
      return genLTE(this.bits2, this.bits1, t, true);
    }
  }
});

// bits1 < bits2
Logic.lessThan = function (bits1, bits2) {
  return new Logic.LessThanFormula(bits1, bits2);
};

Logic.LessThanFormula = function (bits1, bits2) {
  if (assert) assert(bits1, Logic.isBits);
  if (assert) assert(bits2, Logic.isBits);
  if (assert) assertNumArgs(arguments.length, 2, "Bits comparison function");
  this.bits1 = bits1;
  this.bits2 = bits2;
};

Logic._defineFormula(Logic.LessThanFormula, 'lt', {
  generateClauses: function (isTrue, t) {
    if (isTrue) {
      // bits1 < bits2
      return genLTE(this.bits1, this.bits2, t, true);
    } else {
      // bits2 <= bits1
      return genLTE(this.bits2, this.bits1, t, false);
    }
  }
});

Logic.greaterThan = function (bits1, bits2) {
  return Logic.lessThan(bits2, bits1);
};

Logic.greaterThanOrEqual = function (bits1, bits2) {
  return Logic.lessThanOrEqual(bits2, bits1);
};

Logic.equalBits = function (bits1, bits2) {
  return new Logic.EqualBitsFormula(bits1, bits2);
};

Logic.EqualBitsFormula = function (bits1, bits2) {
  if (assert) assert(bits1, Logic.isBits);
  if (assert) assert(bits2, Logic.isBits);
  if (assert) assertNumArgs(arguments.length, 2, "Logic.equalBits");
  this.bits1 = bits1;
  this.bits2 = bits2;
};

Logic._defineFormula(Logic.EqualBitsFormula, 'equalBits', {
  generateClauses: function (isTrue, t) {
    var A = this.bits1.bits;
    var B = this.bits2.bits;
    var nbits = Math.max(A.length, B.length);
    var facts = [];
    for (var i = 0; i < nbits; i++) {
      if (i >= A.length) {
        facts.push(Logic.not(B[i]));
      } else if (i >= B.length) {
        facts.push(Logic.not(A[i]));
      } else {
        facts.push(Logic.equiv(A[i], B[i]));
      }
    }
    return t.generate(isTrue, Logic.and(facts));
  }
});

// Definition of full-adder and half-adder:
//
// A full-adder is a 3-input, 2-output gate producing the sum of its
// inputs as a 2-bit binary number. The most significant bit is called
// "carry", the least significant "sum". A half-adder does the same
// thing, but has only 2 inputs (and can therefore never output a
// "3").
//
// The half-adder sum bit is really just an XOR, and the carry bit
// is really just an AND.  However, they get their own formula types
// here to enhance readability of the generated clauses.

Logic.HalfAdderSum = function (formula1, formula2) {
  if (assert) assert(formula1, isFormulaOrTerm);
  if (assert) assert(formula2, isFormulaOrTerm);

  if (assert) assertNumArgs(arguments.length, 2, "Logic.HalfAdderSum");
  this.a = formula1;
  this.b = formula2;
};

Logic._defineFormula(Logic.HalfAdderSum, 'hsum', {
  generateClauses: function (isTrue, t) {
    return t.generate(isTrue, Logic.xor(this.a, this.b));
  }
});

Logic.HalfAdderCarry = function (formula1, formula2) {
  if (assert) assert(formula1, isFormulaOrTerm);
  if (assert) assert(formula2, isFormulaOrTerm);
  if (assert) assertNumArgs(arguments.length, 2, "Logic.HalfAdderCarry");
  this.a = formula1;
  this.b = formula2;
};

Logic._defineFormula(Logic.HalfAdderCarry, 'hcarry', {
  generateClauses: function (isTrue, t) {
    return t.generate(isTrue, Logic.and(this.a, this.b));
  }
});

Logic.FullAdderSum = function (formula1, formula2, formula3) {
  if (assert) assert(formula1, isFormulaOrTerm);
  if (assert) assert(formula2, isFormulaOrTerm);
  if (assert) assert(formula3, isFormulaOrTerm);
  if (assert) assertNumArgs(arguments.length, 3, "Logic.FullAdderSum");
  this.a = formula1;
  this.b = formula2;
  this.c = formula3;
};

Logic._defineFormula(Logic.FullAdderSum, 'fsum', {
  generateClauses: function (isTrue, t) {
    return t.generate(isTrue, Logic.xor(this.a, this.b, this.c));
  }
});

Logic.FullAdderCarry = function (formula1, formula2, formula3) {
  if (assert) assert(formula1, isFormulaOrTerm);
  if (assert) assert(formula2, isFormulaOrTerm);
  if (assert) assert(formula3, isFormulaOrTerm);
  if (assert) assertNumArgs(arguments.length, 3, "Logic.FullAdderCarry");
  this.a = formula1;
  this.b = formula2;
  this.c = formula3;
};

Logic._defineFormula(Logic.FullAdderCarry, 'fcarry', {
  generateClauses: function (isTrue, t) {
    return t.generate(! isTrue,
                      Logic.atMostOne(this.a, this.b, this.c));
  }
});

// Implements the Adder strategy from the MiniSat+ paper:
// http://minisat.se/downloads/MiniSat+.pdf
// "Translating Pseudo-boolean Constraints into SAT"
//
// Takes a list of list of Formulas.  The first list is bits
// to give weight 1; the second is bits to give weight 2;
// the third is bits to give weight 4; and so on.
//
// Returns an array of Logic.FormulaOrTerm.
var binaryWeightedSum = function (varsByWeight) {
  if (assert) assert(varsByWeight,
                     isArrayWhere(isArrayWhere(isFormulaOrTerm)));
  // initialize buckets to a two-level clone of varsByWeight
  var buckets = _.map(varsByWeight, _.clone);
  var lowestWeight = 0; // index of the first non-empty array
  var output = [];
  while (lowestWeight < buckets.length) {
    var bucket = buckets[lowestWeight];
    if (! bucket.length) {
      output.push(Logic.FALSE);
      lowestWeight++;
    } else if (bucket.length === 1) {
      output.push(bucket[0]);
      lowestWeight++;
    } else if (bucket.length === 2) {
      var sum = new Logic.HalfAdderSum(bucket[0], bucket[1]);
      var carry = new Logic.HalfAdderCarry(bucket[0], bucket[1]);
      bucket.length = 0;
      bucket.push(sum);
      pushToNth(buckets, lowestWeight+1, carry);
    } else {
      // Whether we take variables from the start or end of the
      // bucket (i.e. `pop` or `shift`) determines the shape of the tree.
      // Empirically, some logic problems are faster with `shift` (2x or so),
      // but `pop` gives an order-of-magnitude speed-up on the Meteor Version
      // Solver "benchmark-tests" suite (Slava's benchmarks based on data from
      // Rails).  So, `pop` it is.
      var c = bucket.pop();
      var b = bucket.pop();
      var a = bucket.pop();
      var sum = new Logic.FullAdderSum(a, b, c);
      var carry = new Logic.FullAdderCarry(a, b, c);
      bucket.push(sum);
      pushToNth(buckets, lowestWeight+1, carry);
    }
  }
  return output;
};

// Push `newItem` onto the array at arrayOfArrays[n],
// first ensuring that it exists by pushing empty
// arrays onto arrayOfArrays.
var pushToNth = function (arrayOfArrays, n, newItem) {
  while (n >= arrayOfArrays.length) {
    arrayOfArrays.push([]);
  }
  arrayOfArrays[n].push(newItem);
};

var checkWeightedSumArgs = function (formulas, weights) {
  if (assert) assert(formulas, isArrayWhere(isFormulaOrTerm));
  if (typeof weights === 'number') {
    if (assert) assert(weights, Logic.isWholeNumber);
  } else {
    if (assert) assert(weights, isArrayWhere(Logic.isWholeNumber));
    if (formulas.length !== weights.length) {
      throw new Error("Formula array and weight array must be same length" +
                      "; they are " + formulas.length + " and " + weights.length);
    }
  }
};

Logic.weightedSum = function (formulas, weights) {
  checkWeightedSumArgs(formulas, weights);

  if (formulas.length === 0) {
    return new Logic.Bits([]);
  }

  if (typeof weights === 'number') {
    weights = _.map(formulas, function () { return weights; });
  }

  var binaryWeighted = [];
  _.each(formulas, function (f, i) {
    var w = weights[i];
    var whichBit = 0;
    while (w) {
      if (w & 1) {
        pushToNth(binaryWeighted, whichBit, f);
      }
      w >>>= 1;
      whichBit++;
    }
  });

  return new Logic.Bits(binaryWeightedSum(binaryWeighted));
};

Logic.sum = function (/*formulaOrBitsOrArray, ...*/) {
  var things = _.flatten(arguments);
  if (assert) assert(things, isArrayWhere(isFormulaOrTermOrBits));

  var binaryWeighted = [];
  _.each(things, function (x) {
    if (x instanceof Logic.Bits) {
      _.each(x.bits, function (b, i) {
        pushToNth(binaryWeighted, i, b);
      });
    } else {
      pushToNth(binaryWeighted, 0, x);
    }
  });

  return new Logic.Bits(binaryWeightedSum(binaryWeighted));
};

////////////////////////////////////////

Logic.Solver.prototype.solve = function (_assumpVar) {
  var self = this;
  if (_assumpVar !== undefined) {
    if (! (_assumpVar >= 1)) {
      throw new Error("_assumpVar must be a variable number");
    }
  }

  if (self._unsat) {
    return null;
  }

  while (self._numClausesAddedToMiniSat < self.clauses.length) {
    var i = self._numClausesAddedToMiniSat;
    var terms = self.clauses[i].terms;
    if (assert) assert(terms, isArrayWhere(Logic.isNumTerm));
    var stillSat = self._minisat.addClause(terms);
    self._numClausesAddedToMiniSat++;
    if (! stillSat) {
      self._unsat = true;
      return null;
    }
  }

  if (assert) assert(this._num2name.length - 1, Logic.isWholeNumber);
  self._minisat.ensureVar(this._num2name.length - 1);

  var stillSat = (_assumpVar ?
                  self._minisat.solveAssuming(_assumpVar) :
                  self._minisat.solve());
  if (! stillSat) {
    if (! _assumpVar) {
      self._unsat = true;
    }
    return null;
  }

  return new Logic.Solution(self, self._minisat.getSolution());
};

Logic.Solver.prototype.solveAssuming = function (formula) {
  if (assert) assert(formula, isFormulaOrTerm);

  // Wrap the formula in a formula of type Assumption, so that
  // we always generate a var like `$assump123`, regardless
  // of whether `formula` is a Term, a NotFormula, an already
  // required or forbidden Formula, etc.
  var assump = new Logic.Assumption(formula);
  var assumpVar = this._formulaToTerm(assump);
  if (! (typeof assumpVar === 'number' && assumpVar > 0)) {
    throw new Error("Assertion failure: not a positive numeric term");
  }

  // Generate clauses as if we used the assumption variable in a
  // clause, in the positive.  So if we assume "A v B", we might get a
  // clause like "A v B v -$assump123" (or actually, "$or1 v
  // -$assump123"), as if we had used $assump123 in a clause.  Instead
  // of using it in a clause, though, we temporarily assume it to be
  // true.
  this._useFormulaTerm(assumpVar);

  var result = this.solve(assumpVar);
  // Tell MiniSat that we will never use assumpVar again.
  // The formula may be used again, however.  (For example, you
  // can solve assuming a formula F, and if it works, require F.)
  this._minisat.retireVar(assumpVar);

  return result;
};

Logic.Assumption = function (formula) {
  if (assert) assert(formula, isFormulaOrTerm);
  this.formula = formula;
};

Logic._defineFormula(Logic.Assumption, 'assump', {
  generateClauses: function (isTrue, t) {
    if (isTrue) {
      return t.clause(this.formula);
    } else {
      return t.clause(Logic.not(this.formula));
    }
  }
});

Logic.Solution = function (_solver, _assignment) {
  var self = this;
  self._solver = _solver;
  self._assignment = _assignment;

  // save a snapshot of which formulas have variables designated
  // for them, but where we haven't generated clauses that constrain
  // those variables in both the positive and the negative direction.
  self._ungeneratedFormulas = _.clone(_solver._ungeneratedFormulas);

  self._formulaValueCache = {};
  self._termifier = new Logic.Termifier(self._solver);
  // Normally, when a Formula uses a Termifier to generate clauses that
  // refer to other Formulas, the Termifier replaces the Formulas with
  // their variables.  We hijack this mechanism to replace the Formulas
  // with their truth variables instead, leading to recursive evaluation.
  // Note that we cache the evaluated truth values of Formulas to avoid
  // redundant evaluation.
  self._termifier.term = function (formula) {
    return self.evaluate(formula) ? Logic.NUM_TRUE : Logic.NUM_FALSE;
  };

  // When true, evaluation doesn't throw errors when
  // `evaluate` or `getWeightedSum` encounter named variables that are
  // unknown or variables that weren't present when this Solution was
  // generated.  Instead, the unknown variables are assumed to be false.
  self._ignoreUnknownVariables = false;
};

Logic.Solution.prototype.ignoreUnknownVariables = function () {
  // We only make this settable one way (false to true).
  // Setting it back and forth would be questionable, since we keep
  // a cache of Formula evaluations.
  this._ignoreUnknownVariables = true;
};

// Get a map of variables to their assignments,
// such as `{A: true, B: false, C: true}`.
// Internal variables are excluded.
Logic.Solution.prototype.getMap = function () {
  var solver = this._solver;
  var assignment = this._assignment;
  var result = {};
  for (var i = 1; i < assignment.length; i++) {
    var name = solver.getVarName(i);
    if (name && name.charAt(0) !== '$') {
      result[name] = assignment[i];
    }
  }
  return result;
};

// Get an array of variables that are assigned
// `true` by this solution, sorted by name.
// Internal variables are excluded.
Logic.Solution.prototype.getTrueVars = function () {
  var solver = this._solver;
  var assignment = this._assignment;
  var result = [];
  for (var i = 1; i < assignment.length; i++) {
    if (assignment[i]) {
      var name = solver.getVarName(i);
      if (name && name.charAt(0) !== '$') {
        result.push(name);
      }
    }
  }
  result.sort();
  return result;
};

// Get a Formula that says that the variables are assigned
// according to this solution.  (Internal variables are
// excluded.)  By forbidding this Formula and solving again,
// you can see if there are other solutions.
Logic.Solution.prototype.getFormula = function () {
  var solver = this._solver;
  var assignment = this._assignment;
  var terms = [];
  for (var i = 1; i < assignment.length; i++) {
    var name = solver.getVarName(i);
    if (name && name.charAt(0) !== '$') {
      terms.push(assignment[i] ? i : -i);
    }
  }
  return Logic.and(terms);
};

// Returns a boolean if the argument is a Formula (or Term), and an integer
// if the argument is a Logic.Bits.
Logic.Solution.prototype.evaluate = function (formulaOrBits) {
  var self = this;
  if (assert) assert(formulaOrBits, isFormulaOrTermOrBits);

  if (formulaOrBits instanceof Logic.Bits) {
    // Evaluate to an integer
    var ret = 0;
    _.each(formulaOrBits.bits, function (f, i) {
      if (self.evaluate(f)) {
        ret += 1 << i;
      }
    });
    return ret;
  }

  var solver = self._solver;
  var ignoreUnknownVariables = self._ignoreUnknownVariables;
  var assignment = self._assignment;
  var formula = formulaOrBits;
  if (formula instanceof Logic.NotFormula) {
    return ! self.evaluate(formula.operand);
  } else if (formula instanceof Logic.Formula) {
    var cachedResult = self._formulaValueCache[formula.guid()];
    if (typeof cachedResult === 'boolean') {
      return cachedResult;
    } else {
      var value;
      var info = solver._getFormulaInfo(formula, true);
      if (info && info.varNum && info.varNum < assignment.length &&
          ! _.has(self._ungeneratedFormulas, info.varNum)) {
        // as an optimization, read the value of the formula directly
        // from a variable if the formula's clauses were completely
        // generated at the time of solving.  (We must be careful,
        // because if we didn't generate both the positive and the
        // negative polarity clauses for the formula, then the formula
        // variable is not actually constrained to have the right
        // value.)
        value = assignment[info.varNum];
      } else {
        var clauses = solver._generateFormula(true, formula, self._termifier);
        var value = _.all(clauses, function (cls) {
          return _.any(cls.terms, function (t) {
            return self.evaluate(t);
          });
        });
      }
      self._formulaValueCache[formula.guid()] = value;
      return value;
    }
  } else {
    // Term; convert to numeric (possibly negative), but throw
    // an error if the name is not found.  If `ignoreUnknownVariables`
    // is set, return false instead.
    var numTerm = solver.toNumTerm(formula, true);
    if (! numTerm) {
      if (ignoreUnknownVariables) {
        return false;
      } else {
        // formula must be a NameTerm naming a variable that doesn't exist
        var vname = String(formula).replace(/^-*/, '');
        throw new Error("No such variable: " + vname);
      }
    }
    var v = numTerm;
    var isNot = false;
    if (numTerm < 0) {
      v = -v;
      isNot = true;
    }
    if (v < 1 || v >= assignment.length) {
      var vname = v;
      if (v >= 1 && v < solver._num2name.length) {
        vname = solver._num2name[v];
      }
      if (ignoreUnknownVariables) {
        return false;
      } else {
        throw new Error("Variable not part of solution: " + vname);
      }
    }
    var ret = assignment[v];
    if (isNot) {
      ret = ! ret;
    }
    return ret;
  }
};

Logic.Solution.prototype.getWeightedSum = function (formulas, weights) {
  checkWeightedSumArgs(formulas, weights);

  var total = 0;
  if (typeof weights === 'number') {
    for (var i = 0; i < formulas.length; i++) {
      total += weights * (this.evaluate(formulas[i]) ? 1 : 0);
    }
  } else {
    for (var i = 0; i < formulas.length; i++) {
      total += weights[i] * (this.evaluate(formulas[i]) ? 1 : 0);
    }
  }
  return total;
};
var getNonZeroWeightedTerms = function (costTerms, costWeights) {
  if (typeof costWeights === 'number') {
    return costWeights ? costTerms : [];
  } else {
    var terms = [];
    for (var i = 0; i < costTerms.length; i++) {
      if (costWeights[i]) {
        terms.push(costTerms[i]);
      }
    }
    return terms;
  }
};

// See comments on minimizeWeightedSum and maximizeWeightedSum.
var minMaxWS = function (solver, solution, costTerms, costWeights, options,
                         isMin) {
  var curSolution = solution;
  var curCost = curSolution.getWeightedSum(costTerms, costWeights);

  var optFormula = options && options.formula;
  var weightedSum = (optFormula || Logic.weightedSum(costTerms, costWeights));

  var progress = options && options.progress;
  var strategy = options && options.strategy;

  // array of terms with non-zero weights, populated on demand
  var nonZeroTerms = null;

  if (isMin && curCost > 0) {
    // try to skip straight to 0 cost, because if it works, it could
    // save us some time
    if (progress) {
      progress('trying', 0);
    }
    var zeroSolution = null;
    nonZeroTerms = getNonZeroWeightedTerms(costTerms, costWeights);
    var zeroSolution = solver.solveAssuming(Logic.not(Logic.or(nonZeroTerms)));
    if (zeroSolution) {
      curSolution = zeroSolution;
      curCost = 0;
    }
  }

  if (isMin && strategy === 'bottom-up') {
    for (var trialCost = 1; trialCost < curCost; trialCost++) {
      if (progress) {
        progress('trying', trialCost);
      }
      var costIsTrialCost = Logic.equalBits(
        weightedSum, Logic.constantBits(trialCost));
      var newSolution = solver.solveAssuming(costIsTrialCost);
      if (newSolution) {
        curSolution = newSolution;
        curCost = trialCost;
        break;
      }
    }
  } else if (strategy && strategy !== 'default') {
    throw new Error("Bad strategy: " + strategy);
  } else {
    strategy = 'default';
  }

  if (strategy === 'default') {
    // for minimization, count down from current cost. for maximization,
    // count up.
    while (isMin ? curCost > 0 : true) {
      if (progress) {
        progress('improving', curCost);
      }
      var improvement = (isMin ? Logic.lessThan : Logic.greaterThan)(
        weightedSum, Logic.constantBits(curCost));
      var newSolution = solver.solveAssuming(improvement);
      if (! newSolution) {
        break;
      }
      solver.require(improvement);
      curSolution = newSolution;
      curCost = curSolution.getWeightedSum(costTerms, costWeights);
    }
  }

  if (isMin && curCost === 0) {
    // express the requirement that the weighted sum be 0 in an efficient
    // way for the solver (all terms with non-zero weights must be 0)
    if (! nonZeroTerms) {
      nonZeroTerms = getNonZeroWeightedTerms(costTerms, costWeights);
    }
    solver.forbid(nonZeroTerms);
  } else {
    solver.require(Logic.equalBits(weightedSum, Logic.constantBits(curCost)));
  }

  if (progress) {
    progress('finished', curCost);
  }

  return curSolution;
};

// Minimize (or maximize) the dot product of costTerms and
// costWeights, and further, require (as in solver.require) that the
// value of the dot product be equal to the optimum found.  Returns a
// valid solution where this optimum is achieved.
//
// `solution` must be a current valid solution as returned from
// `solve` or `solveAssuming`.  It is used as a starting point (to
// evaluate the current cost).
//
// costWeights is an array (of same length as costTerms) or a single
// WholeNumber.
//
// if the caller passes options.formula, it should be the formula
// Logic.weightedSum(costTerms, costWeights).  The optimizer will use
// this existing formula rather than generating a new one (for
// efficiency).  The optimizer still wants to know the terms and
// weights, because it is more efficient for it to evaluate the
// current cost using them directly rather than the formula.
//
// options.progress: a function that takes two arguments, to call at
// particular times during optimization.  Called with arguments
// ('improving', cost) when about to search for a way to improve on
// `cost`, and called with arguments ('finished', cost) when the
// optimum is reached.  There's also ('trying', cost) when a cost
// is tried directly (which is usually done with 0 right off the bat).
//
// options.strategy: a string hinting how to go about the optimization.
// the default strategy (option absent or 'default') is to work down
// from the current cost for minimization or up from the current cost
// for maximization, and iteratively insist that the cost be made lower
// if possible.  For minimization, the alternate strategy 'bottom-up' is
// available, which starts at 0 and tries ever higher costs until one
// works.  All strategies first try and see if a cost of 0 is possible.

// ("costTerms" is kind of a misnomer since they may be Formulas or Terms.)
Logic.Solver.prototype.minimizeWeightedSum = function (solution, costTerms,
                                                       costWeights, options) {
  return minMaxWS(this, solution, costTerms, costWeights, options, true);
};

Logic.Solver.prototype.maximizeWeightedSum = function (solution, costTerms,
                                                       costWeights, options) {
  return minMaxWS(this, solution, costTerms, costWeights, options, false);
};
module.exports = Logic;


/***/ }),
/* 245 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var C_MINISAT = __webpack_require__(246);
var _ = __webpack_require__(247);
var MiniSat;
MiniSat = function () {
  // A MiniSat object wraps an instance of "native" MiniSat.  You can
  // have as many MiniSat objects as you want, and they are all
  // independent.
  //
  // C is the "module" object created by Emscripten.  We wrap the
  // output of Emscripten in a closure, so each call to C_MINISAT()
  // actually instantiates a separate C environment, including
  // the "native" heap.
  //
  // The methods available on `C` include the global functions we
  // define in `logic-solver.cc`, each prefixed with `_`, and a varied
  // assortment of helpers put there by Emscripten, some of which are
  // documented here:
  // http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html
  //
  // See the README in the meteor/minisat repo for more notes about
  // our build of MiniSat.
  var C = this._C = C_MINISAT();

  this._native = {
    getStackPointer: function () {
      return C.Runtime.stackSave();
    },
    setStackPointer: function (ptr) {
      C.Runtime.stackRestore(ptr);
    },
    allocateBytes: function (len) {
      return C.allocate(len, 'i8', C.ALLOC_STACK);
    },
    pushString: function (str) {
      return this.allocateBytes(C.intArrayFromString(str));
    },
    savingStack: function (func) {
      var SP = this.getStackPointer();
      try {
        return func(this, C);
      } finally {
        this.setStackPointer(SP);
      }
    }
  };

  C._createTheSolver();

  // useful log for debugging and testing
  this._clauses = [];
};


// Make sure MiniSat has allocated space in its model for v,
// even if v is unused.  If we have variables A,B,C,D which
// are numbers 1,2,3,4, for example, but we never actually use
// C and D, calling ensureVar(4) will make MiniSat give us
// solution values for them anyway.
MiniSat.prototype.ensureVar = function (v) {
  this._C._ensureVar(v);
};

// Add a clause, in the form of an array of Logic.NumTerms.
// Returns true if the problem is still satisfiable
// (as far as we know without doing more work), and false if
// we can already tell that it is unsatisfiable.
MiniSat.prototype.addClause = function (terms) {
  this._clauses.push(terms);
  return this._native.savingStack(function (native, C) {
    var termsPtr = C.allocate((terms.length+1)*4, 'i32', C.ALLOC_STACK);
    _.each(terms, function (t, i) {
      C.setValue(termsPtr + i*4, t, 'i32');
    });
    C.setValue(termsPtr + terms.length*4, 0, 'i32'); // 0-terminate
    return C._addClause(termsPtr) ? true : false;
  });
};

MiniSat.prototype.solve = function () {
  return this._C._solve() ? true : false;
};

MiniSat.prototype.solveAssuming = function (v) {
  return this._C._solveAssuming(v) ? true : false;
};

MiniSat.prototype.getSolution = function () {
  var solution = [null]; // no 0th var
  var C = this._C;
  var numVars = C._getNumVars();
  var solPtr = C._getSolution();
  for (var i = 0; i < numVars; i++) {
    // 0 is Minisat::l_True (lifted "true").
    // Internally, Minisat has three states for a variable:
    // true, false, and undetermined.  It doesn't distinguish
    // between "false" and "undetermined" in solutions though
    // (I think it sets undetermined variables to false).
    solution[i+1] = (C.getValue(solPtr+i, 'i8') === 0);
  }
  return solution;
};

MiniSat.prototype.retireVar = function (v) {
  this._C._retireVar(v);
};

// The "conflict clause" feature of MiniSat is not what it sounds
// like, unfortunately -- it doesn't help explain conflicts.
// It only tells us which assumption vars are to blame for a failed
// solveAssuming (and we only ever pass one var).
// We keep this function around in case we discover a use for it.
MiniSat.prototype.getConflictClause = function () {
  var C = this._C;
  var numTerms = C._getConflictClauseSize();
  var clausePtr = C._getConflictClause();
  var terms = [];
  for (var i = 0; i < numTerms; i++) {
    var t = C.getValue(clausePtr + i*4, 'i32');
    var v = (t >>> 1);
    var s = (t & 1) ? -1 : 1;
    terms[i] = v * s;
  }
  return terms;
};
module.exports = MiniSat;


/***/ }),
/* 246 */
/***/ ((module) => {

var C_MINISAT;
// This file is generated by the meteor/minisat repo.
// See that repo's README for instructions for building it.
C_MINISAT=(function(){var module={};var require=(function(){});var process={argv:["node","minisat"],on:(function(){}),stdout:{write:(function(str){console.log("MINISAT-out:",str.replace(/\n$/,""))})},stderr:{write:(function(str){console.log("MINISAT-err:",str.replace(/\n$/,""))})}};var window=0;var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};for(var key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function";var ENVIRONMENT_IS_WEB=typeof window==="object";var ENVIRONMENT_IS_WORKER=typeof importScripts==="function";var ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=function print(x){process["stdout"].write(x+"\n")};if(!Module["printErr"])Module["printErr"]=function printErr(x){process["stderr"].write(x+"\n")};var nodeFS=require("fs");var nodePath=require("path");Module["read"]=function read(filename,binary){filename=nodePath["normalize"](filename);var ret=nodeFS["readFileSync"](filename);if(!ret&&filename!=nodePath["resolve"](filename)){filename=path.join(__dirname,"..","src",filename);ret=nodeFS["readFileSync"](filename)}if(ret&&!binary)ret=ret.toString();return ret};Module["readBinary"]=function readBinary(filename){return Module["read"](filename,true)};Module["load"]=function load(f){globalEval(read(f))};if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}else{Module["thisProgram"]="unknown-program"}Module["arguments"]=process["argv"].slice(2);if(typeof module!=="undefined"){module["exports"]=Module}process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}))}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined"){Module["read"]=read}else{Module["read"]=function read(){throw"no read() available (jsc?)"}}Module["readBinary"]=function readBinary(f){if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}var data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}this["Module"]=Module}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function read(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=function print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function printErr(x){console.log(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?(function(x){dump(x)}):(function(x){})}if(ENVIRONMENT_IS_WEB){window["Module"]=Module}else{Module["load"]=importScripts}}else{throw"Unknown runtime environment. Where are we?"}function globalEval(x){eval.call(null,x)}if(!Module["load"]&&Module["read"]){Module["load"]=function load(f){globalEval(Module["read"](f))}}if(!Module["print"]){Module["print"]=(function(){})}if(!Module["printErr"]){Module["printErr"]=Module["print"]}if(!Module["arguments"]){Module["arguments"]=[]}if(!Module["thisProgram"]){Module["thisProgram"]="./this.program"}Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(var key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}var Runtime={setTempRet0:(function(value){tempRet0=value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop}),getNativeTypeSize:(function(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return Runtime.QUANTUM_SIZE}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,getAlignSize:(function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){if(!args.splice)args=Array.prototype.slice.call(args);args.splice(0,0,ptr);return Module["dynCall_"+sig].apply(null,args)}else{return Module["dynCall_"+sig].call(null,ptr)}}),functionPointers:[],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null}),getAsmConst:(function(code,numArgs){if(!Runtime.asmConstCache)Runtime.asmConstCache={};var func=Runtime.asmConstCache[code];if(func)return func;var args=[];for(var i=0;i<numArgs;i++){args.push(String.fromCharCode(36)+i)}var source=Pointer_stringify(code);if(source[0]==='"'){if(source.indexOf('"',1)===source.length-1){source=source.substr(1,source.length-2)}else{abort("invalid EM_ASM input |"+source+"|. Please use EM_ASM(..code..) (no quotes) or EM_ASM({ ..code($0).. }, input) (to input values)")}}try{var evalled=eval("(function(Module, FS) { return function("+args.join(",")+"){ "+source+" } })")(Module,typeof FS!=="undefined"?FS:null)}catch(e){Module.printErr("error in executing inline EM_ASM code: "+e+" on: \n\n"+source+"\n\nwith args |"+args+"| (make sure to use the right one out of EM_ASM, EM_ASM_ARGS, etc.)");throw e}return Runtime.asmConstCache[code]=evalled}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}}),funcWrappers:{},getFuncWrapper:(function(func,sig){assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={}}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,arguments)}}return sigCache[func]}),UTF8Processor:(function(){var buffer=[];var needed=0;this.processCChar=(function(code){code=code&255;if(buffer.length==0){if((code&128)==0){return String.fromCharCode(code)}buffer.push(code);if((code&224)==192){needed=1}else if((code&240)==224){needed=2}else{needed=3}return""}if(needed){buffer.push(code);needed--;if(needed>0)return""}var c1=buffer[0];var c2=buffer[1];var c3=buffer[2];var c4=buffer[3];var ret;if(buffer.length==2){ret=String.fromCharCode((c1&31)<<6|c2&63)}else if(buffer.length==3){ret=String.fromCharCode((c1&15)<<12|(c2&63)<<6|c3&63)}else{var codePoint=(c1&7)<<18|(c2&63)<<12|(c3&63)<<6|c4&63;ret=String.fromCharCode(((codePoint-65536)/1024|0)+55296,(codePoint-65536)%1024+56320)}buffer.length=0;return ret});this.processJSString=function processJSString(string){string=unescape(encodeURIComponent(string));var ret=[];for(var i=0;i<string.length;i++){ret.push(string.charCodeAt(i))}return ret}}),getCompilerSetting:(function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=DYNAMICTOP;DYNAMICTOP=DYNAMICTOP+size|0;DYNAMICTOP=DYNAMICTOP+15&-16;if(DYNAMICTOP>=TOTAL_MEMORY)enlargeMemory();return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var __THREW__=0;var ABORT=false;var EXITSTATUS=0;var undef=0;var tempValue,tempInt,tempBigInt,tempInt2,tempBigInt2,tempPair,tempBigIntI,tempBigIntR,tempBigIntS,tempBigIntP,tempBigIntD,tempDouble,tempFloat;var tempI64,tempI64b;var tempRet0,tempRet1,tempRet2,tempRet3,tempRet4,tempRet5,tempRet6,tempRet7,tempRet8,tempRet9;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}var globalScope=this;function getCFunc(ident){var func=Module["_"+ident];if(!func){try{func=eval("_"+ident)}catch(e){}}assert(func,"Cannot call unknown function "+ident+" (perhaps LLVM optimizations or closure removed it?)");return func}var cwrap,ccall;((function(){var JSfuncs={"stackSave":(function(){Runtime.stackSave()}),"stackRestore":(function(){Runtime.stackRestore()}),"arrayToC":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=Runtime.stackAlloc((str.length<<2)+1);writeStringToMemory(str,ret)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};ccall=function ccallFunc(ident,returnType,argTypes,args){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0)Runtime.stackRestore(stack);return ret};var sourceRegex=/^function\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;function parseJSFunc(jsfunc){var parsed=jsfunc.toString().match(sourceRegex).slice(1);return{arguments:parsed[0],body:parsed[1],returnValue:parsed[2]}}var JSsource={};for(var fun in JSfuncs){if(JSfuncs.hasOwnProperty(fun)){JSsource[fun]=parseJSFunc(JSfuncs[fun])}}cwrap=function cwrap(ident,returnType,argTypes){argTypes=argTypes||[];var cfunc=getCFunc(ident);var numericArgs=argTypes.every((function(type){return type==="number"}));var numericRet=returnType!=="string";if(numericRet&&numericArgs){return cfunc}var argNames=argTypes.map((function(x,i){return"$"+i}));var funcstr="(function("+argNames.join(",")+") {";var nargs=argTypes.length;if(!numericArgs){funcstr+="var stack = "+JSsource["stackSave"].body+";";for(var i=0;i<nargs;i++){var arg=argNames[i],type=argTypes[i];if(type==="number")continue;var convertCode=JSsource[type+"ToC"];funcstr+="var "+convertCode.arguments+" = "+arg+";";funcstr+=convertCode.body+";";funcstr+=arg+"="+convertCode.returnValue+";"}}var cfuncname=parseJSFunc((function(){return cfunc})).returnValue;funcstr+="var ret = "+cfuncname+"("+argNames.join(",")+");";if(!numericRet){var strgfy=parseJSFunc((function(){return Pointer_stringify})).returnValue;funcstr+="ret = "+strgfy+"(ret);"}if(!numericArgs){funcstr+=JSsource["stackRestore"].body.replace("()","(stack)")+";"}funcstr+="return ret})";return eval(funcstr)}}))();Module["cwrap"]=cwrap;Module["ccall"]=ccall;function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for setValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[_malloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var ptr=ret,stop;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function"){curr=Runtime.getFunctionIndex(curr)}type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}Module["allocate"]=allocate;function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=false;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];if(t>=128)hasUtf=true;else if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(!hasUtf){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}var utf8=new Runtime.UTF8Processor;for(i=0;i<length;i++){t=HEAPU8[ptr+i>>0];ret+=utf8.processCChar(t)}return ret}Module["Pointer_stringify"]=Pointer_stringify;function UTF16ToString(ptr){var i=0;var str="";while(1){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)return str;++i;str+=String.fromCharCode(codeUnit)}}Module["UTF16ToString"]=UTF16ToString;function stringToUTF16(str,outPtr){for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr+i*2>>1]=codeUnit}HEAP16[outPtr+str.length*2>>1]=0}Module["stringToUTF16"]=stringToUTF16;function UTF32ToString(ptr){var i=0;var str="";while(1){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)return str;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}}Module["UTF32ToString"]=UTF32ToString;function stringToUTF32(str,outPtr){var iChar=0;for(var iCodeUnit=0;iCodeUnit<str.length;++iCodeUnit){var codeUnit=str.charCodeAt(iCodeUnit);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++iCodeUnit);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr+iChar*4>>2]=codeUnit;++iChar}HEAP32[outPtr+iChar*4>>2]=0}Module["stringToUTF32"]=stringToUTF32;function demangle(func){var hasLibcxxabi=!!Module["___cxa_demangle"];if(hasLibcxxabi){try{var buf=_malloc(func.length);writeStringToMemory(func.substr(1),buf);var status=_malloc(4);var ret=Module["___cxa_demangle"](buf,0,0,status);if(getValue(status,"i32")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}}var i=3;var basicTypes={"v":"void","b":"bool","c":"char","s":"short","i":"int","l":"long","f":"float","d":"double","w":"wchar_t","a":"signed char","h":"unsigned char","t":"unsigned short","j":"unsigned int","m":"unsigned long","x":"long long","y":"unsigned long long","z":"..."};var subs=[];var first=true;function dump(x){if(x)Module.print(x);Module.print(func);var pre="";for(var a=0;a<i;a++)pre+=" ";Module.print(pre+"^")}function parseNested(){i++;if(func[i]==="K")i++;var parts=[];while(func[i]!=="E"){if(func[i]==="S"){i++;var next=func.indexOf("_",i);var num=func.substring(i,next)||0;parts.push(subs[num]||"?");i=next+1;continue}if(func[i]==="C"){parts.push(parts[parts.length-1]);i+=2;continue}var size=parseInt(func.substr(i));var pre=size.toString().length;if(!size||!pre){i--;break}var curr=func.substr(i+pre,size);parts.push(curr);subs.push(curr);i+=pre+size}i++;return parts}function parse(rawList,limit,allowVoid){limit=limit||Infinity;var ret="",list=[];function flushList(){return"("+list.join(", ")+")"}var name;if(func[i]==="N"){name=parseNested().join("::");limit--;if(limit===0)return rawList?[name]:name}else{if(func[i]==="K"||first&&func[i]==="L")i++;var size=parseInt(func.substr(i));if(size){var pre=size.toString().length;name=func.substr(i+pre,size);i+=pre+size}}first=false;if(func[i]==="I"){i++;var iList=parse(true);var iRet=parse(true,1,true);ret+=iRet[0]+" "+name+"<"+iList.join(", ")+">"}else{ret=name}paramLoop:while(i<func.length&&limit-->0){var c=func[i++];if(c in basicTypes){list.push(basicTypes[c])}else{switch(c){case"P":list.push(parse(true,1,true)[0]+"*");break;case"R":list.push(parse(true,1,true)[0]+"&");break;case"L":{i++;var end=func.indexOf("E",i);var size=end-i;list.push(func.substr(i,size));i+=size+2;break};case"A":{var size=parseInt(func.substr(i));i+=size.toString().length;if(func[i]!=="_")throw"?";i++;list.push(parse(true,1,true)[0]+" ["+size+"]");break};case"E":break paramLoop;default:ret+="?"+c;break paramLoop}}}if(!allowVoid&&list.length===1&&list[0]==="void")list=[];if(rawList){if(ret){list.push(ret+"?")}return list}else{return ret+flushList()}}var parsed=func;try{if(func=="Object._main"||func=="_main"){return"main()"}if(typeof func==="number")func=Pointer_stringify(func);if(func[0]!=="_")return func;if(func[1]!=="_")return func;if(func[2]!=="Z")return func;switch(func[3]){case"n":return"operator new()";case"d":return"operator delete()"}parsed=parse()}catch(e){parsed+="?"}if(parsed.indexOf("?")>=0&&!hasLibcxxabi){Runtime.warnOnce("warning: a problem occurred in builtin C++ name demangling; build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling")}return parsed}function demangleAll(text){return text.replace(/__Z[\w\d_]+/g,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){return demangleAll(jsStackTrace())}Module["stackTrace"]=stackTrace;var PAGE_SIZE=4096;function alignMemoryPage(x){return x+4095&-4096}var HEAP;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var STATIC_BASE=0,STATICTOP=0,staticSealed=false;var STACK_BASE=0,STACKTOP=0,STACK_MAX=0;var DYNAMIC_BASE=0,DYNAMICTOP=0;function enlargeMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value "+TOTAL_MEMORY+", (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.")}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||67108864;var FAST_MEMORY=Module["FAST_MEMORY"]||2097152;var totalMemory=64*1024;while(totalMemory<TOTAL_MEMORY||totalMemory<2*TOTAL_STACK){if(totalMemory<16*1024*1024){totalMemory*=2}else{totalMemory+=16*1024*1024}}if(totalMemory!==TOTAL_MEMORY){Module.printErr("increasing TOTAL_MEMORY to "+totalMemory+" to be compliant with the asm.js spec");TOTAL_MEMORY=totalMemory}assert(typeof Int32Array!=="undefined"&&typeof Float64Array!=="undefined"&&!!(new Int32Array(1))["subarray"]&&!!(new Int32Array(1))["set"],"JS engine does not provide full typed array support");var buffer=new ArrayBuffer(TOTAL_MEMORY);HEAP8=new Int8Array(buffer);HEAP16=new Int16Array(buffer);HEAP32=new Int32Array(buffer);HEAPU8=new Uint8Array(buffer);HEAPU16=new Uint16Array(buffer);HEAPU32=new Uint32Array(buffer);HEAPF32=new Float32Array(buffer);HEAPF64=new Float64Array(buffer);HEAP32[0]=255;assert(HEAPU8[0]===255&&HEAPU8[3]===0,"Typed arrays 2 must be run on a little-endian system");Module["HEAP"]=HEAP;Module["buffer"]=buffer;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Runtime.dynCall("v",func)}else{Runtime.dynCall("vi",func,[callback.arg])}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=Module.addOnPreRun=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=Module.addOnInit=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=Module.addOnPreMain=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=Module.addOnExit=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=Module.addOnPostRun=addOnPostRun;function intArrayFromString(stringy,dontAddNull,length){var ret=(new Runtime.UTF8Processor).processJSString(stringy);if(length){ret.length=length}if(!dontAddNull){ret.push(0)}return ret}Module["intArrayFromString"]=intArrayFromString;function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayToString"]=intArrayToString;function writeStringToMemory(string,buffer,dontAddNull){var array=intArrayFromString(string,dontAddNull);var i=0;while(i<array.length){var chr=array[i];HEAP8[buffer+i>>0]=chr;i=i+1}}Module["writeStringToMemory"]=writeStringToMemory;function writeArrayToMemory(array,buffer){for(var i=0;i<array.length;i++){HEAP8[buffer+i>>0]=array[i]}}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;i++){HEAP8[buffer+i>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer+str.length>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;function unSign(value,bits,ignore){if(value>=0){return value}return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}function reSign(value,bits,ignore){if(value<=0){return value}var half=bits<=32?Math.abs(1<<bits-1):Math.pow(2,bits-1);if(value>=half&&(bits<=32||value>half)){value=-2*half+value}return value}if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}Module["addRunDependency"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;STATIC_BASE=8;STATICTOP=STATIC_BASE+5664;__ATINIT__.push({func:(function(){__GLOBAL__I_a()})},{func:(function(){__GLOBAL__I_a127()})});allocate([78,55,77,105,110,105,115,97,116,50,48,79,117,116,79,102,77,101,109,111,114,121,69,120,99,101,112,116,105,111,110,69,0,0,0,0,0,0,0,0,88,18,0,0,8,0,0,0,78,55,77,105,110,105,115,97,116,54,79,112,116,105,111,110,69,0,0,0,0,0,0,0,88,18,0,0,56,0,0,0,10,32,32,32,32,32,32,32,32,37,115,10,0,0,0,0,0,0,0,0,80,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,200,0,0,0,1,0,0,0,3,0,0,0,1,0,0,0,1,0,0,0,78,55,77,105,110,105,115,97,116,49,48,66,111,111,108,79,112,116,105,111,110,69,0,0,128,18,0,0,176,0,0,0,80,0,0,0,0,0,0,0,32,32,45,37,115,44,32,45,110,111,45,37,115,0,0,0,40,100,101,102,97,117,108,116,58,32,37,115,41,10,0,0,111,110,0,0,0,0,0,0,111,102,102,0,0,0,0,0,110,111,45,0,0,0,0,0,0,0,0,0,64,1,0,0,1,0,0,0,4,0,0,0,2,0,0,0,2,0,0,0,78,55,77,105,110,105,115,97,116,57,73,110,116,79,112,116,105,111,110,69,0,0,0,0,128,18,0,0,40,1,0,0,80,0,0,0,0,0,0,0,32,32,45,37,45,49,50,115,32,61,32,37,45,56,115,32,91,0,0,0,0,0,0,0,105,109,105,110,0,0,0,0,37,52,100,0,0,0,0,0,32,46,46,32,0,0,0,0,105,109,97,120,0,0,0,0,93,32,40,100,101,102,97,117,108,116,58,32,37,100,41,10,0,0,0,0,0,0,0,0,69,82,82,79,82,33,32,118,97,108,117,101,32,60,37,115,62,32,105,115,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,111,112,116,105,111,110,32,34,37,115,34,46,10,0,0,0,0,0,0,0,0,69,82,82,79,82,33,32,118,97,108,117,101,32,60,37,115,62,32,105,115,32,116,111,111,32,115,109,97,108,108,32,102,111,114,32,111,112,116,105,111,110,32,34,37,115,34,46,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,118,97,114,45,100,101,99,97,121,0,0,0,0,0,0,0,84,104,101,32,118,97,114,105,97,98,108,101,32,97,99,116,105,118,105,116,121,32,100,101,99,97,121,32,102,97,99,116,111,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,108,97,45,100,101,99,97,121,0,0,0,0,0,0,0,84,104,101,32,99,108,97,117,115,101,32,97,99,116,105,118,105,116,121,32,100,101,99,97,121,32,102,97,99,116,111,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,110,100,45,102,114,101,113,0,0,0,0,0,0,0,0,84,104,101,32,102,114,101,113,117,101,110,99,121,32,119,105,116,104,32,119,104,105,99,104,32,116,104,101,32,100,101,99,105,115,105,111,110,32,104,101,117,114,105,115,116,105,99,32,116,114,105,101,115,32,116,111,32,99,104,111,111,115,101,32,97,32,114,97,110,100,111,109,32,118,97,114,105,97,98,108,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,110,100,45,115,101,101,100,0,0,0,0,0,0,0,0,85,115,101,100,32,98,121,32,116,104,101,32,114,97,110,100,111,109,32,118,97,114,105,97,98,108,101,32,115,101,108,101,99,116,105,111,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,99,109,105,110,45,109,111,100,101,0,0,0,0,0,0,67,111,110,116,114,111,108,115,32,99,111,110,102,108,105,99,116,32,99,108,97,117,115,101,32,109,105,110,105,109,105,122,97,116,105,111,110,32,40,48,61,110,111,110,101,44,32,49,61,98,97,115,105,99,44,32,50,61,100,101,101,112,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,104,97,115,101,45,115,97,118,105,110,103,0,0,0,0,67,111,110,116,114,111,108,115,32,116,104,101,32,108,101,118,101,108,32,111,102,32,112,104,97,115,101,32,115,97,118,105,110,103,32,40,48,61,110,111,110,101,44,32,49,61,108,105,109,105,116,101,100,44,32,50,61,102,117,108,108,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,110,100,45,105,110,105,116,0,0,0,0,0,0,0,0,82,97,110,100,111,109,105,122,101,32,116,104,101,32,105,110,105,116,105,97,108,32,97,99,116,105,118,105,116,121,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,117,98,121,0,0,0,0,85,115,101,32,116,104,101,32,76,117,98,121,32,114,101,115,116,97,114,116,32,115,101,113,117,101,110,99,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,102,105,114,115,116,0,0,84,104,101,32,98,97,115,101,32,114,101,115,116,97,114,116,32,105,110,116,101,114,118,97,108,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,105,110,99,0,0,0,0,82,101,115,116,97,114,116,32,105,110,116,101,114,118,97,108,32,105,110,99,114,101,97,115,101,32,102,97,99,116,111,114,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,99,45,102,114,97,99,0,84,104,101,32,102,114,97,99,116,105,111,110,32,111,102,32,119,97,115,116,101,100,32,109,101,109,111,114,121,32,97,108,108,111,119,101,100,32,98,101,102,111,114,101,32,97,32,103,97,114,98,97,103,101,32,99,111,108,108,101,99,116,105,111,110,32,105,115,32,116,114,105,103,103,101,114,101,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,109,105,110,45,108,101,97,114,110,116,115,0,0,0,0,0,77,105,110,105,109,117,109,32,108,101,97,114,110,116,32,99,108,97,117,115,101,32,108,105,109,105,116,0,0,0,0,0,0,0,0,0,192,7,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,124,32,37,57,100,32,124,32,37,55,100,32,37,56,100,32,37,56,100,32,124,32,37,56,100,32,37,56,100,32,37,54,46,48,102,32,124,32,37,54,46,51,102,32,37,37,32,124,10,0,0,0,0,0,0,0,124,32,32,71,97,114,98,97,103,101,32,99,111,108,108,101,99,116,105,111,110,58,32,32,32,37,49,50,100,32,98,121,116,101,115,32,61,62,32,37,49,50,100,32,98,121,116,101,115,32,32,32,32,32,32,32,32,32,32,32,32,32,124,10,0,0,0,0,0,0,0,0,78,55,77,105,110,105,115,97,116,54,83,111,108,118,101,114,69,0,0,0,0,0,0,0,88,18,0,0,168,7,0,0,60,98,111,111,108,62,0,0,10,32,32,32,32,32,32,32,32,37,115,10,0,0,0,0,60,105,110,116,51,50,62,0,69,82,82,79,82,33,32,118,97,108,117,101,32,60,37,115,62,32,105,115,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,111,112,116,105,111,110,32,34,37,115,34,46,10,0,0,0,0,0,0,0,0,69,82,82,79,82,33,32,118,97,108,117,101,32,60,37,115,62,32,105,115,32,116,111,111,32,115,109,97,108,108,32,102,111,114,32,111,112,116,105,111,110,32,34,37,115,34,46,10,0,0,0,0,0,0,0,0,67,79,82,69,0,0,0,0,60,100,111,117,98,108,101,62,0,0,0,0,0,0,0,0,0,0,0,0,168,8,0,0,1,0,0,0,8,0,0,0,3,0,0,0,3,0,0,0,78,55,77,105,110,105,115,97,116,49,50,68,111,117,98,108,101,79,112,116,105,111,110,69,0,0,0,0,0,0,0,0,128,18,0,0,136,8,0,0,80,0,0,0,0,0,0,0,32,32,45,37,45,49,50,115,32,61,32,37,45,56,115,32,37,99,37,52,46,50,103,32,46,46,32,37,52,46,50,103,37,99,32,40,100,101,102,97,117,108,116,58,32,37,103,41,10,0,0,0,0,0,0,0,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,91,32,83,101,97,114,99,104,32,83,116,97,116,105,115,116,105,99,115,32,93,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,0,124,32,67,111,110,102,108,105,99,116,115,32,124,32,32,32,32,32,32,32,32,32,32,79,82,73,71,73,78,65,76,32,32,32,32,32,32,32,32,32,124,32,32,32,32,32,32,32,32,32,32,76,69,65,82,78,84,32,32,32,32,32,32,32,32,32,32,124,32,80,114,111,103,114,101,115,115,32,124,0,124,32,32,32,32,32,32,32,32,32,32,32,124,32,32,32,32,86,97,114,115,32,32,67,108,97,117,115,101,115,32,76,105,116,101,114,97,108,115,32,124,32,32,32,32,76,105,109,105,116,32,32,67,108,97,117,115,101,115,32,76,105,116,47,67,108,32,124,32,32,32,32,32,32,32,32,32,32,124,0,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,115,121,109,109,0,0,0,83,104,114,105,110,107,32,99,108,97,117,115,101,115,32,98,121,32,97,115,121,109,109,101,116,114,105,99,32,98,114,97,110,99,104,105,110,103,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,99,104,101,99,107,0,0,67,104,101,99,107,32,105,102,32,97,32,99,108,97,117,115,101,32,105,115,32,97,108,114,101,97,100,121,32,105,109,112,108,105,101,100,46,32,40,99,111,115,116,108,121,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,101,108,105,109,0,0,0,0,80,101,114,102,111,114,109,32,118,97,114,105,97,98,108,101,32,101,108,105,109,105,110,97,116,105,111,110,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,114,111,119,0,0,0,0,65,108,108,111,119,32,97,32,118,97,114,105,97,98,108,101,32,101,108,105,109,105,110,97,116,105,111,110,32,115,116,101,112,32,116,111,32,103,114,111,119,32,98,121,32,97,32,110,117,109,98,101,114,32,111,102,32,99,108,97,117,115,101,115,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,108,45,108,105,109,0,0,86,97,114,105,97,98,108,101,115,32,97,114,101,32,110,111,116,32,101,108,105,109,105,110,97,116,101,100,32,105,102,32,105,116,32,112,114,111,100,117,99,101,115,32,97,32,114,101,115,111,108,118,101,110,116,32,119,105,116,104,32,97,32,108,101,110,103,116,104,32,97,98,111,118,101,32,116,104,105,115,32,108,105,109,105,116,46,32,45,49,32,109,101,97,110,115,32,110,111,32,108,105,109,105,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,115,117,98,45,108,105,109,0,68,111,32,110,111,116,32,99,104,101,99,107,32,105,102,32,115,117,98,115,117,109,112,116,105,111,110,32,97,103,97,105,110,115,116,32,97,32,99,108,97,117,115,101,32,108,97,114,103,101,114,32,116,104,97,110,32,116,104,105,115,46,32,45,49,32,109,101,97,110,115,32,110,111,32,108,105,109,105,116,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,115,105,109,112,45,103,99,45,102,114,97,99,0,0,0,0,84,104,101,32,102,114,97,99,116,105,111,110,32,111,102,32,119,97,115,116,101,100,32,109,101,109,111,114,121,32,97,108,108,111,119,101,100,32,98,101,102,111,114,101,32,97,32,103,97,114,98,97,103,101,32,99,111,108,108,101,99,116,105,111,110,32,105,115,32,116,114,105,103,103,101,114,101,100,32,100,117,114,105,110,103,32,115,105,109,112,108,105,102,105,99,97,116,105,111,110,46,0,0,0,0,0,0,0,120,14,0,0,9,0,0,0,10,0,0,0,11,0,0,0,0,0,0,0,115,117,98,115,117,109,112,116,105,111,110,32,108,101,102,116,58,32,37,49,48,100,32,40,37,49,48,100,32,115,117,98,115,117,109,101,100,44,32,37,49,48,100,32,100,101,108,101,116,101,100,32,108,105,116,101,114,97,108,115,41,13,0,0,101,108,105,109,105,110,97,116,105,111,110,32,108,101,102,116,58,32,37,49,48,100,13,0,124,32,32,69,108,105,109,105,110,97,116,101,100,32,99,108,97,117,115,101,115,58,32,32,32,32,32,37,49,48,46,50,102,32,77,98,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,124,10,0,0,0,0,124,32,32,71,97,114,98,97,103,101,32,99,111,108,108,101,99,116,105,111,110,58,32,32,32,37,49,50,100,32,98,121,116,101,115,32,61,62,32,37,49,50,100,32,98,121,116,101,115,32,32,32,32,32,32,32,32,32,32,32,32,32,124,10,0,0,0,0,0,0,0,0,78,55,77,105,110,105,115,97,116,49,48,83,105,109,112,83,111,108,118,101,114,69,0,0,128,18,0,0,96,14,0,0,192,7,0,0,0,0,0,0,60,100,111,117,98,108,101,62,0,0,0,0,0,0,0,0,60,105,110,116,51,50,62,0,83,73,77,80,0,0,0,0,60,98,111,111,108,62,0,0,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,89,79,33,0,0,0,0,0,2,0,0,0,0,0,0,0,48,15,0,0,0,0,0,0,117,110,99,97,117,103,104,116,0,0,0,0,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,101,120,99,101,112,116,105,111,110,32,111,102,32,116,121,112,101,32,37,115,58,32,37,115,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,101,120,99,101,112,116,105,111,110,32,111,102,32,116,121,112,101,32,37,115,0,0,0,0,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,102,111,114,101,105,103,110,32,101,120,99,101,112,116,105,111,110,0,0,0,116,101,114,109,105,110,97,116,105,110,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,116,104,114,101,97,100,95,111,110,99,101,32,102,97,105,108,117,114,101,32,105,110,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,95,102,97,115,116,40,41,0,0,0,0,0,0,0,0,99,97,110,110,111,116,32,99,114,101,97,116,101,32,112,116,104,114,101,97,100,32,107,101,121,32,102,111,114,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,40,41,0,0,0,0,0,0,0,99,97,110,110,111,116,32,122,101,114,111,32,111,117,116,32,116,104,114,101,97,100,32,118,97,108,117,101,32,102,111,114,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,40,41,0,0,0,0,0,0,0,0,200,16,0,0,12,0,0,0,13,0,0,0,1,0,0,0,0,0,0,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,0,83,116,57,98,97,100,95,97,108,108,111,99,0,0,0,0,128,18,0,0,184,16,0,0,80,17,0,0,0,0,0,0,116,101,114,109,105,110,97,116,101,95,104,97,110,100,108,101,114,32,117,110,101,120,112,101,99,116,101,100,108,121,32,114,101,116,117,114,110,101,100,0,116,101,114,109,105,110,97,116,101,95,104,97,110,100,108,101,114,32,117,110,101,120,112,101,99,116,101,100,108,121,32,116,104,114,101,119,32,97,110,32,101,120,99,101,112,116,105,111,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,116,57,101,120,99,101,112,116,105,111,110,0,0,0,0,88,18,0,0,64,17,0,0,83,116,57,116,121,112,101,95,105,110,102,111,0,0,0,0,88,18,0,0,88,17,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,0,128,18,0,0,112,17,0,0,104,17,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,128,18,0,0,168,17,0,0,152,17,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,57,95,95,112,111,105,110,116,101,114,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,112,98,97,115,101,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,128,18,0,0,8,18,0,0,152,17,0,0,0,0,0,0,128,18,0,0,224,17,0,0,48,18,0,0,0,0,0,0,0,0,0,0,208,17,0,0,14,0,0,0,15,0,0,0,16,0,0,0,17,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,200,18,0,0,14,0,0,0,18,0,0,0,16,0,0,0,17,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,128,18,0,0,160,18,0,0,208,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,1,2,3,4,5,6,7,8,9,255,255,255,255,255,255,255,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,255,255,255,255,255,255,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,1,2,4,7,3,6,5,0,0,0,0,0,0,0,0,105,110,102,105,110,105,116,121,0,0,0,0,0,0,0,0,110,97,110,0,0,0,0,0,95,112,137,0,255,9,47,15,10,0,0,0,100,0,0,0,232,3,0,0,16,39,0,0,160,134,1,0,64,66,15,0,128,150,152,0,0,225,245,5],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE);var tempDoublePtr=Runtime.alignMemory(allocate(12,"i8",ALLOC_STATIC),8);assert(tempDoublePtr%8==0);function copyTempFloat(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3]}function copyTempDouble(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3];HEAP8[tempDoublePtr+4]=HEAP8[ptr+4];HEAP8[tempDoublePtr+5]=HEAP8[ptr+5];HEAP8[tempDoublePtr+6]=HEAP8[ptr+6];HEAP8[tempDoublePtr+7]=HEAP8[ptr+7]}function _atexit(func,arg){__ATEXIT__.unshift({func:func,arg:arg})}function ___cxa_atexit(){return _atexit.apply(null,arguments)}Module["_i64Subtract"]=_i64Subtract;var ___errno_state=0;function ___setErrNo(value){HEAP32[___errno_state>>2]=value;return value}var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function _sysconf(name){switch(name){case 30:return PAGE_SIZE;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 79:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:{if(typeof navigator==="object")return navigator["hardwareConcurrency"]||1;return 1}}___setErrNo(ERRNO_CODES.EINVAL);return-1}function __ZSt18uncaught_exceptionv(){return!!__ZSt18uncaught_exceptionv.uncaught_exception}var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:(function(adjusted){if(!adjusted||EXCEPTIONS.infos[adjusted])return adjusted;for(var ptr in EXCEPTIONS.infos){var info=EXCEPTIONS.infos[ptr];if(info.adjusted===adjusted){return ptr}}return adjusted}),addRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount++}),decRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];assert(info.refcount>0);info.refcount--;if(info.refcount===0){if(info.destructor){Runtime.dynCall("vi",info.destructor,[ptr])}delete EXCEPTIONS.infos[ptr];___cxa_free_exception(ptr)}}),clearRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount=0})};function ___resumeException(ptr){if(!EXCEPTIONS.last){EXCEPTIONS.last=ptr}EXCEPTIONS.clearRef(EXCEPTIONS.deAdjust(ptr));throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}function ___cxa_find_matching_catch(){var thrown=EXCEPTIONS.last;if(!thrown){return(asm["setTempRet0"](0),0)|0}var info=EXCEPTIONS.infos[thrown];var throwntype=info.type;if(!throwntype){return(asm["setTempRet0"](0),thrown)|0}var typeArray=Array.prototype.slice.call(arguments);var pointer=Module["___cxa_is_pointer_type"](throwntype);if(!___cxa_find_matching_catch.buffer)___cxa_find_matching_catch.buffer=_malloc(4);HEAP32[___cxa_find_matching_catch.buffer>>2]=thrown;thrown=___cxa_find_matching_catch.buffer;for(var i=0;i<typeArray.length;i++){if(typeArray[i]&&Module["___cxa_can_catch"](typeArray[i],throwntype,thrown)){thrown=HEAP32[thrown>>2];info.adjusted=thrown;return(asm["setTempRet0"](typeArray[i]),thrown)|0}}thrown=HEAP32[thrown>>2];return(asm["setTempRet0"](throwntype),thrown)|0}function ___cxa_throw(ptr,type,destructor){EXCEPTIONS.infos[ptr]={ptr:ptr,adjusted:ptr,type:type,destructor:destructor,refcount:0};EXCEPTIONS.last=ptr;if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exception=1}else{__ZSt18uncaught_exceptionv.uncaught_exception++}throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}Module["_memset"]=_memset;Module["_bitshift64Shl"]=_bitshift64Shl;function _abort(){Module["abort"]()}var FS=undefined;var SOCKFS=undefined;function _send(fd,buf,len,flags){var sock=SOCKFS.getSocket(fd);if(!sock){___setErrNo(ERRNO_CODES.EBADF);return-1}return _write(fd,buf,len)}function _pwrite(fildes,buf,nbyte,offset){var stream=FS.getStream(fildes);if(!stream){___setErrNo(ERRNO_CODES.EBADF);return-1}try{var slab=HEAP8;return FS.write(stream,slab,buf,nbyte,offset)}catch(e){FS.handleFSError(e);return-1}}function _write(fildes,buf,nbyte){var stream=FS.getStream(fildes);if(!stream){___setErrNo(ERRNO_CODES.EBADF);return-1}try{var slab=HEAP8;return FS.write(stream,slab,buf,nbyte)}catch(e){FS.handleFSError(e);return-1}}function _fileno(stream){stream=FS.getStreamFromPtr(stream);if(!stream)return-1;return stream.fd}function _fwrite(ptr,size,nitems,stream){var bytesToWrite=nitems*size;if(bytesToWrite==0)return 0;var fd=_fileno(stream);var bytesWritten=_write(fd,ptr,bytesToWrite);if(bytesWritten==-1){var streamObj=FS.getStreamFromPtr(stream);if(streamObj)streamObj.error=true;return 0}else{return bytesWritten/size|0}}Module["_strlen"]=_strlen;function __reallyNegative(x){return x<0||x===0&&1/x===-Infinity}function __formatString(format,varargs){var textIndex=format;var argIndex=0;function getNextArg(type){var ret;if(type==="double"){ret=(HEAP32[tempDoublePtr>>2]=HEAP32[varargs+argIndex>>2],HEAP32[tempDoublePtr+4>>2]=HEAP32[varargs+(argIndex+4)>>2],+HEAPF64[tempDoublePtr>>3])}else if(type=="i64"){ret=[HEAP32[varargs+argIndex>>2],HEAP32[varargs+(argIndex+4)>>2]]}else{type="i32";ret=HEAP32[varargs+argIndex>>2]}argIndex+=Runtime.getNativeFieldSize(type);return ret}var ret=[];var curr,next,currArg;while(1){var startTextIndex=textIndex;curr=HEAP8[textIndex>>0];if(curr===0)break;next=HEAP8[textIndex+1>>0];if(curr==37){var flagAlwaysSigned=false;var flagLeftAlign=false;var flagAlternative=false;var flagZeroPad=false;var flagPadSign=false;flagsLoop:while(1){switch(next){case 43:flagAlwaysSigned=true;break;case 45:flagLeftAlign=true;break;case 35:flagAlternative=true;break;case 48:if(flagZeroPad){break flagsLoop}else{flagZeroPad=true;break};case 32:flagPadSign=true;break;default:break flagsLoop}textIndex++;next=HEAP8[textIndex+1>>0]}var width=0;if(next==42){width=getNextArg("i32");textIndex++;next=HEAP8[textIndex+1>>0]}else{while(next>=48&&next<=57){width=width*10+(next-48);textIndex++;next=HEAP8[textIndex+1>>0]}}var precisionSet=false,precision=-1;if(next==46){precision=0;precisionSet=true;textIndex++;next=HEAP8[textIndex+1>>0];if(next==42){precision=getNextArg("i32");textIndex++}else{while(1){var precisionChr=HEAP8[textIndex+1>>0];if(precisionChr<48||precisionChr>57)break;precision=precision*10+(precisionChr-48);textIndex++}}next=HEAP8[textIndex+1>>0]}if(precision<0){precision=6;precisionSet=false}var argSize;switch(String.fromCharCode(next)){case"h":var nextNext=HEAP8[textIndex+2>>0];if(nextNext==104){textIndex++;argSize=1}else{argSize=2}break;case"l":var nextNext=HEAP8[textIndex+2>>0];if(nextNext==108){textIndex++;argSize=8}else{argSize=4}break;case"L":case"q":case"j":argSize=8;break;case"z":case"t":case"I":argSize=4;break;default:argSize=null}if(argSize)textIndex++;next=HEAP8[textIndex+1>>0];switch(String.fromCharCode(next)){case"d":case"i":case"u":case"o":case"x":case"X":case"p":{var signed=next==100||next==105;argSize=argSize||4;var currArg=getNextArg("i"+argSize*8);var origArg=currArg;var argText;if(argSize==8){currArg=Runtime.makeBigInt(currArg[0],currArg[1],next==117)}if(argSize<=4){var limit=Math.pow(256,argSize)-1;currArg=(signed?reSign:unSign)(currArg&limit,argSize*8)}var currAbsArg=Math.abs(currArg);var prefix="";if(next==100||next==105){if(argSize==8&&i64Math)argText=i64Math.stringify(origArg[0],origArg[1],null);else argText=reSign(currArg,8*argSize,1).toString(10)}else if(next==117){if(argSize==8&&i64Math)argText=i64Math.stringify(origArg[0],origArg[1],true);else argText=unSign(currArg,8*argSize,1).toString(10);currArg=Math.abs(currArg)}else if(next==111){argText=(flagAlternative?"0":"")+currAbsArg.toString(8)}else if(next==120||next==88){prefix=flagAlternative&&currArg!=0?"0x":"";if(argSize==8&&i64Math){if(origArg[1]){argText=(origArg[1]>>>0).toString(16);var lower=(origArg[0]>>>0).toString(16);while(lower.length<8)lower="0"+lower;argText+=lower}else{argText=(origArg[0]>>>0).toString(16)}}else if(currArg<0){currArg=-currArg;argText=(currAbsArg-1).toString(16);var buffer=[];for(var i=0;i<argText.length;i++){buffer.push((15-parseInt(argText[i],16)).toString(16))}argText=buffer.join("");while(argText.length<argSize*2)argText="f"+argText}else{argText=currAbsArg.toString(16)}if(next==88){prefix=prefix.toUpperCase();argText=argText.toUpperCase()}}else if(next==112){if(currAbsArg===0){argText="(nil)"}else{prefix="0x";argText=currAbsArg.toString(16)}}if(precisionSet){while(argText.length<precision){argText="0"+argText}}if(currArg>=0){if(flagAlwaysSigned){prefix="+"+prefix}else if(flagPadSign){prefix=" "+prefix}}if(argText.charAt(0)=="-"){prefix="-"+prefix;argText=argText.substr(1)}while(prefix.length+argText.length<width){if(flagLeftAlign){argText+=" "}else{if(flagZeroPad){argText="0"+argText}else{prefix=" "+prefix}}}argText=prefix+argText;argText.split("").forEach((function(chr){ret.push(chr.charCodeAt(0))}));break};case"f":case"F":case"e":case"E":case"g":case"G":{var currArg=getNextArg("double");var argText;if(isNaN(currArg)){argText="nan";flagZeroPad=false}else if(!isFinite(currArg)){argText=(currArg<0?"-":"")+"inf";flagZeroPad=false}else{var isGeneral=false;var effectivePrecision=Math.min(precision,20);if(next==103||next==71){isGeneral=true;precision=precision||1;var exponent=parseInt(currArg.toExponential(effectivePrecision).split("e")[1],10);if(precision>exponent&&exponent>=-4){next=(next==103?"f":"F").charCodeAt(0);precision-=exponent+1}else{next=(next==103?"e":"E").charCodeAt(0);precision--}effectivePrecision=Math.min(precision,20)}if(next==101||next==69){argText=currArg.toExponential(effectivePrecision);if(/[eE][-+]\d$/.test(argText)){argText=argText.slice(0,-1)+"0"+argText.slice(-1)}}else if(next==102||next==70){argText=currArg.toFixed(effectivePrecision);if(currArg===0&&__reallyNegative(currArg)){argText="-"+argText}}var parts=argText.split("e");if(isGeneral&&!flagAlternative){while(parts[0].length>1&&parts[0].indexOf(".")!=-1&&(parts[0].slice(-1)=="0"||parts[0].slice(-1)==".")){parts[0]=parts[0].slice(0,-1)}}else{if(flagAlternative&&argText.indexOf(".")==-1)parts[0]+=".";while(precision>effectivePrecision++)parts[0]+="0"}argText=parts[0]+(parts.length>1?"e"+parts[1]:"");if(next==69)argText=argText.toUpperCase();if(currArg>=0){if(flagAlwaysSigned){argText="+"+argText}else if(flagPadSign){argText=" "+argText}}}while(argText.length<width){if(flagLeftAlign){argText+=" "}else{if(flagZeroPad&&(argText[0]=="-"||argText[0]=="+")){argText=argText[0]+"0"+argText.slice(1)}else{argText=(flagZeroPad?"0":" ")+argText}}}if(next<97)argText=argText.toUpperCase();argText.split("").forEach((function(chr){ret.push(chr.charCodeAt(0))}));break};case"s":{var arg=getNextArg("i8*");var argLength=arg?_strlen(arg):"(null)".length;if(precisionSet)argLength=Math.min(argLength,precision);if(!flagLeftAlign){while(argLength<width--){ret.push(32)}}if(arg){for(var i=0;i<argLength;i++){ret.push(HEAPU8[arg++>>0])}}else{ret=ret.concat(intArrayFromString("(null)".substr(0,argLength),true))}if(flagLeftAlign){while(argLength<width--){ret.push(32)}}break};case"c":{if(flagLeftAlign)ret.push(getNextArg("i8"));while(--width>0){ret.push(32)}if(!flagLeftAlign)ret.push(getNextArg("i8"));break};case"n":{var ptr=getNextArg("i32*");HEAP32[ptr>>2]=ret.length;break};case"%":{ret.push(curr);break};default:{for(var i=startTextIndex;i<textIndex+2;i++){ret.push(HEAP8[i>>0])}}}textIndex+=2}else{ret.push(curr);textIndex+=1}}return ret}function _fprintf(stream,format,varargs){var result=__formatString(format,varargs);var stack=Runtime.stackSave();var ret=_fwrite(allocate(result,"i8",ALLOC_STACK),1,result.length,stream);Runtime.stackRestore(stack);return ret}function _printf(format,varargs){var result=__formatString(format,varargs);var string=intArrayToString(result);if(string[string.length-1]==="\n")string=string.substr(0,string.length-1);Module.print(string);return result.length}function _pthread_once(ptr,func){if(!_pthread_once.seen)_pthread_once.seen={};if(ptr in _pthread_once.seen)return;Runtime.dynCall("v",func);_pthread_once.seen[ptr]=1}function _fputc(c,stream){var chr=unSign(c&255);HEAP8[_fputc.ret>>0]=chr;var fd=_fileno(stream);var ret=_write(fd,_fputc.ret,1);if(ret==-1){var streamObj=FS.getStreamFromPtr(stream);if(streamObj)streamObj.error=true;return-1}else{return chr}}var PTHREAD_SPECIFIC={};function _pthread_getspecific(key){return PTHREAD_SPECIFIC[key]||0}Module["_i64Add"]=_i64Add;function _fputs(s,stream){var fd=_fileno(stream);return _write(fd,s,_strlen(s))}var _stdout=allocate(1,"i32*",ALLOC_STATIC);function _puts(s){var result=Pointer_stringify(s);var string=result.substr(0);if(string[string.length-1]==="\n")string=string.substr(0,string.length-1);Module.print(string);return result.length}function _pthread_setspecific(key,value){if(!(key in PTHREAD_SPECIFIC)){return ERRNO_CODES.EINVAL}PTHREAD_SPECIFIC[key]=value;return 0}function __exit(status){Module["exit"](status)}function _exit(status){__exit(status)}var _UItoD=true;function _malloc(bytes){var ptr=Runtime.dynamicAlloc(bytes+8);return ptr+8&4294967288}Module["_malloc"]=_malloc;function ___cxa_allocate_exception(size){return _malloc(size)}function _fmod(x,y){return x%y}function _fmodl(){return _fmod.apply(null,arguments)}Module["_bitshift64Lshr"]=_bitshift64Lshr;function ___cxa_pure_virtual(){ABORT=true;throw"Pure virtual function called!"}function _time(ptr){var ret=Date.now()/1e3|0;if(ptr){HEAP32[ptr>>2]=ret}return ret}var PTHREAD_SPECIFIC_NEXT_KEY=1;function _pthread_key_create(key,destructor){if(key==0){return ERRNO_CODES.EINVAL}HEAP32[key>>2]=PTHREAD_SPECIFIC_NEXT_KEY;PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY]=0;PTHREAD_SPECIFIC_NEXT_KEY++;return 0}function ___cxa_guard_acquire(variable){if(!HEAP8[variable>>0]){HEAP8[variable>>0]=1;return 1}return 0}function ___cxa_guard_release(){}function _vfprintf(s,f,va_arg){return _fprintf(s,f,HEAP32[va_arg>>2])}function ___cxa_begin_catch(ptr){__ZSt18uncaught_exceptionv.uncaught_exception--;EXCEPTIONS.caught.push(ptr);EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));return ptr}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}Module["_memcpy"]=_memcpy;var _llvm_pow_f64=Math_pow;function _sbrk(bytes){var self=_sbrk;if(!self.called){DYNAMICTOP=alignMemoryPage(DYNAMICTOP);self.called=true;assert(Runtime.dynamicAlloc);self.alloc=Runtime.dynamicAlloc;Runtime.dynamicAlloc=(function(){abort("cannot dynamically allocate, sbrk now has control")})}var ret=DYNAMICTOP;if(bytes!=0)self.alloc(bytes);return ret}var _fabs=Math_abs;function ___errno_location(){return ___errno_state}var _BItoD=true;function _copysign(a,b){return __reallyNegative(a)===__reallyNegative(b)?a:-a}function _copysignl(){return _copysign.apply(null,arguments)}var ___dso_handle=allocate(1,"i32*",ALLOC_STATIC);var _stderr=allocate(1,"i32*",ALLOC_STATIC);___errno_state=Runtime.staticAlloc(4);HEAP32[___errno_state>>2]=0;_fputc.ret=allocate([0],"i8",ALLOC_STATIC);STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);staticSealed=true;STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=DYNAMICTOP=Runtime.alignMemory(STACK_MAX);assert(DYNAMIC_BASE<TOTAL_MEMORY,"TOTAL_MEMORY not big enough for stack");var ctlz_i8=allocate([8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"i8",ALLOC_DYNAMIC);var cttz_i8=allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],"i8",ALLOC_DYNAMIC);function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viiiii(index,a1,a2,a3,a4,a5){try{Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_vi(index,a1){try{Module["dynCall_vi"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_vii(index,a1,a2){try{Module["dynCall_vii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_v(index){try{Module["dynCall_v"](index)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){try{Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_iii(index,a1,a2){try{return Module["dynCall_iii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viiii(index,a1,a2,a3,a4){try{Module["dynCall_viiii"](index,a1,a2,a3,a4)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}Module.asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array};Module.asmLibraryArg={"abort":abort,"assert":assert,"min":Math_min,"invoke_iiii":invoke_iiii,"invoke_viiiii":invoke_viiiii,"invoke_vi":invoke_vi,"invoke_vii":invoke_vii,"invoke_ii":invoke_ii,"invoke_v":invoke_v,"invoke_viiiiii":invoke_viiiiii,"invoke_iii":invoke_iii,"invoke_viiii":invoke_viiii,"_fabs":_fabs,"_llvm_pow_f64":_llvm_pow_f64,"_send":_send,"_fmod":_fmod,"___cxa_guard_acquire":___cxa_guard_acquire,"___setErrNo":___setErrNo,"_vfprintf":_vfprintf,"___cxa_allocate_exception":___cxa_allocate_exception,"___cxa_find_matching_catch":___cxa_find_matching_catch,"___cxa_guard_release":___cxa_guard_release,"_pwrite":_pwrite,"__reallyNegative":__reallyNegative,"_sbrk":_sbrk,"___cxa_begin_catch":___cxa_begin_catch,"_emscripten_memcpy_big":_emscripten_memcpy_big,"_fileno":_fileno,"___resumeException":___resumeException,"__ZSt18uncaught_exceptionv":__ZSt18uncaught_exceptionv,"_sysconf":_sysconf,"_pthread_getspecific":_pthread_getspecific,"_atexit":_atexit,"_pthread_once":_pthread_once,"_puts":_puts,"_printf":_printf,"_pthread_key_create":_pthread_key_create,"_write":_write,"___errno_location":___errno_location,"_pthread_setspecific":_pthread_setspecific,"___cxa_atexit":___cxa_atexit,"_copysign":_copysign,"_fputc":_fputc,"___cxa_throw":___cxa_throw,"__exit":__exit,"_copysignl":_copysignl,"_abort":_abort,"_fwrite":_fwrite,"_time":_time,"_fprintf":_fprintf,"__formatString":__formatString,"_fputs":_fputs,"_exit":_exit,"___cxa_pure_virtual":___cxa_pure_virtual,"_fmodl":_fmodl,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"cttz_i8":cttz_i8,"ctlz_i8":ctlz_i8,"NaN":NaN,"Infinity":Infinity,"___dso_handle":___dso_handle,"_stderr":_stderr};// EMSCRIPTEN_START_ASM
var asm=(function(global,env,buffer) {
"use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.STACKTOP|0;var j=env.STACK_MAX|0;var k=env.tempDoublePtr|0;var l=env.ABORT|0;var m=env.cttz_i8|0;var n=env.ctlz_i8|0;var o=env.___dso_handle|0;var p=env._stderr|0;var q=0;var r=0;var s=0;var t=0;var u=+env.NaN,v=+env.Infinity;var w=0,x=0,y=0,z=0,A=0.0,B=0,C=0,D=0,E=0.0;var F=0;var G=0;var H=0;var I=0;var J=0;var K=0;var L=0;var M=0;var N=0;var O=0;var P=global.Math.floor;var Q=global.Math.abs;var R=global.Math.sqrt;var S=global.Math.pow;var T=global.Math.cos;var U=global.Math.sin;var V=global.Math.tan;var W=global.Math.acos;var X=global.Math.asin;var Y=global.Math.atan;var Z=global.Math.atan2;var _=global.Math.exp;var $=global.Math.log;var aa=global.Math.ceil;var ba=global.Math.imul;var ca=env.abort;var da=env.assert;var ea=env.min;var fa=env.invoke_iiii;var ga=env.invoke_viiiii;var ha=env.invoke_vi;var ia=env.invoke_vii;var ja=env.invoke_ii;var ka=env.invoke_v;var la=env.invoke_viiiiii;var ma=env.invoke_iii;var na=env.invoke_viiii;var oa=env._fabs;var pa=env._llvm_pow_f64;var qa=env._send;var ra=env._fmod;var sa=env.___cxa_guard_acquire;var ta=env.___setErrNo;var ua=env._vfprintf;var va=env.___cxa_allocate_exception;var wa=env.___cxa_find_matching_catch;var xa=env.___cxa_guard_release;var ya=env._pwrite;var za=env.__reallyNegative;var Aa=env._sbrk;var Ba=env.___cxa_begin_catch;var Ca=env._emscripten_memcpy_big;var Da=env._fileno;var Ea=env.___resumeException;var Fa=env.__ZSt18uncaught_exceptionv;var Ga=env._sysconf;var Ha=env._pthread_getspecific;var Ia=env._atexit;var Ja=env._pthread_once;var Ka=env._puts;var La=env._printf;var Ma=env._pthread_key_create;var Na=env._write;var Oa=env.___errno_location;var Pa=env._pthread_setspecific;var Qa=env.___cxa_atexit;var Ra=env._copysign;var Sa=env._fputc;var Ta=env.___cxa_throw;var Ua=env.__exit;var Va=env._copysignl;var Wa=env._abort;var Xa=env._fwrite;var Ya=env._time;var Za=env._fprintf;var _a=env.__formatString;var $a=env._fputs;var ab=env._exit;var bb=env.___cxa_pure_virtual;var cb=env._fmodl;var db=0.0;
// EMSCRIPTEN_START_FUNCS
function nb(a){a=a|0;var b=0;b=i;i=i+a|0;i=i+15&-16;return b|0}function ob(){return i|0}function pb(a){a=a|0;i=a}function qb(a,b){a=a|0;b=b|0;if(!q){q=a;r=b}}function rb(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0]}function sb(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0];a[k+4>>0]=a[b+4>>0];a[k+5>>0]=a[b+5>>0];a[k+6>>0]=a[b+6>>0];a[k+7>>0]=a[b+7>>0]}function tb(a){a=a|0;F=a}function ub(){return F|0}function vb(a){a=a|0;Ba(a|0)|0;ud()}function wb(a){a=a|0;return}function xb(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;h=i;c[b>>2]=112;c[b+4>>2]=d;c[b+8>>2]=e;c[b+12>>2]=f;c[b+16>>2]=g;if((a[144]|0)==0?(sa(144)|0)!=0:0){c[32]=0;c[33]=0;c[34]=0;Qa(19,128,o|0)|0;xa(144)}g=c[33]|0;if((g|0)==(c[34]|0)){f=(g>>1)+2&-2;f=(f|0)<2?2:f;if((f|0)>(2147483647-g|0)){d=va(1)|0;Ta(d|0,48,0)}e=c[32]|0;d=f+g|0;c[34]=d;d=Ud(e,d<<2)|0;c[32]=d;if((d|0)==0?(c[(Oa()|0)>>2]|0)==12:0){d=va(1)|0;Ta(d|0,48,0)}g=c[33]|0}c[33]=g+1;g=(c[32]|0)+(g<<2)|0;if(!g){i=h;return}c[g>>2]=b;i=h;return}function yb(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function zb(a){a=a|0;var b=0,d=0;b=i;d=c[a>>2]|0;if(!d){i=b;return}c[a+4>>2]=0;Td(d);c[a>>2]=0;c[a+8>>2]=0;i=b;return}function Ab(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function Bb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;if((a[d>>0]|0)!=45){k=0;i=e;return k|0}f=d+1|0;g=110;j=f;k=0;while(1){h=k+1|0;if((a[j>>0]|0)!=g<<24>>24){g=1;break}j=d+(k+2)|0;if((h|0)==3){g=0;f=j;break}else{g=a[264+h>>0]|0;k=h}}if(ee(f,c[b+4>>2]|0)|0){k=0;i=e;return k|0}a[b+20>>0]=g;k=1;i=e;return k|0}function Cb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0;h=i;i=i+16|0;e=h;f=c[p>>2]|0;g=b+4|0;j=c[g>>2]|0;c[e>>2]=j;c[e+4>>2]=j;Za(f|0,216,e|0)|0;j=0;while(1){k=j>>>0<(32-((me(c[g>>2]|0)|0)<<1)|0)>>>0;Sa(32,f|0)|0;if(k)j=j+1|0;else break}c[e>>2]=(a[b+20>>0]|0)!=0?248:256;Za(f|0,232,e|0)|0;if(!d){i=h;return}c[e>>2]=c[b+8>>2];Za(f|0,88,e|0)|0;Sa(10,f|0)|0;i=h;return}function Db(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function Eb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;e=i;i=i+16|0;h=e;g=e+8|0;if((a[d>>0]|0)!=45){n=0;i=e;return n|0}l=d+1|0;f=b+4|0;j=c[f>>2]|0;k=a[j>>0]|0;a:do if(k<<24>>24){m=0;while(1){n=m;m=m+1|0;if((a[l>>0]|0)!=k<<24>>24){b=0;break}k=a[j+m>>0]|0;l=d+(n+2)|0;if(!(k<<24>>24))break a}i=e;return b|0}while(0);if((a[l>>0]|0)!=61){n=0;i=e;return n|0}d=l+1|0;j=de(d,g,10)|0;if(!(c[g>>2]|0)){n=0;i=e;return n|0}if((j|0)>(c[b+24>>2]|0)){n=c[p>>2]|0;m=c[f>>2]|0;c[h>>2]=d;c[h+4>>2]=m;Za(n|0,416,h|0)|0;ab(1)}if((j|0)<(c[b+20>>2]|0)){n=c[p>>2]|0;m=c[f>>2]|0;c[h>>2]=d;c[h+4>>2]=m;Za(n|0,472,h|0)|0;ab(1)}c[b+28>>2]=j;n=1;i=e;return n|0}function Fb(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;i=i+16|0;e=d;f=c[p>>2]|0;g=c[a+16>>2]|0;c[e>>2]=c[a+4>>2];c[e+4>>2]=g;Za(f|0,336,e|0)|0;g=c[a+20>>2]|0;if((g|0)==-2147483648)Xa(360,4,1,f|0)|0;else{c[e>>2]=g;Za(f|0,368,e|0)|0}Xa(376,4,1,f|0)|0;g=c[a+24>>2]|0;if((g|0)==2147483647)Xa(384,4,1,f|0)|0;else{c[e>>2]=g;Za(f|0,368,e|0)|0}c[e>>2]=c[a+28>>2];Za(f|0,392,e|0)|0;if(!b){i=d;return}c[e>>2]=c[a+8>>2];Za(f|0,88,e|0)|0;Sa(10,f|0)|0;i=d;return}function Gb(b){b=b|0;var d=0,e=0,f=0,g=0,j=0;g=i;c[b>>2]=1816;f=b+4|0;e=b+32|0;j=b+48|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;c[f+20>>2]=0;c[e+0>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;h[j>>3]=+h[75];h[b+56>>3]=+h[89];h[b+64>>3]=+h[103];h[b+72>>3]=+h[123];a[b+80>>0]=a[1364]|0;c[b+84>>2]=c[269];c[b+88>>2]=c[297];a[b+92>>0]=0;a[b+93>>0]=a[1292]|0;h[b+96>>3]=+h[204];c[b+104>>2]=c[439];c[b+108>>2]=c[359];h[b+112>>3]=+h[191];h[b+120>>3]=.3333333333333333;h[b+128>>3]=1.1;c[b+136>>2]=100;h[b+144>>3]=1.5;j=b+316|0;c[b+332>>2]=0;c[b+336>>2]=0;c[b+340>>2]=0;c[b+348>>2]=0;c[b+352>>2]=0;c[b+356>>2]=0;c[b+364>>2]=0;c[b+368>>2]=0;c[b+372>>2]=0;c[b+380>>2]=0;c[b+384>>2]=0;c[b+388>>2]=0;c[b+396>>2]=0;c[b+400>>2]=0;c[b+404>>2]=0;e=b+544|0;c[b+412>>2]=0;c[b+416>>2]=0;c[b+420>>2]=0;c[b+428>>2]=0;c[b+432>>2]=0;c[b+436>>2]=0;c[b+444>>2]=0;c[b+448>>2]=0;c[b+452>>2]=0;ke(b+152|0,0,176)|0;c[b+456>>2]=e;f=b+460|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;c[f+20>>2]=0;c[b+488>>2]=j;a[b+492>>0]=1;h[b+496>>3]=1.0;h[b+504>>3]=1.0;c[b+512>>2]=0;c[b+516>>2]=-1;j=b+520|0;f=b+536|0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;a[f>>0]=1;f=b+540|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;gc(e,1048576);a[b+560>>0]=0;e=b+604|0;f=b+664|0;j=b+564|0;d=j+36|0;do{c[j>>2]=0;j=j+4|0}while((j|0)<(d|0));j=e+0|0;d=j+36|0;do{c[j>>2]=0;j=j+4|0}while((j|0)<(d|0));j=b+680|0;c[f+0>>2]=-1;c[f+4>>2]=-1;c[f+8>>2]=-1;c[f+12>>2]=-1;a[j>>0]=0;i=g;return}function Hb(a){a=a|0;var b=0;b=i;Ib(a);pd(a);i=b;return}function Ib(a){a=a|0;var b=0,d=0,e=0;b=i;c[a>>2]=1816;d=a+628|0;e=c[d>>2]|0;if(e){c[a+632>>2]=0;Td(e);c[d>>2]=0;c[a+636>>2]=0}d=a+616|0;e=c[d>>2]|0;if(e){c[a+620>>2]=0;Td(e);c[d>>2]=0;c[a+624>>2]=0}d=a+604|0;e=c[d>>2]|0;if(e){c[a+608>>2]=0;Td(e);c[d>>2]=0;c[a+612>>2]=0}d=a+588|0;e=c[d>>2]|0;if(e){c[a+592>>2]=0;Td(e);c[d>>2]=0;c[a+596>>2]=0}d=a+576|0;e=c[d>>2]|0;if(e){c[a+580>>2]=0;Td(e);c[d>>2]=0;c[a+584>>2]=0}d=a+564|0;e=c[d>>2]|0;if(e){c[a+568>>2]=0;Td(e);c[d>>2]=0;c[a+572>>2]=0}d=c[a+544>>2]|0;if(d)Td(d);d=a+472|0;e=c[d>>2]|0;if(e){c[a+476>>2]=0;Td(e);c[d>>2]=0;c[a+480>>2]=0}d=a+460|0;e=c[d>>2]|0;if(e){c[a+464>>2]=0;Td(e);c[d>>2]=0;c[a+468>>2]=0}hc(a+412|0);d=a+396|0;e=c[d>>2]|0;if(e){c[a+400>>2]=0;Td(e);c[d>>2]=0;c[a+404>>2]=0}d=a+380|0;e=c[d>>2]|0;if(e){c[a+384>>2]=0;Td(e);c[d>>2]=0;c[a+388>>2]=0}e=a+364|0;d=c[e>>2]|0;if(d){c[a+368>>2]=0;Td(d);c[e>>2]=0;c[a+372>>2]=0}d=a+348|0;e=c[d>>2]|0;if(e){c[a+352>>2]=0;Td(e);c[d>>2]=0;c[a+356>>2]=0}d=a+332|0;e=c[d>>2]|0;if(e){c[a+336>>2]=0;Td(e);c[d>>2]=0;c[a+340>>2]=0}d=a+316|0;e=c[d>>2]|0;if(e){c[a+320>>2]=0;Td(e);c[d>>2]=0;c[a+324>>2]=0}d=a+304|0;e=c[d>>2]|0;if(e){c[a+308>>2]=0;Td(e);c[d>>2]=0;c[a+312>>2]=0}d=a+292|0;e=c[d>>2]|0;if(e){c[a+296>>2]=0;Td(e);c[d>>2]=0;c[a+300>>2]=0}d=a+280|0;e=c[d>>2]|0;if(e){c[a+284>>2]=0;Td(e);c[d>>2]=0;c[a+288>>2]=0}d=a+268|0;e=c[d>>2]|0;if(e){c[a+272>>2]=0;Td(e);c[d>>2]=0;c[a+276>>2]=0}d=a+256|0;e=c[d>>2]|0;if(e){c[a+260>>2]=0;Td(e);c[d>>2]=0;c[a+264>>2]=0}d=a+32|0;e=c[d>>2]|0;if(e){c[a+36>>2]=0;Td(e);c[d>>2]=0;c[a+40>>2]=0}d=a+16|0;e=c[d>>2]|0;if(e){c[a+20>>2]=0;Td(e);c[d>>2]=0;c[a+24>>2]=0}e=a+4|0;d=c[e>>2]|0;if(!d){i=b;return}c[a+8>>2]=0;Td(d);c[e>>2]=0;c[a+12>>2]=0;i=b;return}function Jb(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,j=0,k=0,l=0.0,m=0,n=0,o=0,p=0,q=0,r=0;f=i;i=i+16|0;k=f+4|0;j=f;g=b+580|0;m=c[g>>2]|0;if((m|0)>0){o=m+ -1|0;p=c[(c[b+576>>2]|0)+(o<<2)>>2]|0;c[g>>2]=o;g=p}else{p=b+540|0;g=c[p>>2]|0;c[p>>2]=g+1}m=b+412|0;p=g<<1;c[k>>2]=p;ic(m,k);c[j>>2]=p|1;ic(m,j);k=b+332|0;m=a[544]|0;j=g+1|0;jc(k,j);a[(c[k>>2]|0)+g>>0]=m;k=b+396|0;m=b+400|0;if((c[m>>2]|0)<(j|0)){o=b+404|0;p=c[o>>2]|0;if((p|0)<(j|0)){q=g+2-p&-2;n=(p>>1)+2&-2;n=(q|0)>(n|0)?q:n;if((n|0)>(2147483647-p|0)){q=va(1)|0;Ta(q|0,48,0)}r=c[k>>2]|0;q=n+p|0;c[o>>2]=q;q=Ud(r,q<<3)|0;c[k>>2]=q;if((q|0)==0?(c[(Oa()|0)>>2]|0)==12:0){r=va(1)|0;Ta(r|0,48,0)}}o=c[m>>2]|0;if((o|0)<(j|0))do{n=(c[k>>2]|0)+(o<<3)|0;if(n){r=n;c[r>>2]=0;c[r+4>>2]=0}o=o+1|0}while((o|0)!=(j|0));c[m>>2]=j}m=(c[k>>2]|0)+(g<<3)|0;c[m>>2]=-1;c[m+4>>2]=0;m=b+316|0;if(!(a[b+93>>0]|0))l=0.0;else{r=b+72|0;l=+h[r>>3]*1389796.0;l=l- +(~~(l/2147483647.0)|0)*2147483647.0;h[r>>3]=l;l=l/2147483647.0*1.0e-5}k=b+320|0;if((c[k>>2]|0)<(j|0)){n=b+324|0;o=c[n>>2]|0;if((o|0)<(j|0)){r=g+2-o&-2;p=(o>>1)+2&-2;p=(r|0)>(p|0)?r:p;if((p|0)>(2147483647-o|0)){r=va(1)|0;Ta(r|0,48,0)}q=c[m>>2]|0;r=p+o|0;c[n>>2]=r;r=Ud(q,r<<3)|0;c[m>>2]=r;if((r|0)==0?(c[(Oa()|0)>>2]|0)==12:0){r=va(1)|0;Ta(r|0,48,0)}}p=c[k>>2]|0;if((p|0)<(j|0)){n=c[m>>2]|0;do{o=n+(p<<3)|0;if(o)h[o>>3]=0.0;p=p+1|0}while((p|0)!=(j|0))}c[k>>2]=j}h[(c[m>>2]|0)+(g<<3)>>3]=l;kc(b+588|0,g,0);kc(b+348|0,g,1);k=b+364|0;d=a[d>>0]|0;jc(k,j);a[(c[k>>2]|0)+g>>0]=d;k=b+380|0;d=b+384|0;if((c[d>>2]|0)<(j|0)){m=b+388|0;o=c[m>>2]|0;if((o|0)<(j|0)){r=g+2-o&-2;n=(o>>1)+2&-2;n=(r|0)>(n|0)?r:n;if((n|0)>(2147483647-o|0)){r=va(1)|0;Ta(r|0,48,0)}q=c[k>>2]|0;r=n+o|0;c[m>>2]=r;r=Ud(q,r)|0;c[k>>2]=r;if((r|0)==0?(c[(Oa()|0)>>2]|0)==12:0){r=va(1)|0;Ta(r|0,48,0)}}m=c[d>>2]|0;if((m|0)<(j|0))do{n=(c[k>>2]|0)+m|0;if(n)a[n>>0]=0;m=m+1|0}while((m|0)!=(j|0));c[d>>2]=j}d=b+288|0;k=c[d>>2]|0;if((k|0)<(j|0)){r=g+2-k&-2;j=(k>>1)+2&-2;j=(r|0)>(j|0)?r:j;if((j|0)>(2147483647-k|0)){r=va(1)|0;Ta(r|0,48,0)}q=b+280|0;p=c[q>>2]|0;r=j+k|0;c[d>>2]=r;r=Ud(p,r<<2)|0;c[q>>2]=r;if((r|0)==0?(c[(Oa()|0)>>2]|0)==12:0){r=va(1)|0;Ta(r|0,48,0)}}j=b+380|0;d=(c[j>>2]|0)+g|0;k=(a[d>>0]|0)==0;if(e){if(k){r=b+200|0;q=r;q=ne(c[q>>2]|0,c[q+4>>2]|0,1,0)|0;c[r>>2]=q;c[r+4>>2]=F}}else if(!k){r=b+200|0;q=r;q=ne(c[q>>2]|0,c[q+4>>2]|0,-1,-1)|0;c[r>>2]=q;c[r+4>>2]=F}a[d>>0]=e&1;e=b+460|0;if((c[b+476>>2]|0)>(g|0)?(c[(c[b+472>>2]|0)+(g<<2)>>2]|0)>-1:0){i=f;return g|0}if(!(a[(c[j>>2]|0)+g>>0]|0)){i=f;return g|0}lc(e,g);i=f;return g|0}function Kb(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;f=i;i=i+16|0;k=f+1|0;j=f;g=b+492|0;if(!(a[g>>0]|0)){s=0;i=f;return s|0}s=c[e>>2]|0;h=e+4|0;l=c[h>>2]|0;a[k+0>>0]=a[j+0>>0]|0;oc(s,l,k);l=c[h>>2]|0;a:do if((l|0)>0){k=b+332|0;j=a[528]|0;m=0;n=0;p=-2;while(1){s=c[e>>2]|0;o=c[s+(m<<2)>>2]|0;r=d[(c[k>>2]|0)+(o>>1)>>0]|0;t=r^o&1;q=t&255;u=j&255;if((o|0)==(p^1|0)?1:(q<<24>>24==j<<24>>24&(u>>>1^1)|u&2&t|0)!=0){b=1;break}t=a[536]|0;u=t&255;if((o|0)!=(p|0)?((u>>>1^1)&q<<24>>24==t<<24>>24|r&2&u|0)==0:0){c[s+(n<<2)>>2]=o;l=c[h>>2]|0;n=n+1|0}else o=p;m=m+1|0;if((m|0)<(l|0))p=o;else break a}i=f;return b|0}else{m=0;n=0}while(0);j=m-n|0;if((j|0)>0){l=l-j|0;c[h>>2]=l}if(!l){a[g>>0]=0;u=0;i=f;return u|0}else if((l|0)==1){t=c[c[e>>2]>>2]|0;s=t>>1;a[(c[b+332>>2]|0)+s>>0]=(t&1^1)&255^1;u=c[b+296>>2]|0;s=(c[b+396>>2]|0)+(s<<3)|0;c[s>>2]=-1;c[s+4>>2]=u;s=b+284|0;u=c[s>>2]|0;c[s>>2]=u+1;c[(c[b+280>>2]|0)+(u<<2)>>2]=t;u=(Mb(b)|0)==-1;a[g>>0]=u&1;i=f;return u|0}else{e=pc(b+544|0,e,0)|0;h=b+256|0;g=b+260|0;k=c[g>>2]|0;j=b+264|0;if((k|0)==(c[j>>2]|0)){l=(k>>1)+2&-2;l=(l|0)<2?2:l;if((l|0)>(2147483647-k|0)){u=va(1)|0;Ta(u|0,48,0)}t=c[h>>2]|0;u=l+k|0;c[j>>2]=u;u=Ud(t,u<<2)|0;c[h>>2]=u;if((u|0)==0?(c[(Oa()|0)>>2]|0)==12:0){u=va(1)|0;Ta(u|0,48,0)}k=c[g>>2]|0}c[g>>2]=k+1;g=(c[h>>2]|0)+(k<<2)|0;if(g)c[g>>2]=e;Nb(b,e);u=1;i=f;return u|0}return 0}function Lb(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0;f=c[d>>2]|0;d=f>>1;a[(c[b+332>>2]|0)+d>>0]=(f&1^1)&255^1;g=c[b+296>>2]|0;d=(c[b+396>>2]|0)+(d<<3)|0;c[d>>2]=e;c[d+4>>2]=g;e=b+284|0;d=c[e>>2]|0;c[e>>2]=d+1;c[(c[b+280>>2]|0)+(d<<2)>>2]=f;return}function Mb(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;k=i;i=i+16|0;r=k;h=b+512|0;t=c[h>>2]|0;q=b+284|0;if((t|0)>=(c[q>>2]|0)){M=0;K=0;O=-1;N=b+184|0;I=N;L=I;L=c[L>>2]|0;I=I+4|0;I=c[I>>2]|0;I=ne(L|0,I|0,M|0,K|0)|0;L=F;J=N;c[J>>2]=I;N=N+4|0;c[N>>2]=L;N=b+520|0;L=N;J=L;J=c[J>>2]|0;L=L+4|0;L=c[L>>2]|0;K=je(J|0,L|0,M|0,K|0)|0;M=F;L=N;c[L>>2]=K;N=N+4|0;c[N>>2]=M;i=k;return O|0}o=b+280|0;j=b+428|0;g=b+412|0;l=b+332|0;m=b+544|0;n=r+4|0;e=b+396|0;p=b+296|0;f=b+456|0;z=-1;s=0;do{c[h>>2]=t+1;w=c[(c[o>>2]|0)+(t<<2)>>2]|0;if(a[(c[j>>2]|0)+w>>0]|0){u=c[g>>2]|0;t=u+(w*12|0)+4|0;y=c[t>>2]|0;if((y|0)>0){u=u+(w*12|0)|0;v=0;x=0;do{B=c[u>>2]|0;A=B+(v<<3)|0;if((c[(c[c[f>>2]>>2]|0)+(c[A>>2]<<2)>>2]&3|0)!=1){N=A;O=c[N+4>>2]|0;y=B+(x<<3)|0;c[y>>2]=c[N>>2];c[y+4>>2]=O;y=c[t>>2]|0;x=x+1|0}v=v+1|0}while((v|0)<(y|0))}else{v=0;x=0}u=v-x|0;if((u|0)>0)c[t>>2]=y-u;a[(c[j>>2]|0)+w>>0]=0}t=c[g>>2]|0;s=s+1|0;u=c[t+(w*12|0)>>2]|0;t=t+(w*12|0)+4|0;x=c[t>>2]|0;v=u+(x<<3)|0;a:do if(!x){v=u;y=u}else{w=w^1;x=(x<<3)+ -1|0;B=u;y=u;while(1){while(1){b:while(1){H=c[B+4>>2]|0;O=d[(c[l>>2]|0)+(H>>1)>>0]^H&1;J=a[528]|0;I=J&255;K=I&2;I=I>>>1^1;if((O&255)<<24>>24==J<<24>>24&I|K&O){E=19;break}A=c[B>>2]|0;E=c[m>>2]|0;G=E+(A<<2)|0;C=E+(A+1<<2)|0;D=c[C>>2]|0;if((D|0)==(w|0)){O=E+(A+2<<2)|0;D=c[O>>2]|0;c[C>>2]=D;c[O>>2]=w}C=B+8|0;c[r>>2]=A;c[n>>2]=D;if((D|0)!=(H|0)?(O=d[(c[l>>2]|0)+(D>>1)>>0]^D&1,((O&255)<<24>>24==J<<24>>24&I|K&O|0)!=0):0){E=27;break}K=c[G>>2]|0;if(K>>>0<=95){E=31;break}I=c[l>>2]|0;J=a[536]|0;H=J&255;O=H&2;H=H>>>1^1;N=2;while(1){L=G+(N<<2)+4|0;M=c[L>>2]|0;P=d[I+(M>>1)>>0]^M&1;N=N+1|0;if(!((P&255)<<24>>24==J<<24>>24&H|O&P))break;if((N|0)>=(K>>>5|0)){E=32;break b}}P=E+(A+2<<2)|0;c[P>>2]=M;c[L>>2]=w;qc((c[g>>2]|0)+((c[P>>2]^1)*12|0)|0,r);if((C|0)==(v|0))break a;else B=C}if((E|0)==19){E=0;N=B;O=c[N+4>>2]|0;P=y;c[P>>2]=c[N>>2];c[P+4>>2]=O;B=B+8|0;y=y+8|0}else if((E|0)==27){E=0;O=r;P=c[O+4>>2]|0;B=y;c[B>>2]=c[O>>2];c[B+4>>2]=P;B=C;y=y+8|0}else if((E|0)==31){J=a[536]|0;E=32}if((E|0)==32){E=y+8|0;G=r;I=c[G+4>>2]|0;H=y;c[H>>2]=c[G>>2];c[H+4>>2]=I;H=D>>1;I=D&1;G=(c[l>>2]|0)+H|0;P=d[G>>0]^I;O=J&255;if((P&255)<<24>>24==J<<24>>24&(O>>>1^1)|O&2&P)break;a[G>>0]=(I^1)&255^1;y=c[p>>2]|0;B=(c[e>>2]|0)+(H<<3)|0;c[B>>2]=A;c[B+4>>2]=y;B=c[q>>2]|0;c[q>>2]=B+1;c[(c[o>>2]|0)+(B<<2)>>2]=D;B=C;y=E}if((B|0)==(v|0))break a}c[h>>2]=c[q>>2];if(C>>>0<v>>>0){z=(u+(x-C)|0)>>>3;while(1){N=C;C=C+8|0;O=c[N+4>>2]|0;P=E;c[P>>2]=c[N>>2];c[P+4>>2]=O;if(C>>>0>=v>>>0)break;else E=E+8|0}B=B+(z+2<<3)|0;y=y+(z+2<<3)|0}else{B=C;y=E}if((B|0)==(v|0)){z=A;break}else z=A}}while(0);u=v-y|0;if((u|0)>0)c[t>>2]=(c[t>>2]|0)-(u>>3);t=c[h>>2]|0}while((t|0)<(c[q>>2]|0));N=s;L=((s|0)<0)<<31>>31;P=z;O=b+184|0;J=O;M=J;M=c[M>>2]|0;J=J+4|0;J=c[J>>2]|0;J=ne(M|0,J|0,N|0,L|0)|0;M=F;K=O;c[K>>2]=J;O=O+4|0;c[O>>2]=M;O=b+520|0;M=O;K=M;K=c[K>>2]|0;M=M+4|0;M=c[M>>2]|0;L=je(K|0,M|0,N|0,L|0)|0;N=F;M=O;c[M>>2]=L;O=O+4|0;c[O>>2]=N;i=k;return P|0}function Nb(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;d=i;i=i+16|0;k=d+8|0;f=d;g=c[a+544>>2]|0;e=g+(b<<2)|0;h=g+(b+1<<2)|0;j=a+412|0;l=(c[j>>2]|0)+((c[h>>2]^1)*12|0)|0;g=g+(b+2<<2)|0;m=c[g>>2]|0;c[k>>2]=b;c[k+4>>2]=m;qc(l,k);g=(c[j>>2]|0)+((c[g>>2]^1)*12|0)|0;h=c[h>>2]|0;c[f>>2]=b;c[f+4>>2]=h;qc(g,f);if(!(c[e>>2]&4)){m=a+208|0;l=m;l=ne(c[l>>2]|0,c[l+4>>2]|0,1,0)|0;c[m>>2]=l;c[m+4>>2]=F;m=a+224|0;l=m;l=ne((c[e>>2]|0)>>>5|0,0,c[l>>2]|0,c[l+4>>2]|0)|0;c[m>>2]=l;c[m+4>>2]=F;i=d;return}else{m=a+216|0;l=m;l=ne(c[l>>2]|0,c[l+4>>2]|0,1,0)|0;c[m>>2]=l;c[m+4>>2]=F;m=a+232|0;l=m;l=ne((c[e>>2]|0)>>>5|0,0,c[l>>2]|0,c[l+4>>2]|0)|0;c[m>>2]=l;c[m+4>>2]=F;i=d;return}}function Ob(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=i;i=i+16|0;l=g+4|0;j=g;h=c[b+544>>2]|0;f=h+(d<<2)|0;k=c[h+(d+1<<2)>>2]^1;if(!e){c[l>>2]=k;e=b+428|0;m=c[e>>2]|0;k=m+k|0;if(!(a[k>>0]|0)){a[k>>0]=1;mc(b+444|0,l);m=c[e>>2]|0}d=c[h+(d+2<<2)>>2]^1;c[j>>2]=d;d=m+d|0;if(!(a[d>>0]|0)){a[d>>0]=1;mc(b+444|0,j)}}else{j=b+412|0;e=c[j>>2]|0;l=e+(k*12|0)|0;h=h+(d+2<<2)|0;k=e+(k*12|0)+4|0;m=c[k>>2]|0;a:do if((m|0)>0){p=c[l>>2]|0;o=0;while(1){n=o+1|0;if((c[p+(o<<3)>>2]|0)==(d|0)){n=o;break a}if((n|0)<(m|0))o=n;else break}}else n=0;while(0);m=m+ -1|0;if((n|0)<(m|0)){do{e=c[l>>2]|0;m=n;n=n+1|0;o=e+(n<<3)|0;p=c[o+4>>2]|0;m=e+(m<<3)|0;c[m>>2]=c[o>>2];c[m+4>>2]=p;m=(c[k>>2]|0)+ -1|0}while((n|0)<(m|0));e=c[j>>2]|0}c[k>>2]=m;j=c[h>>2]^1;h=e+(j*12|0)|0;j=e+(j*12|0)+4|0;k=c[j>>2]|0;b:do if((k|0)>0){e=c[h>>2]|0;m=0;while(1){l=m+1|0;if((c[e+(m<<3)>>2]|0)==(d|0)){l=m;break b}if((l|0)<(k|0))m=l;else break}}else l=0;while(0);d=k+ -1|0;if((l|0)<(d|0))do{n=c[h>>2]|0;d=l;l=l+1|0;o=n+(l<<3)|0;p=c[o+4>>2]|0;d=n+(d<<3)|0;c[d>>2]=c[o>>2];c[d+4>>2]=p;d=(c[j>>2]|0)+ -1|0}while((l|0)<(d|0));c[j>>2]=d}if(!(c[f>>2]&4)){p=b+208|0;o=p;o=ne(c[o>>2]|0,c[o+4>>2]|0,-1,-1)|0;c[p>>2]=o;c[p+4>>2]=F;p=b+224|0;o=p;o=je(c[o>>2]|0,c[o+4>>2]|0,(c[f>>2]|0)>>>5|0,0)|0;c[p>>2]=o;c[p+4>>2]=F;i=g;return}else{p=b+216|0;o=p;o=ne(c[o>>2]|0,c[o+4>>2]|0,-1,-1)|0;c[p>>2]=o;c[p+4>>2]=F;p=b+232|0;o=p;o=je(c[o>>2]|0,c[o+4>>2]|0,(c[f>>2]|0)>>>5|0,0)|0;c[p>>2]=o;c[p+4>>2]=F;i=g;return}}function Pb(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;h=i;g=b+544|0;m=c[g>>2]|0;f=m+(e<<2)|0;Ob(b,e,0);m=c[m+(e+1<<2)>>2]|0;j=m>>1;m=(d[(c[b+332>>2]|0)+j>>0]|0)^m&1;o=a[528]|0;n=o&255;if((((m&255)<<24>>24==o<<24>>24&(n>>>1^1)|n&2&m|0)!=0?(k=(c[b+396>>2]|0)+(j<<3)|0,l=c[k>>2]|0,(l|0)!=-1):0)?((c[g>>2]|0)+(l<<2)|0)==(f|0):0)c[k>>2]=-1;c[f>>2]=c[f>>2]&-4|1;n=c[(c[g>>2]|0)+(e<<2)>>2]|0;o=b+556|0;c[o>>2]=((((n>>>3&1)+(n>>>5)<<2)+4|0)>>>2)+(c[o>>2]|0);i=h;return}function Qb(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;g=c[e>>2]|0;if(g>>>0<=31){l=0;i=f;return l|0}h=c[b+332>>2]|0;j=a[528]|0;k=j&255;l=k&2;k=k>>>1^1;b=0;while(1){m=c[e+(b<<2)+4>>2]|0;m=(d[h+(m>>1)>>0]|0)^m&1;b=b+1|0;if((m&255)<<24>>24==j<<24>>24&k|l&m){g=1;e=5;break}if((b|0)>=(g>>>5|0)){g=0;e=5;break}}if((e|0)==5){i=f;return g|0}return 0}function Rb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;g=i;e=b+296|0;if((c[e>>2]|0)<=(d|0)){i=g;return}f=b+284|0;s=c[f>>2]|0;j=b+292|0;t=c[j>>2]|0;u=c[t+(d<<2)>>2]|0;if((s|0)>(u|0)){r=b+280|0;m=b+332|0;l=b+88|0;k=b+348|0;n=b+460|0;p=b+476|0;q=b+472|0;o=b+380|0;do{s=s+ -1|0;u=c[(c[r>>2]|0)+(s<<2)>>2]>>1;a[(c[m>>2]|0)+u>>0]=a[544]|0;t=c[l>>2]|0;if((t|0)<=1){if((t|0)==1?(s|0)>(c[(c[j>>2]|0)+((c[e>>2]|0)+ -1<<2)>>2]|0):0)h=7}else h=7;if((h|0)==7){h=0;a[(c[k>>2]|0)+u>>0]=c[(c[r>>2]|0)+(s<<2)>>2]&1}if(!((c[p>>2]|0)>(u|0)?(c[(c[q>>2]|0)+(u<<2)>>2]|0)>-1:0))h=11;if((h|0)==11?(h=0,(a[(c[o>>2]|0)+u>>0]|0)!=0):0)lc(n,u);t=c[j>>2]|0;u=c[t+(d<<2)>>2]|0}while((s|0)>(u|0));s=c[f>>2]|0}c[b+512>>2]=u;b=c[t+(d<<2)>>2]|0;if((s-b|0)>0)c[f>>2]=b;if(((c[e>>2]|0)-d|0)<=0){i=g;return}c[e>>2]=d;i=g;return}function Sb(b){b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0;d=i;f=b+72|0;q=+h[f>>3]*1389796.0;q=q- +(~~(q/2147483647.0)|0)*2147483647.0;h[f>>3]=q;l=b+464|0;if(q/2147483647.0<+h[b+64>>3]?(m=c[l>>2]|0,(m|0)!=0):0){q=q*1389796.0;q=q- +(~~(q/2147483647.0)|0)*2147483647.0;h[f>>3]=q;m=c[(c[b+460>>2]|0)+(~~(+(m|0)*(q/2147483647.0))<<2)>>2]|0;o=a[(c[b+332>>2]|0)+m>>0]|0;n=a[544]|0;p=n&255;if(((p>>>1^1)&o<<24>>24==n<<24>>24|o&2&p|0)!=0?(a[(c[b+380>>2]|0)+m>>0]|0)!=0:0){p=b+176|0;o=p;o=ne(c[o>>2]|0,c[o+4>>2]|0,1,0)|0;c[p>>2]=o;c[p+4>>2]=F}}else m=-1;n=b+460|0;p=b+332|0;o=b+380|0;while(1){if(((m|0)!=-1?(r=a[(c[p>>2]|0)+m>>0]|0,j=a[544]|0,e=j&255,g=e>>>1^1,(g&r<<24>>24==j<<24>>24|r&2&e|0)!=0):0)?(a[(c[o>>2]|0)+m>>0]|0)!=0:0)break;if(!(c[l>>2]|0)){e=-2;k=17;break}m=rc(n)|0}if((k|0)==17){i=d;return e|0}l=a[(c[b+364>>2]|0)+m>>0]|0;k=l&255;if(!(g&l<<24>>24==j<<24>>24|e&2&k)){p=a[528]|0;r=p&255;r=((r>>>1^1)&l<<24>>24==p<<24>>24|k&2&r|0)!=0|m<<1;i=d;return r|0}if(!(a[b+92>>0]|0)){r=(a[(c[b+348>>2]|0)+m>>0]|0)!=0|m<<1;i=d;return r|0}else{q=+h[f>>3]*1389796.0;q=q- +(~~(q/2147483647.0)|0)*2147483647.0;h[f>>3]=q;r=q/2147483647.0<.5|m<<1;i=d;return r|0}return 0}function Tb(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0.0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0.0,U=0;j=i;i=i+16|0;p=j+8|0;t=j+4|0;n=j;m=e+4|0;k=c[m>>2]|0;l=e+8|0;if((k|0)==(c[l>>2]|0)){q=(k>>1)+2&-2;q=(q|0)<2?2:q;if((q|0)>(2147483647-k|0)){S=va(1)|0;Ta(S|0,48,0)}R=c[e>>2]|0;S=q+k|0;c[l>>2]=S;S=Ud(R,S<<2)|0;c[e>>2]=S;if((S|0)==0?(c[(Oa()|0)>>2]|0)==12:0){S=va(1)|0;Ta(S|0,48,0)}k=c[m>>2]|0}l=(c[e>>2]|0)+(k<<2)|0;if(l){c[l>>2]=0;k=c[m>>2]|0}c[m>>2]=k+1;q=b+544|0;H=b+280|0;k=b+588|0;l=b+396|0;C=b+504|0;E=b+316|0;D=b+540|0;B=b+476|0;A=b+472|0;z=b+460|0;y=b+488|0;x=b+296|0;v=b+496|0;w=b+272|0;G=b+268|0;J=-2;I=(c[b+284>>2]|0)+ -1|0;K=0;do{L=c[q>>2]|0;d=L+(d<<2)|0;M=c[d>>2]|0;if((M&4|0)!=0?(r=+h[v>>3],S=d+(M>>>5<<2)+4|0,T=r+ +g[S>>2],g[S>>2]=T,T>1.0e20):0){O=c[w>>2]|0;if((O|0)>0){N=c[G>>2]|0;M=0;do{S=L+(c[N+(M<<2)>>2]<<2)|0;S=S+((c[S>>2]|0)>>>5<<2)+4|0;g[S>>2]=+g[S>>2]*1.0e-20;M=M+1|0}while((M|0)!=(O|0))}h[v>>3]=r*1.0e-20}J=(J|0)!=-2&1;if(J>>>0<(c[d>>2]|0)>>>5>>>0)do{M=c[d+(J<<2)+4>>2]|0;c[t>>2]=M;M=M>>1;L=(c[k>>2]|0)+M|0;do if((a[L>>0]|0)==0?(c[(c[l>>2]|0)+(M<<3)+4>>2]|0)>0:0){O=c[E>>2]|0;S=O+(M<<3)|0;T=+h[C>>3]+ +h[S>>3];h[S>>3]=T;if(T>1.0e+100){P=c[D>>2]|0;if((P|0)>0){N=0;do{S=O+(N<<3)|0;h[S>>3]=+h[S>>3]*1.0e-100;N=N+1|0}while((N|0)!=(P|0))}h[C>>3]=+h[C>>3]*1.0e-100}if((c[B>>2]|0)>(M|0)?(u=c[A>>2]|0,s=c[u+(M<<2)>>2]|0,(s|0)>-1):0){N=c[z>>2]|0;O=c[N+(s<<2)>>2]|0;a:do if(!s)R=0;else{S=s;while(1){R=S;S=S+ -1>>1;Q=N+(S<<2)|0;P=c[Q>>2]|0;U=c[c[y>>2]>>2]|0;if(!(+h[U+(O<<3)>>3]>+h[U+(P<<3)>>3]))break a;c[N+(R<<2)>>2]=P;c[u+(c[Q>>2]<<2)>>2]=R;if(!S){R=0;break}}}while(0);c[N+(R<<2)>>2]=O;c[u+(O<<2)>>2]=R}a[L>>0]=1;if((c[(c[l>>2]|0)+(M<<3)+4>>2]|0)<(c[x>>2]|0)){mc(e,t);break}else{K=K+1|0;break}}while(0);J=J+1|0}while((J|0)<((c[d>>2]|0)>>>5|0));d=c[H>>2]|0;L=c[k>>2]|0;do{J=I;I=I+ -1|0;J=c[d+(J<<2)>>2]|0;N=J>>1;M=L+N|0}while((a[M>>0]|0)==0);d=c[(c[l>>2]|0)+(N<<3)>>2]|0;a[M>>0]=0;K=K+ -1|0}while((K|0)>0);c[c[e>>2]>>2]=J^1;t=b+616|0;v=c[t>>2]|0;s=b+620|0;if(!v)w=c[s>>2]|0;else{c[s>>2]=0;w=0}u=c[m>>2]|0;if((w|0)<(u|0)){y=b+624|0;x=c[y>>2]|0;if((x|0)<(u|0)){U=u+1-x&-2;w=(x>>1)+2&-2;w=(U|0)>(w|0)?U:w;if((w|0)>(2147483647-x|0)){U=va(1)|0;Ta(U|0,48,0)}U=w+x|0;c[y>>2]=U;v=Ud(v,U<<2)|0;c[t>>2]=v;if((v|0)==0?(c[(Oa()|0)>>2]|0)==12:0){U=va(1)|0;Ta(U|0,48,0)}}w=c[s>>2]|0;b:do if((w|0)<(u|0))while(1){v=v+(w<<2)|0;if(v)c[v>>2]=0;w=w+1|0;if((w|0)==(u|0))break b;v=c[t>>2]|0}while(0);c[s>>2]=u;u=c[m>>2]|0}if((u|0)>0){w=c[t>>2]|0;v=c[e>>2]|0;x=0;do{c[w+(x<<2)>>2]=c[v+(x<<2)>>2];x=x+1|0;u=c[m>>2]|0}while((x|0)<(u|0))}v=c[b+84>>2]|0;if((v|0)==1)if((u|0)>1){n=c[e>>2]|0;o=1;v=1;while(1){u=c[n+(o<<2)>>2]|0;p=c[l>>2]|0;w=c[p+(u>>1<<3)>>2]|0;c:do if((w|0)!=-1){x=(c[q>>2]|0)+(w<<2)|0;y=c[x>>2]|0;if(y>>>0>63){w=c[k>>2]|0;z=1;while(1){U=c[x+(z<<2)+4>>2]>>1;if((a[w+U>>0]|0)==0?(c[p+(U<<3)+4>>2]|0)>0:0)break;z=z+1|0;if((z|0)>=(y>>>5|0))break c}c[n+(v<<2)>>2]=u;v=v+1|0}}else{c[n+(v<<2)>>2]=u;v=v+1|0}while(0);o=o+1|0;p=c[m>>2]|0;if((o|0)>=(p|0)){n=p;break}}}else{n=u;o=1;v=1}else if((v|0)==2)if((u|0)>1){q=1;v=1;do{w=c[e>>2]|0;u=c[w+(q<<2)>>2]|0;if((c[(c[l>>2]|0)+(u>>1<<3)>>2]|0)!=-1){c[n>>2]=u;c[p+0>>2]=c[n+0>>2];if(!(Ub(b,p)|0)){u=c[e>>2]|0;w=u;u=c[u+(q<<2)>>2]|0;o=62}}else o=62;if((o|0)==62){o=0;c[w+(v<<2)>>2]=u;v=v+1|0}q=q+1|0;u=c[m>>2]|0}while((q|0)<(u|0));n=u;o=q}else{n=u;o=1;v=1}else{n=u;o=u;v=u}U=b+240|0;S=U;S=ne(c[S>>2]|0,c[S+4>>2]|0,n|0,((n|0)<0)<<31>>31|0)|0;c[U>>2]=S;c[U+4>>2]=F;o=o-v|0;if((o|0)>0){n=n-o|0;c[m>>2]=n}U=b+248|0;S=U;S=ne(c[S>>2]|0,c[S+4>>2]|0,n|0,((n|0)<0)<<31>>31|0)|0;c[U>>2]=S;c[U+4>>2]=F;if((n|0)==1)e=0;else{e=c[e>>2]|0;if((n|0)>2){b=c[l>>2]|0;m=2;o=1;do{o=(c[b+(c[e+(m<<2)>>2]>>1<<3)+4>>2]|0)>(c[b+(c[e+(o<<2)>>2]>>1<<3)+4>>2]|0)?m:o;m=m+1|0}while((m|0)<(n|0))}else o=1;S=e+(o<<2)|0;U=c[S>>2]|0;e=e+4|0;c[S>>2]=c[e>>2];c[e>>2]=U;e=c[(c[l>>2]|0)+(U>>1<<3)+4>>2]|0}c[f>>2]=e;if((c[s>>2]|0)>0)f=0;else{i=j;return}do{a[(c[k>>2]|0)+(c[(c[t>>2]|0)+(f<<2)>>2]>>1)>>0]=0;f=f+1|0}while((f|0)<(c[s>>2]|0));i=j;return}function Ub(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;e=i;n=c[d>>2]|0;l=b+396|0;q=c[l>>2]|0;k=b+544|0;s=(c[k>>2]|0)+(c[q+(n>>1<<3)>>2]<<2)|0;h=b+604|0;f=b+608|0;if(c[h>>2]|0)c[f>>2]=0;g=b+588|0;j=b+612|0;b=b+616|0;o=1;while(1){if(o>>>0<(c[s>>2]|0)>>>5>>>0){r=c[s+(o<<2)+4>>2]|0;p=r>>1;if((c[q+(p<<3)+4>>2]|0)!=0?(m=a[(c[g>>2]|0)+p>>0]|0,(m+ -1<<24>>24&255)>=2):0){s=c[f>>2]|0;t=(s|0)==(c[j>>2]|0);if(m<<24>>24==3?1:(c[q+(p<<3)>>2]|0)==-1){k=8;break}if(t){q=(s>>1)+2&-2;q=(q|0)<2?2:q;if((q|0)>(2147483647-s|0)){k=24;break}u=c[h>>2]|0;t=q+s|0;c[j>>2]=t;t=Ud(u,t<<3)|0;c[h>>2]=t;if((t|0)==0?(c[(Oa()|0)>>2]|0)==12:0){k=24;break}s=c[f>>2]|0}c[f>>2]=s+1;q=(c[h>>2]|0)+(s<<3)|0;if(q){u=q;c[u>>2]=o;c[u+4>>2]=n}c[d>>2]=r;s=c[l>>2]|0;n=r;q=s;s=(c[k>>2]|0)+(c[s+(p<<3)>>2]<<2)|0;o=0}}else{n=(c[g>>2]|0)+(n>>1)|0;if(!(a[n>>0]|0)){a[n>>0]=2;mc(b,d)}n=c[f>>2]|0;if(!n){f=1;k=34;break}u=n+ -1|0;n=c[h>>2]|0;o=c[n+(u<<3)>>2]|0;n=c[n+(u<<3)+4>>2]|0;c[d>>2]=n;q=c[l>>2]|0;s=(c[k>>2]|0)+(c[q+(n>>1<<3)>>2]<<2)|0;c[f>>2]=u}o=o+1|0}if((k|0)==8){if(t){k=(s>>1)+2&-2;k=(k|0)<2?2:k;if((k|0)>(2147483647-s|0)){u=va(1)|0;Ta(u|0,48,0)}t=c[h>>2]|0;u=k+s|0;c[j>>2]=u;u=Ud(t,u<<3)|0;c[h>>2]=u;if((u|0)==0?(c[(Oa()|0)>>2]|0)==12:0){u=va(1)|0;Ta(u|0,48,0)}s=c[f>>2]|0}j=s+1|0;c[f>>2]=j;k=(c[h>>2]|0)+(s<<3)|0;if(k){j=k;c[j>>2]=0;c[j+4>>2]=n;j=c[f>>2]|0}if((j|0)>0)k=0;else{u=0;i=e;return u|0}do{l=(c[g>>2]|0)+(c[(c[h>>2]|0)+(k<<3)+4>>2]>>1)|0;if(!(a[l>>0]|0)){a[l>>0]=3;mc(b,(c[h>>2]|0)+(k<<3)+4|0);j=c[f>>2]|0}k=k+1|0}while((k|0)<(j|0));f=0;i=e;return f|0}else if((k|0)==24)Ta(va(1)|0,48,0);else if((k|0)==34){i=e;return f|0}return 0}function Vb(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;j=i;i=i+32|0;h=j+16|0;g=j+12|0;k=j+8|0;f=j;n=e+20|0;l=e+16|0;if((c[n>>2]|0)>0){m=0;do{a[(c[e>>2]|0)+(c[(c[l>>2]|0)+(m<<2)>>2]|0)>>0]=0;m=m+1|0}while((m|0)<(c[n>>2]|0))}if(c[l>>2]|0)c[n>>2]=0;m=c[d>>2]|0;c[k>>2]=m;c[g>>2]=m;c[h+0>>2]=c[g+0>>2];sc(e,h,0);l=(c[e>>2]|0)+m|0;if(!(a[l>>0]|0)){a[l>>0]=1;mc(e+16|0,k)}if(!(c[b+296>>2]|0)){i=j;return}d=m>>1;o=b+588|0;a[(c[o>>2]|0)+d>>0]=1;p=c[b+284>>2]|0;n=b+292|0;s=c[c[n>>2]>>2]|0;if((p|0)>(s|0)){k=b+280|0;l=b+396|0;m=e+16|0;b=b+544|0;do{p=p+ -1|0;r=c[(c[k>>2]|0)+(p<<2)>>2]|0;q=r>>1;if(a[(c[o>>2]|0)+q>>0]|0){s=c[l>>2]|0;t=c[s+(q<<3)>>2]|0;a:do if((t|0)==-1){r=r^1;c[f>>2]=r;c[g>>2]=r;c[h+0>>2]=c[g+0>>2];sc(e,h,0);r=(c[e>>2]|0)+r|0;if(!(a[r>>0]|0)){a[r>>0]=1;mc(m,f)}}else{r=(c[b>>2]|0)+(t<<2)|0;t=c[r>>2]|0;if(t>>>0>63){u=1;while(1){v=c[r+(u<<2)+4>>2]>>1;if((c[s+(v<<3)+4>>2]|0)>0){a[(c[o>>2]|0)+v>>0]=1;t=c[r>>2]|0}u=u+1|0;if((u|0)>=(t>>>5|0))break a;s=c[l>>2]|0}}}while(0);a[(c[o>>2]|0)+q>>0]=0;s=c[c[n>>2]>>2]|0}}while((p|0)>(s|0))}a[(c[o>>2]|0)+d>>0]=0;i=j;return}function Wb(b){b=b|0;var e=0,f=0,j=0,k=0,l=0,m=0,n=0.0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;f=i;i=i+16|0;p=f+4|0;u=f;e=b+272|0;w=c[e>>2]|0;n=+h[b+496>>3]/+(w|0);k=b+544|0;l=b+268|0;v=c[l>>2]|0;c[u>>2]=k;c[p+0>>2]=c[u+0>>2];tc(v,w,p);p=c[e>>2]|0;if((p|0)>0){m=b+332|0;o=b+396|0;q=0;v=0;do{t=c[l>>2]|0;u=c[t+(q<<2)>>2]|0;w=c[k>>2]|0;r=w+(u<<2)|0;s=c[r>>2]|0;do if(s>>>0>95){x=c[w+(u+1<<2)>>2]|0;w=x>>1;x=(d[(c[m>>2]|0)+w>>0]|0)^x&1;z=a[528]|0;y=z&255;if(((x&255)<<24>>24==z<<24>>24&(y>>>1^1)|y&2&x|0)!=0?(z=c[(c[o>>2]|0)+(w<<3)>>2]|0,(z|0)!=-1&(z|0)==(u|0)):0){j=9;break}if((q|0)>=((p|0)/2|0|0)?!(+g[r+(s>>>5<<2)+4>>2]<n):0){j=9;break}Pb(b,u)}else j=9;while(0);if((j|0)==9){j=0;c[t+(v<<2)>>2]=u;v=v+1|0}q=q+1|0;p=c[e>>2]|0}while((q|0)<(p|0))}else{q=0;v=0}j=q-v|0;if((j|0)>0)c[e>>2]=p-j;if(!(+((c[b+556>>2]|0)>>>0)>+h[b+96>>3]*+((c[b+548>>2]|0)>>>0))){i=f;return}gb[c[(c[b>>2]|0)+8>>2]&31](b);i=f;return}function Xb(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;f=i;g=e+4|0;m=c[g>>2]|0;if((m|0)>0){j=b+544|0;h=b+332|0;k=0;l=0;do{u=c[e>>2]|0;p=c[u+(k<<2)>>2]|0;m=(c[j>>2]|0)+(p<<2)|0;o=c[m>>2]|0;do if(o>>>0>31){v=c[h>>2]|0;r=a[528]|0;q=r&255;w=q&2;q=q>>>1^1;s=o>>>5;t=0;do{x=c[m+(t<<2)+4>>2]|0;x=(d[v+(x>>1)>>0]|0)^x&1;t=t+1|0;if((x&255)<<24>>24==r<<24>>24&q|w&x){n=7;break}}while((t|0)<(s|0));if((n|0)==7){n=0;Pb(b,p);break}if(o>>>0>95){n=a[536]|0;q=o>>>5;p=2;do{r=m+(p<<2)+4|0;x=c[r>>2]|0;x=(d[(c[h>>2]|0)+(x>>1)>>0]|0)^x&1;w=n&255;if((x&255)<<24>>24==n<<24>>24&(w>>>1^1)|w&2&x){c[r>>2]=c[m+(q+ -1<<2)+4>>2];o=c[m>>2]|0;if(o&8){o=o>>>5;c[m+(o+ -1<<2)+4>>2]=c[m+(o<<2)+4>>2];o=c[m>>2]|0}o=o+ -32|0;c[m>>2]=o;p=p+ -1|0}p=p+1|0;q=o>>>5}while((p|0)<(q|0));p=c[e>>2]|0;u=p;p=c[p+(k<<2)>>2]|0;n=16}else n=16}else n=16;while(0);if((n|0)==16){n=0;c[u+(l<<2)>>2]=p;l=l+1|0}k=k+1|0;m=c[g>>2]|0}while((k|0)<(m|0))}else{k=0;l=0}e=k-l|0;if((e|0)<=0){i=f;return}c[g>>2]=m-e;i=f;return}function Yb(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;g=i;i=i+16|0;e=g+4|0;h=g;c[e>>2]=0;d=e+4|0;c[d>>2]=0;f=e+8|0;c[f>>2]=0;c[h>>2]=0;j=b+540|0;n=c[j>>2]|0;if((n|0)>0){l=b+380|0;k=b+332|0;m=0;do{if((a[(c[l>>2]|0)+m>>0]|0)!=0?(p=a[(c[k>>2]|0)+m>>0]|0,q=a[544]|0,o=q&255,((o>>>1^1)&p<<24>>24==q<<24>>24|p&2&o|0)!=0):0){nc(e,h);n=c[j>>2]|0}m=m+1|0;c[h>>2]=m}while((m|0)<(n|0))}uc(b+460|0,e);b=c[e>>2]|0;if(!b){i=g;return}c[d>>2]=0;Td(b);c[e>>2]=0;c[f>>2]=0;i=g;return}function Zb(b){b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;d=i;f=b+492|0;if((a[f>>0]|0)!=0?(Mb(b)|0)==-1:0){f=b+284|0;g=b+516|0;if((c[f>>2]|0)==(c[g>>2]|0)){s=1;i=d;return s|0}j=b+520|0;s=j;r=c[s+4>>2]|0;if((r|0)>0|(r|0)==0&(c[s>>2]|0)>>>0>0){s=1;i=d;return s|0}Xb(b,b+268|0);if(a[b+536>>0]|0){Xb(b,b+256|0);l=b+564|0;k=b+568|0;if((c[k>>2]|0)>0){n=b+588|0;m=0;do{a[(c[n>>2]|0)+(c[(c[l>>2]|0)+(m<<2)>>2]|0)>>0]=1;m=m+1|0}while((m|0)<(c[k>>2]|0))}p=c[f>>2]|0;if((p|0)>0){m=c[b+280>>2]|0;n=c[b+588>>2]|0;q=0;o=0;do{r=c[m+(q<<2)>>2]|0;if(!(a[n+(r>>1)>>0]|0)){c[m+(o<<2)>>2]=r;p=c[f>>2]|0;o=o+1|0}q=q+1|0}while((q|0)<(p|0))}else{q=0;o=0}m=q-o|0;if((m|0)>0){p=p-m|0;c[f>>2]=p}c[b+512>>2]=p;a:do if((c[k>>2]|0)>0){o=b+588|0;m=0;do{a[(c[o>>2]|0)+(c[(c[l>>2]|0)+(m<<2)>>2]|0)>>0]=0;m=m+1|0;n=c[k>>2]|0}while((m|0)<(n|0));if((n|0)>0){n=b+580|0;o=b+584|0;m=b+576|0;p=0;while(1){r=c[n>>2]|0;if((r|0)==(c[o>>2]|0)){q=(r>>1)+2&-2;q=(q|0)<2?2:q;if((q|0)>(2147483647-r|0)){e=28;break}s=c[m>>2]|0;q=q+r|0;c[o>>2]=q;q=Ud(s,q<<2)|0;c[m>>2]=q;if((q|0)==0?(c[(Oa()|0)>>2]|0)==12:0){e=28;break}r=c[n>>2]|0}else q=c[m>>2]|0;s=q+(r<<2)|0;if(s){c[s>>2]=0;r=c[n>>2]|0}c[n>>2]=r+1;s=c[l>>2]|0;c[q+(r<<2)>>2]=c[s+(p<<2)>>2];p=p+1|0;if((p|0)>=(c[k>>2]|0))break a}if((e|0)==28)Ta(va(1)|0,48,0)}else e=21}else e=21;while(0);if((e|0)==21)s=c[l>>2]|0;if(s)c[k>>2]=0}if(+((c[b+556>>2]|0)>>>0)>+h[b+96>>3]*+((c[b+548>>2]|0)>>>0))gb[c[(c[b>>2]|0)+8>>2]&31](b);Yb(b);c[g>>2]=c[f>>2];r=b+224|0;s=b+232|0;r=ne(c[s>>2]|0,c[s+4>>2]|0,c[r>>2]|0,c[r+4>>2]|0)|0;s=j;c[s>>2]=r;c[s+4>>2]=F;s=1;i=d;return s|0}a[f>>0]=0;s=0;i=d;return s|0}function _b(b,e,f){b=b|0;e=e|0;f=f|0;var j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0.0,ga=0,ha=0,ia=0,ja=0.0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0.0,ra=0,sa=0,ta=0.0;n=i;i=i+64|0;_=n;G=n+60|0;B=n+56|0;j=n+44|0;$=n+40|0;c[j>>2]=0;m=j+4|0;c[m>>2]=0;l=j+8|0;c[l>>2]=0;N=e+160|0;M=N;M=ne(c[M>>2]|0,c[M+4>>2]|0,1,0)|0;c[N>>2]=M;c[N+4>>2]=F;N=(f|0)<0;M=e+680|0;L=e+664|0;K=e+672|0;q=e+296|0;w=e+272|0;o=e+284|0;I=e+640|0;E=e+308|0;D=e+304|0;r=e+332|0;H=e+292|0;ba=e+168|0;t=e+396|0;v=e+280|0;J=e+184|0;C=e+192|0;u=e+48|0;U=e+504|0;Y=e+56|0;aa=e+496|0;ca=e+656|0;O=e+144|0;P=e+648|0;Q=e+128|0;R=e+44|0;T=e+200|0;V=e+208|0;W=e+224|0;X=e+216|0;s=e+232|0;Z=e+540|0;p=e+292|0;x=e+544|0;z=e+276|0;y=e+268|0;A=e+268|0;da=0;a:while(1){ea=N|(da|0)<(f|0);while(1){ga=Mb(e)|0;if((ga|0)!=-1)break;if(!ea){ga=41;break a}if(a[M>>0]|0){ga=41;break a}ga=L;ha=c[ga+4>>2]|0;if((ha|0)>=0?(sa=C,ra=c[sa+4>>2]|0,!(ra>>>0<ha>>>0|((ra|0)==(ha|0)?(c[sa>>2]|0)>>>0<(c[ga>>2]|0)>>>0:0))):0){ga=41;break a}ga=K;ha=c[ga+4>>2]|0;if((ha|0)>=0?(sa=J,ra=c[sa+4>>2]|0,!(ra>>>0<ha>>>0|((ra|0)==(ha|0)?(c[sa>>2]|0)>>>0<(c[ga>>2]|0)>>>0:0))):0){ga=41;break a}if((c[q>>2]|0)==0?!(Zb(e)|0):0){ga=50;break a}if(+((c[w>>2]|0)-(c[o>>2]|0)|0)>=+h[I>>3])Wb(e);while(1){ga=c[q>>2]|0;if((ga|0)>=(c[E>>2]|0)){ga=59;break}ka=c[(c[D>>2]|0)+(ga<<2)>>2]|0;ha=d[(c[r>>2]|0)+(ka>>1)>>0]|0;sa=ha^ka&1;ia=sa&255;pa=a[528]|0;ra=pa&255;if(!(ia<<24>>24==pa<<24>>24&(ra>>>1^1)|ra&2&sa)){ga=56;break}c[G>>2]=c[o>>2];nc(H,G)}if((ga|0)==56){ga=0;ra=a[536]|0;sa=ra&255;if((sa>>>1^1)&ia<<24>>24==ra<<24>>24|ha&2&sa){ga=57;break a}if((ka|0)==-2)ga=59}if((ga|0)==59){sa=ba;sa=ne(c[sa>>2]|0,c[sa+4>>2]|0,1,0)|0;ka=ba;c[ka>>2]=sa;c[ka+4>>2]=F;ka=Sb(e)|0;if((ka|0)==-2){ga=60;break a}}c[_>>2]=c[o>>2];nc(H,_);sa=ka>>1;a[(c[r>>2]|0)+sa>>0]=(ka&1^1)&255^1;ra=c[q>>2]|0;sa=(c[t>>2]|0)+(sa<<3)|0;c[sa>>2]=-1;c[sa+4>>2]=ra;sa=c[o>>2]|0;c[o>>2]=sa+1;c[(c[v>>2]|0)+(sa<<2)>>2]=ka}ra=C;ra=ne(c[ra>>2]|0,c[ra+4>>2]|0,1,0)|0;sa=C;c[sa>>2]=ra;c[sa+4>>2]=F;da=da+1|0;if(!(c[q>>2]|0)){ga=5;break}if(c[j>>2]|0)c[m>>2]=0;Tb(e,ga,j,B);Rb(e,c[B>>2]|0);if((c[m>>2]|0)==1){ra=c[c[j>>2]>>2]|0;sa=ra>>1;a[(c[r>>2]|0)+sa>>0]=(ra&1^1)&255^1;pa=c[q>>2]|0;sa=(c[t>>2]|0)+(sa<<3)|0;c[sa>>2]=-1;c[sa+4>>2]=pa;sa=c[o>>2]|0;c[o>>2]=sa+1;c[(c[v>>2]|0)+(sa<<2)>>2]=ra}else{ea=pc(x,j,1)|0;ga=c[w>>2]|0;if((ga|0)==(c[z>>2]|0)){ha=(ga>>1)+2&-2;ha=(ha|0)<2?2:ha;if((ha|0)>(2147483647-ga|0)){ga=14;break}ra=c[y>>2]|0;sa=ha+ga|0;c[z>>2]=sa;sa=Ud(ra,sa<<2)|0;c[y>>2]=sa;if((sa|0)==0?(c[(Oa()|0)>>2]|0)==12:0){ga=14;break}ga=c[w>>2]|0}c[w>>2]=ga+1;ga=(c[y>>2]|0)+(ga<<2)|0;if(ga)c[ga>>2]=ea;Nb(e,ea);ia=c[x>>2]|0;sa=ia+(ea<<2)|0;fa=+h[aa>>3];sa=sa+((c[sa>>2]|0)>>>5<<2)+4|0;ta=fa+ +g[sa>>2];g[sa>>2]=ta;if(ta>1.0e20){ha=c[w>>2]|0;if((ha|0)>0){ga=c[A>>2]|0;ka=0;do{sa=ia+(c[ga+(ka<<2)>>2]<<2)|0;sa=sa+((c[sa>>2]|0)>>>5<<2)+4|0;g[sa>>2]=+g[sa>>2]*1.0e-20;ka=ka+1|0}while((ka|0)!=(ha|0))}h[aa>>3]=fa*1.0e-20}ra=c[c[j>>2]>>2]|0;sa=ra>>1;a[(c[r>>2]|0)+sa>>0]=(ra&1^1)&255^1;pa=c[q>>2]|0;sa=(c[t>>2]|0)+(sa<<3)|0;c[sa>>2]=ea;c[sa+4>>2]=pa;sa=c[o>>2]|0;c[o>>2]=sa+1;c[(c[v>>2]|0)+(sa<<2)>>2]=ra}h[U>>3]=1.0/+h[u>>3]*+h[U>>3];h[aa>>3]=1.0/+h[Y>>3]*+h[aa>>3];sa=(c[ca>>2]|0)+ -1|0;c[ca>>2]=sa;if(sa)continue;fa=+h[O>>3]*+h[P>>3];h[P>>3]=fa;c[ca>>2]=~~fa;fa=+h[Q>>3]*+h[I>>3];h[I>>3]=fa;if((c[R>>2]|0)<=0)continue;ga=c[C>>2]|0;ea=c[T>>2]|0;oa=c[q>>2]|0;if(!oa)ha=o;else ha=c[p>>2]|0;ha=c[ha>>2]|0;na=c[V>>2]|0;ma=c[W>>2]|0;la=c[X>>2]|0;ka=s;ia=c[ka>>2]|0;ka=c[ka+4>>2]|0;ja=+(c[Z>>2]|0);qa=1.0/ja;if((oa|0)<0)ta=0.0;else{pa=0;ta=0.0;while(1){if(!pa)ra=0;else ra=c[(c[p>>2]|0)+(pa+ -1<<2)>>2]|0;if((pa|0)==(oa|0))sa=o;else sa=(c[p>>2]|0)+(pa<<2)|0;ta=ta+ +S(+qa,+(+(pa|0)))*+((c[sa>>2]|0)-ra|0);if((pa|0)==(oa|0))break;else pa=pa+1|0}}c[_>>2]=ga;c[_+4>>2]=ea-ha;c[_+8>>2]=na;c[_+12>>2]=ma;c[_+16>>2]=~~fa;c[_+20>>2]=la;sa=_+24|0;h[k>>3]=(+(ia>>>0)+4294967296.0*+(ka>>>0))/+(la|0);c[sa>>2]=c[k>>2];c[sa+4>>2]=c[k+4>>2];sa=_+32|0;h[k>>3]=ta/ja*100.0;c[sa>>2]=c[k>>2];c[sa+4>>2]=c[k+4>>2];La(1832,_|0)|0}if((ga|0)==5)a[b>>0]=a[536]|0;else if((ga|0)==14)Ta(va(1)|0,48,0);else if((ga|0)==41){fa=+(c[Z>>2]|0);ja=1.0/fa;r=c[q>>2]|0;if((r|0)<0)qa=0.0;else{q=0;qa=0.0;while(1){if(!q)s=0;else s=c[(c[p>>2]|0)+(q+ -1<<2)>>2]|0;if((q|0)==(r|0))t=o;else t=(c[p>>2]|0)+(q<<2)|0;qa=qa+ +S(+ja,+(+(q|0)))*+((c[t>>2]|0)-s|0);if((q|0)==(r|0))break;else q=q+1|0}}h[e+528>>3]=qa/fa;Rb(e,0);a[b>>0]=a[544]|0}else if((ga|0)==50)a[b>>0]=a[536]|0;else if((ga|0)==57){c[$>>2]=ka^1;sa=e+16|0;c[_+0>>2]=c[$+0>>2];Vb(e,_,sa);a[b>>0]=a[536]|0}else if((ga|0)==60)a[b>>0]=a[528]|0;b=c[j>>2]|0;if(!b){i=n;return}c[m>>2]=0;Td(b);c[j>>2]=0;c[l>>2]=0;i=n;return}function $b(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0.0,w=0,x=0,y=0,z=0.0,A=0,B=0;f=i;i=i+16|0;j=f;e=d+4|0;if(c[e>>2]|0)c[d+8>>2]=0;g=d+36|0;k=d+32|0;if((c[g>>2]|0)>0){l=d+16|0;m=0;do{a[(c[l>>2]|0)+(c[(c[k>>2]|0)+(m<<2)>>2]|0)>>0]=0;m=m+1|0}while((m|0)<(c[g>>2]|0))}if(c[k>>2]|0)c[g>>2]=0;k=d+492|0;if(!(a[k>>0]|0)){a[b>>0]=a[536]|0;i=f;return}l=d+152|0;y=l;y=ne(c[y>>2]|0,c[y+4>>2]|0,1,0)|0;c[l>>2]=y;c[l+4>>2]=F;z=+h[d+120>>3]*+(c[d+208>>2]|0);l=d+640|0;h[l>>3]=z;v=+(c[d+104>>2]|0);if(z<v)h[l>>3]=v;w=c[d+136>>2]|0;h[d+648>>3]=+(w|0);c[d+656>>2]=w;w=a[544]|0;l=d+44|0;if((c[l>>2]|0)>0){Ka(2288)|0;Ka(2368)|0;Ka(2448)|0;Ka(2528)|0;o=a[544]|0}else o=w;n=d+192|0;m=d+184|0;y=o&255;a:do if((y>>>1^1)&w<<24>>24==o<<24>>24|w&2&y){q=d+80|0;t=d+112|0;p=d+108|0;o=d+680|0;r=d+664|0;s=d+672|0;u=0;while(1){v=+h[t>>3];if(!(a[q>>0]|0))v=+S(+v,+(+(u|0)));else{y=u+1|0;if((u|0)>0){x=0;w=1;do{x=x+1|0;w=w<<1|1}while((w|0)<(y|0));y=w+ -1|0}else{x=0;y=0}if((y|0)!=(u|0)){w=u;do{A=y>>1;x=x+ -1|0;w=(w|0)%(A|0)|0;y=A+ -1|0}while((y|0)!=(w|0))}v=+S(+v,+(+(x|0)))}_b(j,d,~~(v*+(c[p>>2]|0)));w=a[j>>0]|0;if(a[o>>0]|0)break a;y=r;x=c[y+4>>2]|0;if((x|0)>=0?(A=n,B=c[A+4>>2]|0,!(B>>>0<x>>>0|((B|0)==(x|0)?(c[A>>2]|0)>>>0<(c[y>>2]|0)>>>0:0))):0)break a;y=s;x=c[y+4>>2]|0;if((x|0)>=0?(B=m,A=c[B+4>>2]|0,!(A>>>0<x>>>0|((A|0)==(x|0)?(c[B>>2]|0)>>>0<(c[y>>2]|0)>>>0:0))):0)break a;A=a[544]|0;B=A&255;if(!((B>>>1^1)&w<<24>>24==A<<24>>24|w&2&B))break;else u=u+1|0}}while(0);if((c[l>>2]|0)>0)Ka(2528)|0;A=a[528]|0;B=A&255;j=w&2;if(!((B>>>1^1)&w<<24>>24==A<<24>>24|j&B)){A=a[536]|0;B=A&255;if(((B>>>1^1)&w<<24>>24==A<<24>>24|j&B|0)!=0?(c[g>>2]|0)==0:0)a[k>>0]=0}else{g=d+540|0;jc(e,c[g>>2]|0);if((c[g>>2]|0)>0){j=d+332|0;k=0;do{a[(c[e>>2]|0)+k>>0]=a[(c[j>>2]|0)+k>>0]|0;k=k+1|0}while((k|0)<(c[g>>2]|0))}}Rb(d,0);a[b>>0]=w;i=f;return}function ac(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;f=i;h=b+412|0;vc(h);k=b+540|0;if((c[k>>2]|0)>0){j=b+544|0;g=0;do{l=g<<1;n=c[h>>2]|0;m=n+(l*12|0)+4|0;if((c[m>>2]|0)>0){p=n+(l*12|0)|0;o=0;do{s=(c[p>>2]|0)+(o<<3)|0;n=c[s>>2]|0;q=c[j>>2]|0;r=q+(n<<2)|0;if(!(c[r>>2]&16)){t=wc(e,r)|0;c[s>>2]=t;c[r>>2]=c[r>>2]|16;c[q+(n+1<<2)>>2]=t}else c[s>>2]=c[q+(n+1<<2)>>2];o=o+1|0}while((o|0)<(c[m>>2]|0));m=c[h>>2]|0}else m=n;n=l|1;l=m+(n*12|0)+4|0;if((c[l>>2]|0)>0){r=m+(n*12|0)|0;q=0;do{m=(c[r>>2]|0)+(q<<3)|0;p=c[m>>2]|0;o=c[j>>2]|0;n=o+(p<<2)|0;if(!(c[n>>2]&16)){t=wc(e,n)|0;c[m>>2]=t;c[n>>2]=c[n>>2]|16;c[o+(p+1<<2)>>2]=t}else c[m>>2]=c[o+(p+1<<2)>>2];q=q+1|0}while((q|0)<(c[l>>2]|0))}g=g+1|0}while((g|0)<(c[k>>2]|0))}g=b+284|0;if((c[g>>2]|0)>0){l=b+280|0;k=b+396|0;j=b+544|0;h=b+332|0;m=0;do{r=c[k>>2]|0;p=r+(c[(c[l>>2]|0)+(m<<2)>>2]>>1<<3)|0;q=c[p>>2]|0;do if((q|0)!=-1){t=c[j>>2]|0;s=t+(q<<2)|0;o=(c[s>>2]&16|0)==0;if(o){u=c[t+(q+1<<2)>>2]|0;n=u>>1;u=(d[(c[h>>2]|0)+n>>0]|0)^u&1;w=a[528]|0;v=w&255;if(!((u&255)<<24>>24==w<<24>>24&(v>>>1^1)|v&2&u))break;w=c[r+(n<<3)>>2]|0;if(!((w|0)!=-1&(w|0)==(q|0)))break;if(o){w=wc(e,s)|0;c[p>>2]=w;c[s>>2]=c[s>>2]|16;c[t+(q+1<<2)>>2]=w;break}}c[p>>2]=c[t+(q+1<<2)>>2]}while(0);m=m+1|0}while((m|0)<(c[g>>2]|0))}g=b+272|0;n=c[g>>2]|0;if((n|0)>0){j=b+268|0;h=b+544|0;m=c[j>>2]|0;k=0;l=0;do{p=m+(k<<2)|0;o=c[p>>2]|0;r=c[h>>2]|0;q=r+(o<<2)|0;s=c[q>>2]|0;if((s&3|0)!=1){if(!(s&16)){n=wc(e,q)|0;c[p>>2]=n;c[q>>2]=c[q>>2]|16;c[r+(o+1<<2)>>2]=n;n=c[j>>2]|0;m=n;n=c[n+(k<<2)>>2]|0}else{n=c[r+(o+1<<2)>>2]|0;c[p>>2]=n}c[m+(l<<2)>>2]=n;n=c[g>>2]|0;l=l+1|0}k=k+1|0}while((k|0)<(n|0))}else{k=0;l=0}h=k-l|0;if((h|0)>0)c[g>>2]=n-h;g=b+260|0;m=c[g>>2]|0;if((m|0)>0){h=b+256|0;b=b+544|0;l=c[h>>2]|0;j=0;k=0;do{n=l+(j<<2)|0;p=c[n>>2]|0;o=c[b>>2]|0;r=o+(p<<2)|0;q=c[r>>2]|0;if((q&3|0)!=1){if(!(q&16)){m=wc(e,r)|0;c[n>>2]=m;c[r>>2]=c[r>>2]|16;c[o+(p+1<<2)>>2]=m;m=c[h>>2]|0;l=m;m=c[m+(j<<2)>>2]|0}else{m=c[o+(p+1<<2)>>2]|0;c[n>>2]=m}c[l+(k<<2)>>2]=m;m=c[g>>2]|0;k=k+1|0}j=j+1|0}while((j|0)<(m|0))}else{j=0;k=0}e=j-k|0;if((e|0)<=0){i=f;return}c[g>>2]=m-e;i=f;return}function bc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0;g=i;i=i+32|0;j=g;d=g+8|0;e=b+548|0;f=b+556|0;h=(c[e>>2]|0)-(c[f>>2]|0)|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;gc(d,h);h=d+16|0;a[h>>0]=0;ac(b,d);if((c[b+44>>2]|0)>1){k=c[d+4>>2]<<2;c[j>>2]=c[e>>2]<<2;c[j+4>>2]=k;La(1888,j|0)|0}a[b+560>>0]=a[h>>0]|0;h=b+544|0;j=c[h>>2]|0;if(j)Td(j);c[h>>2]=c[d>>2];c[e>>2]=c[d+4>>2];c[b+552>>2]=c[d+8>>2];c[f>>2]=c[d+12>>2];i=g;return}function cc(){var d=0,e=0,f=0;d=i;i=i+16|0;e=d;a[528]=0;a[536]=1;a[544]=2;xb(552,608,624,2136,2144);c[138]=2168;h[72]=0.0;h[73]=1.0;a[592]=0;a[593]=0;b[297]=b[e+0>>1]|0;b[298]=b[e+2>>1]|0;b[299]=b[e+4>>1]|0;h[75]=.95;xb(664,720,736,2136,2144);c[166]=2168;h[86]=0.0;h[87]=1.0;a[704]=0;a[705]=0;b[353]=b[e+0>>1]|0;b[354]=b[e+2>>1]|0;b[355]=b[e+4>>1]|0;h[89]=.999;xb(776,832,848,2136,2144);c[194]=2168;h[100]=0.0;h[101]=1.0;a[816]=1;a[817]=1;b[409]=b[e+0>>1]|0;b[410]=b[e+2>>1]|0;b[411]=b[e+4>>1]|0;h[103]=0.0;xb(936,992,1008,2136,2144);c[234]=2168;h[120]=0.0;h[121]=v;a[976]=0;a[977]=0;b[489]=b[e+0>>1]|0;b[490]=b[e+2>>1]|0;b[491]=b[e+4>>1]|0;h[123]=91648253.0;xb(1048,1080,1096,2136,2016);c[262]=280;f=1068|0;c[f>>2]=0;c[f+4>>2]=2;c[269]=2;xb(1160,1192,1208,2136,2016);c[290]=280;f=1180|0;c[f>>2]=0;c[f+4>>2]=2;c[297]=2;xb(1272,1296,1312,2136,1992);c[318]=160;a[1292]=0;xb(1344,1368,1376,2136,1992);c[336]=160;a[1364]=1;xb(1408,1440,1448,2136,2016);c[352]=280;f=1428|0;c[f>>2]=1;c[f+4>>2]=2147483647;c[359]=100;xb(1480,1536,1544,2136,2144);c[370]=2168;h[188]=1.0;h[189]=v;a[1520]=0;a[1521]=0;b[761]=b[e+0>>1]|0;b[762]=b[e+2>>1]|0;b[763]=b[e+4>>1]|0;h[191]=2.0;xb(1584,1640,1648,2136,2144);c[396]=2168;h[201]=0.0;h[202]=v;a[1624]=0;a[1625]=0;b[813]=b[e+0>>1]|0;b[814]=b[e+2>>1]|0;b[815]=b[e+4>>1]|0;h[204]=.2;xb(1728,1760,1776,2136,2016);c[432]=280;e=1748|0;c[e>>2]=0;c[e+4>>2]=2147483647;c[439]=0;i=d;return}function dc(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function ec(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,q=0.0,r=0.0;e=i;i=i+16|0;j=e;g=e+8|0;if((a[d>>0]|0)!=45){o=0;i=e;return o|0}m=d+1|0;f=b+4|0;k=c[f>>2]|0;l=a[k>>0]|0;a:do if(l<<24>>24){n=0;while(1){o=n;n=n+1|0;if((a[m>>0]|0)!=l<<24>>24){b=0;break}l=a[k+n>>0]|0;m=d+(o+2)|0;if(!(l<<24>>24))break a}i=e;return b|0}while(0);if((a[m>>0]|0)!=61){o=0;i=e;return o|0}k=m+1|0;q=+ce(k,g);if(!(c[g>>2]|0)){o=0;i=e;return o|0}r=+h[b+32>>3];if(q>=r?(a[b+41>>0]|0)==0|q!=r:0){o=c[p>>2]|0;n=c[f>>2]|0;c[j>>2]=k;c[j+4>>2]=n;Za(o|0,2024,j|0)|0;ab(1)}r=+h[b+24>>3];if(q<=r?(a[b+40>>0]|0)==0|q!=r:0){o=c[p>>2]|0;n=c[f>>2]|0;c[j>>2]=k;c[j+4>>2]=n;Za(o|0,2080,j|0)|0;ab(1)}h[b+48>>3]=q;o=1;i=e;return o|0}function fc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,j=0,l=0.0,m=0,n=0.0,o=0.0,q=0;e=i;i=i+48|0;f=e;g=c[p>>2]|0;q=c[b+16>>2]|0;m=(a[b+40>>0]|0)!=0?91:40;o=+h[b+24>>3];n=+h[b+32>>3];j=(a[b+41>>0]|0)!=0?93:41;l=+h[b+48>>3];c[f>>2]=c[b+4>>2];c[f+4>>2]=q;c[f+8>>2]=m;m=f+12|0;h[k>>3]=o;c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];m=f+20|0;h[k>>3]=n;c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];c[f+28>>2]=j;j=f+32|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Za(g|0,2232,f|0)|0;if(!d){i=e;return}c[f>>2]=c[b+8>>2];Za(g|0,2e3,f|0)|0;Sa(10,g|0)|0;i=e;return}function gc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=i;e=a+8|0;f=c[e>>2]|0;if(f>>>0<b>>>0)h=f;else{i=d;return}while(1){if(h>>>0>=b>>>0)break;h=((h>>>3)+2+(h>>>1)&-2)+h|0;c[e>>2]=h;if(h>>>0<=f>>>0){g=4;break}}if((g|0)==4)Ta(va(1)|0,48,0);e=Ud(c[a>>2]|0,h<<2)|0;if((e|0)==0?(c[(Oa()|0)>>2]|0)==12:0)Ta(va(1)|0,48,0);c[a>>2]=e;i=d;return}function hc(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0;b=i;e=a+32|0;d=c[e>>2]|0;if(d){c[a+36>>2]=0;Td(d);c[e>>2]=0;c[a+40>>2]=0}e=a+16|0;d=c[e>>2]|0;if(d){c[a+20>>2]=0;Td(d);c[e>>2]=0;c[a+24>>2]=0}e=c[a>>2]|0;if(!e){i=b;return}d=a+4|0;g=c[d>>2]|0;if((g|0)>0){f=0;do{j=e+(f*12|0)|0;h=c[j>>2]|0;if(h){c[e+(f*12|0)+4>>2]=0;Td(h);c[j>>2]=0;c[e+(f*12|0)+8>>2]=0;e=c[a>>2]|0;g=c[d>>2]|0}f=f+1|0}while((f|0)<(g|0))}c[d>>2]=0;Td(e);c[a>>2]=0;c[a+8>>2]=0;i=b;return}function ic(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;i=i+16|0;e=f+4|0;d=f;l=c[b>>2]|0;h=l+1|0;g=a+4|0;if((c[g>>2]|0)<(h|0)){k=a+8|0;j=c[k>>2]|0;if((j|0)<(h|0)){m=l+2-j&-2;l=(j>>1)+2&-2;l=(m|0)>(l|0)?m:l;if((l|0)>(2147483647-j|0)){m=va(1)|0;Ta(m|0,48,0)}n=c[a>>2]|0;m=l+j|0;c[k>>2]=m;m=Ud(n,m*12|0)|0;c[a>>2]=m;if((m|0)==0?(c[(Oa()|0)>>2]|0)==12:0){n=va(1)|0;Ta(n|0,48,0)}}k=c[g>>2]|0;if((k|0)<(h|0)){j=c[a>>2]|0;do{l=j+(k*12|0)|0;if(l){c[l>>2]=0;c[j+(k*12|0)+4>>2]=0;c[j+(k*12|0)+8>>2]=0}k=k+1|0}while((k|0)!=(h|0))}c[g>>2]=h;l=c[b>>2]|0}g=c[a>>2]|0;if(!(c[g+(l*12|0)>>2]|0)){m=l;n=a+16|0;c[d>>2]=m;c[e+0>>2]=c[d+0>>2];sc(n,e,0);i=f;return}c[g+(l*12|0)+4>>2]=0;m=c[b>>2]|0;n=a+16|0;c[d>>2]=m;c[e+0>>2]=c[d+0>>2];sc(n,e,0);i=f;return}function jc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0;f=i;e=b+4|0;if((c[e>>2]|0)>=(d|0)){i=f;return}h=b+8|0;g=c[h>>2]|0;if((g|0)<(d|0)){k=d+1-g&-2;j=(g>>1)+2&-2;j=(k|0)>(j|0)?k:j;if((j|0)>(2147483647-g|0)){k=va(1)|0;Ta(k|0,48,0)}l=c[b>>2]|0;k=j+g|0;c[h>>2]=k;k=Ud(l,k)|0;c[b>>2]=k;if((k|0)==0?(c[(Oa()|0)>>2]|0)==12:0){l=va(1)|0;Ta(l|0,48,0)}}g=c[e>>2]|0;if((g|0)<(d|0)){b=c[b>>2]|0;do{h=b+g|0;if(h)a[h>>0]=0;g=g+1|0}while((g|0)!=(d|0))}c[e>>2]=d;i=f;return}function kc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;h=i;g=d+1|0;f=b+4|0;if((c[f>>2]|0)>=(g|0)){l=c[b>>2]|0;l=l+d|0;a[l>>0]=e;i=h;return}k=b+8|0;j=c[k>>2]|0;if((j|0)<(g|0)){m=d+2-j&-2;l=(j>>1)+2&-2;l=(m|0)>(l|0)?m:l;if((l|0)>(2147483647-j|0)){m=va(1)|0;Ta(m|0,48,0)}n=c[b>>2]|0;m=l+j|0;c[k>>2]=m;m=Ud(n,m)|0;c[b>>2]=m;if((m|0)==0?(c[(Oa()|0)>>2]|0)==12:0){n=va(1)|0;Ta(n|0,48,0)}}j=c[f>>2]|0;if((j|0)<(g|0))do{k=(c[b>>2]|0)+j|0;if(k)a[k>>0]=0;j=j+1|0}while((j|0)!=(g|0));c[f>>2]=g;n=c[b>>2]|0;n=n+d|0;a[n>>0]=e;i=h;return}function lc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;i=i+16|0;g=d;c[g>>2]=b;j=a+12|0;f=b+1|0;e=a+16|0;if((c[e>>2]|0)<(f|0)){l=a+20|0;k=c[l>>2]|0;if((k|0)<(f|0)){n=b+2-k&-2;m=(k>>1)+2&-2;m=(n|0)>(m|0)?n:m;if((m|0)>(2147483647-k|0)){n=va(1)|0;Ta(n|0,48,0)}o=c[j>>2]|0;n=m+k|0;c[l>>2]=n;n=Ud(o,n<<2)|0;c[j>>2]=n;if((n|0)==0?(c[(Oa()|0)>>2]|0)==12:0){o=va(1)|0;Ta(o|0,48,0)}}k=c[e>>2]|0;if((f|0)>(k|0))ke((c[j>>2]|0)+(k<<2)|0,-1,f-k<<2|0)|0;c[e>>2]=f}c[(c[j>>2]|0)+(b<<2)>>2]=c[a+4>>2];nc(a,g);e=c[j>>2]|0;g=c[e+(b<<2)>>2]|0;b=c[a>>2]|0;f=c[b+(g<<2)>>2]|0;if(!g){n=0;o=b+(n<<2)|0;c[o>>2]=f;o=e+(f<<2)|0;c[o>>2]=n;i=d;return}a=a+28|0;while(1){j=g;g=g+ -1>>1;k=b+(g<<2)|0;l=c[k>>2]|0;o=c[c[a>>2]>>2]|0;if(!(+h[o+(f<<3)>>3]>+h[o+(l<<3)>>3])){a=14;break}c[b+(j<<2)>>2]=l;c[e+(c[k>>2]<<2)>>2]=j;if(!g){j=0;a=14;break}}if((a|0)==14){o=b+(j<<2)|0;c[o>>2]=f;o=e+(f<<2)|0;c[o>>2]=j;i=d;return}}function mc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+4|0;f=c[e>>2]|0;g=a+8|0;h=c[g>>2]|0;if((f|0)==(h|0)&(h|0)<(f+1|0)){h=(f>>1)+2&-2;h=(h|0)<2?2:h;if((h|0)>(2147483647-f|0)){h=va(1)|0;Ta(h|0,48,0)}j=c[a>>2]|0;f=h+f|0;c[g>>2]=f;f=Ud(j,f<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}else f=c[a>>2]|0;j=c[e>>2]|0;c[e>>2]=j+1;e=f+(j<<2)|0;if(!e){i=d;return}c[e>>2]=c[b>>2];i=d;return}function nc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+4|0;f=c[e>>2]|0;g=a+8|0;h=c[g>>2]|0;if((f|0)==(h|0)&(h|0)<(f+1|0)){h=(f>>1)+2&-2;h=(h|0)<2?2:h;if((h|0)>(2147483647-f|0)){h=va(1)|0;Ta(h|0,48,0)}j=c[a>>2]|0;f=h+f|0;c[g>>2]=f;f=Ud(j,f<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}else f=c[a>>2]|0;j=c[e>>2]|0;c[e>>2]=j+1;e=f+(j<<2)|0;if(!e){i=d;return}c[e>>2]=c[b>>2];i=d;return}function oc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;e=i;i=i+16|0;f=e+2|0;h=e+1|0;g=e;if((d|0)<16){g=d+ -1|0;if((g|0)>0)h=0;else{i=e;return}do{f=h;h=h+1|0;if((h|0)<(d|0)){k=f;j=h;do{k=(c[b+(j<<2)>>2]|0)<(c[b+(k<<2)>>2]|0)?j:k;j=j+1|0}while((j|0)!=(d|0))}else k=f;n=b+(f<<2)|0;o=c[n>>2]|0;p=b+(k<<2)|0;c[n>>2]=c[p>>2];c[p>>2]=o}while((h|0)!=(g|0));i=e;return}j=c[b+(((d|0)/2|0)<<2)>>2]|0;m=-1;n=d;while(1){do{m=m+1|0;l=b+(m<<2)|0;k=c[l>>2]|0}while((k|0)<(j|0));do{n=n+ -1|0;o=b+(n<<2)|0;p=c[o>>2]|0}while((j|0)<(p|0));if((m|0)>=(n|0))break;c[l>>2]=p;c[o>>2]=k}a[f+0>>0]=a[h+0>>0]|0;oc(b,m,f);p=d-m|0;a[f+0>>0]=a[g+0>>0]|0;oc(l,p,f);i=e;return}function pc(a,b,e){a=a|0;b=b|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0;f=i;k=e&1;j=d[a+16>>0]|0|k;h=b+4|0;l=((j+(c[h>>2]|0)<<2)+4|0)>>>2;m=a+4|0;gc(a,l+(c[m>>2]|0)|0);e=c[m>>2]|0;l=l+e|0;c[m>>2]=l;if(l>>>0<e>>>0)Ta(va(1)|0,48,0);a=(c[a>>2]|0)+(e<<2)|0;if(!a){i=f;return e|0}j=j<<3|k<<2;c[a>>2]=c[a>>2]&-32|j;j=c[h>>2]<<5|j;c[a>>2]=j;if((c[h>>2]|0)>0){j=c[b>>2]|0;b=0;do{c[a+(b<<2)+4>>2]=c[j+(b<<2)>>2];b=b+1|0}while((b|0)<(c[h>>2]|0));j=c[a>>2]|0}if(!(j&8)){i=f;return e|0}h=j>>>5;if(j&4){g[a+(h<<2)+4>>2]=0.0;i=f;return e|0}if(!h){h=0;j=0}else{j=0;b=0;do{j=1<<((c[a+(b<<2)+4>>2]|0)>>>1&31)|j;b=b+1|0}while((b|0)<(h|0))}c[a+(h<<2)+4>>2]=j;i=f;return e|0}function qc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+4|0;f=c[e>>2]|0;g=a+8|0;h=c[g>>2]|0;if((f|0)==(h|0)&(h|0)<(f+1|0)){h=(f>>1)+2&-2;h=(h|0)<2?2:h;if((h|0)>(2147483647-f|0)){h=va(1)|0;Ta(h|0,48,0)}j=c[a>>2]|0;f=h+f|0;c[g>>2]=f;f=Ud(j,f<<3)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}else f=c[a>>2]|0;j=c[e>>2]|0;c[e>>2]=j+1;e=f+(j<<3)|0;if(!e){i=d;return}g=b;h=c[g+4>>2]|0;j=e;c[j>>2]=c[g>>2];c[j+4>>2]=h;i=d;return}function rc(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0.0,s=0;b=i;d=c[a>>2]|0;f=c[d>>2]|0;k=a+4|0;o=c[d+((c[k>>2]|0)+ -1<<2)>>2]|0;c[d>>2]=o;e=c[a+12>>2]|0;c[e+(o<<2)>>2]=0;c[e+(f<<2)>>2]=-1;o=(c[k>>2]|0)+ -1|0;c[k>>2]=o;if((o|0)<=1){i=b;return f|0}g=c[d>>2]|0;l=a+28|0;a=0;m=1;while(1){n=(a<<1)+2|0;if((n|0)<(o|0)){p=c[d+(n<<2)>>2]|0;s=c[d+(m<<2)>>2]|0;o=c[c[l>>2]>>2]|0;q=+h[o+(p<<3)>>3];r=+h[o+(s<<3)>>3];if(!(q>r)){p=s;q=r;j=6}}else{o=c[c[l>>2]>>2]|0;j=c[d+(m<<2)>>2]|0;p=j;q=+h[o+(j<<3)>>3];j=6}if((j|0)==6){j=0;n=m}if(!(q>+h[o+(g<<3)>>3]))break;c[d+(a<<2)>>2]=p;c[e+(p<<2)>>2]=a;m=n<<1|1;o=c[k>>2]|0;if((m|0)>=(o|0)){a=n;break}else a=n}c[d+(a<<2)>>2]=g;c[e+(g<<2)>>2]=a;i=b;return f|0}function sc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;k=c[d>>2]|0;d=k+1|0;g=b+4|0;if((c[g>>2]|0)>=(d|0)){i=f;return}j=b+8|0;h=c[j>>2]|0;if((h|0)<(d|0)){l=k+2-h&-2;k=(h>>1)+2&-2;k=(l|0)>(k|0)?l:k;if((k|0)>(2147483647-h|0)){l=va(1)|0;Ta(l|0,48,0)}m=c[b>>2]|0;l=k+h|0;c[j>>2]=l;l=Ud(m,l)|0;c[b>>2]=l;if((l|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}h=c[g>>2]|0;if((h|0)<(d|0))do{a[(c[b>>2]|0)+h>>0]=e;h=h+1|0}while((h|0)!=(d|0));c[g>>2]=d;i=f;return}function tc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;e=i;i=i+16|0;h=e+8|0;f=e+4|0;j=e;if((b|0)<16){f=b+ -1|0;if((f|0)<=0){i=e;return}h=c[d>>2]|0;d=0;do{j=d;d=d+1|0;if((d|0)<(b|0)){k=c[h>>2]|0;m=j;l=d;do{n=k+(c[a+(l<<2)>>2]<<2)|0;u=c[n>>2]|0;q=u>>>5;if(u>>>0>95){o=k+(c[a+(m<<2)>>2]<<2)|0;p=(c[o>>2]|0)>>>5;if((p|0)==2)m=l;else m=+g[n+(q<<2)+4>>2]<+g[o+(p<<2)+4>>2]?l:m}l=l+1|0}while((l|0)!=(b|0))}else m=j;s=a+(j<<2)|0;t=c[s>>2]|0;u=a+(m<<2)|0;c[s>>2]=c[u>>2];c[u>>2]=t}while((d|0)!=(f|0));i=e;return}k=c[a+(((b|0)/2|0)<<2)>>2]|0;q=-1;o=b;while(1){t=q+1|0;p=a+(t<<2)|0;u=c[p>>2]|0;l=c[d>>2]|0;m=c[l>>2]|0;s=m+(u<<2)|0;r=c[s>>2]|0;q=m+(k<<2)|0;n=c[q>>2]|0;a:do if(r>>>0>95)while(1){v=n>>>5;if((v|0)!=2?!(+g[s+(r>>>5<<2)+4>>2]<+g[q+(v<<2)+4>>2]):0){q=t;break a}t=t+1|0;p=a+(t<<2)|0;u=c[p>>2]|0;s=m+(u<<2)|0;r=c[s>>2]|0;if(r>>>0<=95){q=t;break}}else q=t;while(0);o=o+ -1|0;s=a+(o<<2)|0;r=m+(k<<2)|0;b:do if(n>>>0>95)while(1){t=m+(c[s>>2]<<2)|0;v=(c[t>>2]|0)>>>5;if((v|0)!=2?!(+g[r+(n>>>5<<2)+4>>2]<+g[t+(v<<2)+4>>2]):0)break b;v=o+ -1|0;s=a+(v<<2)|0;o=v}while(0);if((q|0)>=(o|0))break;c[p>>2]=c[s>>2];c[s>>2]=u}c[f>>2]=l;c[h+0>>2]=c[f+0>>2];tc(a,q,h);v=b-q|0;c[j>>2]=l;c[h+0>>2]=c[j+0>>2];tc(p,v,h);i=e;return}function uc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0.0,s=0;e=i;f=a+4|0;j=c[f>>2]|0;g=c[a>>2]|0;if((j|0)>0){l=c[a+12>>2]|0;k=0;do{c[l+(c[g+(k<<2)>>2]<<2)>>2]=-1;k=k+1|0;j=c[f>>2]|0}while((k|0)<(j|0))}if(g){c[f>>2]=0;j=0}g=b+4|0;if((c[g>>2]|0)>0){k=a+12|0;j=0;do{s=(c[b>>2]|0)+(j<<2)|0;c[(c[k>>2]|0)+(c[s>>2]<<2)>>2]=j;nc(a,s);j=j+1|0}while((j|0)<(c[g>>2]|0));j=c[f>>2]|0}if((j|0)<=1){i=e;return}g=c[a>>2]|0;b=a+28|0;a=a+12|0;o=j;k=(j|0)/2|0;while(1){k=k+ -1|0;j=c[g+(k<<2)>>2]|0;m=k<<1|1;a:do if((m|0)<(o|0)){l=k;while(1){n=(l<<1)+2|0;if((n|0)<(o|0)){p=c[g+(n<<2)>>2]|0;s=c[g+(m<<2)>>2]|0;o=c[c[b>>2]>>2]|0;q=+h[o+(p<<3)>>3];r=+h[o+(s<<3)>>3];if(!(q>r)){p=s;q=r;d=16}}else{o=c[c[b>>2]>>2]|0;d=c[g+(m<<2)>>2]|0;p=d;q=+h[o+(d<<3)>>3];d=16}if((d|0)==16){d=0;n=m}if(!(q>+h[o+(j<<3)>>3]))break a;c[g+(l<<2)>>2]=p;c[(c[a>>2]|0)+(p<<2)>>2]=l;m=n<<1|1;o=c[f>>2]|0;if((m|0)>=(o|0)){l=n;break}else l=n}}else l=k;while(0);c[g+(l<<2)>>2]=j;c[(c[a>>2]|0)+(j<<2)>>2]=l;if((k|0)<=0)break;o=c[f>>2]|0}i=e;return}function vc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;e=i;d=b+36|0;l=c[d>>2]|0;f=b+32|0;n=c[f>>2]|0;if((l|0)>0){h=b+16|0;g=b+44|0;j=0;do{k=n+(j<<2)|0;m=c[k>>2]|0;if(a[(c[h>>2]|0)+m>>0]|0){n=c[b>>2]|0;l=n+(m*12|0)+4|0;p=c[l>>2]|0;if((p|0)>0){m=n+(m*12|0)|0;n=0;o=0;do{q=c[m>>2]|0;r=q+(n<<3)|0;if((c[(c[c[g>>2]>>2]|0)+(c[r>>2]<<2)>>2]&3|0)!=1){s=r;r=c[s+4>>2]|0;p=q+(o<<3)|0;c[p>>2]=c[s>>2];c[p+4>>2]=r;p=c[l>>2]|0;o=o+1|0}n=n+1|0}while((n|0)<(p|0))}else{n=0;o=0}m=n-o|0;if((m|0)>0)c[l>>2]=p-m;a[(c[h>>2]|0)+(c[k>>2]|0)>>0]=0;l=c[d>>2]|0;n=c[f>>2]|0}j=j+1|0}while((j|0)<(l|0))}if(!n){i=e;return}c[d>>2]=0;i=e;return}function wc(a,b){a=a|0;b=b|0;var e=0,f=0,h=0,j=0,k=0;f=i;j=c[b>>2]|0;h=j>>>2&1|(d[a+16>>0]|0);j=((h+(j>>>5)<<2)+4|0)>>>2;k=a+4|0;gc(a,j+(c[k>>2]|0)|0);e=c[k>>2]|0;j=j+e|0;c[k>>2]=j;if(j>>>0<e>>>0)Ta(va(1)|0,48,0);a=(c[a>>2]|0)+(e<<2)|0;if(!a){i=f;return e|0}h=c[b>>2]&-9|h<<3;c[a>>2]=h;if((c[b>>2]|0)>>>0>31){h=0;do{c[a+(h<<2)+4>>2]=c[b+(h<<2)+4>>2];h=h+1|0}while((h|0)<((c[b>>2]|0)>>>5|0));h=c[a>>2]|0}if(!(h&8)){i=f;return e|0}j=h>>>5;b=b+(j<<2)+4|0;if(!(h&4)){c[a+(j<<2)+4>>2]=c[b>>2];i=f;return e|0}else{g[a+(j<<2)+4>>2]=+g[b>>2];i=f;return e|0}return 0}function xc(b){b=b|0;var d=0,e=0,f=0,g=0,j=0,k=0;d=i;i=i+16|0;g=d;Gb(b);c[b>>2]=3424;c[b+684>>2]=c[719];c[b+688>>2]=c[747];c[b+692>>2]=c[785];h[b+696>>3]=+h[411];a[b+704>>0]=a[2652]|0;a[b+705>>0]=a[2724]|0;a[b+706>>0]=a[2804]|0;a[b+707>>0]=1;c[b+708>>2]=0;c[b+712>>2]=0;c[b+716>>2]=0;c[b+720>>2]=1;a[b+724>>0]=1;e=b+732|0;k=b+544|0;c[b+760>>2]=0;c[b+764>>2]=0;c[b+768>>2]=0;c[b+776>>2]=0;c[b+780>>2]=0;c[b+784>>2]=0;c[b+792>>2]=0;c[b+796>>2]=0;c[b+800>>2]=0;j=b+804|0;c[e+0>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[j>>2]=k;j=b+808|0;c[j>>2]=0;c[b+812>>2]=0;c[b+816>>2]=0;e=b+824|0;c[e+0>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;c[b+852>>2]=j;Qc(b+856|0,1);j=b+868|0;e=b+892|0;c[b+920>>2]=0;c[b+924>>2]=0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;c[j+16>>2]=0;c[e+0>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0;c[e+16>>2]=0;c[e+20>>2]=0;e=g+4|0;c[e>>2]=0;j=g+8|0;c[j>>2]=2;f=Ud(0,8)|0;c[g>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0)Ta(va(1)|0,48,0);c[f>>2]=-2;c[e>>2]=1;a[b+560>>0]=1;c[b+928>>2]=pc(k,g,0)|0;a[b+536>>0]=0;if(!f){i=d;return}c[e>>2]=0;Td(f);c[g>>2]=0;c[j>>2]=0;i=d;return}function yc(a){a=a|0;var b=0;b=i;zc(a);pd(a);i=b;return}function zc(a){a=a|0;var b=0,d=0,e=0;b=i;c[a>>2]=3424;d=a+904|0;e=c[d>>2]|0;if(e){c[a+908>>2]=0;Td(e);c[d>>2]=0;c[a+912>>2]=0}d=a+892|0;e=c[d>>2]|0;if(e){c[a+896>>2]=0;Td(e);c[d>>2]=0;c[a+900>>2]=0}d=a+876|0;e=c[d>>2]|0;if(e){c[a+880>>2]=0;Td(e);c[d>>2]=0;c[a+884>>2]=0}d=a+856|0;e=c[d>>2]|0;if(e){c[a+860>>2]=0;Td(e);c[d>>2]=0;c[a+864>>2]=0}e=a+836|0;d=c[e>>2]|0;if(d){c[a+840>>2]=0;Td(d);c[e>>2]=0;c[a+844>>2]=0}d=a+824|0;e=c[d>>2]|0;if(e){c[a+828>>2]=0;Td(e);c[d>>2]=0;c[a+832>>2]=0}d=a+808|0;e=c[d>>2]|0;if(e){c[a+812>>2]=0;Td(e);c[d>>2]=0;c[a+816>>2]=0}Rc(a+760|0);d=a+744|0;e=c[d>>2]|0;if(e){c[a+748>>2]=0;Td(e);c[d>>2]=0;c[a+752>>2]=0}d=a+732|0;e=c[d>>2]|0;if(!e){Ib(a);i=b;return}c[a+736>>2]=0;Td(e);c[d>>2]=0;c[a+740>>2]=0;Ib(a);i=b;return}function Ac(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0;f=i;i=i+32|0;h=f+12|0;k=f+8|0;l=f+16|0;g=f+4|0;j=f;a[l>>0]=a[d>>0]|0;a[h+0>>0]=a[l+0>>0]|0;e=Jb(b,h,e)|0;c[k>>2]=e;kc(b+876|0,e,0);kc(b+904|0,e,0);if(!(a[b+724>>0]|0)){i=f;return e|0}l=b+808|0;d=e<<1;c[g>>2]=d;c[h+0>>2]=c[g+0>>2];Sc(l,h,0);c[j>>2]=d|1;c[h+0>>2]=c[j+0>>2];Sc(l,h,0);Tc(b+760|0,k);kc(b+744|0,e,0);Uc(b+824|0,e);i=f;return e|0}function Bc(b,e,f,g){b=b|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;k=i;i=i+32|0;h=k+4|0;r=k;p=k+16|0;c[h>>2]=0;j=h+4|0;c[j>>2]=0;l=h+8|0;c[l>>2]=0;s=a[2608]|0;a[b>>0]=s;m=e+724|0;f=(d[m>>0]&(f&1)|0)!=0;if(f){u=e+308|0;x=c[u>>2]|0;if((x|0)>0){t=e+304|0;s=e+876|0;v=0;do{w=c[(c[t>>2]|0)+(v<<2)>>2]>>1;c[r>>2]=w;w=(c[s>>2]|0)+w|0;if(!(a[w>>0]|0)){a[w>>0]=1;nc(h,r);x=c[u>>2]|0}v=v+1|0}while((v|0)<(x|0))}r=(Cc(e,g)|0)&1^1;a[b>>0]=r;g=a[2608]|0}else{g=s;r=s}x=g&255;if(!((x>>>1^1)&r<<24>>24==g<<24>>24|x&2&(r&255))){if((c[e+44>>2]|0)>0)Ka(3760)|0}else{$b(p,e);r=a[p>>0]|0;a[b>>0]=r}w=a[2608]|0;x=w&255;if((((x>>>1^1)&r<<24>>24==w<<24>>24|x&2&(r&255)|0)!=0?(a[e+707>>0]|0)!=0:0)?(q=(c[e+736>>2]|0)+ -1|0,(q|0)>0):0){b=e+732|0;p=e+4|0;do{g=c[b>>2]|0;u=c[g+(q<<2)>>2]|0;v=q+ -1|0;w=c[g+(v<<2)>>2]|0;q=c[p>>2]|0;a:do if((u|0)>1){s=a[2616]|0;r=s&255;t=r&2;r=r>>>1^1;x=v;while(1){w=d[q+(w>>1)>>0]^w&1;v=u+ -1|0;if(!((w&255)<<24>>24==s<<24>>24&r|t&w))break a;u=x+ -1|0;w=c[g+(u<<2)>>2]|0;if((v|0)>1){x=u;u=v}else{x=u;u=v;o=20;break}}}else{x=v;o=20}while(0);if((o|0)==20){o=0;a[q+(w>>1)>>0]=(w&1^1)&255^1}q=x-u|0}while((q|0)>0)}if(f?(n=c[j>>2]|0,(n|0)>0):0){o=c[h>>2]|0;f=e+876|0;p=0;do{b=c[o+(p<<2)>>2]|0;a[(c[f>>2]|0)+b>>0]=0;if(a[m>>0]|0)Vc(e,b);p=p+1|0}while((p|0)<(n|0))}e=c[h>>2]|0;if(!e){i=k;return}c[j>>2]=0;Td(e);c[h>>2]=0;c[l>>2]=0;i=k;return}function Cc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;m=i;i=i+16|0;j=m;if(!(Zb(b)|0)){H=0;i=m;return H|0}l=b+724|0;if(!(a[l>>0]|0)){H=1;i=m;return H|0}x=b+924|0;v=b+872|0;w=b+868|0;u=b+860|0;r=b+680|0;y=b+824|0;g=b+828|0;o=b+836|0;z=b+904|0;A=b+332|0;e=b+44|0;B=b+704|0;D=b+706|0;E=b+696|0;p=b+556|0;q=b+548|0;C=b+876|0;s=b+920|0;t=b+284|0;a:while(1){if(((c[x>>2]|0)<=0?(c[s>>2]|0)>=(c[t>>2]|0):0)?(c[g>>2]|0)<=0:0)break;Ic(b);G=c[v>>2]|0;H=c[w>>2]|0;F=G-H|0;if((G|0)<(H|0))F=(c[u>>2]|0)+F|0;if(!((F|0)<=0?(c[s>>2]|0)>=(c[t>>2]|0):0))n=11;if((n|0)==11?(n=0,!(Jc(b,1)|0)):0){n=12;break}H=c[g>>2]|0;if(a[r>>0]|0){n=15;break}if(!H)continue;else F=0;while(1){J=c[y>>2]|0;G=c[J>>2]|0;I=c[J+(H+ -1<<2)>>2]|0;c[J>>2]=I;H=c[o>>2]|0;c[H+(I<<2)>>2]=0;c[H+(G<<2)>>2]=-1;H=(c[g>>2]|0)+ -1|0;c[g>>2]=H;if((H|0)>1)Wc(y,0);if(a[r>>0]|0)continue a;if((a[(c[z>>2]|0)+G>>0]|0)==0?(I=a[(c[A>>2]|0)+G>>0]|0,H=a[2624]|0,J=H&255,((J>>>1^1)&I<<24>>24==H<<24>>24|I&2&J|0)!=0):0){if((c[e>>2]|0)>1&((F|0)%100|0|0)==0){c[j>>2]=c[g>>2];La(3504,j|0)|0}if(a[B>>0]|0){J=(c[C>>2]|0)+G|0;H=a[J>>0]|0;a[J>>0]=1;if(!(Lc(b,G)|0)){n=29;break a}a[(c[C>>2]|0)+G>>0]=H<<24>>24!=0&1}if((((a[D>>0]|0)!=0?(I=a[(c[A>>2]|0)+G>>0]|0,H=a[2624]|0,J=H&255,((J>>>1^1)&I<<24>>24==H<<24>>24|I&2&J|0)!=0):0)?(a[(c[C>>2]|0)+G>>0]|0)==0:0)?!(Mc(b,G)|0):0){n=35;break a}if(+((c[p>>2]|0)>>>0)>+h[E>>3]*+((c[q>>2]|0)>>>0))gb[c[(c[b>>2]|0)+8>>2]&31](b)}H=c[g>>2]|0;if(!H)continue a;else F=F+1|0}}do if((n|0)==12)a[b+492>>0]=0;else if((n|0)==15){r=c[b+824>>2]|0;if((H|0)<=0){if(!r)break}else{t=c[o>>2]|0;s=0;do{c[t+(c[r+(s<<2)>>2]<<2)>>2]=-1;s=s+1|0}while((s|0)<(c[g>>2]|0))}c[g>>2]=0}else if((n|0)==29)a[b+492>>0]=0;else if((n|0)==35)a[b+492>>0]=0;while(0);if(!d){if(+((c[p>>2]|0)>>>0)>+h[b+96>>3]*+((c[q>>2]|0)>>>0))gb[c[(c[b>>2]|0)+8>>2]&31](b)}else{d=b+744|0;p=c[d>>2]|0;if(p){c[b+748>>2]=0;Td(p);c[d>>2]=0;c[b+752>>2]=0}Xc(b+760|0,1);d=b+808|0;p=c[d>>2]|0;if(p){c[b+812>>2]=0;Td(p);c[d>>2]=0;c[b+816>>2]=0}p=b+824|0;d=c[p>>2]|0;if((c[g>>2]|0)<=0){if(d)n=48}else{n=c[o>>2]|0;o=0;do{c[n+(c[d+(o<<2)>>2]<<2)>>2]=-1;o=o+1|0}while((o|0)<(c[g>>2]|0));n=48}if((n|0)==48){c[g>>2]=0;Td(d);c[p>>2]=0;c[b+832>>2]=0}Yc(b+856|0,1);a[l>>0]=0;a[b+536>>0]=1;a[b+560>>0]=0;c[b+728>>2]=c[b+540>>2];Yb(b);gb[c[(c[b>>2]|0)+8>>2]&31](b)}if((c[e>>2]|0)>0?(f=c[b+736>>2]|0,(f|0)>0):0){h[k>>3]=+(f<<2>>>0)*9.5367431640625e-7;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];La(3528,j|0)|0}J=(a[b+492>>0]|0)!=0;i=m;return J|0}function Dc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;e=i;i=i+16|0;g=e;j=b+256|0;k=b+260|0;h=c[k>>2]|0;if((a[b+705>>0]|0)!=0?Ec(b,d)|0:0){p=1;i=e;return p|0}if(!(Kb(b,d)|0)){p=0;i=e;return p|0}if(!(a[b+724>>0]|0)){p=1;i=e;return p|0}d=c[k>>2]|0;if((d|0)!=(h+1|0)){p=1;i=e;return p|0}p=c[(c[j>>2]|0)+(d+ -1<<2)>>2]|0;c[g>>2]=p;m=(c[b+544>>2]|0)+(p<<2)|0;Zc(b+856|0,p);if((c[m>>2]|0)>>>0<=31){p=1;i=e;return p|0}l=b+760|0;k=b+808|0;j=b+744|0;h=b+924|0;d=b+824|0;n=b+840|0;b=b+836|0;o=0;do{p=m+(o<<2)+4|0;_c((c[l>>2]|0)+((c[p>>2]>>1)*12|0)|0,g);q=(c[k>>2]|0)+(c[p>>2]<<2)|0;c[q>>2]=(c[q>>2]|0)+1;a[(c[j>>2]|0)+(c[p>>2]>>1)>>0]=1;c[h>>2]=(c[h>>2]|0)+1;p=c[p>>2]>>1;if((c[n>>2]|0)>(p|0)?(f=c[(c[b>>2]|0)+(p<<2)>>2]|0,(f|0)>-1):0)Wc(d,f);o=o+1|0}while((o|0)<((c[m>>2]|0)>>>5|0));f=1;i=e;return f|0}function Ec(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;k=i;i=i+16|0;h=k+8|0;j=k+4|0;g=k;c[j>>2]=c[b+284>>2];nc(b+292|0,j);j=e+4|0;m=c[j>>2]|0;a:do if((m|0)>0){f=b+332|0;l=0;while(1){n=c[(c[e>>2]|0)+(l<<2)>>2]|0;p=d[(c[f>>2]|0)+(n>>1)>>0]|0;q=p^n&1;o=q&255;s=a[2608]|0;r=s&255;if(o<<24>>24==s<<24>>24&(r>>>1^1)|r&2&q)break;r=a[2616]|0;s=r&255;if(!((s>>>1^1)&o<<24>>24==r<<24>>24|p&2&s)){c[g>>2]=n^1;c[h+0>>2]=c[g+0>>2];Lb(b,h,-1);m=c[j>>2]|0}l=l+1|0;if((l|0)>=(m|0))break a}Rb(b,0);s=1;i=k;return s|0}while(0);s=(Mb(b)|0)!=-1;Rb(b,0);i=k;return s|0}function Fc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;e=i;i=i+16|0;g=e;f=(c[b+544>>2]|0)+(d<<2)|0;if(!(a[b+724>>0]|0)){Pb(b,d);i=e;return}if((c[f>>2]|0)>>>0<=31){Pb(b,d);i=e;return}j=b+808|0;k=b+776|0;h=b+792|0;l=0;do{m=f+(l<<2)+4|0;n=(c[j>>2]|0)+(c[m>>2]<<2)|0;c[n>>2]=(c[n>>2]|0)+ -1;Vc(b,c[m>>2]>>1);m=c[m>>2]>>1;c[g>>2]=m;m=(c[k>>2]|0)+m|0;if(!(a[m>>0]|0)){a[m>>0]=1;nc(h,g)}l=l+1|0}while((l|0)<((c[f>>2]|0)>>>5|0));Pb(b,d);i=e;return}function Gc(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;g=i;i=i+16|0;j=g+4|0;h=g;l=c[b+544>>2]|0;k=l+(e<<2)|0;Zc(b+856|0,e);if((c[k>>2]&-32|0)==64){Fc(b,e);p=c[f>>2]|0;f=c[k>>2]|0;a:do if(f>>>0>31){m=f>>>5;n=0;while(1){o=n+1|0;if((c[k+(n<<2)+4>>2]|0)==(p|0)){o=n;break a}if((o|0)<(m|0))n=o;else break}}else{m=0;o=0}while(0);n=m+ -1|0;if((o|0)<(n|0))do{f=o;o=o+1|0;c[k+(f<<2)+4>>2]=c[k+(o<<2)+4>>2];f=c[k>>2]|0;m=f>>>5;n=m+ -1|0}while((o|0)<(n|0));if(f&8){c[k+(n<<2)+4>>2]=c[k+(m<<2)+4>>2];f=c[k>>2]|0}m=f+ -32|0;c[k>>2]=m;m=m>>>5;if(!m){m=0;f=0}else{f=0;n=0;do{f=1<<((c[k+(n<<2)+4>>2]|0)>>>1&31)|f;n=n+1|0}while((n|0)<(m|0))}c[k+(m<<2)+4>>2]=f}else{Ob(b,e,1);f=c[f>>2]|0;n=c[k>>2]|0;b:do if(n>>>0>31){m=n>>>5;o=0;while(1){p=o+1|0;if((c[k+(o<<2)+4>>2]|0)==(f|0)){p=o;break b}if((p|0)<(m|0))o=p;else break}}else{m=0;p=0}while(0);o=m+ -1|0;if((p|0)<(o|0))do{n=p;p=p+1|0;c[k+(n<<2)+4>>2]=c[k+(p<<2)+4>>2];n=c[k>>2]|0;m=n>>>5;o=m+ -1|0}while((p|0)<(o|0));if(n&8){c[k+(o<<2)+4>>2]=c[k+(m<<2)+4>>2];n=c[k>>2]|0}o=n+ -32|0;c[k>>2]=o;o=o>>>5;if(!o){o=0;m=0}else{m=0;n=0;do{m=1<<((c[k+(n<<2)+4>>2]|0)>>>1&31)|m;n=n+1|0}while((n|0)<(o|0))}c[k+(o<<2)+4>>2]=m;Nb(b,e);m=f>>1;n=c[b+760>>2]|0;o=n+(m*12|0)|0;n=n+(m*12|0)+4|0;p=c[n>>2]|0;c:do if((p|0)>0){s=c[o>>2]|0;q=0;while(1){r=q+1|0;if((c[s+(q<<2)>>2]|0)==(e|0))break c;if((r|0)<(p|0))q=r;else{q=r;break}}}else q=0;while(0);p=p+ -1|0;if((q|0)<(p|0)){o=c[o>>2]|0;do{p=q;q=q+1|0;c[o+(p<<2)>>2]=c[o+(q<<2)>>2];p=(c[n>>2]|0)+ -1|0}while((q|0)<(p|0))}c[n>>2]=p;s=(c[b+808>>2]|0)+(f<<2)|0;c[s>>2]=(c[s>>2]|0)+ -1;Vc(b,m)}if((c[k>>2]&-32|0)!=32){s=1;i=g;return s|0}l=c[l+(e+1<<2)>>2]|0;k=d[(c[b+332>>2]|0)+(l>>1)>>0]|0;s=k^l&1;e=s&255;q=a[2624]|0;r=q&255;if(!(e<<24>>24==q<<24>>24&(r>>>1^1)|r&2&s)){r=a[2616]|0;s=r&255;if((s>>>1^1)&e<<24>>24==r<<24>>24|k&2&s){s=0;i=g;return s|0}}else{c[h>>2]=l;c[j+0>>2]=c[h+0>>2];Lb(b,j,-1)}s=(Mb(b)|0)==-1;i=g;return s|0}function Hc(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;g=i;i=i+16|0;j=g+4|0;h=g;o=a+708|0;c[o>>2]=(c[o>>2]|0)+1;if(c[f>>2]|0)c[f+4>>2]=0;k=(c[b>>2]|0)>>>5>>>0<(c[d>>2]|0)>>>5>>>0;a=k?d:b;b=k?b:d;k=c[b>>2]|0;a:do if(k>>>0>31){d=0;b:while(1){l=c[b+(d<<2)+4>>2]|0;c:do if((l>>1|0)!=(e|0)){m=c[a>>2]|0;d:do if(m>>>0>31){n=0;while(1){o=c[a+(n<<2)+4>>2]|0;n=n+1|0;if((l^o)>>>0<2)break;if((n|0)>=(m>>>5|0))break d}if((o|0)==(l^1|0)){f=0;break b}else break c}while(0);c[j>>2]=l;mc(f,j);k=c[b>>2]|0}while(0);d=d+1|0;if((d|0)>=(k>>>5|0))break a}i=g;return f|0}while(0);d=c[a>>2]|0;if(d>>>0<=31){o=1;i=g;return o|0}j=0;do{b=c[a+(j<<2)+4>>2]|0;if((b>>1|0)!=(e|0)){c[h>>2]=b;mc(f,h);d=c[a>>2]|0}j=j+1|0}while((j|0)<(d>>>5|0));f=1;i=g;return f|0}function Ic(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;d=i;k=b+924|0;if(!(c[k>>2]|0)){i=d;return}h=b+856|0;e=b+872|0;f=b+868|0;j=b+860|0;g=b+544|0;l=0;while(1){w=c[e>>2]|0;m=c[f>>2]|0;n=w-m|0;if((w|0)<(m|0))n=(c[j>>2]|0)+n|0;if((l|0)>=(n|0))break;n=(c[g>>2]|0)+(c[(c[h>>2]|0)+(((m+l|0)%(c[j>>2]|0)|0)<<2)>>2]<<2)|0;m=c[n>>2]|0;if(!(m&3))c[n>>2]=m&-4|2;l=l+1|0}l=b+540|0;q=c[l>>2]|0;if((q|0)>0){n=b+744|0;o=b+776|0;m=b+760|0;b=b+804|0;p=0;do{if(a[(c[n>>2]|0)+p>>0]|0){r=(c[o>>2]|0)+p|0;if(a[r>>0]|0){s=c[m>>2]|0;q=s+(p*12|0)+4|0;u=c[q>>2]|0;if((u|0)>0){s=c[s+(p*12|0)>>2]|0;v=0;t=0;do{w=c[s+(v<<2)>>2]|0;if((c[(c[c[b>>2]>>2]|0)+(w<<2)>>2]&3|0)!=1){c[s+(t<<2)>>2]=w;u=c[q>>2]|0;t=t+1|0}v=v+1|0}while((v|0)<(u|0))}else{v=0;t=0}s=v-t|0;if((s|0)>0)c[q>>2]=u-s;a[r>>0]=0}r=c[m>>2]|0;q=r+(p*12|0)+4|0;t=c[q>>2]|0;if((t|0)>0){r=r+(p*12|0)|0;s=0;do{u=c[(c[r>>2]|0)+(s<<2)>>2]|0;if(!(c[(c[g>>2]|0)+(u<<2)>>2]&3)){Zc(h,u);t=(c[g>>2]|0)+(c[(c[r>>2]|0)+(s<<2)>>2]<<2)|0;c[t>>2]=c[t>>2]&-4|2;t=c[q>>2]|0}s=s+1|0}while((s|0)<(t|0))}a[(c[n>>2]|0)+p>>0]=0;q=c[l>>2]|0}p=p+1|0}while((p|0)<(q|0));l=0}else l=0;while(1){w=c[e>>2]|0;m=c[f>>2]|0;n=w-m|0;if((w|0)<(m|0))n=(c[j>>2]|0)+n|0;if((l|0)>=(n|0))break;m=(c[g>>2]|0)+(c[(c[h>>2]|0)+(((m+l|0)%(c[j>>2]|0)|0)<<2)>>2]<<2)|0;n=c[m>>2]|0;if((n&3|0)==2)c[m>>2]=n&-4;l=l+1|0}c[k>>2]=0;i=d;return}function Jc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;e=i;i=i+16|0;m=e;x=e+12|0;g=b+856|0;l=b+872|0;q=b+868|0;j=b+860|0;u=b+680|0;f=b+920|0;h=b+284|0;t=b+280|0;r=b+544|0;s=b+928|0;o=b+44|0;n=b+776|0;v=b+692|0;p=b+804|0;k=b+760|0;C=0;F=0;D=0;a:while(1){E=c[q>>2]|0;do{A=c[l>>2]|0;B=(A|0)<(E|0);A=A-E|0;if(B)G=(c[j>>2]|0)+A|0;else G=A;if((G|0)<=0?(c[f>>2]|0)>=(c[h>>2]|0):0){f=1;j=53;break a}if(a[u>>0]|0){j=8;break a}if(B)A=(c[j>>2]|0)+A|0;if((A|0)==0?(z=c[f>>2]|0,(z|0)<(c[h>>2]|0)):0){c[f>>2]=z+1;c[(c[r>>2]|0)+((c[s>>2]|0)+1<<2)>>2]=c[(c[t>>2]|0)+(z<<2)>>2];A=(c[r>>2]|0)+(c[s>>2]<<2)|0;B=(c[A>>2]|0)>>>5;if(!B){B=0;G=0}else{G=0;E=0;do{G=1<<((c[A+(E<<2)+4>>2]|0)>>>1&31)|G;E=E+1|0}while((E|0)<(B|0))}c[A+(B<<2)+4>>2]=G;Zc(g,c[s>>2]|0);E=c[q>>2]|0}A=c[(c[g>>2]|0)+(E<<2)>>2]|0;E=E+1|0;J=c[j>>2]|0;E=(E|0)==(J|0)?0:E;c[q>>2]=E;G=c[r>>2]|0;B=G+(A<<2)|0;I=c[B>>2]|0}while((I&3|0)!=0);if(d?(c[o>>2]|0)>1:0){H=C+1|0;if(!((C|0)%1e3|0)){I=c[l>>2]|0;c[m>>2]=I-E+((I|0)<(E|0)?J:0);c[m+4>>2]=D;c[m+8>>2]=F;La(3440,m|0)|0;I=c[B>>2]|0;C=H}else C=H}E=G+(A+1<<2)|0;G=c[E>>2]>>1;if(I>>>0>63){H=c[k>>2]|0;I=I>>>5;J=1;do{P=c[B+(J<<2)+4>>2]>>1;G=(c[H+(P*12|0)+4>>2]|0)<(c[H+(G*12|0)+4>>2]|0)?P:G;J=J+1|0}while((J|0)<(I|0))}I=(c[n>>2]|0)+G|0;if(a[I>>0]|0){J=c[k>>2]|0;H=J+(G*12|0)+4|0;M=c[H>>2]|0;if((M|0)>0){J=c[J+(G*12|0)>>2]|0;L=0;K=0;do{N=c[J+(L<<2)>>2]|0;if((c[(c[c[p>>2]>>2]|0)+(N<<2)>>2]&3|0)!=1){c[J+(K<<2)>>2]=N;M=c[H>>2]|0;K=K+1|0}L=L+1|0}while((L|0)<(M|0))}else{L=0;K=0}J=L-K|0;if((J|0)>0)c[H>>2]=M-J;a[I>>0]=0}I=c[k>>2]|0;H=c[I+(G*12|0)>>2]|0;I=I+(G*12|0)+4|0;if((c[I>>2]|0)>0)J=0;else continue;while(1){N=c[B>>2]|0;if(N&3)continue a;K=c[H+(J<<2)>>2]|0;L=c[r>>2]|0;O=L+(K<<2)|0;M=c[O>>2]|0;b:do if(((!((M&3|0)!=0|(K|0)==(A|0))?(P=c[v>>2]|0,y=M>>>5,(P|0)==-1|(y|0)<(P|0)):0)?(w=N>>>5,y>>>0>=w>>>0):0)?(c[B+(w<<2)+4>>2]&~c[O+(y<<2)+4>>2]|0)==0:0){L=L+(K+1<<2)|0;do if(N>>>0>31){if(M>>>0>31){O=-2;M=0}else break b;while(1){N=c[E+(M<<2)>>2]|0;c:do if((O|0)==-2){P=0;while(1){O=c[L+(P<<2)>>2]|0;if((N|0)==(O|0)){N=-2;break c}P=P+1|0;if((N|0)==(O^1|0))break c;if(P>>>0>=y>>>0)break b}}else{P=0;while(1){if((N|0)==(c[L+(P<<2)>>2]|0)){N=O;break c}P=P+1|0;if(P>>>0>=y>>>0)break b}}while(0);M=M+1|0;if(M>>>0>=w>>>0)break;else O=N}if((N|0)==-2)break;else if((N|0)==-1)break b;c[x>>2]=N^1;c[m+0>>2]=c[x+0>>2];if(!(Gc(b,K,m)|0)){f=0;j=53;break a}F=F+1|0;J=(((N>>1|0)==(G|0))<<31>>31)+J|0;break b}while(0);Fc(b,K);D=D+1|0}while(0);J=J+1|0;if((J|0)>=(c[I>>2]|0))continue a}}if((j|0)==8){Yc(g,0);c[f>>2]=c[h>>2];P=1;i=e;return P|0}else if((j|0)==53){i=e;return f|0}return 0}function Kc(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;h=i;i=i+16|0;g=h+12|0;m=h+8|0;k=h+4|0;j=h;l=(c[b+544>>2]|0)+(f<<2)|0;if(c[l>>2]&3){r=1;i=h;return r|0}if(Qb(b,l)|0){r=1;i=h;return r|0}c[m>>2]=c[b+284>>2];nc(b+292|0,m);p=c[l>>2]|0;if(p>>>0>31){m=b+332|0;n=0;o=-2;do{q=c[l+(n<<2)+4>>2]|0;r=q>>1;if((r|0)!=(e|0)?(r=(d[(c[m>>2]|0)+r>>0]|0)^q&1,t=a[2616]|0,s=t&255,((r&255)<<24>>24==t<<24>>24&(s>>>1^1)|s&2&r|0)==0):0){c[k>>2]=q^1;c[g+0>>2]=c[k+0>>2];Lb(b,g,-1);p=c[l>>2]|0}else o=q;n=n+1|0}while((n|0)<(p>>>5|0))}else o=-2;t=(Mb(b)|0)==-1;Rb(b,0);if(!t){t=b+712|0;c[t>>2]=(c[t>>2]|0)+1;c[j>>2]=o;c[g+0>>2]=c[j+0>>2];if(!(Gc(b,f,g)|0)){t=0;i=h;return t|0}}t=1;i=h;return t|0}function Lc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;h=(c[b+776>>2]|0)+d|0;f=b+760|0;if(a[h>>0]|0){k=c[f>>2]|0;g=k+(d*12|0)+4|0;n=c[g>>2]|0;if((n|0)>0){j=b+804|0;k=c[k+(d*12|0)>>2]|0;m=0;l=0;do{o=c[k+(m<<2)>>2]|0;if((c[(c[c[j>>2]>>2]|0)+(o<<2)>>2]&3|0)!=1){c[k+(l<<2)>>2]=o;n=c[g>>2]|0;l=l+1|0}m=m+1|0}while((m|0)<(n|0))}else{m=0;l=0}j=m-l|0;if((j|0)>0)c[g>>2]=n-j;a[h>>0]=0}g=c[f>>2]|0;n=a[(c[b+332>>2]|0)+d>>0]|0;m=a[2624]|0;o=m&255;if(!((o>>>1^1)&n<<24>>24==m<<24>>24|n&2&o)){o=1;i=e;return o|0}f=g+(d*12|0)+4|0;h=c[f>>2]|0;if(!h){o=1;i=e;return o|0}a:do if((h|0)>0){g=g+(d*12|0)|0;h=0;while(1){if(!(Kc(b,d,c[(c[g>>2]|0)+(h<<2)>>2]|0)|0)){b=0;break}h=h+1|0;if((h|0)>=(c[f>>2]|0))break a}i=e;return b|0}while(0);o=Jc(b,0)|0;i=e;return o|0}function Mc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0;e=i;i=i+48|0;s=e+36|0;r=e+32|0;t=e+28|0;u=e+24|0;f=e+12|0;g=e;n=(c[b+776>>2]|0)+d|0;m=b+760|0;if(a[n>>0]|0){q=c[m>>2]|0;o=q+(d*12|0)+4|0;y=c[o>>2]|0;if((y|0)>0){p=b+804|0;q=c[q+(d*12|0)>>2]|0;w=0;v=0;do{z=c[q+(w<<2)>>2]|0;if((c[(c[c[p>>2]>>2]|0)+(z<<2)>>2]&3|0)!=1){c[q+(v<<2)>>2]=z;y=c[o>>2]|0;v=v+1|0}w=w+1|0}while((w|0)<(y|0))}else{w=0;v=0}p=w-v|0;if((p|0)>0)c[o>>2]=y-p;a[n>>0]=0}v=c[m>>2]|0;w=v+(d*12|0)|0;c[f>>2]=0;n=f+4|0;c[n>>2]=0;o=f+8|0;c[o>>2]=0;c[g>>2]=0;q=g+4|0;c[q>>2]=0;p=g+8|0;c[p>>2]=0;v=v+(d*12|0)+4|0;a:do if((c[v>>2]|0)>0){y=b+544|0;B=d<<1;A=0;do{C=(c[w>>2]|0)+(A<<2)|0;E=(c[y>>2]|0)+(c[C>>2]<<2)|0;Z=c[E>>2]|0;z=Z>>>5;b:do if(Z>>>0>31){G=0;while(1){D=G+1|0;if((c[E+(G<<2)+4>>2]|0)==(B|0)){D=G;break b}if((D|0)<(z|0))G=D;else break}}else D=0;while(0);_c((D|0)<(z|0)?f:g,C);A=A+1|0;z=c[v>>2]|0}while((A|0)<(z|0));y=c[n>>2]|0;B=(y|0)>0;if(B){C=c[q>>2]|0;K=(C|0)>0;J=b+544|0;D=c[f>>2]|0;A=c[g>>2]|0;E=b+708|0;I=b+684|0;H=b+688|0;P=0;G=0;while(1){if(K){M=D+(G<<2)|0;L=c[J>>2]|0;N=c[E>>2]|0;O=0;do{S=L+(c[M>>2]<<2)|0;U=L+(c[A+(O<<2)>>2]<<2)|0;N=N+1|0;c[E>>2]=N;Q=(c[S>>2]|0)>>>5>>>0<(c[U>>2]|0)>>>5>>>0;R=Q?U:S;U=Q?S:U;S=R+4|0;Q=U+4|0;R=c[R>>2]|0;T=R>>>5;W=T+ -1|0;U=c[U>>2]|0;c:do if(U>>>0>31){V=0;while(1){Z=c[Q+(V<<2)>>2]|0;d:do if((Z>>1|0)!=(d|0)){e:do if(R>>>0>31){Y=0;while(1){X=c[S+(Y<<2)>>2]|0;Y=Y+1|0;if((X^Z)>>>0<2)break;if((Y|0)>=(T|0))break e}if((X|0)==(Z^1|0))break c;else break d}while(0);W=W+1|0}while(0);V=V+1|0;if((V|0)>=(U>>>5|0)){x=28;break}}}else x=28;while(0);if((x|0)==28){x=0;if((P|0)>=((c[I>>2]|0)+z|0)){b=1;break a}Z=c[H>>2]|0;if((Z|0)!=-1&(W|0)>(Z|0)){b=1;break a}else P=P+1|0}O=O+1|0}while((O|0)<(C|0))}G=G+1|0;if((G|0)>=(y|0)){x=32;break}}}else{B=0;x=32}}else{y=0;B=0;x=32}while(0);f:do if((x|0)==32){a[(c[b+904>>2]|0)+d>>0]=1;z=b+380|0;A=(c[z>>2]|0)+d|0;if(a[A>>0]|0){Z=b+200|0;Y=Z;Y=ne(c[Y>>2]|0,c[Y+4>>2]|0,-1,-1)|0;c[Z>>2]=Y;c[Z+4>>2]=F}a[A>>0]=0;A=b+460|0;if(!((c[b+476>>2]|0)>(d|0)?(c[(c[b+472>>2]|0)+(d<<2)>>2]|0)>-1:0))x=36;if((x|0)==36?(a[(c[z>>2]|0)+d>>0]|0)!=0:0)lc(A,d);x=b+716|0;c[x>>2]=(c[x>>2]|0)+1;x=c[q>>2]|0;if((y|0)>(x|0)){A=b+732|0;if((x|0)>0){u=b+544|0;t=c[g>>2]|0;E=b+736|0;D=0;do{C=(c[u>>2]|0)+(c[t+(D<<2)>>2]<<2)|0;z=c[E>>2]|0;if((c[C>>2]|0)>>>0>31){G=0;H=-1;do{Z=C+(G<<2)+4|0;c[s>>2]=c[Z>>2];_c(A,s);H=(c[Z>>2]>>1|0)==(d|0)?G+z|0:H;G=G+1|0}while((G|0)<((c[C>>2]|0)>>>5|0))}else H=-1;Z=c[A>>2]|0;X=Z+(H<<2)|0;Y=c[X>>2]|0;Z=Z+(z<<2)|0;c[X>>2]=c[Z>>2];c[Z>>2]=Y;c[r>>2]=(c[C>>2]|0)>>>5;_c(A,r);D=D+1|0}while((D|0)<(x|0))}c[s>>2]=d<<1;_c(A,s);c[r>>2]=1;_c(A,r)}else{D=b+732|0;if(B){G=b+544|0;E=c[f>>2]|0;z=b+736|0;H=0;do{C=(c[G>>2]|0)+(c[E+(H<<2)>>2]<<2)|0;A=c[z>>2]|0;if((c[C>>2]|0)>>>0>31){I=0;J=-1;do{Z=C+(I<<2)+4|0;c[s>>2]=c[Z>>2];_c(D,s);J=(c[Z>>2]>>1|0)==(d|0)?I+A|0:J;I=I+1|0}while((I|0)<((c[C>>2]|0)>>>5|0))}else J=-1;Z=c[D>>2]|0;X=Z+(J<<2)|0;Y=c[X>>2]|0;Z=Z+(A<<2)|0;c[X>>2]=c[Z>>2];c[Z>>2]=Y;c[r>>2]=(c[C>>2]|0)>>>5;_c(D,r);H=H+1|0}while((H|0)<(y|0))}c[t>>2]=d<<1|1;_c(D,t);c[u>>2]=1;_c(D,u)}if((c[v>>2]|0)>0){r=0;do{Fc(b,c[(c[w>>2]|0)+(r<<2)>>2]|0);r=r+1|0}while((r|0)<(c[v>>2]|0))}r=b+628|0;g:do if(B){s=b+544|0;w=c[f>>2]|0;A=c[g>>2]|0;if((x|0)>0)v=0;else{r=0;while(1){r=r+1|0;if((r|0)>=(y|0))break g}}do{u=w+(v<<2)|0;t=0;do{Z=c[s>>2]|0;if(Hc(b,Z+(c[u>>2]<<2)|0,Z+(c[A+(t<<2)>>2]<<2)|0,d,r)|0?!(Dc(b,r)|0):0){b=0;break f}t=t+1|0}while((t|0)<(x|0));v=v+1|0}while((v|0)<(y|0))}while(0);r=c[m>>2]|0;m=r+(d*12|0)|0;s=c[m>>2]|0;if(s){c[r+(d*12|0)+4>>2]=0;Td(s);c[m>>2]=0;c[r+(d*12|0)+8>>2]=0}m=b+412|0;d=d<<1;s=c[m>>2]|0;r=s+(d*12|0)+4|0;if((c[r>>2]|0)==0?(l=s+(d*12|0)|0,k=c[l>>2]|0,(k|0)!=0):0){c[r>>2]=0;Td(k);c[l>>2]=0;c[s+(d*12|0)+8>>2]=0;s=c[m>>2]|0}k=d|1;l=s+(k*12|0)+4|0;if((c[l>>2]|0)==0?(j=s+(k*12|0)|0,h=c[j>>2]|0,(h|0)!=0):0){c[l>>2]=0;Td(h);c[j>>2]=0;c[s+(k*12|0)+8>>2]=0}b=Jc(b,0)|0;A=c[g>>2]|0}while(0);if(A){c[q>>2]=0;Td(A);c[g>>2]=0;c[p>>2]=0}g=c[f>>2]|0;if(!g){i=e;return b|0}c[n>>2]=0;Td(g);c[f>>2]=0;c[o>>2]=0;i=e;return b|0}function Nc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;e=i;if(!(a[b+724>>0]|0)){i=e;return}l=b+540|0;if((c[l>>2]|0)>0){j=b+760|0;f=b+804|0;g=b+776|0;k=b+544|0;h=0;do{n=c[j>>2]|0;m=n+(h*12|0)+4|0;p=c[m>>2]|0;if((p|0)>0){n=c[n+(h*12|0)>>2]|0;q=0;o=0;do{r=c[n+(q<<2)>>2]|0;if((c[(c[c[f>>2]>>2]|0)+(r<<2)>>2]&3|0)!=1){c[n+(o<<2)>>2]=r;p=c[m>>2]|0;o=o+1|0}q=q+1|0}while((q|0)<(p|0))}else{q=0;o=0}n=q-o|0;if((n|0)>0)c[m>>2]=p-n;a[(c[g>>2]|0)+h>>0]=0;n=c[j>>2]|0;m=n+(h*12|0)+4|0;if((c[m>>2]|0)>0){r=n+(h*12|0)|0;p=0;do{n=(c[r>>2]|0)+(p<<2)|0;o=c[n>>2]|0;q=c[k>>2]|0;s=q+(o<<2)|0;if(!(c[s>>2]&16)){t=wc(d,s)|0;c[n>>2]=t;c[s>>2]=c[s>>2]|16;c[q+(o+1<<2)>>2]=t}else c[n>>2]=c[q+(o+1<<2)>>2];p=p+1|0}while((p|0)<(c[m>>2]|0))}h=h+1|0}while((h|0)<(c[l>>2]|0))}f=b+856|0;t=c[b+872>>2]|0;g=b+868|0;m=c[g>>2]|0;k=t-m|0;if((t|0)<(m|0))k=(c[b+860>>2]|0)+k|0;a:do if((k|0)>0){h=b+860|0;j=b+544|0;while(1){l=c[(c[f>>2]|0)+(m<<2)>>2]|0;n=m+1|0;c[g>>2]=(n|0)==(c[h>>2]|0)?0:n;n=c[j>>2]|0;o=n+(l<<2)|0;m=c[o>>2]|0;if(!(m&3)){if(!(m&16)){t=wc(d,o)|0;c[o>>2]=c[o>>2]|16;c[n+(l+1<<2)>>2]=t;l=t}else l=c[n+(l+1<<2)>>2]|0;Zc(f,l)}k=k+ -1|0;if((k|0)<=0)break a;m=c[g>>2]|0}}else j=b+544|0;while(0);b=b+928|0;f=c[b>>2]|0;h=c[j>>2]|0;g=h+(f<<2)|0;if(!(c[g>>2]&16)){t=wc(d,g)|0;c[b>>2]=t;c[g>>2]=c[g>>2]|16;c[h+(f+1<<2)>>2]=t;i=e;return}else{c[b>>2]=c[h+(f+1<<2)>>2];i=e;return}}function Oc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;h=i;i=i+32|0;l=h;d=h+8|0;e=b+544|0;f=b+548|0;g=b+556|0;j=(c[f>>2]|0)-(c[g>>2]|0)|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;gc(d,j);j=d+16|0;k=b+560|0;a[j>>0]=a[k>>0]|0;Nc(b,d);ac(b,d);if((c[b+44>>2]|0)>1){m=c[d+4>>2]<<2;c[l>>2]=c[f>>2]<<2;c[l+4>>2]=m;La(3608,l|0)|0}a[k>>0]=a[j>>0]|0;j=c[e>>2]|0;if(j)Td(j);c[e>>2]=c[d>>2];c[f>>2]=c[d+4>>2];c[b+552>>2]=c[d+8>>2];c[g>>2]=c[d+12>>2];i=h;return}function Pc(){var d=0,e=0,f=0;d=i;i=i+16|0;e=d;a[2608]=0;a[2616]=1;a[2624]=2;xb(2632,2656,2664,3744,3752);c[658]=160;a[2652]=0;xb(2704,2728,2736,3744,3752);c[676]=160;a[2724]=0;xb(2784,2808,2816,3744,3752);c[696]=160;a[2804]=1;xb(2848,2880,2888,3744,3736);c[712]=280;f=2868|0;c[f>>2]=-2147483648;c[f+4>>2]=2147483647;c[719]=0;xb(2960,2992,3e3,3744,3736);c[740]=280;f=2980|0;c[f>>2]=-1;c[f+4>>2]=2147483647;c[747]=20;xb(3112,3144,3152,3744,3736);c[778]=280;f=3132|0;c[f>>2]=-1;c[f+4>>2]=2147483647;c[785]=1e3;xb(3240,3296,3312,3744,3720);c[810]=2168;h[408]=0.0;h[409]=v;a[3280]=0;a[3281]=0;b[1641]=b[e+0>>1]|0;b[1642]=b[e+2>>1]|0;b[1643]=b[e+4>>1]|0;h[411]=.5;i=d;return}function Qc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;c[a>>2]=0;e=a+4|0;c[e>>2]=0;f=a+8|0;c[f>>2]=0;if((b|0)<=0){i=d;return}g=b+1&-2;g=(g|0)>2?g:2;c[f>>2]=g;f=Ud(0,g<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0)Ta(va(1)|0,48,0);a=c[e>>2]|0;if((a|0)<(b|0))do{g=f+(a<<2)|0;if(g)c[g>>2]=0;a=a+1|0}while((a|0)!=(b|0));c[e>>2]=b;i=d;return}function Rc(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0;b=i;e=a+32|0;d=c[e>>2]|0;if(d){c[a+36>>2]=0;Td(d);c[e>>2]=0;c[a+40>>2]=0}e=a+16|0;d=c[e>>2]|0;if(d){c[a+20>>2]=0;Td(d);c[e>>2]=0;c[a+24>>2]=0}e=c[a>>2]|0;if(!e){i=b;return}d=a+4|0;g=c[d>>2]|0;if((g|0)>0){f=0;do{j=e+(f*12|0)|0;h=c[j>>2]|0;if(h){c[e+(f*12|0)+4>>2]=0;Td(h);c[j>>2]=0;c[e+(f*12|0)+8>>2]=0;e=c[a>>2]|0;g=c[d>>2]|0}f=f+1|0}while((f|0)<(g|0))}c[d>>2]=0;Td(e);c[a>>2]=0;c[a+8>>2]=0;i=b;return}function Sc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;b=c[b>>2]|0;g=b+1|0;f=a+4|0;if((c[f>>2]|0)>=(g|0)){k=c[a>>2]|0;k=k+(b<<2)|0;c[k>>2]=d;i=e;return}h=a+8|0;k=c[h>>2]|0;if((k|0)<(g|0)){l=b+2-k&-2;j=(k>>1)+2&-2;j=(l|0)>(j|0)?l:j;if((j|0)>(2147483647-k|0)){l=va(1)|0;Ta(l|0,48,0)}m=c[a>>2]|0;l=j+k|0;c[h>>2]=l;l=Ud(m,l<<2)|0;c[a>>2]=l;if((l|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}k=c[f>>2]|0;if((k|0)<(g|0)){h=c[a>>2]|0;do{j=h+(k<<2)|0;if(j)c[j>>2]=0;k=k+1|0}while((k|0)!=(g|0))}c[f>>2]=g;m=c[a>>2]|0;m=m+(b<<2)|0;c[m>>2]=d;i=e;return}function Tc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;k=c[d>>2]|0;g=k+1|0;f=b+4|0;if((c[f>>2]|0)<(g|0)){j=b+8|0;h=c[j>>2]|0;if((h|0)<(g|0)){l=k+2-h&-2;k=(h>>1)+2&-2;k=(l|0)>(k|0)?l:k;if((k|0)>(2147483647-h|0)){l=va(1)|0;Ta(l|0,48,0)}m=c[b>>2]|0;l=k+h|0;c[j>>2]=l;l=Ud(m,l*12|0)|0;c[b>>2]=l;if((l|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}j=c[f>>2]|0;if((j|0)<(g|0)){h=c[b>>2]|0;do{k=h+(j*12|0)|0;if(k){c[k>>2]=0;c[h+(j*12|0)+4>>2]=0;c[h+(j*12|0)+8>>2]=0}j=j+1|0}while((j|0)!=(g|0))}c[f>>2]=g;h=c[d>>2]|0}else h=k;f=c[b>>2]|0;if(c[f+(h*12|0)>>2]|0){c[f+(h*12|0)+4>>2]=0;h=c[d>>2]|0}d=b+16|0;f=h+1|0;g=b+20|0;if((c[g>>2]|0)>=(f|0)){i=e;return}j=b+24|0;b=c[j>>2]|0;if((b|0)<(f|0)){m=h+2-b&-2;h=(b>>1)+2&-2;h=(m|0)>(h|0)?m:h;if((h|0)>(2147483647-b|0)){m=va(1)|0;Ta(m|0,48,0)}l=c[d>>2]|0;m=h+b|0;c[j>>2]=m;m=Ud(l,m)|0;c[d>>2]=m;if((m|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}b=c[g>>2]|0;if((b|0)<(f|0))do{a[(c[d>>2]|0)+b>>0]=0;b=b+1|0}while((b|0)!=(f|0));c[g>>2]=f;i=e;return}function Uc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;d=i;i=i+16|0;g=d;c[g>>2]=b;f=a+12|0;e=b+1|0;h=a+16|0;if((c[h>>2]|0)<(e|0)){k=a+20|0;j=c[k>>2]|0;if((j|0)<(e|0)){m=b+2-j&-2;l=(j>>1)+2&-2;l=(m|0)>(l|0)?m:l;if((l|0)>(2147483647-j|0)){m=va(1)|0;Ta(m|0,48,0)}n=c[f>>2]|0;m=l+j|0;c[k>>2]=m;m=Ud(n,m<<2)|0;c[f>>2]=m;if((m|0)==0?(c[(Oa()|0)>>2]|0)==12:0){n=va(1)|0;Ta(n|0,48,0)}}j=c[h>>2]|0;if((e|0)>(j|0))ke((c[f>>2]|0)+(j<<2)|0,-1,e-j<<2|0)|0;c[h>>2]=e}c[(c[f>>2]|0)+(b<<2)>>2]=c[a+4>>2];nc(a,g);e=c[f>>2]|0;j=c[e+(b<<2)>>2]|0;b=c[a>>2]|0;f=c[b+(j<<2)>>2]|0;if(!j){m=0;n=b+(m<<2)|0;c[n>>2]=f;n=e+(f<<2)|0;c[n>>2]=m;i=d;return}a=a+28|0;g=f<<1;h=g|1;while(1){m=j;j=j+ -1>>1;l=b+(j<<2)|0;k=c[l>>2]|0;r=c[c[a>>2]>>2]|0;o=c[r+(g<<2)>>2]|0;q=c[r+(h<<2)>>2]|0;o=we(q|0,((q|0)<0)<<31>>31|0,o|0,((o|0)<0)<<31>>31|0)|0;q=F;p=k<<1;n=c[r+(p<<2)>>2]|0;p=c[r+((p|1)<<2)>>2]|0;n=we(p|0,((p|0)<0)<<31>>31|0,n|0,((n|0)<0)<<31>>31|0)|0;p=F;if(!(q>>>0<p>>>0|(q|0)==(p|0)&o>>>0<n>>>0)){a=14;break}c[b+(m<<2)>>2]=k;c[e+(c[l>>2]<<2)>>2]=m;if(!j){m=0;a=14;break}}if((a|0)==14){r=b+(m<<2)|0;c[r>>2]=f;r=e+(f<<2)|0;c[r>>2]=m;i=d;return}}function Vc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;e=i;h=b+824|0;l=(c[b+840>>2]|0)>(d|0);if(l?(c[(c[b+836>>2]|0)+(d<<2)>>2]|0)>-1:0)j=7;else j=3;do if((j|0)==3){if(a[(c[b+876>>2]|0)+d>>0]|0){i=e;return}if(a[(c[b+904>>2]|0)+d>>0]|0){i=e;return}o=a[(c[b+332>>2]|0)+d>>0]|0;n=a[2624]|0;p=n&255;if((p>>>1^1)&o<<24>>24==n<<24>>24|o&2&p)if(l){j=7;break}else break;else{i=e;return}}while(0);if((j|0)==7?(f=c[b+836>>2]|0,g=f+(d<<2)|0,k=c[g>>2]|0,(k|0)>-1):0){d=c[h>>2]|0;j=c[d+(k<<2)>>2]|0;a:do if(!k)o=0;else{l=b+852|0;m=j<<1;b=m|1;while(1){o=k;k=k+ -1>>1;p=d+(k<<2)|0;n=c[p>>2]|0;u=c[c[l>>2]>>2]|0;r=c[u+(m<<2)>>2]|0;t=c[u+(b<<2)>>2]|0;r=we(t|0,((t|0)<0)<<31>>31|0,r|0,((r|0)<0)<<31>>31|0)|0;t=F;s=n<<1;q=c[u+(s<<2)>>2]|0;s=c[u+((s|1)<<2)>>2]|0;q=we(s|0,((s|0)<0)<<31>>31|0,q|0,((q|0)<0)<<31>>31|0)|0;s=F;if(!(t>>>0<s>>>0|(t|0)==(s|0)&r>>>0<q>>>0))break a;c[d+(o<<2)>>2]=n;c[f+(c[p>>2]<<2)>>2]=o;if(!k){o=0;break}}}while(0);c[d+(o<<2)>>2]=j;c[f+(j<<2)>>2]=o;Wc(h,c[g>>2]|0);i=e;return}Uc(h,d);i=e;return}function Wc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;d=i;e=c[a>>2]|0;f=c[e+(b<<2)>>2]|0;m=b<<1|1;l=a+4|0;o=c[l>>2]|0;if((m|0)>=(o|0)){p=b;q=a+12|0;o=e+(p<<2)|0;c[o>>2]=f;q=c[q>>2]|0;q=q+(f<<2)|0;c[q>>2]=p;i=d;return}h=a+28|0;k=f<<1;j=k|1;a=a+12|0;while(1){n=(b<<1)+2|0;if((n|0)<(o|0)){p=c[e+(n<<2)>>2]|0;q=c[e+(m<<2)>>2]|0;u=p<<1;o=c[c[h>>2]>>2]|0;s=c[o+(u<<2)>>2]|0;u=c[o+((u|1)<<2)>>2]|0;s=we(u|0,((u|0)<0)<<31>>31|0,s|0,((s|0)<0)<<31>>31|0)|0;u=F;t=q<<1;r=c[o+(t<<2)>>2]|0;t=c[o+((t|1)<<2)>>2]|0;r=we(t|0,((t|0)<0)<<31>>31|0,r|0,((r|0)<0)<<31>>31|0)|0;t=F;if(!(u>>>0<t>>>0|(u|0)==(t|0)&s>>>0<r>>>0)){p=q;g=7}}else{p=c[e+(m<<2)>>2]|0;o=c[c[h>>2]>>2]|0;g=7}if((g|0)==7){g=0;n=m}r=p<<1;t=c[o+(r<<2)>>2]|0;r=c[o+((r|1)<<2)>>2]|0;t=we(r|0,((r|0)<0)<<31>>31|0,t|0,((t|0)<0)<<31>>31|0)|0;r=F;u=c[o+(k<<2)>>2]|0;s=c[o+(j<<2)>>2]|0;u=we(s|0,((s|0)<0)<<31>>31|0,u|0,((u|0)<0)<<31>>31|0)|0;s=F;if(!(r>>>0<s>>>0|(r|0)==(s|0)&t>>>0<u>>>0)){g=10;break}c[e+(b<<2)>>2]=p;c[(c[a>>2]|0)+(p<<2)>>2]=b;m=n<<1|1;o=c[l>>2]|0;if((m|0)>=(o|0)){b=n;g=10;break}else b=n}if((g|0)==10){u=e+(b<<2)|0;c[u>>2]=f;u=c[a>>2]|0;u=u+(f<<2)|0;c[u>>2]=b;i=d;return}}function Xc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0;d=i;h=c[a>>2]|0;if(h){e=a+4|0;f=c[e>>2]|0;a:do if((f|0)>0){g=0;while(1){j=h+(g*12|0)|0;k=c[j>>2]|0;if(k){c[h+(g*12|0)+4>>2]=0;Td(k);c[j>>2]=0;c[h+(g*12|0)+8>>2]=0;f=c[e>>2]|0}g=g+1|0;if((g|0)>=(f|0))break a;h=c[a>>2]|0}}while(0);c[e>>2]=0;if(b){Td(c[a>>2]|0);c[a>>2]=0;c[a+8>>2]=0}}e=a+16|0;f=c[e>>2]|0;if((f|0)!=0?(c[a+20>>2]=0,b):0){Td(f);c[e>>2]=0;c[a+24>>2]=0}f=a+32|0;e=c[f>>2]|0;if(!e){i=d;return}c[a+36>>2]=0;if(!b){i=d;return}Td(e);c[f>>2]=0;c[a+40>>2]=0;i=d;return}function Yc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;e=i;f=c[a>>2]|0;d=a+4|0;if(f){c[d>>2]=0;if(b){Td(f);c[a>>2]=0;c[a+8>>2]=0;f=0}}else f=0;if((c[d>>2]|0)>=1){h=a+16|0;c[h>>2]=0;h=a+12|0;c[h>>2]=0;i=e;return}h=a+8|0;g=c[h>>2]|0;if((g|0)<1){j=2-g&-2;b=(g>>1)+2&-2;b=(j|0)>(b|0)?j:b;if((b|0)>(2147483647-g|0)){j=va(1)|0;Ta(j|0,48,0)}j=b+g|0;c[h>>2]=j;f=Ud(f,j<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}b=c[d>>2]|0;if((b|0)<1)while(1){g=f+(b<<2)|0;if(g)c[g>>2]=0;if(!b)break;else b=b+1|0}c[d>>2]=1;j=a+16|0;c[j>>2]=0;j=a+12|0;c[j>>2]=0;i=e;return}function Zc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;i=i+16|0;d=e;f=a+16|0;j=c[f>>2]|0;c[f>>2]=j+1;c[(c[a>>2]|0)+(j<<2)>>2]=b;j=c[f>>2]|0;b=a+4|0;h=c[b>>2]|0;if((j|0)==(h|0)){c[f>>2]=0;j=0}g=a+12|0;if((c[g>>2]|0)!=(j|0)){i=e;return}Qc(d,(h*3|0)+1>>1);l=c[g>>2]|0;m=c[b>>2]|0;if((l|0)<(m|0)){j=c[a>>2]|0;k=c[d>>2]|0;m=0;while(1){h=m+1|0;c[k+(m<<2)>>2]=c[j+(l<<2)>>2];l=l+1|0;m=c[b>>2]|0;if((l|0)>=(m|0)){k=h;break}else m=h}}else k=0;h=c[a>>2]|0;if((c[f>>2]|0)>0){j=c[d>>2]|0;l=0;while(1){c[j+(k<<2)>>2]=c[h+(l<<2)>>2];l=l+1|0;if((l|0)>=(c[f>>2]|0))break;else k=k+1|0}m=c[b>>2]|0}c[g>>2]=0;c[f>>2]=m;if(!h)f=a+8|0;else{c[b>>2]=0;Td(h);c[a>>2]=0;f=a+8|0;c[f>>2]=0}c[a>>2]=c[d>>2];l=d+4|0;c[b>>2]=c[l>>2];m=d+8|0;c[f>>2]=c[m>>2];c[d>>2]=0;c[l>>2]=0;c[m>>2]=0;i=e;return}function _c(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+4|0;f=c[e>>2]|0;g=a+8|0;h=c[g>>2]|0;if((f|0)==(h|0)&(h|0)<(f+1|0)){h=(f>>1)+2&-2;h=(h|0)<2?2:h;if((h|0)>(2147483647-f|0)){h=va(1)|0;Ta(h|0,48,0)}j=c[a>>2]|0;f=h+f|0;c[g>>2]=f;f=Ud(j,f<<2)|0;c[a>>2]=f;if((f|0)==0?(c[(Oa()|0)>>2]|0)==12:0){j=va(1)|0;Ta(j|0,48,0)}}else f=c[a>>2]|0;j=c[e>>2]|0;c[e>>2]=j+1;e=f+(j<<2)|0;if(!e){i=d;return}c[e>>2]=c[b>>2];i=d;return}function $c(){var a=0,b=0;b=i;Ka(3864)|0;a=od(936)|0;xc(a);i=b;return a|0}function ad(a){a=a|0;var b=0;b=i;if(!a){i=b;return}gb[c[(c[a>>2]|0)+4>>2]&31](a);i=b;return}function bd(){var b=0,d=0,e=0;b=i;i=i+16|0;d=b;e=od(936)|0;xc(e);c[964]=e;Cc(e,1)|0;e=c[964]|0;a[d+0>>0]=a[3840]|0;Ac(e,d,1)|0;i=b;return}function cd(b){b=b|0;var d=0,e=0,f=0;d=i;i=i+16|0;e=d;if((c[962]|0)>=(b|0)){i=d;return}do{f=c[964]|0;a[e+0>>0]=a[3840]|0;Ac(f,e,1)|0;f=(c[962]|0)+1|0;c[962]=f}while((f|0)<(b|0));i=d;return}function dd(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;g=i;i=i+32|0;h=g+16|0;e=g+4|0;j=g;c[e>>2]=0;f=e+4|0;c[f>>2]=0;d=e+8|0;c[d>>2]=0;k=c[b>>2]|0;if(k)do{l=(k|0)<0?0-k|0:k;if((c[962]|0)<(l|0))do{m=c[964]|0;a[h+0>>0]=a[3840]|0;Ac(m,h,1)|0;m=(c[962]|0)+1|0;c[962]=m}while((m|0)<(l|0));c[j>>2]=l<<1|k>>>31;mc(e,j);b=b+4|0;k=c[b>>2]|0}while((k|0)!=0);j=c[964]|0;h=j+628|0;ld(e,h);h=Dc(j,h)|0;j=c[e>>2]|0;if(!j){i=g;return h|0}c[f>>2]=0;Td(j);c[e>>2]=0;c[d>>2]=0;i=g;return h|0}function ed(){var b=0,d=0,e=0,f=0;d=i;i=i+16|0;b=d;e=c[964]|0;f=e+664|0;c[f+0>>2]=-1;c[f+4>>2]=-1;c[f+8>>2]=-1;c[f+12>>2]=-1;if(c[e+304>>2]|0)c[e+308>>2]=0;Bc(b,e,1,0);i=d;return(a[b>>0]|0)==0|0}function fd(){return(c[(c[964]|0)+4>>2]|0)+1|0}function gd(){return c[962]|0}function hd(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;i=i+32|0;h=d+16|0;f=d+4|0;j=d;c[f>>2]=0;e=f+4|0;c[e>>2]=0;g=f+8|0;c[g>>2]=0;c[j>>2]=b<<1;mc(f,j);b=c[964]|0;j=b+664|0;c[j+0>>2]=-1;c[j+4>>2]=-1;c[j+8>>2]=-1;c[j+12>>2]=-1;ld(f,b+304|0);Bc(h,b,1,0);b=(a[h>>0]|0)==0;h=c[f>>2]|0;if(!h){i=d;return b|0}c[e>>2]=0;Td(h);c[f>>2]=0;c[g>>2]=0;i=d;return b|0}function id(a){a=a|0;var b=0,d=0,e=0;b=i;i=i+16|0;e=b;d=c[964]|0;c[e>>2]=a<<1|1;a=d+628|0;if(c[a>>2]|0)c[d+632>>2]=0;mc(a,e);Dc(d,a)|0;i=b;return}function jd(){return c[(c[964]|0)+36>>2]|0}function kd(){return c[(c[964]|0)+32>>2]|0}function ld(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;d=i;h=c[b>>2]|0;e=b+4|0;if(!h)j=c[e>>2]|0;else{c[e>>2]=0;j=0}e=a+4|0;f=c[e>>2]|0;g=b+4|0;if((j|0)<(f|0)){k=b+8|0;j=c[k>>2]|0;if((j|0)<(f|0)){m=f+1-j&-2;l=(j>>1)+2&-2;l=(m|0)>(l|0)?m:l;if((l|0)>(2147483647-j|0)){m=va(1)|0;Ta(m|0,48,0)}m=l+j|0;c[k>>2]=m;h=Ud(h,m<<2)|0;c[b>>2]=h;if((h|0)==0?(c[(Oa()|0)>>2]|0)==12:0){m=va(1)|0;Ta(m|0,48,0)}}j=c[g>>2]|0;a:do if((j|0)<(f|0))while(1){h=h+(j<<2)|0;if(h)c[h>>2]=0;j=j+1|0;if((j|0)==(f|0))break a;h=c[b>>2]|0}while(0);c[g>>2]=f;f=c[e>>2]|0}if((f|0)<=0){i=d;return}b=c[b>>2]|0;a=c[a>>2]|0;f=0;do{c[b+(f<<2)>>2]=c[a+(f<<2)>>2];f=f+1|0}while((f|0)<(c[e>>2]|0));i=d;return}function md(a,b){a=a|0;b=b|0;var d=0;d=i;i=i+16|0;c[d>>2]=b;b=c[p>>2]|0;ua(b|0,a|0,d|0)|0;Sa(10,b|0)|0;Wa()}function nd(){var a=0,b=0;a=i;i=i+16|0;if(!(Ja(4064,3)|0)){b=Ha(c[1014]|0)|0;i=a;return b|0}else md(4072,a);return 0}function od(a){a=a|0;var b=0,d=0;b=i;a=(a|0)==0?1:a;d=Sd(a)|0;if(d){i=b;return d|0}while(1){d=vd()|0;if(!d){a=4;break}jb[d&3]();d=Sd(a)|0;if(d){a=5;break}}if((a|0)==4){d=va(4)|0;c[d>>2]=4248;Ta(d|0,4296,12)}else if((a|0)==5){i=b;return d|0}return 0}function pd(a){a=a|0;var b=0;b=i;Td(a);i=b;return}function qd(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function rd(a){a=a|0;return}function sd(a){a=a|0;return 4264}function td(a){a=a|0;var b=0;b=i;i=i+16|0;jb[a&3]();md(4312,b)}function ud(){var a=0,b=0;b=nd()|0;if(((b|0)!=0?(a=c[b>>2]|0,(a|0)!=0):0)?(b=a+48|0,(c[b>>2]&-256|0)==1126902528?(c[b+4>>2]|0)==1129074247:0):0)td(c[a+12>>2]|0);b=c[968]|0;c[968]=b+0;td(b)}function vd(){var a=0;a=c[1102]|0;c[1102]=a+0;return a|0}function wd(a){a=a|0;return}function xd(a){a=a|0;return}function yd(a){a=a|0;return}function zd(a){a=a|0;return}function Ad(a){a=a|0;return}function Bd(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function Cd(a){a=a|0;var b=0;b=i;pd(a);i=b;return}function Dd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=i;i=i+64|0;f=e;if((a|0)==(b|0)){h=1;i=e;return h|0}if(!b){h=0;i=e;return h|0}b=Hd(b,4504,4560,0)|0;if(!b){h=0;i=e;return h|0}h=f+0|0;g=h+56|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(g|0));c[f>>2]=b;c[f+8>>2]=a;c[f+12>>2]=-1;c[f+48>>2]=1;mb[c[(c[b>>2]|0)+28>>2]&3](b,f,c[d>>2]|0,1);if((c[f+24>>2]|0)!=1){h=0;i=e;return h|0}c[d>>2]=c[f+16>>2];h=1;i=e;return h|0}function Ed(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;b=i;g=d+16|0;h=c[g>>2]|0;if(!h){c[g>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;i=b;return}if((h|0)!=(e|0)){h=d+36|0;c[h>>2]=(c[h>>2]|0)+1;c[d+24>>2]=2;a[d+54>>0]=1;i=b;return}e=d+24|0;if((c[e>>2]|0)!=2){i=b;return}c[e>>2]=f;i=b;return}function Fd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;if((c[b+8>>2]|0)!=(a|0)){i=f;return}Ed(0,b,d,e);i=f;return}function Gd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;if((a|0)==(c[b+8>>2]|0)){Ed(0,b,d,e);i=f;return}else{a=c[a+8>>2]|0;mb[c[(c[a>>2]|0)+28>>2]&3](a,b,d,e);i=f;return}}function Hd(d,e,f,g){d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;h=i;i=i+64|0;j=h;k=c[d>>2]|0;l=d+(c[k+ -8>>2]|0)|0;k=c[k+ -4>>2]|0;c[j>>2]=f;c[j+4>>2]=d;c[j+8>>2]=e;c[j+12>>2]=g;n=j+16|0;o=j+20|0;e=j+24|0;m=j+28|0;g=j+32|0;d=j+40|0;p=(k|0)==(f|0);q=n+0|0;f=q+36|0;do{c[q>>2]=0;q=q+4|0}while((q|0)<(f|0));b[n+36>>1]=0;a[n+38>>0]=0;if(p){c[j+48>>2]=1;kb[c[(c[k>>2]|0)+20>>2]&3](k,j,l,l,1,0);q=(c[e>>2]|0)==1?l:0;i=h;return q|0}fb[c[(c[k>>2]|0)+24>>2]&3](k,j,l,1,0);j=c[j+36>>2]|0;if(!j){q=(c[d>>2]|0)==1&(c[m>>2]|0)==1&(c[g>>2]|0)==1?c[o>>2]|0:0;i=h;return q|0}else if((j|0)==1){if((c[e>>2]|0)!=1?!((c[d>>2]|0)==0&(c[m>>2]|0)==1&(c[g>>2]|0)==1):0){q=0;i=h;return q|0}q=c[n>>2]|0;i=h;return q|0}else{q=0;i=h;return q|0}return 0}function Id(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;b=i;a[d+53>>0]=1;if((c[d+4>>2]|0)!=(f|0)){i=b;return}a[d+52>>0]=1;f=d+16|0;h=c[f>>2]|0;if(!h){c[f>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((g|0)==1?(c[d+48>>2]|0)==1:0)){i=b;return}a[d+54>>0]=1;i=b;return}if((h|0)!=(e|0)){h=d+36|0;c[h>>2]=(c[h>>2]|0)+1;a[d+54>>0]=1;i=b;return}e=d+24|0;f=c[e>>2]|0;if((f|0)==2)c[e>>2]=g;else g=f;if(!((g|0)==1?(c[d+48>>2]|0)==1:0)){i=b;return}a[d+54>>0]=1;i=b;return}function Jd(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0;h=i;if((b|0)==(c[d+8>>2]|0)){if((c[d+4>>2]|0)!=(e|0)){i=h;return}j=d+28|0;if((c[j>>2]|0)==1){i=h;return}c[j>>2]=f;i=h;return}if((b|0)!=(c[d>>2]|0)){l=c[b+8>>2]|0;fb[c[(c[l>>2]|0)+24>>2]&3](l,d,e,f,g);i=h;return}if((c[d+16>>2]|0)!=(e|0)?(k=d+20|0,(c[k>>2]|0)!=(e|0)):0){c[d+32>>2]=f;f=d+44|0;if((c[f>>2]|0)==4){i=h;return}l=d+52|0;a[l>>0]=0;m=d+53|0;a[m>>0]=0;b=c[b+8>>2]|0;kb[c[(c[b>>2]|0)+20>>2]&3](b,d,e,e,1,g);if(a[m>>0]|0){if(!(a[l>>0]|0)){b=1;j=13}}else{b=0;j=13}do if((j|0)==13){c[k>>2]=e;m=d+40|0;c[m>>2]=(c[m>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0){a[d+54>>0]=1;if(b)break}else j=16;if((j|0)==16?b:0)break;c[f>>2]=4;i=h;return}while(0);c[f>>2]=3;i=h;return}if((f|0)!=1){i=h;return}c[d+32>>2]=1;i=h;return}function Kd(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;g=i;if((c[d+8>>2]|0)==(b|0)){if((c[d+4>>2]|0)!=(e|0)){i=g;return}d=d+28|0;if((c[d>>2]|0)==1){i=g;return}c[d>>2]=f;i=g;return}if((c[d>>2]|0)!=(b|0)){i=g;return}if((c[d+16>>2]|0)!=(e|0)?(h=d+20|0,(c[h>>2]|0)!=(e|0)):0){c[d+32>>2]=f;c[h>>2]=e;b=d+40|0;c[b>>2]=(c[b>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0)a[d+54>>0]=1;c[d+44>>2]=4;i=g;return}if((f|0)!=1){i=g;return}c[d+32>>2]=1;i=g;return}function Ld(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;h=i;if((a|0)==(c[b+8>>2]|0)){Id(0,b,d,e,f);i=h;return}else{a=c[a+8>>2]|0;kb[c[(c[a>>2]|0)+20>>2]&3](a,b,d,e,f,g);i=h;return}}function Md(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;g=i;if((c[b+8>>2]|0)!=(a|0)){i=g;return}Id(0,b,d,e,f);i=g;return}function Nd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=i;i=i+16|0;f=e;c[f>>2]=c[d>>2];a=eb[c[(c[a>>2]|0)+16>>2]&1](a,b,f)|0;b=a&1;if(!a){i=e;return b|0}c[d>>2]=c[f>>2];i=e;return b|0}function Od(a){a=a|0;var b=0;b=i;if(!a)a=0;else a=(Hd(a,4504,4672,0)|0)!=0;i=b;return a&1|0}function Pd(){var a=0,b=0,d=0,e=0,f=0;a=i;i=i+16|0;b=a;a=a+12|0;d=nd()|0;if(!d)md(4040,b);d=c[d>>2]|0;if(!d)md(4040,b);f=d+48|0;e=c[f>>2]|0;f=c[f+4>>2]|0;if(!((e&-256|0)==1126902528&(f|0)==1129074247)){c[b>>2]=c[970];md(4e3,b)}if((e|0)==1126902529&(f|0)==1129074247)e=c[d+44>>2]|0;else e=d+80|0;c[a>>2]=e;f=c[d>>2]|0;d=c[f+4>>2]|0;if(eb[c[(c[4432>>2]|0)+16>>2]&1](4432,f,a)|0){f=c[a>>2]|0;e=c[970]|0;f=ib[c[(c[f>>2]|0)+8>>2]&1](f)|0;c[b>>2]=e;c[b+4>>2]=d;c[b+8>>2]=f;md(3904,b)}else{c[b>>2]=c[970];c[b+4>>2]=d;md(3952,b)}}function Qd(){var a=0;a=i;i=i+16|0;if(!(Ma(4056,20)|0)){i=a;return}else md(4128,a)}function Rd(a){a=a|0;var b=0;b=i;i=i+16|0;Td(a);if(!(Pa(c[1014]|0,0)|0)){i=b;return}else md(4184,b)}function Sd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;b=i;do if(a>>>0<245){if(a>>>0<11)a=16;else a=a+11&-8;x=a>>>3;p=c[1206]|0;w=p>>>x;if(w&3){g=(w&1^1)+x|0;f=g<<1;d=4864+(f<<2)|0;f=4864+(f+2<<2)|0;h=c[f>>2]|0;j=h+8|0;e=c[j>>2]|0;do if((d|0)!=(e|0)){if(e>>>0<(c[1210]|0)>>>0)Wa();k=e+12|0;if((c[k>>2]|0)==(h|0)){c[k>>2]=d;c[f>>2]=e;break}else Wa()}else c[1206]=p&~(1<<g);while(0);H=g<<3;c[h+4>>2]=H|3;H=h+(H|4)|0;c[H>>2]=c[H>>2]|1;H=j;i=b;return H|0}v=c[1208]|0;if(a>>>0>v>>>0){if(w){h=2<<x;h=w<<x&(h|0-h);h=(h&0-h)+ -1|0;d=h>>>12&16;h=h>>>d;j=h>>>5&8;h=h>>>j;f=h>>>2&4;h=h>>>f;g=h>>>1&2;h=h>>>g;e=h>>>1&1;e=(j|d|f|g|e)+(h>>>e)|0;h=e<<1;g=4864+(h<<2)|0;h=4864+(h+2<<2)|0;f=c[h>>2]|0;d=f+8|0;j=c[d>>2]|0;do if((g|0)!=(j|0)){if(j>>>0<(c[1210]|0)>>>0)Wa();k=j+12|0;if((c[k>>2]|0)==(f|0)){c[k>>2]=g;c[h>>2]=j;E=c[1208]|0;break}else Wa()}else{c[1206]=p&~(1<<e);E=v}while(0);H=e<<3;e=H-a|0;c[f+4>>2]=a|3;g=f+a|0;c[f+(a|4)>>2]=e|1;c[f+H>>2]=e;if(E){f=c[1211]|0;l=E>>>3;j=l<<1;h=4864+(j<<2)|0;k=c[1206]|0;l=1<<l;if(k&l){j=4864+(j+2<<2)|0;k=c[j>>2]|0;if(k>>>0<(c[1210]|0)>>>0)Wa();else{D=j;C=k}}else{c[1206]=k|l;D=4864+(j+2<<2)|0;C=h}c[D>>2]=f;c[C+12>>2]=f;c[f+8>>2]=C;c[f+12>>2]=h}c[1208]=e;c[1211]=g;H=d;i=b;return H|0}p=c[1207]|0;if(p){d=(p&0-p)+ -1|0;G=d>>>12&16;d=d>>>G;F=d>>>5&8;d=d>>>F;H=d>>>2&4;d=d>>>H;f=d>>>1&2;d=d>>>f;e=d>>>1&1;e=c[5128+((F|G|H|f|e)+(d>>>e)<<2)>>2]|0;d=(c[e+4>>2]&-8)-a|0;f=e;while(1){g=c[f+16>>2]|0;if(!g){g=c[f+20>>2]|0;if(!g)break}f=(c[g+4>>2]&-8)-a|0;H=f>>>0<d>>>0;d=H?f:d;f=g;e=H?g:e}h=c[1210]|0;if(e>>>0<h>>>0)Wa();f=e+a|0;if(e>>>0>=f>>>0)Wa();g=c[e+24>>2]|0;k=c[e+12>>2]|0;do if((k|0)==(e|0)){k=e+20|0;j=c[k>>2]|0;if(!j){k=e+16|0;j=c[k>>2]|0;if(!j){B=0;break}}while(1){l=j+20|0;m=c[l>>2]|0;if(m){j=m;k=l;continue}l=j+16|0;m=c[l>>2]|0;if(!m)break;else{j=m;k=l}}if(k>>>0<h>>>0)Wa();else{c[k>>2]=0;B=j;break}}else{j=c[e+8>>2]|0;if(j>>>0<h>>>0)Wa();h=j+12|0;if((c[h>>2]|0)!=(e|0))Wa();l=k+8|0;if((c[l>>2]|0)==(e|0)){c[h>>2]=k;c[l>>2]=j;B=k;break}else Wa()}while(0);do if(g){j=c[e+28>>2]|0;h=5128+(j<<2)|0;if((e|0)==(c[h>>2]|0)){c[h>>2]=B;if(!B){c[1207]=c[1207]&~(1<<j);break}}else{if(g>>>0<(c[1210]|0)>>>0)Wa();h=g+16|0;if((c[h>>2]|0)==(e|0))c[h>>2]=B;else c[g+20>>2]=B;if(!B)break}h=c[1210]|0;if(B>>>0<h>>>0)Wa();c[B+24>>2]=g;g=c[e+16>>2]|0;do if(g)if(g>>>0<h>>>0)Wa();else{c[B+16>>2]=g;c[g+24>>2]=B;break}while(0);g=c[e+20>>2]|0;if(g)if(g>>>0<(c[1210]|0)>>>0)Wa();else{c[B+20>>2]=g;c[g+24>>2]=B;break}}while(0);if(d>>>0<16){H=d+a|0;c[e+4>>2]=H|3;H=e+(H+4)|0;c[H>>2]=c[H>>2]|1}else{c[e+4>>2]=a|3;c[e+(a|4)>>2]=d|1;c[e+(d+a)>>2]=d;h=c[1208]|0;if(h){g=c[1211]|0;k=h>>>3;l=k<<1;h=4864+(l<<2)|0;j=c[1206]|0;k=1<<k;if(j&k){j=4864+(l+2<<2)|0;k=c[j>>2]|0;if(k>>>0<(c[1210]|0)>>>0)Wa();else{A=j;z=k}}else{c[1206]=j|k;A=4864+(l+2<<2)|0;z=h}c[A>>2]=g;c[z+12>>2]=g;c[g+8>>2]=z;c[g+12>>2]=h}c[1208]=d;c[1211]=f}H=e+8|0;i=b;return H|0}}}else if(a>>>0<=4294967231){z=a+11|0;a=z&-8;B=c[1207]|0;if(B){A=0-a|0;z=z>>>8;if(z)if(a>>>0>16777215)C=31;else{G=(z+1048320|0)>>>16&8;H=z<<G;F=(H+520192|0)>>>16&4;H=H<<F;C=(H+245760|0)>>>16&2;C=14-(F|G|C)+(H<<C>>>15)|0;C=a>>>(C+7|0)&1|C<<1}else C=0;D=c[5128+(C<<2)>>2]|0;a:do if(!D){F=0;z=0}else{if((C|0)==31)z=0;else z=25-(C>>>1)|0;F=0;E=a<<z;z=0;while(1){G=c[D+4>>2]&-8;H=G-a|0;if(H>>>0<A>>>0)if((G|0)==(a|0)){A=H;F=D;z=D;break a}else{A=H;z=D}H=c[D+20>>2]|0;D=c[D+(E>>>31<<2)+16>>2]|0;F=(H|0)==0|(H|0)==(D|0)?F:H;if(!D)break;else E=E<<1}}while(0);if((F|0)==0&(z|0)==0){H=2<<C;B=B&(H|0-H);if(!B)break;H=(B&0-B)+ -1|0;D=H>>>12&16;H=H>>>D;C=H>>>5&8;H=H>>>C;E=H>>>2&4;H=H>>>E;G=H>>>1&2;H=H>>>G;F=H>>>1&1;F=c[5128+((C|D|E|G|F)+(H>>>F)<<2)>>2]|0}if(F)while(1){H=(c[F+4>>2]&-8)-a|0;B=H>>>0<A>>>0;A=B?H:A;z=B?F:z;B=c[F+16>>2]|0;if(B){F=B;continue}F=c[F+20>>2]|0;if(!F)break}if((z|0)!=0?A>>>0<((c[1208]|0)-a|0)>>>0:0){f=c[1210]|0;if(z>>>0<f>>>0)Wa();d=z+a|0;if(z>>>0>=d>>>0)Wa();e=c[z+24>>2]|0;g=c[z+12>>2]|0;do if((g|0)==(z|0)){h=z+20|0;g=c[h>>2]|0;if(!g){h=z+16|0;g=c[h>>2]|0;if(!g){x=0;break}}while(1){j=g+20|0;k=c[j>>2]|0;if(k){g=k;h=j;continue}j=g+16|0;k=c[j>>2]|0;if(!k)break;else{g=k;h=j}}if(h>>>0<f>>>0)Wa();else{c[h>>2]=0;x=g;break}}else{h=c[z+8>>2]|0;if(h>>>0<f>>>0)Wa();j=h+12|0;if((c[j>>2]|0)!=(z|0))Wa();f=g+8|0;if((c[f>>2]|0)==(z|0)){c[j>>2]=g;c[f>>2]=h;x=g;break}else Wa()}while(0);do if(e){f=c[z+28>>2]|0;g=5128+(f<<2)|0;if((z|0)==(c[g>>2]|0)){c[g>>2]=x;if(!x){c[1207]=c[1207]&~(1<<f);break}}else{if(e>>>0<(c[1210]|0)>>>0)Wa();f=e+16|0;if((c[f>>2]|0)==(z|0))c[f>>2]=x;else c[e+20>>2]=x;if(!x)break}f=c[1210]|0;if(x>>>0<f>>>0)Wa();c[x+24>>2]=e;e=c[z+16>>2]|0;do if(e)if(e>>>0<f>>>0)Wa();else{c[x+16>>2]=e;c[e+24>>2]=x;break}while(0);e=c[z+20>>2]|0;if(e)if(e>>>0<(c[1210]|0)>>>0)Wa();else{c[x+20>>2]=e;c[e+24>>2]=x;break}}while(0);b:do if(A>>>0>=16){c[z+4>>2]=a|3;c[z+(a|4)>>2]=A|1;c[z+(A+a)>>2]=A;f=A>>>3;if(A>>>0<256){h=f<<1;e=4864+(h<<2)|0;g=c[1206]|0;f=1<<f;do if(!(g&f)){c[1206]=g|f;w=4864+(h+2<<2)|0;v=e}else{f=4864+(h+2<<2)|0;g=c[f>>2]|0;if(g>>>0>=(c[1210]|0)>>>0){w=f;v=g;break}Wa()}while(0);c[w>>2]=d;c[v+12>>2]=d;c[z+(a+8)>>2]=v;c[z+(a+12)>>2]=e;break}e=A>>>8;if(e)if(A>>>0>16777215)e=31;else{G=(e+1048320|0)>>>16&8;H=e<<G;F=(H+520192|0)>>>16&4;H=H<<F;e=(H+245760|0)>>>16&2;e=14-(F|G|e)+(H<<e>>>15)|0;e=A>>>(e+7|0)&1|e<<1}else e=0;f=5128+(e<<2)|0;c[z+(a+28)>>2]=e;c[z+(a+20)>>2]=0;c[z+(a+16)>>2]=0;g=c[1207]|0;h=1<<e;if(!(g&h)){c[1207]=g|h;c[f>>2]=d;c[z+(a+24)>>2]=f;c[z+(a+12)>>2]=d;c[z+(a+8)>>2]=d;break}h=c[f>>2]|0;if((e|0)==31)e=0;else e=25-(e>>>1)|0;c:do if((c[h+4>>2]&-8|0)!=(A|0)){e=A<<e;while(1){g=h+(e>>>31<<2)+16|0;f=c[g>>2]|0;if(!f)break;if((c[f+4>>2]&-8|0)==(A|0)){p=f;break c}else{e=e<<1;h=f}}if(g>>>0<(c[1210]|0)>>>0)Wa();else{c[g>>2]=d;c[z+(a+24)>>2]=h;c[z+(a+12)>>2]=d;c[z+(a+8)>>2]=d;break b}}else p=h;while(0);f=p+8|0;e=c[f>>2]|0;H=c[1210]|0;if(p>>>0>=H>>>0&e>>>0>=H>>>0){c[e+12>>2]=d;c[f>>2]=d;c[z+(a+8)>>2]=e;c[z+(a+12)>>2]=p;c[z+(a+24)>>2]=0;break}else Wa()}else{H=A+a|0;c[z+4>>2]=H|3;H=z+(H+4)|0;c[H>>2]=c[H>>2]|1}while(0);H=z+8|0;i=b;return H|0}}}else a=-1;while(0);p=c[1208]|0;if(p>>>0>=a>>>0){e=p-a|0;d=c[1211]|0;if(e>>>0>15){c[1211]=d+a;c[1208]=e;c[d+(a+4)>>2]=e|1;c[d+p>>2]=e;c[d+4>>2]=a|3}else{c[1208]=0;c[1211]=0;c[d+4>>2]=p|3;H=d+(p+4)|0;c[H>>2]=c[H>>2]|1}H=d+8|0;i=b;return H|0}p=c[1209]|0;if(p>>>0>a>>>0){G=p-a|0;c[1209]=G;H=c[1212]|0;c[1212]=H+a;c[H+(a+4)>>2]=G|1;c[H+4>>2]=a|3;H=H+8|0;i=b;return H|0}do if(!(c[1324]|0)){p=Ga(30)|0;if(!(p+ -1&p)){c[1326]=p;c[1325]=p;c[1327]=-1;c[1328]=-1;c[1329]=0;c[1317]=0;c[1324]=(Ya(0)|0)&-16^1431655768;break}else Wa()}while(0);x=a+48|0;p=c[1326]|0;w=a+47|0;A=p+w|0;p=0-p|0;v=A&p;if(v>>>0<=a>>>0){H=0;i=b;return H|0}z=c[1316]|0;if((z|0)!=0?(G=c[1314]|0,H=G+v|0,H>>>0<=G>>>0|H>>>0>z>>>0):0){H=0;i=b;return H|0}d:do if(!(c[1317]&4)){B=c[1212]|0;e:do if(B){z=5272|0;while(1){C=c[z>>2]|0;if(C>>>0<=B>>>0?(y=z+4|0,(C+(c[y>>2]|0)|0)>>>0>B>>>0):0)break;z=c[z+8>>2]|0;if(!z){o=181;break e}}if(z){A=A-(c[1209]|0)&p;if(A>>>0<2147483647){p=Aa(A|0)|0;if((p|0)==((c[z>>2]|0)+(c[y>>2]|0)|0)){z=A;o=190}else{z=A;o=191}}else z=0}else o=181}else o=181;while(0);do if((o|0)==181){y=Aa(0)|0;if((y|0)!=(-1|0)){A=y;z=c[1325]|0;p=z+ -1|0;if(!(p&A))z=v;else z=v-A+(p+A&0-z)|0;p=c[1314]|0;A=p+z|0;if(z>>>0>a>>>0&z>>>0<2147483647){H=c[1316]|0;if((H|0)!=0?A>>>0<=p>>>0|A>>>0>H>>>0:0){z=0;break}p=Aa(z|0)|0;if((p|0)==(y|0)){p=y;o=190}else o=191}else z=0}else z=0}while(0);f:do if((o|0)==190){if((p|0)!=(-1|0)){q=z;o=201;break d}}else if((o|0)==191){o=0-z|0;do if((p|0)!=(-1|0)&z>>>0<2147483647&x>>>0>z>>>0?(u=c[1326]|0,u=w-z+u&0-u,u>>>0<2147483647):0)if((Aa(u|0)|0)==(-1|0)){Aa(o|0)|0;z=0;break f}else{z=u+z|0;break}while(0);if((p|0)==(-1|0))z=0;else{q=z;o=201;break d}}while(0);c[1317]=c[1317]|4;o=198}else{z=0;o=198}while(0);if((((o|0)==198?v>>>0<2147483647:0)?(t=Aa(v|0)|0,s=Aa(0)|0,(t|0)!=(-1|0)&(s|0)!=(-1|0)&t>>>0<s>>>0):0)?(r=s-t|0,q=r>>>0>(a+40|0)>>>0,q):0){p=t;q=q?r:z;o=201}if((o|0)==201){r=(c[1314]|0)+q|0;c[1314]=r;if(r>>>0>(c[1315]|0)>>>0)c[1315]=r;r=c[1212]|0;g:do if(r){t=5272|0;while(1){s=c[t>>2]|0;v=t+4|0;w=c[v>>2]|0;if((p|0)==(s+w|0)){o=213;break}u=c[t+8>>2]|0;if(!u)break;else t=u}if(((o|0)==213?(c[t+12>>2]&8|0)==0:0)?r>>>0>=s>>>0&r>>>0<p>>>0:0){c[v>>2]=w+q;d=(c[1209]|0)+q|0;e=r+8|0;if(!(e&7))e=0;else e=0-e&7;H=d-e|0;c[1212]=r+e;c[1209]=H;c[r+(e+4)>>2]=H|1;c[r+(d+4)>>2]=40;c[1213]=c[1328];break}s=c[1210]|0;if(p>>>0<s>>>0){c[1210]=p;s=p}v=p+q|0;t=5272|0;while(1){if((c[t>>2]|0)==(v|0)){o=223;break}u=c[t+8>>2]|0;if(!u)break;else t=u}if((o|0)==223?(c[t+12>>2]&8|0)==0:0){c[t>>2]=p;h=t+4|0;c[h>>2]=(c[h>>2]|0)+q;h=p+8|0;if(!(h&7))h=0;else h=0-h&7;j=p+(q+8)|0;if(!(j&7))n=0;else n=0-j&7;o=p+(n+q)|0;k=h+a|0;j=p+k|0;m=o-(p+h)-a|0;c[p+(h+4)>>2]=a|3;h:do if((o|0)!=(r|0)){if((o|0)==(c[1211]|0)){H=(c[1208]|0)+m|0;c[1208]=H;c[1211]=j;c[p+(k+4)>>2]=H|1;c[p+(H+k)>>2]=H;break}r=q+4|0;u=c[p+(r+n)>>2]|0;if((u&3|0)==1){a=u&-8;t=u>>>3;i:do if(u>>>0>=256){l=c[p+((n|24)+q)>>2]|0;t=c[p+(q+12+n)>>2]|0;do if((t|0)==(o|0)){v=n|16;u=p+(r+v)|0;t=c[u>>2]|0;if(!t){u=p+(v+q)|0;t=c[u>>2]|0;if(!t){g=0;break}}while(1){w=t+20|0;v=c[w>>2]|0;if(v){t=v;u=w;continue}w=t+16|0;v=c[w>>2]|0;if(!v)break;else{t=v;u=w}}if(u>>>0<s>>>0)Wa();else{c[u>>2]=0;g=t;break}}else{u=c[p+((n|8)+q)>>2]|0;if(u>>>0<s>>>0)Wa();v=u+12|0;if((c[v>>2]|0)!=(o|0))Wa();s=t+8|0;if((c[s>>2]|0)==(o|0)){c[v>>2]=t;c[s>>2]=u;g=t;break}else Wa()}while(0);if(!l)break;s=c[p+(q+28+n)>>2]|0;t=5128+(s<<2)|0;do if((o|0)!=(c[t>>2]|0)){if(l>>>0<(c[1210]|0)>>>0)Wa();s=l+16|0;if((c[s>>2]|0)==(o|0))c[s>>2]=g;else c[l+20>>2]=g;if(!g)break i}else{c[t>>2]=g;if(g)break;c[1207]=c[1207]&~(1<<s);break i}while(0);o=c[1210]|0;if(g>>>0<o>>>0)Wa();c[g+24>>2]=l;s=n|16;l=c[p+(s+q)>>2]|0;do if(l)if(l>>>0<o>>>0)Wa();else{c[g+16>>2]=l;c[l+24>>2]=g;break}while(0);l=c[p+(r+s)>>2]|0;if(!l)break;if(l>>>0<(c[1210]|0)>>>0)Wa();else{c[g+20>>2]=l;c[l+24>>2]=g;break}}else{g=c[p+((n|8)+q)>>2]|0;r=c[p+(q+12+n)>>2]|0;u=4864+(t<<1<<2)|0;do if((g|0)!=(u|0)){if(g>>>0<s>>>0)Wa();if((c[g+12>>2]|0)==(o|0))break;Wa()}while(0);if((r|0)==(g|0)){c[1206]=c[1206]&~(1<<t);break}do if((r|0)==(u|0))l=r+8|0;else{if(r>>>0<s>>>0)Wa();s=r+8|0;if((c[s>>2]|0)==(o|0)){l=s;break}Wa()}while(0);c[g+12>>2]=r;c[l>>2]=g}while(0);o=p+((a|n)+q)|0;m=a+m|0}g=o+4|0;c[g>>2]=c[g>>2]&-2;c[p+(k+4)>>2]=m|1;c[p+(m+k)>>2]=m;g=m>>>3;if(m>>>0<256){l=g<<1;d=4864+(l<<2)|0;m=c[1206]|0;g=1<<g;do if(!(m&g)){c[1206]=m|g;f=4864+(l+2<<2)|0;e=d}else{l=4864+(l+2<<2)|0;g=c[l>>2]|0;if(g>>>0>=(c[1210]|0)>>>0){f=l;e=g;break}Wa()}while(0);c[f>>2]=j;c[e+12>>2]=j;c[p+(k+8)>>2]=e;c[p+(k+12)>>2]=d;break}e=m>>>8;do if(!e)e=0;else{if(m>>>0>16777215){e=31;break}G=(e+1048320|0)>>>16&8;H=e<<G;F=(H+520192|0)>>>16&4;H=H<<F;e=(H+245760|0)>>>16&2;e=14-(F|G|e)+(H<<e>>>15)|0;e=m>>>(e+7|0)&1|e<<1}while(0);l=5128+(e<<2)|0;c[p+(k+28)>>2]=e;c[p+(k+20)>>2]=0;c[p+(k+16)>>2]=0;g=c[1207]|0;f=1<<e;if(!(g&f)){c[1207]=g|f;c[l>>2]=j;c[p+(k+24)>>2]=l;c[p+(k+12)>>2]=j;c[p+(k+8)>>2]=j;break}f=c[l>>2]|0;if((e|0)==31)e=0;else e=25-(e>>>1)|0;j:do if((c[f+4>>2]&-8|0)!=(m|0)){e=m<<e;while(1){g=f+(e>>>31<<2)+16|0;l=c[g>>2]|0;if(!l)break;if((c[l+4>>2]&-8|0)==(m|0)){d=l;break j}else{e=e<<1;f=l}}if(g>>>0<(c[1210]|0)>>>0)Wa();else{c[g>>2]=j;c[p+(k+24)>>2]=f;c[p+(k+12)>>2]=j;c[p+(k+8)>>2]=j;break h}}else d=f;while(0);e=d+8|0;f=c[e>>2]|0;H=c[1210]|0;if(d>>>0>=H>>>0&f>>>0>=H>>>0){c[f+12>>2]=j;c[e>>2]=j;c[p+(k+8)>>2]=f;c[p+(k+12)>>2]=d;c[p+(k+24)>>2]=0;break}else Wa()}else{H=(c[1209]|0)+m|0;c[1209]=H;c[1212]=j;c[p+(k+4)>>2]=H|1}while(0);H=p+(h|8)|0;i=b;return H|0}e=5272|0;while(1){d=c[e>>2]|0;if(d>>>0<=r>>>0?(n=c[e+4>>2]|0,m=d+n|0,m>>>0>r>>>0):0)break;e=c[e+8>>2]|0}e=d+(n+ -39)|0;if(!(e&7))e=0;else e=0-e&7;d=d+(n+ -47+e)|0;d=d>>>0<(r+16|0)>>>0?r:d;e=d+8|0;f=p+8|0;if(!(f&7))f=0;else f=0-f&7;H=q+ -40-f|0;c[1212]=p+f;c[1209]=H;c[p+(f+4)>>2]=H|1;c[p+(q+ -36)>>2]=40;c[1213]=c[1328];c[d+4>>2]=27;c[e+0>>2]=c[1318];c[e+4>>2]=c[1319];c[e+8>>2]=c[1320];c[e+12>>2]=c[1321];c[1318]=p;c[1319]=q;c[1321]=0;c[1320]=e;e=d+28|0;c[e>>2]=7;if((d+32|0)>>>0<m>>>0)do{H=e;e=e+4|0;c[e>>2]=7}while((H+8|0)>>>0<m>>>0);if((d|0)!=(r|0)){d=d-r|0;e=r+(d+4)|0;c[e>>2]=c[e>>2]&-2;c[r+4>>2]=d|1;c[r+d>>2]=d;e=d>>>3;if(d>>>0<256){f=e<<1;d=4864+(f<<2)|0;g=c[1206]|0;e=1<<e;do if(!(g&e)){c[1206]=g|e;k=4864+(f+2<<2)|0;j=d}else{f=4864+(f+2<<2)|0;e=c[f>>2]|0;if(e>>>0>=(c[1210]|0)>>>0){k=f;j=e;break}Wa()}while(0);c[k>>2]=r;c[j+12>>2]=r;c[r+8>>2]=j;c[r+12>>2]=d;break}e=d>>>8;if(e)if(d>>>0>16777215)e=31;else{G=(e+1048320|0)>>>16&8;H=e<<G;F=(H+520192|0)>>>16&4;H=H<<F;e=(H+245760|0)>>>16&2;e=14-(F|G|e)+(H<<e>>>15)|0;e=d>>>(e+7|0)&1|e<<1}else e=0;j=5128+(e<<2)|0;c[r+28>>2]=e;c[r+20>>2]=0;c[r+16>>2]=0;f=c[1207]|0;g=1<<e;if(!(f&g)){c[1207]=f|g;c[j>>2]=r;c[r+24>>2]=j;c[r+12>>2]=r;c[r+8>>2]=r;break}f=c[j>>2]|0;if((e|0)==31)e=0;else e=25-(e>>>1)|0;k:do if((c[f+4>>2]&-8|0)!=(d|0)){e=d<<e;j=f;while(1){f=j+(e>>>31<<2)+16|0;g=c[f>>2]|0;if(!g)break;if((c[g+4>>2]&-8|0)==(d|0)){h=g;break k}else{e=e<<1;j=g}}if(f>>>0<(c[1210]|0)>>>0)Wa();else{c[f>>2]=r;c[r+24>>2]=j;c[r+12>>2]=r;c[r+8>>2]=r;break g}}else h=f;while(0);e=h+8|0;d=c[e>>2]|0;H=c[1210]|0;if(h>>>0>=H>>>0&d>>>0>=H>>>0){c[d+12>>2]=r;c[e>>2]=r;c[r+8>>2]=d;c[r+12>>2]=h;c[r+24>>2]=0;break}else Wa()}}else{H=c[1210]|0;if((H|0)==0|p>>>0<H>>>0)c[1210]=p;c[1318]=p;c[1319]=q;c[1321]=0;c[1215]=c[1324];c[1214]=-1;d=0;do{H=d<<1;G=4864+(H<<2)|0;c[4864+(H+3<<2)>>2]=G;c[4864+(H+2<<2)>>2]=G;d=d+1|0}while((d|0)!=32);d=p+8|0;if(!(d&7))d=0;else d=0-d&7;H=q+ -40-d|0;c[1212]=p+d;c[1209]=H;c[p+(d+4)>>2]=H|1;c[p+(q+ -36)>>2]=40;c[1213]=c[1328]}while(0);d=c[1209]|0;if(d>>>0>a>>>0){G=d-a|0;c[1209]=G;H=c[1212]|0;c[1212]=H+a;c[H+(a+4)>>2]=G|1;c[H+4>>2]=a|3;H=H+8|0;i=b;return H|0}}c[(Oa()|0)>>2]=12;H=0;i=b;return H|0}function Td(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;b=i;if(!a){i=b;return}q=a+ -8|0;r=c[1210]|0;if(q>>>0<r>>>0)Wa();n=c[a+ -4>>2]|0;m=n&3;if((m|0)==1)Wa();j=n&-8;h=a+(j+ -8)|0;do if(!(n&1)){u=c[q>>2]|0;if(!m){i=b;return}q=-8-u|0;n=a+q|0;m=u+j|0;if(n>>>0<r>>>0)Wa();if((n|0)==(c[1211]|0)){e=a+(j+ -4)|0;o=c[e>>2]|0;if((o&3|0)!=3){e=n;o=m;break}c[1208]=m;c[e>>2]=o&-2;c[a+(q+4)>>2]=m|1;c[h>>2]=m;i=b;return}t=u>>>3;if(u>>>0<256){e=c[a+(q+8)>>2]|0;o=c[a+(q+12)>>2]|0;p=4864+(t<<1<<2)|0;if((e|0)!=(p|0)){if(e>>>0<r>>>0)Wa();if((c[e+12>>2]|0)!=(n|0))Wa()}if((o|0)==(e|0)){c[1206]=c[1206]&~(1<<t);e=n;o=m;break}if((o|0)!=(p|0)){if(o>>>0<r>>>0)Wa();p=o+8|0;if((c[p>>2]|0)==(n|0))s=p;else Wa()}else s=o+8|0;c[e+12>>2]=o;c[s>>2]=e;e=n;o=m;break}s=c[a+(q+24)>>2]|0;t=c[a+(q+12)>>2]|0;do if((t|0)==(n|0)){u=a+(q+20)|0;t=c[u>>2]|0;if(!t){u=a+(q+16)|0;t=c[u>>2]|0;if(!t){p=0;break}}while(1){v=t+20|0;w=c[v>>2]|0;if(w){t=w;u=v;continue}v=t+16|0;w=c[v>>2]|0;if(!w)break;else{t=w;u=v}}if(u>>>0<r>>>0)Wa();else{c[u>>2]=0;p=t;break}}else{u=c[a+(q+8)>>2]|0;if(u>>>0<r>>>0)Wa();r=u+12|0;if((c[r>>2]|0)!=(n|0))Wa();v=t+8|0;if((c[v>>2]|0)==(n|0)){c[r>>2]=t;c[v>>2]=u;p=t;break}else Wa()}while(0);if(s){r=c[a+(q+28)>>2]|0;t=5128+(r<<2)|0;if((n|0)==(c[t>>2]|0)){c[t>>2]=p;if(!p){c[1207]=c[1207]&~(1<<r);e=n;o=m;break}}else{if(s>>>0<(c[1210]|0)>>>0)Wa();r=s+16|0;if((c[r>>2]|0)==(n|0))c[r>>2]=p;else c[s+20>>2]=p;if(!p){e=n;o=m;break}}r=c[1210]|0;if(p>>>0<r>>>0)Wa();c[p+24>>2]=s;s=c[a+(q+16)>>2]|0;do if(s)if(s>>>0<r>>>0)Wa();else{c[p+16>>2]=s;c[s+24>>2]=p;break}while(0);q=c[a+(q+20)>>2]|0;if(q)if(q>>>0<(c[1210]|0)>>>0)Wa();else{c[p+20>>2]=q;c[q+24>>2]=p;e=n;o=m;break}else{e=n;o=m}}else{e=n;o=m}}else{e=q;o=j}while(0);if(e>>>0>=h>>>0)Wa();m=a+(j+ -4)|0;n=c[m>>2]|0;if(!(n&1))Wa();if(!(n&2)){if((h|0)==(c[1212]|0)){w=(c[1209]|0)+o|0;c[1209]=w;c[1212]=e;c[e+4>>2]=w|1;if((e|0)!=(c[1211]|0)){i=b;return}c[1211]=0;c[1208]=0;i=b;return}if((h|0)==(c[1211]|0)){w=(c[1208]|0)+o|0;c[1208]=w;c[1211]=e;c[e+4>>2]=w|1;c[e+w>>2]=w;i=b;return}o=(n&-8)+o|0;m=n>>>3;do if(n>>>0>=256){l=c[a+(j+16)>>2]|0;m=c[a+(j|4)>>2]|0;do if((m|0)==(h|0)){n=a+(j+12)|0;m=c[n>>2]|0;if(!m){n=a+(j+8)|0;m=c[n>>2]|0;if(!m){k=0;break}}while(1){q=m+20|0;p=c[q>>2]|0;if(p){m=p;n=q;continue}p=m+16|0;q=c[p>>2]|0;if(!q)break;else{m=q;n=p}}if(n>>>0<(c[1210]|0)>>>0)Wa();else{c[n>>2]=0;k=m;break}}else{n=c[a+j>>2]|0;if(n>>>0<(c[1210]|0)>>>0)Wa();p=n+12|0;if((c[p>>2]|0)!=(h|0))Wa();q=m+8|0;if((c[q>>2]|0)==(h|0)){c[p>>2]=m;c[q>>2]=n;k=m;break}else Wa()}while(0);if(l){m=c[a+(j+20)>>2]|0;n=5128+(m<<2)|0;if((h|0)==(c[n>>2]|0)){c[n>>2]=k;if(!k){c[1207]=c[1207]&~(1<<m);break}}else{if(l>>>0<(c[1210]|0)>>>0)Wa();m=l+16|0;if((c[m>>2]|0)==(h|0))c[m>>2]=k;else c[l+20>>2]=k;if(!k)break}h=c[1210]|0;if(k>>>0<h>>>0)Wa();c[k+24>>2]=l;l=c[a+(j+8)>>2]|0;do if(l)if(l>>>0<h>>>0)Wa();else{c[k+16>>2]=l;c[l+24>>2]=k;break}while(0);h=c[a+(j+12)>>2]|0;if(h)if(h>>>0<(c[1210]|0)>>>0)Wa();else{c[k+20>>2]=h;c[h+24>>2]=k;break}}}else{k=c[a+j>>2]|0;j=c[a+(j|4)>>2]|0;a=4864+(m<<1<<2)|0;if((k|0)!=(a|0)){if(k>>>0<(c[1210]|0)>>>0)Wa();if((c[k+12>>2]|0)!=(h|0))Wa()}if((j|0)==(k|0)){c[1206]=c[1206]&~(1<<m);break}if((j|0)!=(a|0)){if(j>>>0<(c[1210]|0)>>>0)Wa();a=j+8|0;if((c[a>>2]|0)==(h|0))l=a;else Wa()}else l=j+8|0;c[k+12>>2]=j;c[l>>2]=k}while(0);c[e+4>>2]=o|1;c[e+o>>2]=o;if((e|0)==(c[1211]|0)){c[1208]=o;i=b;return}}else{c[m>>2]=n&-2;c[e+4>>2]=o|1;c[e+o>>2]=o}h=o>>>3;if(o>>>0<256){j=h<<1;d=4864+(j<<2)|0;k=c[1206]|0;h=1<<h;if(k&h){j=4864+(j+2<<2)|0;h=c[j>>2]|0;if(h>>>0<(c[1210]|0)>>>0)Wa();else{f=j;g=h}}else{c[1206]=k|h;f=4864+(j+2<<2)|0;g=d}c[f>>2]=e;c[g+12>>2]=e;c[e+8>>2]=g;c[e+12>>2]=d;i=b;return}f=o>>>8;if(f)if(o>>>0>16777215)f=31;else{v=(f+1048320|0)>>>16&8;w=f<<v;u=(w+520192|0)>>>16&4;w=w<<u;f=(w+245760|0)>>>16&2;f=14-(u|v|f)+(w<<f>>>15)|0;f=o>>>(f+7|0)&1|f<<1}else f=0;g=5128+(f<<2)|0;c[e+28>>2]=f;c[e+20>>2]=0;c[e+16>>2]=0;j=c[1207]|0;h=1<<f;a:do if(j&h){g=c[g>>2]|0;if((f|0)==31)f=0;else f=25-(f>>>1)|0;b:do if((c[g+4>>2]&-8|0)!=(o|0)){f=o<<f;while(1){j=g+(f>>>31<<2)+16|0;h=c[j>>2]|0;if(!h)break;if((c[h+4>>2]&-8|0)==(o|0)){d=h;break b}else{f=f<<1;g=h}}if(j>>>0<(c[1210]|0)>>>0)Wa();else{c[j>>2]=e;c[e+24>>2]=g;c[e+12>>2]=e;c[e+8>>2]=e;break a}}else d=g;while(0);g=d+8|0;f=c[g>>2]|0;w=c[1210]|0;if(d>>>0>=w>>>0&f>>>0>=w>>>0){c[f+12>>2]=e;c[g>>2]=e;c[e+8>>2]=f;c[e+12>>2]=d;c[e+24>>2]=0;break}else Wa()}else{c[1207]=j|h;c[g>>2]=e;c[e+24>>2]=g;c[e+12>>2]=e;c[e+8>>2]=e}while(0);w=(c[1214]|0)+ -1|0;c[1214]=w;if(!w)d=5280|0;else{i=b;return}while(1){d=c[d>>2]|0;if(!d)break;else d=d+8|0}c[1214]=-1;i=b;return}function Ud(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=i;do if(a){if(b>>>0>4294967231){c[(Oa()|0)>>2]=12;e=0;break}if(b>>>0<11)e=16;else e=b+11&-8;e=fe(a+ -8|0,e)|0;if(e){e=e+8|0;break}e=Sd(b)|0;if(!e)e=0;else{f=c[a+ -4>>2]|0;f=(f&-8)-((f&3|0)==0?8:4)|0;pe(e|0,a|0,(f>>>0<b>>>0?f:b)|0)|0;Td(a)}}else e=Sd(b)|0;while(0);i=d;return e|0}function Vd(a){a=a|0;if((a|0)==32)a=1;else a=(a+ -9|0)>>>0<5;return a&1|0}function Wd(b,e,f,g,h){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;j=i;if(e>>>0>36){c[(Oa()|0)>>2]=22;s=0;t=0;F=s;i=j;return t|0}k=b+4|0;l=b+100|0;do{m=c[k>>2]|0;if(m>>>0<(c[l>>2]|0)>>>0){c[k>>2]=m+1;o=d[m>>0]|0}else o=Zd(b)|0}while((Vd(o)|0)!=0);do if((o|0)==43|(o|0)==45){m=((o|0)==45)<<31>>31;n=c[k>>2]|0;if(n>>>0<(c[l>>2]|0)>>>0){c[k>>2]=n+1;o=d[n>>0]|0;break}else{o=Zd(b)|0;break}}else m=0;while(0);n=(e|0)==0;do if((e&-17|0)==0&(o|0)==48){o=c[k>>2]|0;if(o>>>0<(c[l>>2]|0)>>>0){c[k>>2]=o+1;o=d[o>>0]|0}else o=Zd(b)|0;if((o|32|0)!=120)if(n){e=8;f=46;break}else{f=32;break}e=c[k>>2]|0;if(e>>>0<(c[l>>2]|0)>>>0){c[k>>2]=e+1;o=d[e>>0]|0}else o=Zd(b)|0;if((d[o+5321>>0]|0)>15){g=(c[l>>2]|0)==0;if(!g)c[k>>2]=(c[k>>2]|0)+ -1;if(!f){Yd(b,0);s=0;t=0;F=s;i=j;return t|0}if(g){s=0;t=0;F=s;i=j;return t|0}c[k>>2]=(c[k>>2]|0)+ -1;s=0;t=0;F=s;i=j;return t|0}else{e=16;f=46}}else{e=n?10:e;if((d[o+5321>>0]|0)>>>0<e>>>0)f=32;else{if(c[l>>2]|0)c[k>>2]=(c[k>>2]|0)+ -1;Yd(b,0);c[(Oa()|0)>>2]=22;s=0;t=0;F=s;i=j;return t|0}}while(0);if((f|0)==32)if((e|0)==10){e=o+ -48|0;if(e>>>0<10){n=0;do{n=(n*10|0)+e|0;e=c[k>>2]|0;if(e>>>0<(c[l>>2]|0)>>>0){c[k>>2]=e+1;o=d[e>>0]|0}else o=Zd(b)|0;e=o+ -48|0}while(e>>>0<10&n>>>0<429496729);p=0}else{n=0;p=0}e=o+ -48|0;if(e>>>0<10){do{q=we(n|0,p|0,10,0)|0;r=F;s=((e|0)<0)<<31>>31;t=~s;if(r>>>0>t>>>0|(r|0)==(t|0)&q>>>0>~e>>>0)break;n=ne(q|0,r|0,e|0,s|0)|0;p=F;e=c[k>>2]|0;if(e>>>0<(c[l>>2]|0)>>>0){c[k>>2]=e+1;o=d[e>>0]|0}else o=Zd(b)|0;e=o+ -48|0}while(e>>>0<10&(p>>>0<429496729|(p|0)==429496729&n>>>0<2576980378));if(e>>>0<=9){e=10;f=72}}}else f=46;a:do if((f|0)==46){if(!(e+ -1&e)){f=a[5584+((e*23|0)>>>5&7)>>0]|0;r=a[o+5321>>0]|0;n=r&255;if(n>>>0<e>>>0){o=n;n=0;do{n=o|n<<f;o=c[k>>2]|0;if(o>>>0<(c[l>>2]|0)>>>0){c[k>>2]=o+1;s=d[o>>0]|0}else s=Zd(b)|0;r=a[s+5321>>0]|0;o=r&255}while(o>>>0<e>>>0&n>>>0<134217728);p=0}else{p=0;n=0;s=o}o=oe(-1,-1,f|0)|0;q=F;if((r&255)>>>0>=e>>>0|(p>>>0>q>>>0|(p|0)==(q|0)&n>>>0>o>>>0)){o=s;f=72;break}while(1){n=le(n|0,p|0,f|0)|0;p=F;n=r&255|n;r=c[k>>2]|0;if(r>>>0<(c[l>>2]|0)>>>0){c[k>>2]=r+1;s=d[r>>0]|0}else s=Zd(b)|0;r=a[s+5321>>0]|0;if((r&255)>>>0>=e>>>0|(p>>>0>q>>>0|(p|0)==(q|0)&n>>>0>o>>>0)){o=s;f=72;break a}}}r=a[o+5321>>0]|0;f=r&255;if(f>>>0<e>>>0){n=0;do{n=f+(ba(n,e)|0)|0;f=c[k>>2]|0;if(f>>>0<(c[l>>2]|0)>>>0){c[k>>2]=f+1;q=d[f>>0]|0}else q=Zd(b)|0;r=a[q+5321>>0]|0;f=r&255}while(f>>>0<e>>>0&n>>>0<119304647);p=0}else{n=0;p=0;q=o}if((r&255)>>>0<e>>>0){f=xe(-1,-1,e|0,0)|0;o=F;while(1){if(p>>>0>o>>>0|(p|0)==(o|0)&n>>>0>f>>>0){o=q;f=72;break a}s=we(n|0,p|0,e|0,0)|0;t=F;r=r&255;if(t>>>0>4294967295|(t|0)==-1&s>>>0>~r>>>0){o=q;f=72;break a}n=ne(r|0,0,s|0,t|0)|0;p=F;q=c[k>>2]|0;if(q>>>0<(c[l>>2]|0)>>>0){c[k>>2]=q+1;q=d[q>>0]|0}else q=Zd(b)|0;r=a[q+5321>>0]|0;if((r&255)>>>0>=e>>>0){o=q;f=72;break}}}else{o=q;f=72}}while(0);if((f|0)==72)if((d[o+5321>>0]|0)>>>0<e>>>0){do{f=c[k>>2]|0;if(f>>>0<(c[l>>2]|0)>>>0){c[k>>2]=f+1;f=d[f>>0]|0}else f=Zd(b)|0}while((d[f+5321>>0]|0)>>>0<e>>>0);c[(Oa()|0)>>2]=34;p=h;n=g}if(c[l>>2]|0)c[k>>2]=(c[k>>2]|0)+ -1;if(!(p>>>0<h>>>0|(p|0)==(h|0)&n>>>0<g>>>0)){if(!((g&1|0)!=0|0!=0|(m|0)!=0)){c[(Oa()|0)>>2]=34;t=ne(g|0,h|0,-1,-1)|0;s=F;F=s;i=j;return t|0}if(p>>>0>h>>>0|(p|0)==(h|0)&n>>>0>g>>>0){c[(Oa()|0)>>2]=34;s=h;t=g;F=s;i=j;return t|0}}t=((m|0)<0)<<31>>31;t=je(n^m|0,p^t|0,m|0,t|0)|0;s=F;F=s;i=j;return t|0}



function Xd(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0,s=0,t=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0.0,H=0,I=0.0,J=0.0,K=0.0,L=0.0;g=i;i=i+512|0;k=g;if(!e){e=24;j=-149}else if((e|0)==2){e=53;j=-1074}else if((e|0)==1){e=53;j=-1074}else{J=0.0;i=g;return+J}n=b+4|0;o=b+100|0;do{h=c[n>>2]|0;if(h>>>0<(c[o>>2]|0)>>>0){c[n>>2]=h+1;w=d[h>>0]|0}else w=Zd(b)|0}while((Vd(w)|0)!=0);do if((w|0)==43|(w|0)==45){h=1-(((w|0)==45&1)<<1)|0;m=c[n>>2]|0;if(m>>>0<(c[o>>2]|0)>>>0){c[n>>2]=m+1;w=d[m>>0]|0;break}else{w=Zd(b)|0;break}}else h=1;while(0);r=0;do{if((w|32|0)!=(a[5600+r>>0]|0))break;do if(r>>>0<7){m=c[n>>2]|0;if(m>>>0<(c[o>>2]|0)>>>0){c[n>>2]=m+1;w=d[m>>0]|0;break}else{w=Zd(b)|0;break}}while(0);r=r+1|0}while(r>>>0<8);do if((r|0)==3)p=23;else if((r|0)!=8){m=(f|0)!=0;if(r>>>0>3&m)if((r|0)==8)break;else{p=23;break}a:do if(!r){r=0;do{if((w|32|0)!=(a[5616+r>>0]|0))break a;do if(r>>>0<2){s=c[n>>2]|0;if(s>>>0<(c[o>>2]|0)>>>0){c[n>>2]=s+1;w=d[s>>0]|0;break}else{w=Zd(b)|0;break}}while(0);r=r+1|0}while(r>>>0<3)}while(0);if(!r){do if((w|0)==48){m=c[n>>2]|0;if(m>>>0<(c[o>>2]|0)>>>0){c[n>>2]=m+1;m=d[m>>0]|0}else m=Zd(b)|0;if((m|32|0)!=120){if(!(c[o>>2]|0)){w=48;break}c[n>>2]=(c[n>>2]|0)+ -1;w=48;break}k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k>>0]|0;x=0}else{z=Zd(b)|0;x=0}while(1){if((z|0)==46){p=70;break}else if((z|0)!=48){k=0;m=0;s=0;r=0;w=0;y=0;G=1.0;t=0;q=0.0;break}k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k>>0]|0;x=1;continue}else{z=Zd(b)|0;x=1;continue}}if((p|0)==70){k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k>>0]|0}else z=Zd(b)|0;if((z|0)==48){s=0;r=0;do{k=c[n>>2]|0;if(k>>>0<(c[o>>2]|0)>>>0){c[n>>2]=k+1;z=d[k>>0]|0}else z=Zd(b)|0;s=ne(s|0,r|0,-1,-1)|0;r=F}while((z|0)==48);k=0;m=0;x=1;w=1;y=0;G=1.0;t=0;q=0.0}else{k=0;m=0;s=0;r=0;w=1;y=0;G=1.0;t=0;q=0.0}}b:while(1){B=z+ -48|0;do if(B>>>0>=10){A=z|32;C=(z|0)==46;if(!((A+ -97|0)>>>0<6|C))break b;if(C)if(!w){s=m;r=k;w=1;break}else{z=46;break b}else{B=(z|0)>57?A+ -87|0:B;p=83;break}}else p=83;while(0);if((p|0)==83){p=0;do if(!((k|0)<0|(k|0)==0&m>>>0<8)){if((k|0)<0|(k|0)==0&m>>>0<14){J=G*.0625;I=J;q=q+J*+(B|0);break}if((B|0)==0|(y|0)!=0)I=G;else{y=1;I=G;q=q+G*.5}}else{I=G;t=B+(t<<4)|0}while(0);m=ne(m|0,k|0,1,0)|0;k=F;x=1;G=I}z=c[n>>2]|0;if(z>>>0<(c[o>>2]|0)>>>0){c[n>>2]=z+1;z=d[z>>0]|0;continue}else{z=Zd(b)|0;continue}}if(!x){e=(c[o>>2]|0)==0;if(!e)c[n>>2]=(c[n>>2]|0)+ -1;if(f){if(!e?(l=c[n>>2]|0,c[n>>2]=l+ -1,(w|0)!=0):0)c[n>>2]=l+ -2}else Yd(b,0);J=+(h|0)*0.0;i=g;return+J}p=(w|0)==0;l=p?m:s;p=p?k:r;if((k|0)<0|(k|0)==0&m>>>0<8)do{t=t<<4;m=ne(m|0,k|0,1,0)|0;k=F}while((k|0)<0|(k|0)==0&m>>>0<8);do if((z|32|0)==112){m=he(b,f)|0;k=F;if((m|0)==0&(k|0)==-2147483648)if(!f){Yd(b,0);J=0.0;i=g;return+J}else{if(!(c[o>>2]|0)){m=0;k=0;break}c[n>>2]=(c[n>>2]|0)+ -1;m=0;k=0;break}}else if(!(c[o>>2]|0)){m=0;k=0}else{c[n>>2]=(c[n>>2]|0)+ -1;m=0;k=0}while(0);l=le(l|0,p|0,2)|0;l=ne(l|0,F|0,-32,-1)|0;k=ne(l|0,F|0,m|0,k|0)|0;l=F;if(!t){J=+(h|0)*0.0;i=g;return+J}if((l|0)>0|(l|0)==0&k>>>0>(0-j|0)>>>0){c[(Oa()|0)>>2]=34;J=+(h|0)*1.7976931348623157e+308*1.7976931348623157e+308;i=g;return+J}H=j+ -106|0;E=((H|0)<0)<<31>>31;if((l|0)<(E|0)|(l|0)==(E|0)&k>>>0<H>>>0){c[(Oa()|0)>>2]=34;J=+(h|0)*2.2250738585072014e-308*2.2250738585072014e-308;i=g;return+J}if((t|0)>-1)do{t=t<<1;if(!(q>=.5))G=q;else{G=q+-1.0;t=t|1}q=q+G;k=ne(k|0,l|0,-1,-1)|0;l=F}while((t|0)>-1);j=je(32,0,j|0,((j|0)<0)<<31>>31|0)|0;j=ne(k|0,l|0,j|0,F|0)|0;H=F;if(0>(H|0)|0==(H|0)&e>>>0>j>>>0)if((j|0)<0){e=0;p=126}else{e=j;p=124}else p=124;if((p|0)==124)if((e|0)<53)p=126;else{j=e;G=+(h|0);I=0.0}if((p|0)==126){I=+(h|0);j=e;G=I;I=+Va(+(+_d(1.0,84-e|0)),+I)}H=(j|0)<32&q!=0.0&(t&1|0)==0;q=G*(H?0.0:q)+(I+G*+(((H&1)+t|0)>>>0))-I;if(!(q!=0.0))c[(Oa()|0)>>2]=34;J=+$d(q,k);i=g;return+J}while(0);m=j+e|0;l=0-m|0;B=0;while(1){if((w|0)==46){p=137;break}else if((w|0)!=48){D=0;C=0;A=0;break}r=c[n>>2]|0;if(r>>>0<(c[o>>2]|0)>>>0){c[n>>2]=r+1;w=d[r>>0]|0;B=1;continue}else{w=Zd(b)|0;B=1;continue}}if((p|0)==137){p=c[n>>2]|0;if(p>>>0<(c[o>>2]|0)>>>0){c[n>>2]=p+1;w=d[p>>0]|0}else w=Zd(b)|0;if((w|0)==48){D=0;C=0;do{D=ne(D|0,C|0,-1,-1)|0;C=F;p=c[n>>2]|0;if(p>>>0<(c[o>>2]|0)>>>0){c[n>>2]=p+1;w=d[p>>0]|0}else w=Zd(b)|0}while((w|0)==48);B=1;A=1}else{D=0;C=0;A=1}}c[k>>2]=0;z=w+ -48|0;E=(w|0)==46;c:do if(z>>>0<10|E){p=k+496|0;y=0;x=0;t=0;s=0;r=0;d:while(1){do if(E)if(!A){D=y;C=x;A=1}else break d;else{E=ne(y|0,x|0,1,0)|0;x=F;H=(w|0)!=48;if((s|0)>=125){if(!H){y=E;break}c[p>>2]=c[p>>2]|1;y=E;break}y=k+(s<<2)|0;if(t)z=w+ -48+((c[y>>2]|0)*10|0)|0;c[y>>2]=z;t=t+1|0;z=(t|0)==9;y=E;B=1;t=z?0:t;s=(z&1)+s|0;r=H?E:r}while(0);w=c[n>>2]|0;if(w>>>0<(c[o>>2]|0)>>>0){c[n>>2]=w+1;w=d[w>>0]|0}else w=Zd(b)|0;z=w+ -48|0;E=(w|0)==46;if(!(z>>>0<10|E)){p=160;break c}}z=(B|0)!=0;p=168}else{y=0;x=0;t=0;s=0;r=0;p=160}while(0);do if((p|0)==160){z=(A|0)==0;D=z?y:D;C=z?x:C;z=(B|0)!=0;if(!(z&(w|32|0)==101))if((w|0)>-1){p=168;break}else{p=170;break}z=he(b,f)|0;w=F;do if((z|0)==0&(w|0)==-2147483648)if(!f){Yd(b,0);J=0.0;i=g;return+J}else{if(!(c[o>>2]|0)){z=0;w=0;break}c[n>>2]=(c[n>>2]|0)+ -1;z=0;w=0;break}while(0);b=ne(z|0,w|0,D|0,C|0)|0;C=F}while(0);if((p|0)==168)if(c[o>>2]|0){c[n>>2]=(c[n>>2]|0)+ -1;if(z)b=D;else p=171}else p=170;if((p|0)==170)if(z)b=D;else p=171;if((p|0)==171){c[(Oa()|0)>>2]=22;Yd(b,0);J=0.0;i=g;return+J}n=c[k>>2]|0;if(!n){J=+(h|0)*0.0;i=g;return+J}if((b|0)==(y|0)&(C|0)==(x|0)&((x|0)<0|(x|0)==0&y>>>0<10)?e>>>0>30|(n>>>e|0)==0:0){J=+(h|0)*+(n>>>0);i=g;return+J}H=(j|0)/-2|0;E=((H|0)<0)<<31>>31;if((C|0)>(E|0)|(C|0)==(E|0)&b>>>0>H>>>0){c[(Oa()|0)>>2]=34;J=+(h|0)*1.7976931348623157e+308*1.7976931348623157e+308;i=g;return+J}H=j+ -106|0;E=((H|0)<0)<<31>>31;if((C|0)<(E|0)|(C|0)==(E|0)&b>>>0<H>>>0){c[(Oa()|0)>>2]=34;J=+(h|0)*2.2250738585072014e-308*2.2250738585072014e-308;i=g;return+J}if(t){if((t|0)<9){n=k+(s<<2)|0;o=c[n>>2]|0;do{o=o*10|0;t=t+1|0}while((t|0)!=9);c[n>>2]=o}s=s+1|0}if((r|0)<9?(r|0)<=(b|0)&(b|0)<18:0){if((b|0)==9){J=+(h|0)*+((c[k>>2]|0)>>>0);i=g;return+J}if((b|0)<9){J=+(h|0)*+((c[k>>2]|0)>>>0)/+(c[5632+(8-b<<2)>>2]|0);i=g;return+J}H=e+27+(ba(b,-3)|0)|0;n=c[k>>2]|0;if((H|0)>30|(n>>>H|0)==0){J=+(h|0)*+(n>>>0)*+(c[5632+(b+ -10<<2)>>2]|0);i=g;return+J}}n=(b|0)%9|0;if(!n){n=0;o=0}else{f=(b|0)>-1?n:n+9|0;p=c[5632+(8-f<<2)>>2]|0;if(s){r=1e9/(p|0)|0;n=0;o=0;t=0;do{D=k+(t<<2)|0;E=c[D>>2]|0;H=((E>>>0)/(p>>>0)|0)+o|0;c[D>>2]=H;o=ba((E>>>0)%(p>>>0)|0,r)|0;E=t;t=t+1|0;if((E|0)==(n|0)&(H|0)==0){n=t&127;b=b+ -9|0}}while((t|0)!=(s|0));if(o){c[k+(s<<2)>>2]=o;s=s+1|0}}else{n=0;s=0}o=0;b=9-f+b|0}e:while(1){f=k+(n<<2)|0;if((b|0)<18){do{r=0;f=s+127|0;while(1){f=f&127;p=k+(f<<2)|0;t=le(c[p>>2]|0,0,29)|0;t=ne(t|0,F|0,r|0,0)|0;r=F;if(r>>>0>0|(r|0)==0&t>>>0>1e9){H=xe(t|0,r|0,1e9,0)|0;t=ye(t|0,r|0,1e9,0)|0;r=H}else r=0;c[p>>2]=t;p=(f|0)==(n|0);if(!((f|0)!=(s+127&127|0)|p))s=(t|0)==0?f:s;if(p)break;else f=f+ -1|0}o=o+ -29|0}while((r|0)==0)}else{if((b|0)!=18)break;do{if((c[f>>2]|0)>>>0>=9007199){b=18;break e}r=0;p=s+127|0;while(1){p=p&127;t=k+(p<<2)|0;w=le(c[t>>2]|0,0,29)|0;w=ne(w|0,F|0,r|0,0)|0;r=F;if(r>>>0>0|(r|0)==0&w>>>0>1e9){H=xe(w|0,r|0,1e9,0)|0;w=ye(w|0,r|0,1e9,0)|0;r=H}else r=0;c[t>>2]=w;t=(p|0)==(n|0);if(!((p|0)!=(s+127&127|0)|t))s=(w|0)==0?p:s;if(t)break;else p=p+ -1|0}o=o+ -29|0}while((r|0)==0)}n=n+127&127;if((n|0)==(s|0)){H=s+127&127;s=k+((s+126&127)<<2)|0;c[s>>2]=c[s>>2]|c[k+(H<<2)>>2];s=H}c[k+(n<<2)>>2]=r;b=b+9|0}f:while(1){f=s+1&127;p=k+((s+127&127)<<2)|0;while(1){t=(b|0)==18;r=(b|0)>27?9:1;while(1){w=0;while(1){x=w+n&127;if((x|0)==(s|0)){w=2;break}y=c[k+(x<<2)>>2]|0;z=c[5624+(w<<2)>>2]|0;if(y>>>0<z>>>0){w=2;break}x=w+1|0;if(y>>>0>z>>>0)break;if((x|0)<2)w=x;else{w=x;break}}if((w|0)==2&t)break f;o=r+o|0;if((n|0)==(s|0))n=s;else break}t=(1<<r)+ -1|0;w=1e9>>>r;x=n;y=0;do{D=k+(n<<2)|0;E=c[D>>2]|0;H=(E>>>r)+y|0;c[D>>2]=H;y=ba(E&t,w)|0;H=(n|0)==(x|0)&(H|0)==0;n=n+1&127;b=H?b+ -9|0:b;x=H?n:x}while((n|0)!=(s|0));if(!y){n=x;continue}if((f|0)!=(x|0))break;c[p>>2]=c[p>>2]|1;n=x}c[k+(s<<2)>>2]=y;n=x;s=f}b=n&127;if((b|0)==(s|0)){c[k+(f+ -1<<2)>>2]=0;s=f}G=+((c[k+(b<<2)>>2]|0)>>>0);b=n+1&127;if((b|0)==(s|0)){s=s+1&127;c[k+(s+ -1<<2)>>2]=0}q=+(h|0);I=q*(G*1.0e9+ +((c[k+(b<<2)>>2]|0)>>>0));h=o+53|0;j=h-j|0;if((j|0)<(e|0))if((j|0)<0){e=0;b=1;p=244}else{e=j;b=1;p=243}else{b=0;p=243}if((p|0)==243)if((e|0)<53)p=244;else{G=0.0;J=0.0}if((p|0)==244){L=+Va(+(+_d(1.0,105-e|0)),+I);K=+cb(+I,+(+_d(1.0,53-e|0)));G=L;J=K;I=L+(I-K)}f=n+2&127;do if((f|0)!=(s|0)){k=c[k+(f<<2)>>2]|0;do if(k>>>0>=5e8){if(k>>>0>5e8){J=q*.75+J;break}if((n+3&127|0)==(s|0)){J=q*.5+J;break}else{J=q*.75+J;break}}else{if((k|0)==0?(n+3&127|0)==(s|0):0)break;J=q*.25+J}while(0);if((53-e|0)<=1)break;if(+cb(+J,1.0)!=0.0)break;J=J+1.0}while(0);q=I+J-G;do if((h&2147483647|0)>(-2-m|0)){if(+Q(+q)>=9007199254740992.0){b=(b|0)!=0&(e|0)==(j|0)?0:b;o=o+1|0;q=q*.5}if((o+50|0)<=(l|0)?!((b|0)!=0&J!=0.0):0)break;c[(Oa()|0)>>2]=34}while(0);L=+$d(q,o);i=g;return+L}else if((r|0)==3){e=c[n>>2]|0;if(e>>>0<(c[o>>2]|0)>>>0){c[n>>2]=e+1;e=d[e>>0]|0}else e=Zd(b)|0;if((e|0)==40)e=1;else{if(!(c[o>>2]|0)){L=u;i=g;return+L}c[n>>2]=(c[n>>2]|0)+ -1;L=u;i=g;return+L}while(1){h=c[n>>2]|0;if(h>>>0<(c[o>>2]|0)>>>0){c[n>>2]=h+1;h=d[h>>0]|0}else h=Zd(b)|0;if(!((h+ -48|0)>>>0<10|(h+ -65|0)>>>0<26)?!((h+ -97|0)>>>0<26|(h|0)==95):0)break;e=e+1|0}if((h|0)==41){L=u;i=g;return+L}h=(c[o>>2]|0)==0;if(!h)c[n>>2]=(c[n>>2]|0)+ -1;if(!m){c[(Oa()|0)>>2]=22;Yd(b,0);L=0.0;i=g;return+L}if((e|0)==0|h){L=u;i=g;return+L}do{e=e+ -1|0;c[n>>2]=(c[n>>2]|0)+ -1}while((e|0)!=0);q=u;i=g;return+q}else{if(c[o>>2]|0)c[n>>2]=(c[n>>2]|0)+ -1;c[(Oa()|0)>>2]=22;Yd(b,0);L=0.0;i=g;return+L}}while(0);if((p|0)==23){e=(c[o>>2]|0)==0;if(!e)c[n>>2]=(c[n>>2]|0)+ -1;if(!(r>>>0<4|(f|0)==0|e))do{c[n>>2]=(c[n>>2]|0)+ -1;r=r+ -1|0}while(r>>>0>3)}L=+(h|0)*v;i=g;return+L}function Yd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;c[a+104>>2]=b;f=c[a+8>>2]|0;e=c[a+4>>2]|0;g=f-e|0;c[a+108>>2]=g;if((b|0)!=0&(g|0)>(b|0)){c[a+100>>2]=e+b;i=d;return}else{c[a+100>>2]=f;i=d;return}}function Zd(b){b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0;f=i;j=b+104|0;l=c[j>>2]|0;if(!((l|0)!=0?(c[b+108>>2]|0)>=(l|0):0))k=3;if((k|0)==3?(e=be(b)|0,(e|0)>=0):0){k=c[j>>2]|0;j=c[b+8>>2]|0;if((k|0)!=0?(g=c[b+4>>2]|0,h=k-(c[b+108>>2]|0)+ -1|0,(j-g|0)>(h|0)):0)c[b+100>>2]=g+h;else c[b+100>>2]=j;g=c[b+4>>2]|0;if(j){l=b+108|0;c[l>>2]=j+1-g+(c[l>>2]|0)}b=g+ -1|0;if((d[b>>0]|0|0)==(e|0)){l=e;i=f;return l|0}a[b>>0]=e;l=e;i=f;return l|0}c[b+100>>2]=0;l=-1;i=f;return l|0}function _d(a,b){a=+a;b=b|0;var d=0,e=0;d=i;if((b|0)>1023){a=a*8.98846567431158e+307;e=b+ -1023|0;if((e|0)>1023){b=b+ -2046|0;b=(b|0)>1023?1023:b;a=a*8.98846567431158e+307}else b=e}else if((b|0)<-1022){a=a*2.2250738585072014e-308;e=b+1022|0;if((e|0)<-1022){b=b+2044|0;b=(b|0)<-1022?-1022:b;a=a*2.2250738585072014e-308}else b=e}b=le(b+1023|0,0,52)|0;e=F;c[k>>2]=b;c[k+4>>2]=e;a=a*+h[k>>3];i=d;return+a}function $d(a,b){a=+a;b=b|0;var c=0;c=i;a=+_d(a,b);i=c;return+a}function ae(b){b=b|0;var d=0,e=0,f=0;e=i;f=b+74|0;d=a[f>>0]|0;a[f>>0]=d+255|d;f=b+20|0;d=b+44|0;if((c[f>>2]|0)>>>0>(c[d>>2]|0)>>>0)eb[c[b+36>>2]&1](b,0,0)|0;c[b+16>>2]=0;c[b+28>>2]=0;c[f>>2]=0;f=c[b>>2]|0;if(!(f&20)){f=c[d>>2]|0;c[b+8>>2]=f;c[b+4>>2]=f;f=0;i=e;return f|0}if(!(f&4)){f=-1;i=e;return f|0}c[b>>2]=f|32;f=-1;i=e;return f|0}function be(a){a=a|0;var b=0,e=0;b=i;i=i+16|0;e=b;if((c[a+8>>2]|0)==0?(ae(a)|0)!=0:0)a=-1;else if((eb[c[a+32>>2]&1](a,e,1)|0)==1)a=d[e>>0]|0;else a=-1;i=b;return a|0}function ce(a,b){a=a|0;b=b|0;var d=0,e=0,f=0.0,g=0,h=0;d=i;i=i+112|0;e=d;h=e+0|0;g=h+112|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(g|0));g=e+4|0;c[g>>2]=a;h=e+8|0;c[h>>2]=-1;c[e+44>>2]=a;c[e+76>>2]=-1;Yd(e,0);f=+Xd(e,1,1);e=(c[g>>2]|0)-(c[h>>2]|0)+(c[e+108>>2]|0)|0;if(!b){i=d;return+f}if(e)a=a+e|0;c[b>>2]=a;i=d;return+f}function de(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=i;i=i+112|0;g=e;c[g>>2]=0;f=g+4|0;c[f>>2]=a;c[g+44>>2]=a;if((a|0)<0)c[g+8>>2]=-1;else c[g+8>>2]=a+2147483647;c[g+76>>2]=-1;Yd(g,0);d=Wd(g,d,1,-2147483648,0)|0;if(!b){i=e;return d|0}c[b>>2]=a+((c[f>>2]|0)+(c[g+108>>2]|0)-(c[g+8>>2]|0));i=e;return d|0}function ee(b,c){b=b|0;c=c|0;var d=0,e=0,f=0;d=i;f=a[b>>0]|0;e=a[c>>0]|0;if(f<<24>>24==0?1:f<<24>>24!=e<<24>>24)c=f;else{do{b=b+1|0;c=c+1|0;f=a[b>>0]|0;e=a[c>>0]|0}while(!(f<<24>>24==0?1:f<<24>>24!=e<<24>>24));c=f}i=d;return(c&255)-(e&255)|0}function fe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;d=i;f=a+4|0;e=c[f>>2]|0;l=e&-8;j=a+l|0;m=c[1210]|0;h=e&3;if(!((h|0)!=1&a>>>0>=m>>>0&a>>>0<j>>>0))Wa();g=a+(l|4)|0;p=c[g>>2]|0;if(!(p&1))Wa();if(!h){if(b>>>0<256){r=0;i=d;return r|0}if(l>>>0>=(b+4|0)>>>0?(l-b|0)>>>0<=c[1326]<<1>>>0:0){r=a;i=d;return r|0}r=0;i=d;return r|0}if(l>>>0>=b>>>0){h=l-b|0;if(h>>>0<=15){r=a;i=d;return r|0}c[f>>2]=e&1|b|2;c[a+(b+4)>>2]=h|3;c[g>>2]=c[g>>2]|1;ge(a+b|0,h);r=a;i=d;return r|0}if((j|0)==(c[1212]|0)){g=(c[1209]|0)+l|0;if(g>>>0<=b>>>0){r=0;i=d;return r|0}r=g-b|0;c[f>>2]=e&1|b|2;c[a+(b+4)>>2]=r|1;c[1212]=a+b;c[1209]=r;r=a;i=d;return r|0}if((j|0)==(c[1211]|0)){h=(c[1208]|0)+l|0;if(h>>>0<b>>>0){r=0;i=d;return r|0}g=h-b|0;if(g>>>0>15){c[f>>2]=e&1|b|2;c[a+(b+4)>>2]=g|1;c[a+h>>2]=g;e=a+(h+4)|0;c[e>>2]=c[e>>2]&-2;e=a+b|0}else{c[f>>2]=e&1|h|2;e=a+(h+4)|0;c[e>>2]=c[e>>2]|1;e=0;g=0}c[1208]=g;c[1211]=e;r=a;i=d;return r|0}if(p&2){r=0;i=d;return r|0}g=(p&-8)+l|0;if(g>>>0<b>>>0){r=0;i=d;return r|0}h=g-b|0;o=p>>>3;do if(p>>>0>=256){n=c[a+(l+24)>>2]|0;o=c[a+(l+12)>>2]|0;do if((o|0)==(j|0)){p=a+(l+20)|0;o=c[p>>2]|0;if(!o){p=a+(l+16)|0;o=c[p>>2]|0;if(!o){k=0;break}}while(1){r=o+20|0;q=c[r>>2]|0;if(q){o=q;p=r;continue}q=o+16|0;r=c[q>>2]|0;if(!r)break;else{o=r;p=q}}if(p>>>0<m>>>0)Wa();else{c[p>>2]=0;k=o;break}}else{p=c[a+(l+8)>>2]|0;if(p>>>0<m>>>0)Wa();m=p+12|0;if((c[m>>2]|0)!=(j|0))Wa();q=o+8|0;if((c[q>>2]|0)==(j|0)){c[m>>2]=o;c[q>>2]=p;k=o;break}else Wa()}while(0);if(n){m=c[a+(l+28)>>2]|0;o=5128+(m<<2)|0;if((j|0)==(c[o>>2]|0)){c[o>>2]=k;if(!k){c[1207]=c[1207]&~(1<<m);break}}else{if(n>>>0<(c[1210]|0)>>>0)Wa();m=n+16|0;if((c[m>>2]|0)==(j|0))c[m>>2]=k;else c[n+20>>2]=k;if(!k)break}j=c[1210]|0;if(k>>>0<j>>>0)Wa();c[k+24>>2]=n;m=c[a+(l+16)>>2]|0;do if(m)if(m>>>0<j>>>0)Wa();else{c[k+16>>2]=m;c[m+24>>2]=k;break}while(0);j=c[a+(l+20)>>2]|0;if(j)if(j>>>0<(c[1210]|0)>>>0)Wa();else{c[k+20>>2]=j;c[j+24>>2]=k;break}}}else{k=c[a+(l+8)>>2]|0;l=c[a+(l+12)>>2]|0;p=4864+(o<<1<<2)|0;if((k|0)!=(p|0)){if(k>>>0<m>>>0)Wa();if((c[k+12>>2]|0)!=(j|0))Wa()}if((l|0)==(k|0)){c[1206]=c[1206]&~(1<<o);break}if((l|0)!=(p|0)){if(l>>>0<m>>>0)Wa();m=l+8|0;if((c[m>>2]|0)==(j|0))n=m;else Wa()}else n=l+8|0;c[k+12>>2]=l;c[n>>2]=k}while(0);if(h>>>0<16){c[f>>2]=g|e&1|2;r=a+(g|4)|0;c[r>>2]=c[r>>2]|1;r=a;i=d;return r|0}else{c[f>>2]=e&1|b|2;c[a+(b+4)>>2]=h|3;r=a+(g|4)|0;c[r>>2]=c[r>>2]|1;ge(a+b|0,h);r=a;i=d;return r|0}return 0}function ge(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;d=i;h=a+b|0;l=c[a+4>>2]|0;do if(!(l&1)){p=c[a>>2]|0;if(!(l&3)){i=d;return}l=a+(0-p)|0;m=p+b|0;r=c[1210]|0;if(l>>>0<r>>>0)Wa();if((l|0)==(c[1211]|0)){e=a+(b+4)|0;n=c[e>>2]|0;if((n&3|0)!=3){e=l;n=m;break}c[1208]=m;c[e>>2]=n&-2;c[a+(4-p)>>2]=m|1;c[h>>2]=m;i=d;return}s=p>>>3;if(p>>>0<256){e=c[a+(8-p)>>2]|0;n=c[a+(12-p)>>2]|0;o=4864+(s<<1<<2)|0;if((e|0)!=(o|0)){if(e>>>0<r>>>0)Wa();if((c[e+12>>2]|0)!=(l|0))Wa()}if((n|0)==(e|0)){c[1206]=c[1206]&~(1<<s);e=l;n=m;break}if((n|0)!=(o|0)){if(n>>>0<r>>>0)Wa();o=n+8|0;if((c[o>>2]|0)==(l|0))q=o;else Wa()}else q=n+8|0;c[e+12>>2]=n;c[q>>2]=e;e=l;n=m;break}q=c[a+(24-p)>>2]|0;s=c[a+(12-p)>>2]|0;do if((s|0)==(l|0)){u=16-p|0;t=a+(u+4)|0;s=c[t>>2]|0;if(!s){t=a+u|0;s=c[t>>2]|0;if(!s){o=0;break}}while(1){v=s+20|0;u=c[v>>2]|0;if(u){s=u;t=v;continue}u=s+16|0;v=c[u>>2]|0;if(!v)break;else{s=v;t=u}}if(t>>>0<r>>>0)Wa();else{c[t>>2]=0;o=s;break}}else{t=c[a+(8-p)>>2]|0;if(t>>>0<r>>>0)Wa();r=t+12|0;if((c[r>>2]|0)!=(l|0))Wa();u=s+8|0;if((c[u>>2]|0)==(l|0)){c[r>>2]=s;c[u>>2]=t;o=s;break}else Wa()}while(0);if(q){s=c[a+(28-p)>>2]|0;r=5128+(s<<2)|0;if((l|0)==(c[r>>2]|0)){c[r>>2]=o;if(!o){c[1207]=c[1207]&~(1<<s);e=l;n=m;break}}else{if(q>>>0<(c[1210]|0)>>>0)Wa();r=q+16|0;if((c[r>>2]|0)==(l|0))c[r>>2]=o;else c[q+20>>2]=o;if(!o){e=l;n=m;break}}r=c[1210]|0;if(o>>>0<r>>>0)Wa();c[o+24>>2]=q;p=16-p|0;q=c[a+p>>2]|0;do if(q)if(q>>>0<r>>>0)Wa();else{c[o+16>>2]=q;c[q+24>>2]=o;break}while(0);p=c[a+(p+4)>>2]|0;if(p)if(p>>>0<(c[1210]|0)>>>0)Wa();else{c[o+20>>2]=p;c[p+24>>2]=o;e=l;n=m;break}else{e=l;n=m}}else{e=l;n=m}}else{e=a;n=b}while(0);l=c[1210]|0;if(h>>>0<l>>>0)Wa();m=a+(b+4)|0;o=c[m>>2]|0;if(!(o&2)){if((h|0)==(c[1212]|0)){v=(c[1209]|0)+n|0;c[1209]=v;c[1212]=e;c[e+4>>2]=v|1;if((e|0)!=(c[1211]|0)){i=d;return}c[1211]=0;c[1208]=0;i=d;return}if((h|0)==(c[1211]|0)){v=(c[1208]|0)+n|0;c[1208]=v;c[1211]=e;c[e+4>>2]=v|1;c[e+v>>2]=v;i=d;return}n=(o&-8)+n|0;m=o>>>3;do if(o>>>0>=256){k=c[a+(b+24)>>2]|0;o=c[a+(b+12)>>2]|0;do if((o|0)==(h|0)){o=a+(b+20)|0;m=c[o>>2]|0;if(!m){o=a+(b+16)|0;m=c[o>>2]|0;if(!m){j=0;break}}while(1){p=m+20|0;q=c[p>>2]|0;if(q){m=q;o=p;continue}q=m+16|0;p=c[q>>2]|0;if(!p)break;else{m=p;o=q}}if(o>>>0<l>>>0)Wa();else{c[o>>2]=0;j=m;break}}else{m=c[a+(b+8)>>2]|0;if(m>>>0<l>>>0)Wa();p=m+12|0;if((c[p>>2]|0)!=(h|0))Wa();l=o+8|0;if((c[l>>2]|0)==(h|0)){c[p>>2]=o;c[l>>2]=m;j=o;break}else Wa()}while(0);if(k){m=c[a+(b+28)>>2]|0;l=5128+(m<<2)|0;if((h|0)==(c[l>>2]|0)){c[l>>2]=j;if(!j){c[1207]=c[1207]&~(1<<m);break}}else{if(k>>>0<(c[1210]|0)>>>0)Wa();l=k+16|0;if((c[l>>2]|0)==(h|0))c[l>>2]=j;else c[k+20>>2]=j;if(!j)break}h=c[1210]|0;if(j>>>0<h>>>0)Wa();c[j+24>>2]=k;k=c[a+(b+16)>>2]|0;do if(k)if(k>>>0<h>>>0)Wa();else{c[j+16>>2]=k;c[k+24>>2]=j;break}while(0);h=c[a+(b+20)>>2]|0;if(h)if(h>>>0<(c[1210]|0)>>>0)Wa();else{c[j+20>>2]=h;c[h+24>>2]=j;break}}}else{j=c[a+(b+8)>>2]|0;a=c[a+(b+12)>>2]|0;b=4864+(m<<1<<2)|0;if((j|0)!=(b|0)){if(j>>>0<l>>>0)Wa();if((c[j+12>>2]|0)!=(h|0))Wa()}if((a|0)==(j|0)){c[1206]=c[1206]&~(1<<m);break}if((a|0)!=(b|0)){if(a>>>0<l>>>0)Wa();b=a+8|0;if((c[b>>2]|0)==(h|0))k=b;else Wa()}else k=a+8|0;c[j+12>>2]=a;c[k>>2]=j}while(0);c[e+4>>2]=n|1;c[e+n>>2]=n;if((e|0)==(c[1211]|0)){c[1208]=n;i=d;return}}else{c[m>>2]=o&-2;c[e+4>>2]=n|1;c[e+n>>2]=n}b=n>>>3;if(n>>>0<256){a=b<<1;h=4864+(a<<2)|0;j=c[1206]|0;b=1<<b;if(j&b){a=4864+(a+2<<2)|0;j=c[a>>2]|0;if(j>>>0<(c[1210]|0)>>>0)Wa();else{g=a;f=j}}else{c[1206]=j|b;g=4864+(a+2<<2)|0;f=h}c[g>>2]=e;c[f+12>>2]=e;c[e+8>>2]=f;c[e+12>>2]=h;i=d;return}f=n>>>8;if(f)if(n>>>0>16777215)f=31;else{u=(f+1048320|0)>>>16&8;v=f<<u;t=(v+520192|0)>>>16&4;v=v<<t;f=(v+245760|0)>>>16&2;f=14-(t|u|f)+(v<<f>>>15)|0;f=n>>>(f+7|0)&1|f<<1}else f=0;g=5128+(f<<2)|0;c[e+28>>2]=f;c[e+20>>2]=0;c[e+16>>2]=0;a=c[1207]|0;h=1<<f;if(!(a&h)){c[1207]=a|h;c[g>>2]=e;c[e+24>>2]=g;c[e+12>>2]=e;c[e+8>>2]=e;i=d;return}g=c[g>>2]|0;if((f|0)==31)f=0;else f=25-(f>>>1)|0;a:do if((c[g+4>>2]&-8|0)!=(n|0)){f=n<<f;a=g;while(1){h=a+(f>>>31<<2)+16|0;g=c[h>>2]|0;if(!g)break;if((c[g+4>>2]&-8|0)==(n|0))break a;else{f=f<<1;a=g}}if(h>>>0<(c[1210]|0)>>>0)Wa();c[h>>2]=e;c[e+24>>2]=a;c[e+12>>2]=e;c[e+8>>2]=e;i=d;return}while(0);f=g+8|0;h=c[f>>2]|0;v=c[1210]|0;if(!(g>>>0>=v>>>0&h>>>0>=v>>>0))Wa();c[h+12>>2]=e;c[f>>2]=e;c[e+8>>2]=h;c[e+12>>2]=g;c[e+24>>2]=0;i=d;return}function he(a,b){a=a|0;b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;g=a+4|0;h=c[g>>2]|0;f=a+100|0;if(h>>>0<(c[f>>2]|0)>>>0){c[g>>2]=h+1;j=d[h>>0]|0}else j=Zd(a)|0;if((j|0)==43|(j|0)==45){k=c[g>>2]|0;h=(j|0)==45&1;if(k>>>0<(c[f>>2]|0)>>>0){c[g>>2]=k+1;j=d[k>>0]|0}else j=Zd(a)|0;if((j+ -48|0)>>>0>9&(b|0)!=0?(c[f>>2]|0)!=0:0)c[g>>2]=(c[g>>2]|0)+ -1}else h=0;if((j+ -48|0)>>>0>9){if(!(c[f>>2]|0)){j=-2147483648;k=0;F=j;i=e;return k|0}c[g>>2]=(c[g>>2]|0)+ -1;j=-2147483648;k=0;F=j;i=e;return k|0}else b=0;do{b=j+ -48+(b*10|0)|0;j=c[g>>2]|0;if(j>>>0<(c[f>>2]|0)>>>0){c[g>>2]=j+1;j=d[j>>0]|0}else j=Zd(a)|0}while((j+ -48|0)>>>0<10&(b|0)<214748364);k=((b|0)<0)<<31>>31;if((j+ -48|0)>>>0<10)do{k=we(b|0,k|0,10,0)|0;b=F;j=ne(j|0,((j|0)<0)<<31>>31|0,-48,-1)|0;b=ne(j|0,F|0,k|0,b|0)|0;k=F;j=c[g>>2]|0;if(j>>>0<(c[f>>2]|0)>>>0){c[g>>2]=j+1;j=d[j>>0]|0}else j=Zd(a)|0}while((j+ -48|0)>>>0<10&((k|0)<21474836|(k|0)==21474836&b>>>0<2061584302));if((j+ -48|0)>>>0<10)do{j=c[g>>2]|0;if(j>>>0<(c[f>>2]|0)>>>0){c[g>>2]=j+1;j=d[j>>0]|0}else j=Zd(a)|0}while((j+ -48|0)>>>0<10);if(c[f>>2]|0)c[g>>2]=(c[g>>2]|0)+ -1;g=(h|0)!=0;h=je(0,0,b|0,k|0)|0;j=g?F:k;k=g?h:b;F=j;i=e;return k|0}function ie(){}function je(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;b=b-d-(c>>>0>a>>>0|0)>>>0;return(F=b,a-c>>>0|0)|0}function ke(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=b+e|0;if((e|0)>=20){d=d&255;i=b&3;h=d|d<<8|d<<16|d<<24;g=f&~3;if(i){i=b+4-i|0;while((b|0)<(i|0)){a[b>>0]=d;b=b+1|0}}while((b|0)<(g|0)){c[b>>2]=h;b=b+4|0}}while((b|0)<(f|0)){a[b>>0]=d;b=b+1|0}return b-e|0}function le(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){F=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}F=a<<c-32;return 0}function me(b){b=b|0;var c=0;c=b;while(a[c>>0]|0)c=c+1|0;return c-b|0}function ne(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return(F=b+d+(c>>>0<a>>>0|0)>>>0,c|0)|0}function oe(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){F=b>>>c;return a>>>c|(b&(1<<c)-1)<<32-c}F=0;return b>>>c-32|0}function pe(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;if((e|0)>=4096)return Ca(b|0,d|0,e|0)|0;f=b|0;if((b&3)==(d&3)){while(b&3){if(!e)return f|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}while((e|0)>=4){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;e=e-4|0}}while((e|0)>0){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}return f|0}function qe(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){F=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}F=(b|0)<0?-1:0;return b>>c-32|0}function re(b){b=b|0;var c=0;c=a[n+(b>>>24)>>0]|0;if((c|0)<8)return c|0;c=a[n+(b>>16&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[n+(b>>8&255)>>0]|0;if((c|0)<8)return c+16|0;return(a[n+(b&255)>>0]|0)+24|0}function se(b){b=b|0;var c=0;c=a[m+(b&255)>>0]|0;if((c|0)<8)return c|0;c=a[m+(b>>8&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[m+(b>>16&255)>>0]|0;if((c|0)<8)return c+16|0;return(a[m+(b>>>24)>>0]|0)+24|0}function te(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;d=b&65535;c=ba(d,f)|0;e=a>>>16;d=(c>>>16)+(ba(d,e)|0)|0;b=b>>>16;a=ba(b,f)|0;return(F=(d>>>16)+(ba(b,e)|0)+(((d&65535)+a|0)>>>16)|0,d+a<<16|c&65535|0)|0}function ue(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=b>>31|((b|0)<0?-1:0)<<1;i=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;f=d>>31|((d|0)<0?-1:0)<<1;e=((d|0)<0?-1:0)>>31|((d|0)<0?-1:0)<<1;h=je(j^a,i^b,j,i)|0;g=F;b=f^j;a=e^i;a=je((ze(h,g,je(f^c,e^d,f,e)|0,F,0)|0)^b,F^a,b,a)|0;return a|0}function ve(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0;f=i;i=i+8|0;j=f|0;h=b>>31|((b|0)<0?-1:0)<<1;g=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;l=e>>31|((e|0)<0?-1:0)<<1;k=((e|0)<0?-1:0)>>31|((e|0)<0?-1:0)<<1;b=je(h^a,g^b,h,g)|0;a=F;ze(b,a,je(l^d,k^e,l,k)|0,F,j)|0;a=je(c[j>>2]^h,c[j+4>>2]^g,h,g)|0;b=F;i=f;return(F=b,a)|0}function we(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;a=te(e,f)|0;c=F;return(F=(ba(b,f)|0)+(ba(d,e)|0)+c|c&0,a|0|0)|0}function xe(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;a=ze(a,b,c,d,0)|0;return a|0}function ye(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;g=i;i=i+8|0;f=g|0;ze(a,b,d,e,f)|0;i=g;return(F=c[f+4>>2]|0,c[f>>2]|0)|0}function ze(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=a;j=b;i=j;l=d;g=e;k=g;if(!i){g=(f|0)!=0;if(!k){if(g){c[f>>2]=(h>>>0)%(l>>>0);c[f+4>>2]=0}k=0;m=(h>>>0)/(l>>>0)>>>0;return(F=k,m)|0}else{if(!g){l=0;m=0;return(F=l,m)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;l=0;m=0;return(F=l,m)|0}}m=(k|0)==0;do if(l){if(!m){k=(re(k|0)|0)-(re(i|0)|0)|0;if(k>>>0<=31){m=k+1|0;l=31-k|0;a=k-31>>31;j=m;b=h>>>(m>>>0)&a|i<<l;a=i>>>(m>>>0)&a;k=0;l=h<<l;break}if(!f){l=0;m=0;return(F=l,m)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;l=0;m=0;return(F=l,m)|0}k=l-1|0;if(k&l){l=(re(l|0)|0)+33-(re(i|0)|0)|0;p=64-l|0;m=32-l|0;n=m>>31;o=l-32|0;a=o>>31;j=l;b=m-1>>31&i>>>(o>>>0)|(i<<m|h>>>(l>>>0))&a;a=a&i>>>(l>>>0);k=h<<p&n;l=(i<<p|h>>>(o>>>0))&n|h<<m&l-33>>31;break}if(f){c[f>>2]=k&h;c[f+4>>2]=0}if((l|0)==1){o=j|b&0;p=a|0|0;return(F=o,p)|0}else{p=se(l|0)|0;o=i>>>(p>>>0)|0;p=i<<32-p|h>>>(p>>>0)|0;return(F=o,p)|0}}else{if(m){if(f){c[f>>2]=(i>>>0)%(l>>>0);c[f+4>>2]=0}o=0;p=(i>>>0)/(l>>>0)>>>0;return(F=o,p)|0}if(!h){if(f){c[f>>2]=0;c[f+4>>2]=(i>>>0)%(k>>>0)}o=0;p=(i>>>0)/(k>>>0)>>>0;return(F=o,p)|0}l=k-1|0;if(!(l&k)){if(f){c[f>>2]=a|0;c[f+4>>2]=l&i|b&0}o=0;p=i>>>((se(k|0)|0)>>>0);return(F=o,p)|0}k=(re(k|0)|0)-(re(i|0)|0)|0;if(k>>>0<=30){a=k+1|0;l=31-k|0;j=a;b=i<<l|h>>>(a>>>0);a=i>>>(a>>>0);k=0;l=h<<l;break}if(!f){o=0;p=0;return(F=o,p)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;o=0;p=0;return(F=o,p)|0}while(0);if(!j){g=l;e=0;i=0}else{h=d|0|0;g=g|e&0;e=ne(h,g,-1,-1)|0;d=F;i=0;do{m=l;l=k>>>31|l<<1;k=i|k<<1;m=b<<1|m>>>31|0;n=b>>>31|a<<1|0;je(e,d,m,n)|0;p=F;o=p>>31|((p|0)<0?-1:0)<<1;i=o&1;b=je(m,n,o&h,(((p|0)<0?-1:0)>>31|((p|0)<0?-1:0)<<1)&g)|0;a=F;j=j-1|0}while((j|0)!=0);g=l;e=0}h=0;if(f){c[f>>2]=b;c[f+4>>2]=a}o=(k|0)>>>31|(g|h)<<1|(h<<1|k>>>31)&0|e;p=(k<<1|0>>>31)&-2|i;return(F=o,p)|0}function Ae(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return eb[a&1](b|0,c|0,d|0)|0}function Be(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;fb[a&3](b|0,c|0,d|0,e|0,f|0)}function Ce(a,b){a=a|0;b=b|0;gb[a&31](b|0)}function De(a,b,c){a=a|0;b=b|0;c=c|0;hb[a&3](b|0,c|0)}function Ee(a,b){a=a|0;b=b|0;return ib[a&1](b|0)|0}function Fe(a){a=a|0;jb[a&3]()}function Ge(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;kb[a&3](b|0,c|0,d|0,e|0,f|0,g|0)}function He(a,b,c){a=a|0;b=b|0;c=c|0;return lb[a&3](b|0,c|0)|0}function Ie(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;mb[a&3](b|0,c|0,d|0,e|0)}function Je(a,b,c){a=a|0;b=b|0;c=c|0;ca(0);return 0}function Ke(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ca(1)}function Le(a){a=a|0;ca(2)}function Me(a,b){a=a|0;b=b|0;ca(3)}function Ne(a){a=a|0;ca(4);return 0}function Oe(){ca(5)}function Pe(){bb()}function Qe(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ca(6)}function Re(a,b){a=a|0;b=b|0;ca(7);return 0}function Se(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ca(8)}




// EMSCRIPTEN_END_FUNCS
// (start of meteor/midamble.js)
// This "midamble" is hacked into the output JS in a place
// where it has access to the inner function generated
// by Emscripten, the one that starts with "use asm".
// NOTE: This doesn't work with minification on!
/////setInnerMalloc = function (hookedMalloc) {
/////  _malloc = hookedMalloc;
/////};
/////setInnerFree = function (hookedFree) {
/////  _free = hookedFree;
/////};
// (end of meteor/midamble.js)
var eb=[Je,Dd];var fb=[Ke,Kd,Jd,Ke];var gb=[Le,wb,yb,Ab,Db,Ib,Hb,bc,dc,zc,yc,Oc,rd,qd,yd,Bd,zd,Ad,Cd,zb,Rd,Le,Le,Le,Le,Le,Le,Le,Le,Le,Le,Le];var hb=[Me,Cb,Fb,fc];var ib=[Ne,sd];var jb=[Oe,Pe,Pd,Qd];var kb=[Qe,Md,Ld,Qe];var lb=[Re,Bb,Eb,ec];var mb=[Se,Fd,Gd,Se];return{_yo:$c,_strlen:me,_retireVar:id,_bitshift64Lshr:oe,_unyo:ad,_solve:ed,_bitshift64Shl:le,_getSolution:fd,___cxa_is_pointer_type:Od,_memset:ke,_getNumVars:gd,_memcpy:pe,_getConflictClauseSize:jd,_addClause:dd,_i64Subtract:je,_createTheSolver:bd,_realloc:Ud,_i64Add:ne,_solveAssuming:hd,___cxa_can_catch:Nd,_ensureVar:cd,_getConflictClause:kd,_free:Td,_malloc:Sd,__GLOBAL__I_a:cc,__GLOBAL__I_a127:Pc,runPostSets:ie,stackAlloc:nb,stackSave:ob,stackRestore:pb,setThrew:qb,setTempRet0:tb,getTempRet0:ub,dynCall_iiii:Ae,dynCall_viiiii:Be,dynCall_vi:Ce,dynCall_vii:De,dynCall_ii:Ee,dynCall_v:Fe,dynCall_viiiiii:Ge,dynCall_iii:He,dynCall_viiii:Ie}})


// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg,Module.asmLibraryArg,buffer);var _yo=Module["_yo"]=asm["_yo"];var _strlen=Module["_strlen"]=asm["_strlen"];var _retireVar=Module["_retireVar"]=asm["_retireVar"];var _bitshift64Lshr=Module["_bitshift64Lshr"]=asm["_bitshift64Lshr"];var _unyo=Module["_unyo"]=asm["_unyo"];var _solve=Module["_solve"]=asm["_solve"];var _bitshift64Shl=Module["_bitshift64Shl"]=asm["_bitshift64Shl"];var _getSolution=Module["_getSolution"]=asm["_getSolution"];var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=asm["___cxa_is_pointer_type"];var _memset=Module["_memset"]=asm["_memset"];var _getNumVars=Module["_getNumVars"]=asm["_getNumVars"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _getConflictClauseSize=Module["_getConflictClauseSize"]=asm["_getConflictClauseSize"];var _addClause=Module["_addClause"]=asm["_addClause"];var _i64Subtract=Module["_i64Subtract"]=asm["_i64Subtract"];var _createTheSolver=Module["_createTheSolver"]=asm["_createTheSolver"];var _realloc=Module["_realloc"]=asm["_realloc"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _solveAssuming=Module["_solveAssuming"]=asm["_solveAssuming"];var ___cxa_can_catch=Module["___cxa_can_catch"]=asm["___cxa_can_catch"];var _ensureVar=Module["_ensureVar"]=asm["_ensureVar"];var _getConflictClause=Module["_getConflictClause"]=asm["_getConflictClause"];var _free=Module["_free"]=asm["_free"];var _malloc=Module["_malloc"]=asm["_malloc"];var __GLOBAL__I_a=Module["__GLOBAL__I_a"]=asm["__GLOBAL__I_a"];var __GLOBAL__I_a127=Module["__GLOBAL__I_a127"]=asm["__GLOBAL__I_a127"];var runPostSets=Module["runPostSets"]=asm["runPostSets"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_viiiii=Module["dynCall_viiiii"]=asm["dynCall_viiiii"];var dynCall_vi=Module["dynCall_vi"]=asm["dynCall_vi"];var dynCall_vii=Module["dynCall_vii"]=asm["dynCall_vii"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_v=Module["dynCall_v"]=asm["dynCall_v"];var dynCall_viiiiii=Module["dynCall_viiiiii"]=asm["dynCall_viiiiii"];var dynCall_iii=Module["dynCall_iii"]=asm["dynCall_iii"];var dynCall_viiii=Module["dynCall_viiii"]=asm["dynCall_viiii"];Runtime.stackAlloc=asm["stackAlloc"];Runtime.stackSave=asm["stackSave"];Runtime.stackRestore=asm["stackRestore"];Runtime.setTempRet0=asm["setTempRet0"];Runtime.getTempRet0=asm["getTempRet0"];var i64Math=(function(){var goog={math:{}};goog.math.Long=(function(low,high){this.low_=low|0;this.high_=high|0});goog.math.Long.IntCache_={};goog.math.Long.fromInt=(function(value){if(-128<=value&&value<128){var cachedObj=goog.math.Long.IntCache_[value];if(cachedObj){return cachedObj}}var obj=new goog.math.Long(value|0,value<0?-1:0);if(-128<=value&&value<128){goog.math.Long.IntCache_[value]=obj}return obj});goog.math.Long.fromNumber=(function(value){if(isNaN(value)||!isFinite(value)){return goog.math.Long.ZERO}else if(value<=-goog.math.Long.TWO_PWR_63_DBL_){return goog.math.Long.MIN_VALUE}else if(value+1>=goog.math.Long.TWO_PWR_63_DBL_){return goog.math.Long.MAX_VALUE}else if(value<0){return goog.math.Long.fromNumber(-value).negate()}else{return new goog.math.Long(value%goog.math.Long.TWO_PWR_32_DBL_|0,value/goog.math.Long.TWO_PWR_32_DBL_|0)}});goog.math.Long.fromBits=(function(lowBits,highBits){return new goog.math.Long(lowBits,highBits)});goog.math.Long.fromString=(function(str,opt_radix){if(str.length==0){throw Error("number format error: empty string")}var radix=opt_radix||10;if(radix<2||36<radix){throw Error("radix out of range: "+radix)}if(str.charAt(0)=="-"){return goog.math.Long.fromString(str.substring(1),radix).negate()}else if(str.indexOf("-")>=0){throw Error('number format error: interior "-" character: '+str)}var radixToPower=goog.math.Long.fromNumber(Math.pow(radix,8));var result=goog.math.Long.ZERO;for(var i=0;i<str.length;i+=8){var size=Math.min(8,str.length-i);var value=parseInt(str.substring(i,i+size),radix);if(size<8){var power=goog.math.Long.fromNumber(Math.pow(radix,size));result=result.multiply(power).add(goog.math.Long.fromNumber(value))}else{result=result.multiply(radixToPower);result=result.add(goog.math.Long.fromNumber(value))}}return result});goog.math.Long.TWO_PWR_16_DBL_=1<<16;goog.math.Long.TWO_PWR_24_DBL_=1<<24;goog.math.Long.TWO_PWR_32_DBL_=goog.math.Long.TWO_PWR_16_DBL_*goog.math.Long.TWO_PWR_16_DBL_;goog.math.Long.TWO_PWR_31_DBL_=goog.math.Long.TWO_PWR_32_DBL_/2;goog.math.Long.TWO_PWR_48_DBL_=goog.math.Long.TWO_PWR_32_DBL_*goog.math.Long.TWO_PWR_16_DBL_;goog.math.Long.TWO_PWR_64_DBL_=goog.math.Long.TWO_PWR_32_DBL_*goog.math.Long.TWO_PWR_32_DBL_;goog.math.Long.TWO_PWR_63_DBL_=goog.math.Long.TWO_PWR_64_DBL_/2;goog.math.Long.ZERO=goog.math.Long.fromInt(0);goog.math.Long.ONE=goog.math.Long.fromInt(1);goog.math.Long.NEG_ONE=goog.math.Long.fromInt(-1);goog.math.Long.MAX_VALUE=goog.math.Long.fromBits(4294967295|0,2147483647|0);goog.math.Long.MIN_VALUE=goog.math.Long.fromBits(0,2147483648|0);goog.math.Long.TWO_PWR_24_=goog.math.Long.fromInt(1<<24);goog.math.Long.prototype.toInt=(function(){return this.low_});goog.math.Long.prototype.toNumber=(function(){return this.high_*goog.math.Long.TWO_PWR_32_DBL_+this.getLowBitsUnsigned()});goog.math.Long.prototype.toString=(function(opt_radix){var radix=opt_radix||10;if(radix<2||36<radix){throw Error("radix out of range: "+radix)}if(this.isZero()){return"0"}if(this.isNegative()){if(this.equals(goog.math.Long.MIN_VALUE)){var radixLong=goog.math.Long.fromNumber(radix);var div=this.div(radixLong);var rem=div.multiply(radixLong).subtract(this);return div.toString(radix)+rem.toInt().toString(radix)}else{return"-"+this.negate().toString(radix)}}var radixToPower=goog.math.Long.fromNumber(Math.pow(radix,6));var rem=this;var result="";while(true){var remDiv=rem.div(radixToPower);var intval=rem.subtract(remDiv.multiply(radixToPower)).toInt();var digits=intval.toString(radix);rem=remDiv;if(rem.isZero()){return digits+result}else{while(digits.length<6){digits="0"+digits}result=""+digits+result}}});goog.math.Long.prototype.getHighBits=(function(){return this.high_});goog.math.Long.prototype.getLowBits=(function(){return this.low_});goog.math.Long.prototype.getLowBitsUnsigned=(function(){return this.low_>=0?this.low_:goog.math.Long.TWO_PWR_32_DBL_+this.low_});goog.math.Long.prototype.getNumBitsAbs=(function(){if(this.isNegative()){if(this.equals(goog.math.Long.MIN_VALUE)){return 64}else{return this.negate().getNumBitsAbs()}}else{var val=this.high_!=0?this.high_:this.low_;for(var bit=31;bit>0;bit--){if((val&1<<bit)!=0){break}}return this.high_!=0?bit+33:bit+1}});goog.math.Long.prototype.isZero=(function(){return this.high_==0&&this.low_==0});goog.math.Long.prototype.isNegative=(function(){return this.high_<0});goog.math.Long.prototype.isOdd=(function(){return(this.low_&1)==1});goog.math.Long.prototype.equals=(function(other){return this.high_==other.high_&&this.low_==other.low_});goog.math.Long.prototype.notEquals=(function(other){return this.high_!=other.high_||this.low_!=other.low_});goog.math.Long.prototype.lessThan=(function(other){return this.compare(other)<0});goog.math.Long.prototype.lessThanOrEqual=(function(other){return this.compare(other)<=0});goog.math.Long.prototype.greaterThan=(function(other){return this.compare(other)>0});goog.math.Long.prototype.greaterThanOrEqual=(function(other){return this.compare(other)>=0});goog.math.Long.prototype.compare=(function(other){if(this.equals(other)){return 0}var thisNeg=this.isNegative();var otherNeg=other.isNegative();if(thisNeg&&!otherNeg){return-1}if(!thisNeg&&otherNeg){return 1}if(this.subtract(other).isNegative()){return-1}else{return 1}});goog.math.Long.prototype.negate=(function(){if(this.equals(goog.math.Long.MIN_VALUE)){return goog.math.Long.MIN_VALUE}else{return this.not().add(goog.math.Long.ONE)}});goog.math.Long.prototype.add=(function(other){var a48=this.high_>>>16;var a32=this.high_&65535;var a16=this.low_>>>16;var a00=this.low_&65535;var b48=other.high_>>>16;var b32=other.high_&65535;var b16=other.low_>>>16;var b00=other.low_&65535;var c48=0,c32=0,c16=0,c00=0;c00+=a00+b00;c16+=c00>>>16;c00&=65535;c16+=a16+b16;c32+=c16>>>16;c16&=65535;c32+=a32+b32;c48+=c32>>>16;c32&=65535;c48+=a48+b48;c48&=65535;return goog.math.Long.fromBits(c16<<16|c00,c48<<16|c32)});goog.math.Long.prototype.subtract=(function(other){return this.add(other.negate())});goog.math.Long.prototype.multiply=(function(other){if(this.isZero()){return goog.math.Long.ZERO}else if(other.isZero()){return goog.math.Long.ZERO}if(this.equals(goog.math.Long.MIN_VALUE)){return other.isOdd()?goog.math.Long.MIN_VALUE:goog.math.Long.ZERO}else if(other.equals(goog.math.Long.MIN_VALUE)){return this.isOdd()?goog.math.Long.MIN_VALUE:goog.math.Long.ZERO}if(this.isNegative()){if(other.isNegative()){return this.negate().multiply(other.negate())}else{return this.negate().multiply(other).negate()}}else if(other.isNegative()){return this.multiply(other.negate()).negate()}if(this.lessThan(goog.math.Long.TWO_PWR_24_)&&other.lessThan(goog.math.Long.TWO_PWR_24_)){return goog.math.Long.fromNumber(this.toNumber()*other.toNumber())}var a48=this.high_>>>16;var a32=this.high_&65535;var a16=this.low_>>>16;var a00=this.low_&65535;var b48=other.high_>>>16;var b32=other.high_&65535;var b16=other.low_>>>16;var b00=other.low_&65535;var c48=0,c32=0,c16=0,c00=0;c00+=a00*b00;c16+=c00>>>16;c00&=65535;c16+=a16*b00;c32+=c16>>>16;c16&=65535;c16+=a00*b16;c32+=c16>>>16;c16&=65535;c32+=a32*b00;c48+=c32>>>16;c32&=65535;c32+=a16*b16;c48+=c32>>>16;c32&=65535;c32+=a00*b32;c48+=c32>>>16;c32&=65535;c48+=a48*b00+a32*b16+a16*b32+a00*b48;c48&=65535;return goog.math.Long.fromBits(c16<<16|c00,c48<<16|c32)});goog.math.Long.prototype.div=(function(other){if(other.isZero()){throw Error("division by zero")}else if(this.isZero()){return goog.math.Long.ZERO}if(this.equals(goog.math.Long.MIN_VALUE)){if(other.equals(goog.math.Long.ONE)||other.equals(goog.math.Long.NEG_ONE)){return goog.math.Long.MIN_VALUE}else if(other.equals(goog.math.Long.MIN_VALUE)){return goog.math.Long.ONE}else{var halfThis=this.shiftRight(1);var approx=halfThis.div(other).shiftLeft(1);if(approx.equals(goog.math.Long.ZERO)){return other.isNegative()?goog.math.Long.ONE:goog.math.Long.NEG_ONE}else{var rem=this.subtract(other.multiply(approx));var result=approx.add(rem.div(other));return result}}}else if(other.equals(goog.math.Long.MIN_VALUE)){return goog.math.Long.ZERO}if(this.isNegative()){if(other.isNegative()){return this.negate().div(other.negate())}else{return this.negate().div(other).negate()}}else if(other.isNegative()){return this.div(other.negate()).negate()}var res=goog.math.Long.ZERO;var rem=this;while(rem.greaterThanOrEqual(other)){var approx=Math.max(1,Math.floor(rem.toNumber()/other.toNumber()));var log2=Math.ceil(Math.log(approx)/Math.LN2);var delta=log2<=48?1:Math.pow(2,log2-48);var approxRes=goog.math.Long.fromNumber(approx);var approxRem=approxRes.multiply(other);while(approxRem.isNegative()||approxRem.greaterThan(rem)){approx-=delta;approxRes=goog.math.Long.fromNumber(approx);approxRem=approxRes.multiply(other)}if(approxRes.isZero()){approxRes=goog.math.Long.ONE}res=res.add(approxRes);rem=rem.subtract(approxRem)}return res});goog.math.Long.prototype.modulo=(function(other){return this.subtract(this.div(other).multiply(other))});goog.math.Long.prototype.not=(function(){return goog.math.Long.fromBits(~this.low_,~this.high_)});goog.math.Long.prototype.and=(function(other){return goog.math.Long.fromBits(this.low_&other.low_,this.high_&other.high_)});goog.math.Long.prototype.or=(function(other){return goog.math.Long.fromBits(this.low_|other.low_,this.high_|other.high_)});goog.math.Long.prototype.xor=(function(other){return goog.math.Long.fromBits(this.low_^other.low_,this.high_^other.high_)});goog.math.Long.prototype.shiftLeft=(function(numBits){numBits&=63;if(numBits==0){return this}else{var low=this.low_;if(numBits<32){var high=this.high_;return goog.math.Long.fromBits(low<<numBits,high<<numBits|low>>>32-numBits)}else{return goog.math.Long.fromBits(0,low<<numBits-32)}}});goog.math.Long.prototype.shiftRight=(function(numBits){numBits&=63;if(numBits==0){return this}else{var high=this.high_;if(numBits<32){var low=this.low_;return goog.math.Long.fromBits(low>>>numBits|high<<32-numBits,high>>numBits)}else{return goog.math.Long.fromBits(high>>numBits-32,high>=0?0:-1)}}});goog.math.Long.prototype.shiftRightUnsigned=(function(numBits){numBits&=63;if(numBits==0){return this}else{var high=this.high_;if(numBits<32){var low=this.low_;return goog.math.Long.fromBits(low>>>numBits|high<<32-numBits,high>>>numBits)}else if(numBits==32){return goog.math.Long.fromBits(high,0)}else{return goog.math.Long.fromBits(high>>>numBits-32,0)}}});var navigator={appName:"Modern Browser"};var dbits;var canary=0xdeadbeefcafe;var j_lm=(canary&16777215)==15715070;function BigInteger(a,b,c){if(a!=null)if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b)}function nbi(){return new BigInteger(null)}function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this[i++]+w[j]+c;c=Math.floor(v/67108864);w[j++]=v&67108863}return c}function am2(i,x,w,j,c,n){var xl=x&32767,xh=x>>15;while(--n>=0){var l=this[i]&32767;var h=this[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&32767)<<15)+w[j]+(c&1073741823);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w[j++]=l&1073741823}return c}function am3(i,x,w,j,c,n){var xl=x&16383,xh=x>>14;while(--n>=0){var l=this[i]&16383;var h=this[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&16383)<<14)+w[j]+c;c=(l>>28)+(m>>14)+xh*h;w[j++]=l&268435455}return c}if(j_lm&&navigator.appName=="Microsoft Internet Explorer"){BigInteger.prototype.am=am2;dbits=30}else if(j_lm&&navigator.appName!="Netscape"){BigInteger.prototype.am=am1;dbits=26}else{BigInteger.prototype.am=am3;dbits=28}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array;var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(n){return BI_RM.charAt(n)}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c}function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i)r[i]=this[i];r.t=this.t;r.s=this.s}function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this[0]=x;else if(x<-1)this[0]=x+DV;else this.t=0}function nbv(i){var r=nbi();r.fromInt(i);return r}function bnpFromString(s,b){var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{this.fromRadix(s,b);return}this.t=0;this.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&255:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue}mi=false;if(sh==0)this[this.t++]=x;else if(sh+k>this.DB){this[this.t-1]|=(x&(1<<this.DB-sh)-1)<<sh;this[this.t++]=x>>this.DB-sh}else this[this.t-1]|=x<<sh;sh+=k;if(sh>=this.DB)sh-=this.DB}if(k==8&&(s[0]&128)!=0){this.s=-1;if(sh>0)this[this.t-1]|=(1<<this.DB-sh)-1<<sh}this.clamp();if(mi)BigInteger.ZERO.subTo(this,this)}function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this[this.t-1]==c)--this.t}function bnToString(b){if(this.s<0)return"-"+this.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return this.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=this.t;var p=this.DB-i*this.DB%k;if(i-->0){if(p<this.DB&&(d=this[i]>>p)>0){m=true;r=int2char(d)}while(i>=0){if(p<k){d=(this[i]&(1<<p)-1)<<k-p;d|=this[--i]>>(p+=this.DB-k)}else{d=this[i]>>(p-=k)&km;if(p<=0){p+=this.DB;--i}}if(d>0)m=true;if(m)r+=int2char(d)}}return m?r:"0"}function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0)if((r=this[i]-a[i])!=0)return r;return 0}function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16}if((t=x>>8)!=0){x=t;r+=8}if((t=x>>4)!=0){x=t;r+=4}if((t=x>>2)!=0){x=t;r+=2}if((t=x>>1)!=0){x=t;r+=1}return r}function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i)r[i+n]=this[i];for(i=n-1;i>=0;--i)r[i]=0;r.t=this.t+n;r.s=this.s}function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i)r[i-n]=this[i];r.t=Math.max(this.t-n,0);r.s=this.s}function bnpLShiftTo(n,r){var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/this.DB),c=this.s<<bs&this.DM,i;for(i=this.t-1;i>=0;--i){r[i+ds+1]=this[i]>>cbs|c;c=(this[i]&bm)<<bs}for(i=ds-1;i>=0;--i)r[i]=0;r[ds]=c;r.t=this.t+ds+1;r.s=this.s;r.clamp()}function bnpRShiftTo(n,r){r.s=this.s;var ds=Math.floor(n/this.DB);if(ds>=this.t){r.t=0;return}var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<bs)-1;r[0]=this[ds]>>bs;for(var i=ds+1;i<this.t;++i){r[i-ds-1]|=(this[i]&bm)<<cbs;r[i-ds]=this[i]>>bs}if(bs>0)r[this.t-ds-1]|=(this.s&bm)<<cbs;r.t=this.t-ds;r.clamp()}function bnpSubTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this[i]-a[i];r[i++]=c&this.DM;c>>=this.DB}if(a.t<this.t){c-=a.s;while(i<this.t){c+=this[i];r[i++]=c&this.DM;c>>=this.DB}c+=this.s}else{c+=this.s;while(i<a.t){c-=a[i];r[i++]=c&this.DM;c>>=this.DB}c-=a.s}r.s=c<0?-1:0;if(c<-1)r[i++]=this.DV+c;else if(c>0)r[i++]=c;r.t=i;r.clamp()}function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0)r[i]=0;for(i=0;i<y.t;++i)r[i+x.t]=x.am(0,y[i],r,i,0,x.t);r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r)}function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0)r[i]=0;for(i=0;i<x.t-1;++i){var c=x.am(i,x[i],r,2*i,0,1);if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1))>=x.DV){r[i+x.t]-=x.DV;r[i+x.t+1]=1}}if(r.t>0)r[r.t-1]+=x.am(i,x[i],r,2*i,0,1);r.s=0;r.clamp()}function bnpDivRemTo(m,q,r){var pm=m.abs();if(pm.t<=0)return;var pt=this.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)this.copyTo(r);return}if(r==null)r=nbi();var y=nbi(),ts=this.s,ms=m.s;var nsh=this.DB-nbits(pm[pm.t-1]);if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r)}else{pm.copyTo(y);pt.copyTo(r)}var ys=y.t;var y0=y[ys-1];if(y0==0)return;var yt=y0*(1<<this.F1)+(ys>1?y[ys-2]>>this.F2:0);var d1=this.FV/yt,d2=(1<<this.F1)/yt,e=1<<this.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r[r.t++]=1;r.subTo(t,r)}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);while(y.t<ys)y[y.t++]=0;while(--j>=0){var qd=r[--i]==y0?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);if((r[i]+=y.am(0,qd,r,j,0,ys))<qd){y.dlShiftTo(j,t);r.subTo(t,r);while(r[i]<--qd)r.subTo(t,r)}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q)}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);if(ts<0)BigInteger.ZERO.subTo(r,r)}function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r}function Classic(m){this.m=m}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x}function cRevert(x){return x}function cReduce(x){x.divRemTo(this.m,null,x)}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}function cSqrTo(x,r){x.squareTo(r);this.reduce(r)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var x=this[0];if((x&1)==0)return 0;var y=x&3;y=y*(2-(x&15)*y)&15;y=y*(2-(x&255)*y)&255;y=y*(2-((x&65535)*y&65535))&65535;y=y*(2-x*y%this.DV)%this.DV;return y>0?this.DV-y:-y}function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t}function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r}function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r}function montReduce(x){while(x.t<=this.mt2)x[x.t++]=0;for(var i=0;i<this.m.t;++i){var j=x[i]&32767;var u0=j*this.mpl+((j*this.mph+(x[i]>>15)*this.mpl&this.um)<<15)&x.DM;j=i+this.m.t;x[j]+=this.m.am(0,u0,x,i,0,this.m.t);while(x[j]>=x.DV){x[j]-=x.DV;x[++j]++}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x)}function montSqrTo(x,r){x.squareTo(r);this.reduce(r)}function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp(e,z){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t}}return z.revert(r)}function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);function bnpFromRadix(s,b){this.fromInt(0);if(b==null)b=10;var cs=this.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&this.signum()==0)mi=true;continue}w=b*w+x;if(++j>=cs){this.dMultiply(d);this.dAddOffset(w,0);j=0;w=0}}if(j>0){this.dMultiply(Math.pow(b,j));this.dAddOffset(w,0)}if(mi)BigInteger.ZERO.subTo(this,this)}function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r))}function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this[0]<=0)return 0;else return 1}function bnpDMultiply(n){this[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w)this[this.t++]=0;this[w]+=n;while(this[w]>=this.DV){this[w]-=this.DV;if(++w>=this.t)this[this.t++]=0;++this[w]}}function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z)}return z.intValue().toString(b)+r}function bnIntValue(){if(this.s<0){if(this.t==1)return this[0]-this.DV;else if(this.t==0)return-1}else if(this.t==1)return this[0];else if(this.t==0)return 0;return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnpAddTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this[i]+a[i];r[i++]=c&this.DM;c>>=this.DB}if(a.t<this.t){c+=a.s;while(i<this.t){c+=this[i];r[i++]=c&this.DM;c>>=this.DB}c+=this.s}else{c+=this.s;while(i<a.t){c+=a[i];r[i++]=c&this.DM;c>>=this.DB}c+=a.s}r.s=c<0?-1:0;if(c>0)r[i++]=c;else if(c<-1)r[i++]=this.DV+c;r.t=i;r.clamp()}BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.addTo=bnpAddTo;var Wrapper={abs:(function(l,h){var x=new goog.math.Long(l,h);var ret;if(x.isNegative()){ret=x.negate()}else{ret=x}HEAP32[tempDoublePtr>>2]=ret.low_;HEAP32[tempDoublePtr+4>>2]=ret.high_}),ensureTemps:(function(){if(Wrapper.ensuredTemps)return;Wrapper.ensuredTemps=true;Wrapper.two32=new BigInteger;Wrapper.two32.fromString("4294967296",10);Wrapper.two64=new BigInteger;Wrapper.two64.fromString("18446744073709551616",10);Wrapper.temp1=new BigInteger;Wrapper.temp2=new BigInteger}),lh2bignum:(function(l,h){var a=new BigInteger;a.fromString(h.toString(),10);var b=new BigInteger;a.multiplyTo(Wrapper.two32,b);var c=new BigInteger;c.fromString(l.toString(),10);var d=new BigInteger;c.addTo(b,d);return d}),stringify:(function(l,h,unsigned){var ret=(new goog.math.Long(l,h)).toString();if(unsigned&&ret[0]=="-"){Wrapper.ensureTemps();var bignum=new BigInteger;bignum.fromString(ret,10);ret=new BigInteger;Wrapper.two64.addTo(bignum,ret);ret=ret.toString(10)}return ret}),fromString:(function(str,base,min,max,unsigned){Wrapper.ensureTemps();var bignum=new BigInteger;bignum.fromString(str,base);var bigmin=new BigInteger;bigmin.fromString(min,10);var bigmax=new BigInteger;bigmax.fromString(max,10);if(unsigned&&bignum.compareTo(BigInteger.ZERO)<0){var temp=new BigInteger;bignum.addTo(Wrapper.two64,temp);bignum=temp}var error=false;if(bignum.compareTo(bigmin)<0){bignum=bigmin;error=true}else if(bignum.compareTo(bigmax)>0){bignum=bigmax;error=true}var ret=goog.math.Long.fromString(bignum.toString());HEAP32[tempDoublePtr>>2]=ret.low_;HEAP32[tempDoublePtr+4>>2]=ret.high_;if(error)throw"range error"})};return Wrapper})();if(memoryInitializer){if(typeof Module["locateFile"]==="function"){memoryInitializer=Module["locateFile"](memoryInitializer)}else if(Module["memoryInitializerPrefixURL"]){memoryInitializer=Module["memoryInitializerPrefixURL"]+memoryInitializer}if(ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_SHELL){var data=Module["readBinary"](memoryInitializer);HEAPU8.set(data,STATIC_BASE)}else{addRunDependency("memory initializer");Browser.asyncLoad(memoryInitializer,(function(data){HEAPU8.set(data,STATIC_BASE);removeRunDependency("memory initializer")}),(function(data){throw"could not load memory initializer "+memoryInitializer}))}}function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;var preloadStartTime=null;var calledMain=false;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"]&&shouldRunNow)run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};Module["callMain"]=Module.callMain=function callMain(args){assert(runDependencies==0,"cannot call main when async dependencies remain! (listen on __ATMAIN__)");assert(__ATPRERUN__.length==0,"cannot call main when preRun functions remain to be called");args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++){argv.push(0)}}var argv=[allocate(intArrayFromString(Module["thisProgram"]),"i8",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),"i8",ALLOC_NORMAL));pad()}argv.push(0);argv=allocate(argv,"i32",ALLOC_NORMAL);initialStackTop=STACKTOP;try{var ret=Module["_main"](argc,argv,0);exit(ret)}catch(e){if(e instanceof ExitStatus){return}else if(e=="SimulateInfiniteLoop"){Module["noExitRuntime"]=true;return}else{if(e&&typeof e==="object"&&e.stack)Module.printErr("exception thrown: "+[e,e.stack]);throw e}}finally{calledMain=true}};function run(args){args=args||Module["arguments"];if(preloadStartTime===null)preloadStartTime=Date.now();if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(ENVIRONMENT_IS_WEB&&preloadStartTime!==null){Module.printErr("pre-main prep time: "+(Date.now()-preloadStartTime)+" ms")}if(Module["_main"]&&shouldRunNow){Module["callMain"](args)}postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}Module["run"]=Module.run=run;function exit(status){if(Module["noExitRuntime"]){return}ABORT=true;EXITSTATUS=status;STACKTOP=initialStackTop;exitRuntime();if(ENVIRONMENT_IS_NODE){process["stdout"]["once"]("drain",(function(){process["exit"](status)}));console.log(" ");setTimeout((function(){process["exit"](status)}),500)}else if(ENVIRONMENT_IS_SHELL&&typeof quit==="function"){quit(status)}throw new ExitStatus(status)}Module["exit"]=Module.exit=exit;function abort(text){if(text){Module.print(text);Module.printErr(text)}ABORT=true;EXITSTATUS=1;var extra="\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw"abort() at "+stackTrace()+extra}Module["abort"]=Module.abort=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"]){shouldRunNow=false}run();var origMalloc=Module._malloc;var origFree=Module._free;var MEMSTATS={totalMemory:Module.HEAPU8.length,heapUsed:0};var MEMSTATS_DATA={pointerToSizeMap:{},getSizeOfPointer:(function(ptr){return MEMSTATS_DATA.pointerToSizeMap[ptr]})};Module.MEMSTATS=MEMSTATS;Module.MEMSTATS_DATA=MEMSTATS_DATA;var hookedMalloc=(function(size){var ptr=origMalloc(size);if(!ptr){return 0}MEMSTATS.heapUsed+=size;MEMSTATS_DATA.pointerToSizeMap[ptr]=size;return ptr});var hookedFree=(function(ptr){if(ptr){MEMSTATS.heapUsed-=MEMSTATS_DATA.getSizeOfPointer(ptr)||0;delete MEMSTATS_DATA.pointerToSizeMap[ptr]}return origFree(ptr)});Module._malloc=hookedMalloc;Module._free=hookedFree;_malloc=hookedMalloc;_free=hookedFree;var setInnerMalloc,setInnerFree;if(setInnerMalloc){setInnerMalloc(hookedMalloc);setInnerFree(hookedFree)}return module.exports});if(true){module.exports=C_MINISAT}






/***/ }),
/* 247 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if ( true && !exports.nodeType) {
    if ( true && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because were not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functions
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that objects
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}());


/***/ }),
/* 248 */
/***/ ((module) => {

"use strict";
module.exports = require("v8");

/***/ }),
/* 249 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Workspace": () => /* binding */ Workspace
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(144);
/* harmony import */ var globby__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(globby__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(230);
/* harmony import */ var _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(222);
/* harmony import */ var _hashUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(142);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(140);







class Workspace {
  constructor(workspaceCwd, {
    project
  }) {
    // @ts-ignore: This variable is set during the setup process
    this.workspacesCwds = new Set(); // Generated at resolution; basically dependencies + devDependencies + child workspaces

    this.dependencies = new Map();
    this.project = project;
    this.cwd = workspaceCwd;
  }

  async setup() {
    // @ts-ignore: It's ok to initialize it now
    this.manifest = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(this.cwd, _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest.fileName)) ? await _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest.find(this.cwd) : new _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest(); // We use ppath.relative to guarantee that the default hash will be consistent even if the project is installed on different OS / path
    // @ts-ignore: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    this.relativeCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.relative(this.project.cwd, this.cwd) || _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.PortablePath.dot;
    const ident = this.manifest.name ? this.manifest.name : _structUtils__WEBPACK_IMPORTED_MODULE_5__.makeIdent(null, `${this.computeCandidateName()}-${_hashUtils__WEBPACK_IMPORTED_MODULE_6__.makeHash(this.relativeCwd).substr(0, 6)}`);
    const reference = this.manifest.version ? this.manifest.version : `0.0.0`; // @ts-ignore: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    this.locator = _structUtils__WEBPACK_IMPORTED_MODULE_5__.makeLocator(ident, reference); // @ts-ignore: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    this.anchoredDescriptor = _structUtils__WEBPACK_IMPORTED_MODULE_5__.makeDescriptor(this.locator, `${_WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol}${this.relativeCwd}`); // @ts-ignore: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    this.anchoredLocator = _structUtils__WEBPACK_IMPORTED_MODULE_5__.makeLocator(this.locator, `${_WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol}${this.relativeCwd}`);

    for (const definition of this.manifest.workspaceDefinitions) {
      const relativeCwds = await globby__WEBPACK_IMPORTED_MODULE_0___default()(definition.pattern, {
        absolute: true,
        cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(this.cwd),
        expandDirectories: false,
        onlyDirectories: true,
        onlyFiles: false,
        ignore: [`**/node_modules`, `**/.git`, `**/.yarn`]
      }); // It seems that the return value of globby isn't in any guaranteed order - not even the directory listing order

      relativeCwds.sort();

      for (const relativeCwd of relativeCwds) {
        const candidateCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.resolve(this.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(relativeCwd));

        if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(candidateCwd, `package.json`))) {
          this.workspacesCwds.add(candidateCwd);
        }
      }
    }
  }

  accepts(range) {
    const protocolIndex = range.indexOf(`:`);
    const protocol = protocolIndex !== -1 ? range.slice(0, protocolIndex + 1) : null;
    const pathname = protocolIndex !== -1 ? range.slice(protocolIndex + 1) : range;
    if (protocol === _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol && pathname === this.relativeCwd) return true;
    if (protocol === _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol && pathname === `*`) return true;
    if (!semver__WEBPACK_IMPORTED_MODULE_1___default().validRange(pathname)) return false;
    if (protocol === _WorkspaceResolver__WEBPACK_IMPORTED_MODULE_7__.WorkspaceResolver.protocol) return semver__WEBPACK_IMPORTED_MODULE_1___default().satisfies(this.manifest.version !== null ? this.manifest.version : `0.0.0`, pathname);
    if (!this.project.configuration.get(`enableTransparentWorkspaces`)) return false;
    if (this.manifest.version !== null) return semver__WEBPACK_IMPORTED_MODULE_1___default().satisfies(this.manifest.version, pathname);
    return false;
  }

  computeCandidateName() {
    if (this.cwd === this.project.cwd) {
      return `root-workspace`;
    } else {
      return `${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.basename(this.cwd)}` || `unnamed-workspace`;
    }
  }

  async persistManifest() {
    const data = {};
    this.manifest.exportTo(data);
    const path = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(this.cwd, _Manifest__WEBPACK_IMPORTED_MODULE_4__.Manifest.fileName);
    const content = `${JSON.stringify(data, null, this.manifest.indent)}\n`;
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.xfs.changeFilePromise(path, content, {
      automaticNewlines: true
    });
  }

}

/***/ }),
/* 250 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThrowReport": () => /* binding */ ThrowReport
/* harmony export */ });
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);

class ThrowReport extends _Report__WEBPACK_IMPORTED_MODULE_0__.Report {
  reportCacheHit(locator) {}

  reportCacheMiss(locator) {}

  startTimerSync(what, cb) {
    return cb();
  }

  async startTimerPromise(what, cb) {
    return await cb();
  }

  async startCacheReport(cb) {
    return await cb();
  }

  reportSeparator() {}

  reportInfo(name, text) {}

  reportWarning(name, text) {}

  reportError(name, text) {}

  reportProgress(progress) {
    const promise = Promise.resolve().then(async () => {
      // eslint-disable-next-line no-empty-pattern
      for await (const {} of progress) {// No need to do anything; we just want to consume the progress events
      }
    });

    const stop = () => {// Nothing to stop
    };

    return { ...promise,
      stop
    };
  }

  reportJson(data) {// Just ignore the json output
  }

  async finalize() {}

}

/***/ }),
/* 251 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LegacyMigrationResolver": () => /* binding */ LegacyMigrationResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(140);





const IMPORTED_PATTERNS = [// These ones come from Git urls
[/^(git(?:\+(?:https|ssh))?:\/\/.*\.git)#(.*)$/, (version, $0, $1, $2) => `${$1}#commit:${$2}`], // These ones come from the GitHub HTTP endpoints
[/^https:\/\/((?:[^/]+?)@)?codeload\.github\.com\/([^/]+\/[^/]+)\/tar\.gz\/([0-9a-f]+)$/, (version, $0, $1 = ``, $2, $3) => `https://${$1}github.com/${$2}.git#commit:${$3}`], [/^https:\/\/((?:[^/]+?)@)?github\.com\/([^/]+\/[^/]+?)(?:\.git)?#([0-9a-f]+)$/, (version, $0, $1 = ``, $2, $3) => `https://${$1}github.com/${$2}.git#commit:${$3}`], // These ones come from the npm registry
[/^https?:\/\/[^/]+\/(?:@[^/]+\/)?([^/]+)\/-\/\1-[^/]+\.tgz(?:#|$)/, version => `npm:${version}`], // These ones come from the old Yarn offline mirror - we assume they came from npm
[/^[^/]+\.tgz#[0-9a-f]+$/, version => `npm:${version}`]];
class LegacyMigrationResolver {
  constructor() {
    this.resolutions = null;
  }

  async setup(project, {
    report
  }) {
    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(project.cwd, project.configuration.get(`lockfileFilename`)); // No need to enable it if the lockfile doesn't exist

    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.existsSync(lockfilePath)) return;
    const content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.readFilePromise(lockfilePath, `utf8`);
    const parsed = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseSyml)(content); // No need to enable it either if the lockfile is modern

    if (Object.prototype.hasOwnProperty.call(parsed, `__metadata`)) return;
    const resolutions = this.resolutions = new Map();

    for (const key of Object.keys(parsed)) {
      let descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.tryParseDescriptor(key);

      if (!descriptor) {
        report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName.YARN_IMPORT_FAILED, `Failed to parse the string "${key}" into a proper descriptor`);
        continue;
      }

      if (semver__WEBPACK_IMPORTED_MODULE_1___default().validRange(descriptor.range)) descriptor = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeDescriptor(descriptor, `npm:${descriptor.range}`);
      const {
        version,
        resolved
      } = parsed[key]; // Workspaces don't have the "resolved" key; we can skip them, as their
      // resolution will be recomputed when needed anyway

      if (!resolved) continue;
      let reference;

      for (const [pattern, matcher] of IMPORTED_PATTERNS) {
        const match = resolved.match(pattern);

        if (match) {
          reference = matcher(version, ...match);
          break;
        }
      }

      if (!reference) {
        report.reportWarning(_MessageName__WEBPACK_IMPORTED_MODULE_5__.MessageName.YARN_IMPORT_FAILED, `${_structUtils__WEBPACK_IMPORTED_MODULE_4__.prettyDescriptor(project.configuration, descriptor)}: Only some patterns can be imported from legacy lockfiles (not "${resolved}")`);
        continue;
      }

      const resolution = _structUtils__WEBPACK_IMPORTED_MODULE_4__.makeLocator(descriptor, reference);
      resolutions.set(descriptor.descriptorHash, resolution);
    }
  }

  supportsDescriptor(descriptor, opts) {
    if (!this.resolutions) return false;
    return this.resolutions.has(descriptor.descriptorHash);
  }

  supportsLocator(locator, opts) {
    // This resolver only supports the descriptor -> locator part of the
    // resolution, not the locator -> package one.
    return false;
  }

  shouldPersistResolution(locator, opts) {
    throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    if (!this.resolutions) throw new Error(`Assertion failed: The resolution store should have been setup`);
    const resolution = this.resolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
    return [resolution];
  }

  async resolve(locator, opts) {
    throw new Error(`Assertion failed: This resolver doesn't support resolving locators to packages`);
  }

}

/***/ }),
/* 252 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LockfileResolver": () => /* binding */ LockfileResolver
/* harmony export */ });
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(140);

class LockfileResolver {
  supportsDescriptor(descriptor, opts) {
    const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
    if (resolution) return true; // If the descriptor matches a package that's already been used, we can just use it even if we never resolved the range before
    // Ex: foo depends on bar@^1.0.0 that we resolved to foo@1.1.0, then we add a package qux that depends on foo@1.1.0 (without the caret)

    if (opts.project.originalPackages.has(_structUtils__WEBPACK_IMPORTED_MODULE_0__.convertDescriptorToLocator(descriptor).locatorHash)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (opts.project.originalPackages.has(locator.locatorHash)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    throw new Error(`The shouldPersistResolution method shouldn't be called on the lockfile resolver, which would always answer yes`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    let pkg = opts.project.originalPackages.get(_structUtils__WEBPACK_IMPORTED_MODULE_0__.convertDescriptorToLocator(descriptor).locatorHash);
    if (pkg) return [pkg];
    const resolution = opts.project.storedResolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Expected the resolution to have been successful - resolution not found`);
    pkg = opts.project.originalPackages.get(resolution);
    if (!pkg) throw new Error(`Expected the resolution to have been successful - package not found`);
    return [pkg];
  }

  async resolve(locator, opts) {
    const pkg = opts.project.originalPackages.get(locator.locatorHash);
    if (!pkg) throw new Error(`The lockfile resolver isn't meant to resolve packages - they should already have been stored into a cache`);
    return pkg;
  }

}

/***/ }),
/* 253 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RunInstallPleaseResolver": () => /* binding */ RunInstallPleaseResolver
/* harmony export */ });
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(217);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);


class RunInstallPleaseResolver {
  constructor(resolver) {
    this.resolver = resolver;
  }

  supportsDescriptor(descriptor, opts) {
    return this.resolver.supportsDescriptor(descriptor, opts);
  }

  supportsLocator(locator, opts) {
    return this.resolver.supportsLocator(locator, opts);
  }

  shouldPersistResolution(locator, opts) {
    return this.resolver.shouldPersistResolution(locator, opts);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return this.resolver.bindDescriptor(descriptor, fromLocator, opts);
  }

  getResolutionDependencies(descriptor, opts) {
    return this.resolver.getResolutionDependencies(descriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    throw new _Report__WEBPACK_IMPORTED_MODULE_0__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
  }

  async resolve(locator, opts) {
    throw new _Report__WEBPACK_IMPORTED_MODULE_0__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_1__.MessageName.MISSING_LOCKFILE_ENTRY, `This package doesn't seem to be present in your lockfile; try to make an install to update your resolutions`);
  }

}

/***/ }),
/* 254 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeScriptEnv": () => /* binding */ makeScriptEnv,
/* harmony export */   "prepareExternalProject": () => /* binding */ prepareExternalProject,
/* harmony export */   "hasPackageScript": () => /* binding */ hasPackageScript,
/* harmony export */   "executePackageScript": () => /* binding */ executePackageScript,
/* harmony export */   "executePackageShellcode": () => /* binding */ executePackageShellcode,
/* harmony export */   "executeWorkspaceScript": () => /* binding */ executeWorkspaceScript,
/* harmony export */   "hasWorkspaceScript": () => /* binding */ hasWorkspaceScript,
/* harmony export */   "getPackageAccessibleBinaries": () => /* binding */ getPackageAccessibleBinaries,
/* harmony export */   "getWorkspaceAccessibleBinaries": () => /* binding */ getWorkspaceAccessibleBinaries,
/* harmony export */   "executePackageAccessibleBinary": () => /* binding */ executePackageAccessibleBinary,
/* harmony export */   "executeWorkspaceAccessibleBinary": () => /* binding */ executeWorkspaceAccessibleBinary
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(215);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(209);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _yarnpkg_shell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(255);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65);
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(p_limit__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(110);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Manifest__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(230);
/* harmony import */ var _MessageName__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(217);
/* harmony import */ var _Report__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(226);
/* harmony import */ var _StreamReport__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(239);
/* harmony import */ var _YarnVersion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(270);
/* harmony import */ var _execUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(271);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(121);
/* harmony import */ var _structUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(140);














var PackageManager;

(function (PackageManager) {
  PackageManager["Yarn1"] = "Yarn Classic";
  PackageManager["Yarn2"] = "Yarn";
  PackageManager["Npm"] = "npm";
  PackageManager["Pnpm"] = "pnpm";
})(PackageManager || (PackageManager = {}));

async function makePathWrapper(location, name, argv0, args = []) {
  if (process.platform === `win32`) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.format({
    dir: location,
    name,
    ext: `.cmd`
  }), `@"${argv0}" ${args.map(arg => `"${arg.replace(`"`, `""`)}"`).join(` `)} %*\n`);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(location, name), `#!/bin/sh\nexec "${argv0}" ${args.map(arg => `'${arg.replace(/'/g, `'"'"'`)}'`).join(` `)} "$@"\n`);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.chmodPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(location, name), 0o755);
}

async function detectPackageManager(location) {
  let yarnLock = null;

  try {
    yarnLock = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.readFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(location, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.Filename.lockfile), `utf8`);
  } catch (_a) {}

  if (yarnLock !== null) {
    if (yarnLock.match(/^__metadata:$/m)) {
      return PackageManager.Yarn2;
    } else {
      return PackageManager.Yarn1;
    }
  }

  if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(location, `package-lock.json`))) return PackageManager.Npm;
  if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(location, `pnpm-lock.yaml`))) return PackageManager.Pnpm;
  return null;
}

async function makeScriptEnv({
  project,
  binFolder,
  lifecycleScript
}) {
  const scriptEnv = {};

  for (const [key, value] of Object.entries(process.env)) if (typeof value !== `undefined`) scriptEnv[key.toLowerCase() !== `path` ? key : `PATH`] = value;

  const nBinFolder = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(binFolder); // We expose the base folder in the environment so that we can later add the
  // binaries for the dependencies of the active package

  scriptEnv.BERRY_BIN_FOLDER = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(nBinFolder); // Register some binaries that must be made available in all subprocesses
  // spawned by Yarn (we thus ensure that they always use the right version)

  await makePathWrapper(binFolder, `node`, process.execPath);

  if (_YarnVersion__WEBPACK_IMPORTED_MODULE_6__.YarnVersion !== null) {
    await makePathWrapper(binFolder, `run`, process.execPath, [process.argv[1], `run`]);
    await makePathWrapper(binFolder, `yarn`, process.execPath, [process.argv[1]]);
    await makePathWrapper(binFolder, `yarnpkg`, process.execPath, [process.argv[1]]);
    await makePathWrapper(binFolder, `node-gyp`, process.execPath, [process.argv[1], `run`, `--top-level`, `node-gyp`]);
  }

  if (project) scriptEnv.INIT_CWD = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(project.configuration.startingCwd);
  scriptEnv.PATH = scriptEnv.PATH ? `${nBinFolder}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.delimiter}${scriptEnv.PATH}` : `${nBinFolder}`;
  scriptEnv.npm_execpath = `${nBinFolder}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.sep}yarn`;
  scriptEnv.npm_node_execpath = `${nBinFolder}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.sep}node`;
  const version = _YarnVersion__WEBPACK_IMPORTED_MODULE_6__.YarnVersion !== null ? `yarn/${_YarnVersion__WEBPACK_IMPORTED_MODULE_6__.YarnVersion}` : `yarn/${_miscUtils__WEBPACK_IMPORTED_MODULE_7__.dynamicRequire(`@yarnpkg/core`).version}-core`;
  scriptEnv.npm_config_user_agent = `${version} npm/? node/${process.versions.node} ${process.platform} ${process.arch}`;
  if (lifecycleScript) scriptEnv.npm_lifecycle_event = lifecycleScript;

  if (project) {
    await project.configuration.triggerHook(hook => hook.setupScriptEnvironment, project, scriptEnv, async (name, argv0, args) => {
      return await makePathWrapper(binFolder, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.toFilename)(name), argv0, args);
    });
  }

  return scriptEnv;
}
/**
 * Given a folder, prepares this project for use. Runs `yarn install` then
 * `yarn build` if a `package.json` is found.
 */

const MAX_PREPARE_CONCURRENCY = 2;
const prepareLimit = p_limit__WEBPACK_IMPORTED_MODULE_2___default()(MAX_PREPARE_CONCURRENCY);
async function prepareExternalProject(cwd, outputPath, {
  configuration,
  report,
  workspace = null
}) {
  await prepareLimit(async () => {
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async logDir => {
      const logFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(logDir, `pack.log`);
      const stdin = null;
      const {
        stdout,
        stderr
      } = configuration.getSubprocessStreams(logFile, {
        prefix: cwd,
        report
      });
      const packageManager = await detectPackageManager(cwd);
      let effectivePackageManager;

      if (packageManager !== null) {
        stdout.write(`Installing the project using ${packageManager}\n\n`);
        effectivePackageManager = packageManager;
      } else {
        stdout.write(`No package manager detected; defaulting to Yarn\n\n`);
        effectivePackageManager = PackageManager.Yarn2;
      }

      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async binFolder => {
        const env = await makeScriptEnv({
          binFolder
        });
        const workflows = new Map([[PackageManager.Yarn1, async () => {
          const workspaceCli = workspace !== null ? [`workspace`, workspace] : []; // Makes sure that we'll be using Yarn 1.x

          const version = await _execUtils__WEBPACK_IMPORTED_MODULE_8__.pipevp(`yarn`, [`set`, `version`, `classic`, `--only-if-needed`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: _execUtils__WEBPACK_IMPORTED_MODULE_8__.EndStrategy.ErrorCode
          });
          if (version.code !== 0) return version.code; // Otherwise Yarn 1 will pack the .yarn directory :(

          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.appendFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(cwd, `.npmignore`), `/.yarn\n`);
          stdout.write(`\n`); // Run an install; we can't avoid it unless we inspect the
          // package.json, which I don't want to do to keep the codebase
          // clean (even if it has a slight perf cost when cloning v1 repos)

          const install = await _execUtils__WEBPACK_IMPORTED_MODULE_8__.pipevp(`yarn`, [`install`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: _execUtils__WEBPACK_IMPORTED_MODULE_8__.EndStrategy.ErrorCode
          });
          if (install.code !== 0) return install.code;
          stdout.write(`\n`);
          const pack = await _execUtils__WEBPACK_IMPORTED_MODULE_8__.pipevp(`yarn`, [...workspaceCli, `pack`, `--filename`, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(outputPath)], {
            cwd,
            env,
            stdin,
            stdout,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          return 0;
        }], [PackageManager.Yarn2, async () => {
          const workspaceCli = workspace !== null ? [`workspace`, workspace] : []; // Yarn 2 supports doing the install and the pack in a single command,
          // so we leverage that. We also don't need the "set version" call since
          // we're already operating within a Yarn 2 context (plus people should
          // really check-in their Yarn versions anyway).

          const pack = await _execUtils__WEBPACK_IMPORTED_MODULE_8__.pipevp(`yarn`, [...workspaceCli, `pack`, `--install-if-needed`, `--filename`, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(outputPath)], {
            cwd,
            env,
            stdin,
            stdout,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          return 0;
        }], [PackageManager.Npm, async () => {
          if (workspace !== null) throw new Error(`Workspaces aren't supported by npm, which has been detected as the primary package manager for ${cwd}`); // Otherwise npm won't properly set the user agent, using the Yarn
          // one instead

          delete env.npm_config_user_agent; // We can't use `npm ci` because some projects don't have npm
          // lockfiles that are up-to-date. Hopefully npm won't decide
          // to change the versions randomly.

          const install = await _execUtils__WEBPACK_IMPORTED_MODULE_8__.pipevp(`npm`, [`install`], {
            cwd,
            env,
            stdin,
            stdout,
            stderr,
            end: _execUtils__WEBPACK_IMPORTED_MODULE_8__.EndStrategy.ErrorCode
          });
          if (install.code !== 0) return install.code;
          const packStream = new stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough();
          const packPromise = _miscUtils__WEBPACK_IMPORTED_MODULE_7__.bufferStream(packStream);
          packStream.pipe(stdout); // It seems that npm doesn't support specifying the pack output path,
          // so we have to extract the stdout on top of forking it to the logs.

          const pack = await _execUtils__WEBPACK_IMPORTED_MODULE_8__.pipevp(`npm`, [`pack`, `--silent`], {
            cwd,
            env,
            stdin,
            stdout: packStream,
            stderr
          });
          if (pack.code !== 0) return pack.code;
          const packOutput = (await packPromise).toString().trim();
          const packTarget = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(packOutput)); // Only then can we move the pack to its rightful location

          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.renamePromise(packTarget, outputPath);
          return 0;
        }]]);
        const workflow = workflows.get(effectivePackageManager);
        if (typeof workflow === `undefined`) throw new Error(`Assertion failed: Unsupported workflow`);
        const code = await workflow();
        if (code === 0 || typeof code === `undefined`) return;
        _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.detachTemp(logDir);
        throw new _Report__WEBPACK_IMPORTED_MODULE_9__.ReportError(_MessageName__WEBPACK_IMPORTED_MODULE_10__.MessageName.PACKAGE_PREPARATION_FAILED, `Packing the package failed (exit code ${code}, logs can be found here: ${logFile})`);
      });
    });
  });
}
async function hasPackageScript(locator, scriptName, {
  project
}) {
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${_structUtils__WEBPACK_IMPORTED_MODULE_11__.prettyLocator(project.configuration, locator)} not found in the project`);
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.ZipOpenFS.openPromise(async zipOpenFs => {
    const configuration = project.configuration;
    const linkers = project.configuration.getLinkers();
    const linkerOptions = {
      project,
      report: new _StreamReport__WEBPACK_IMPORTED_MODULE_13__.StreamReport({
        stdout: new stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(),
        configuration
      })
    };
    const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
    if (!linker) throw new Error(`The package ${_structUtils__WEBPACK_IMPORTED_MODULE_11__.prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
    const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
    const packageFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_14__.CwdFS(packageLocation, {
      baseFs: zipOpenFs
    });
    const manifest = await _Manifest__WEBPACK_IMPORTED_MODULE_15__.Manifest.find(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PortablePath.dot, {
      baseFs: packageFs
    });
    return manifest.scripts.has(scriptName);
  }, {
    libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)()
  });
}
async function executePackageScript(locator, scriptName, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr
}) {
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async binFolder => {
    const {
      manifest,
      env,
      cwd: realCwd
    } = await initializePackageEnvironment(locator, {
      project,
      binFolder,
      cwd,
      lifecycleScript: scriptName
    });
    const script = manifest.scripts.get(scriptName);
    if (typeof script === `undefined`) return 1;

    const realExecutor = async () => {
      return await (0,_yarnpkg_shell__WEBPACK_IMPORTED_MODULE_1__.execute)(script, args, {
        cwd: realCwd,
        env,
        stdin,
        stdout,
        stderr
      });
    };

    const executor = await project.configuration.reduceHook(hooks => {
      return hooks.wrapScriptExecution;
    }, realExecutor, project, locator, scriptName, {
      script,
      args,
      cwd: realCwd,
      env,
      stdin,
      stdout,
      stderr
    });
    return await executor();
  });
}
async function executePackageShellcode(locator, command, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr
}) {
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async binFolder => {
    const {
      env,
      cwd: realCwd
    } = await initializePackageEnvironment(locator, {
      project,
      binFolder,
      cwd
    });
    return await (0,_yarnpkg_shell__WEBPACK_IMPORTED_MODULE_1__.execute)(command, args, {
      cwd: realCwd,
      env,
      stdin,
      stdout,
      stderr
    });
  });
}

async function initializePackageEnvironment(locator, {
  project,
  binFolder,
  cwd,
  lifecycleScript
}) {
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${_structUtils__WEBPACK_IMPORTED_MODULE_11__.prettyLocator(project.configuration, locator)} not found in the project`);
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_12__.ZipOpenFS.openPromise(async zipOpenFs => {
    const configuration = project.configuration;
    const linkers = project.configuration.getLinkers();
    const linkerOptions = {
      project,
      report: new _StreamReport__WEBPACK_IMPORTED_MODULE_13__.StreamReport({
        stdout: new stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(),
        configuration
      })
    };
    const linker = linkers.find(linker => linker.supportsPackage(pkg, linkerOptions));
    if (!linker) throw new Error(`The package ${_structUtils__WEBPACK_IMPORTED_MODULE_11__.prettyLocator(project.configuration, pkg)} isn't supported by any of the available linkers`);
    const env = await makeScriptEnv({
      project,
      binFolder,
      lifecycleScript
    });

    for (const [binaryName, [, binaryPath]] of await getPackageAccessibleBinaries(locator, {
      project
    })) await makePathWrapper(binFolder, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.toFilename)(binaryName), process.execPath, [binaryPath]);

    const packageLocation = await linker.findPackageLocation(pkg, linkerOptions);
    const packageFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_14__.CwdFS(packageLocation, {
      baseFs: zipOpenFs
    });
    const manifest = await _Manifest__WEBPACK_IMPORTED_MODULE_15__.Manifest.find(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PortablePath.dot, {
      baseFs: packageFs
    });
    if (typeof cwd === `undefined`) cwd = packageLocation;
    return {
      manifest,
      binFolder,
      env,
      cwd
    };
  }, {
    libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)()
  });
}

async function executeWorkspaceScript(workspace, scriptName, args, {
  cwd,
  stdin,
  stdout,
  stderr
}) {
  return await executePackageScript(workspace.anchoredLocator, scriptName, args, {
    cwd,
    project: workspace.project,
    stdin,
    stdout,
    stderr
  });
}
async function hasWorkspaceScript(workspace, scriptName) {
  return workspace.manifest.scripts.has(scriptName);
}
/**
 * Return the binaries that can be accessed by the specified package
 *
 * @param locator The queried package
 * @param project The project owning the package
 */

async function getPackageAccessibleBinaries(locator, {
  project
}) {
  const configuration = project.configuration;
  const binaries = new Map();
  const pkg = project.storedPackages.get(locator.locatorHash);
  if (!pkg) throw new Error(`Package for ${_structUtils__WEBPACK_IMPORTED_MODULE_11__.prettyLocator(configuration, locator)} not found in the project`);
  const stdout = new stream__WEBPACK_IMPORTED_MODULE_3__.Writable();
  const linkers = configuration.getLinkers();
  const linkerOptions = {
    project,
    report: new _StreamReport__WEBPACK_IMPORTED_MODULE_13__.StreamReport({
      configuration,
      stdout
    })
  };
  const visibleLocators = new Set([locator.locatorHash]);

  for (const descriptor of pkg.dependencies.values()) {
    const resolution = project.storedResolutions.get(descriptor.descriptorHash);
    if (!resolution) throw new Error(`Assertion failed: The resolution (${_structUtils__WEBPACK_IMPORTED_MODULE_11__.prettyDescriptor(configuration, descriptor)}) should have been registered`);
    visibleLocators.add(resolution);
  }

  for (const locatorHash of visibleLocators) {
    const dependency = project.storedPackages.get(locatorHash);
    if (!dependency) throw new Error(`Assertion failed: The package (${locatorHash}) should have been registered`);
    if (dependency.bin.size === 0) continue;
    const linker = linkers.find(linker => linker.supportsPackage(dependency, linkerOptions));
    if (!linker) continue;
    const packageLocation = await linker.findPackageLocation(dependency, linkerOptions);

    for (const [name, target] of dependency.bin) {
      binaries.set(name, [dependency, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(packageLocation, target))]);
    }
  }

  return binaries;
}
/**
 * Return the binaries that can be accessed by the specified workspace
 *
 * @param workspace The queried workspace
 */

async function getWorkspaceAccessibleBinaries(workspace) {
  return await getPackageAccessibleBinaries(workspace.anchoredLocator, {
    project: workspace.project
  });
}
/**
 * Execute a binary from the specified package.
 *
 * Note that "binary" in this sense means "a Javascript file". Actual native
 * binaries cannot be executed this way, because we use Node in order to
 * transparently read from the archives.
 *
 * @param locator The queried package
 * @param binaryName The name of the binary file to execute
 * @param args The arguments to pass to the file
 */

async function executePackageAccessibleBinary(locator, binaryName, args, {
  cwd,
  project,
  stdin,
  stdout,
  stderr,
  nodeArgs = []
}) {
  const packageAccessibleBinaries = await getPackageAccessibleBinaries(locator, {
    project
  });
  const binary = packageAccessibleBinaries.get(binaryName);
  if (!binary) throw new Error(`Binary not found (${binaryName}) for ${_structUtils__WEBPACK_IMPORTED_MODULE_11__.prettyLocator(project.configuration, locator)}`);
  return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async binFolder => {
    const [, binaryPath] = binary;
    const env = await makeScriptEnv({
      project,
      binFolder
    });

    for (const [binaryName, [, binaryPath]] of packageAccessibleBinaries) await makePathWrapper(env.BERRY_BIN_FOLDER, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.toFilename)(binaryName), process.execPath, [binaryPath]);

    let result;

    try {
      result = await _execUtils__WEBPACK_IMPORTED_MODULE_8__.pipevp(process.execPath, [...nodeArgs, binaryPath, ...args], {
        cwd,
        env,
        stdin,
        stdout,
        stderr
      });
    } finally {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.removePromise(env.BERRY_BIN_FOLDER);
    }

    return result.code;
  });
}
/**
 * Execute a binary from the specified workspace
 *
 * @param workspace The queried package
 * @param binaryName The name of the binary file to execute
 * @param args The arguments to pass to the file
 */

async function executeWorkspaceAccessibleBinary(workspace, binaryName, args, {
  cwd,
  stdin,
  stdout,
  stderr
}) {
  return await executePackageAccessibleBinary(workspace.anchoredLocator, binaryName, args, {
    project: workspace.project,
    cwd,
    stdin,
    stdout,
    stderr
  });
}

/***/ }),
/* 255 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "execute": () => /* binding */ execute
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(213);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var fast_glob__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(147);
/* harmony import */ var fast_glob__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_glob__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(110);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(256);







function cloneState(state, mergeWith = {}) {
  const newState = { ...state,
    ...mergeWith
  };
  newState.environment = { ...state.environment,
    ...mergeWith.environment
  };
  newState.variables = { ...state.variables,
    ...mergeWith.variables
  };
  return newState;
}

const BUILTINS = new Map([[`cd`, async ([target, ...rest], opts, state) => {
  const resolvedTarget = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(state.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.toPortablePath(target));
  const stat = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.statPromise(resolvedTarget);

  if (!stat.isDirectory()) {
    state.stderr.write(`cd: not a directory\n`);
    return 1;
  } else {
    state.cwd = resolvedTarget;
    return 0;
  }
}], [`pwd`, async (args, opts, state) => {
  state.stdout.write(`${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.fromPortablePath(state.cwd)}\n`);
  return 0;
}], [`true`, async (args, opts, state) => {
  return 0;
}], [`false`, async (args, opts, state) => {
  return 1;
}], [`exit`, async ([code, ...rest], opts, state) => {
  return state.exitCode = parseInt(code, 10);
}], [`echo`, async (args, opts, state) => {
  state.stdout.write(`${args.join(` `)}\n`);
  return 0;
}], [`__ysh_run_procedure`, async (args, opts, state) => {
  const procedure = state.procedures[args[0]];
  const exitCode = await (0,_pipe__WEBPACK_IMPORTED_MODULE_3__.start)(procedure, {
    stdin: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(state.stdin),
    stdout: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(state.stdout),
    stderr: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(state.stderr)
  }).run();
  return exitCode;
}], [`__ysh_set_redirects`, async (args, opts, state) => {
  let stdin = state.stdin;
  let stdout = state.stdout;
  const stderr = state.stderr;
  const inputs = [];
  const outputs = [];
  let t = 0;

  while (args[t] !== `--`) {
    const type = args[t++];
    const count = Number(args[t++]);
    const last = t + count;

    for (let u = t; u < last; ++t, ++u) {
      switch (type) {
        case `<`:
          {
            inputs.push(() => {
              return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.createReadStream(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(state.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.toPortablePath(args[u])));
            });
          }
          break;

        case `<<<`:
          {
            inputs.push(() => {
              const input = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
              process.nextTick(() => {
                input.write(`${args[u]}\n`);
                input.end();
              });
              return input;
            });
          }
          break;

        case `>`:
          {
            outputs.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.createWriteStream(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(state.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.toPortablePath(args[u]))));
          }
          break;

        case `>>`:
          {
            outputs.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.createWriteStream(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(state.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.toPortablePath(args[u])), {
              flags: `a`
            }));
          }
          break;
      }
    }
  }

  if (inputs.length > 0) {
    const pipe = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    stdin = pipe;

    const bindInput = n => {
      if (n === inputs.length) {
        pipe.end();
      } else {
        const input = inputs[n]();
        input.pipe(pipe, {
          end: false
        });
        input.on(`end`, () => {
          bindInput(n + 1);
        });
      }
    };

    bindInput(0);
  }

  if (outputs.length > 0) {
    const pipe = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    stdout = pipe;

    for (const output of outputs) {
      pipe.pipe(output);
    }
  }

  const exitCode = await (0,_pipe__WEBPACK_IMPORTED_MODULE_3__.start)(makeCommandAction(args.slice(t + 1), opts, state), {
    stdin: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(stdin),
    stdout: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(stdout),
    stderr: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(stderr)
  }).run(); // Close all the outputs (since the shell never closes the output stream)

  await Promise.all(outputs.map(output => {
    // Wait until the output got flushed to the disk
    return new Promise(resolve => {
      output.on(`close`, () => {
        resolve();
      });
      output.end();
    });
  }));
  return exitCode;
}]]);

async function executeBufferedSubshell(ast, opts, state) {
  const chunks = [];
  const stdout = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
  stdout.on(`data`, chunk => chunks.push(chunk));
  await executeShellLine(ast, opts, cloneState(state, {
    stdout
  }));
  return Buffer.concat(chunks).toString().replace(/[\r\n]+$/, ``);
}

async function applyEnvVariables(environmentSegments, opts, state) {
  const envPromises = environmentSegments.map(async envSegment => {
    const interpolatedArgs = await interpolateArguments(envSegment.args, opts, state);
    return {
      name: envSegment.name,
      value: interpolatedArgs.join(` `)
    };
  });
  const interpolatedEnvs = await Promise.all(envPromises);
  return interpolatedEnvs.reduce((envs, env) => {
    envs[env.name] = env.value;
    return envs;
  }, {});
}

function split(raw) {
  return raw.match(/[^ \r\n\t]+/g) || [];
}

async function evaluateVariable(segment, opts, state, push, pushAndClose = push) {
  switch (segment.name) {
    case `#`:
      {
        push(String(opts.args.length));
      }
      break;

    case `@`:
      {
        if (segment.quoted) {
          for (const raw of opts.args) {
            pushAndClose(raw);
          }
        } else {
          for (const raw of opts.args) {
            const parts = split(raw);

            for (let t = 0; t < parts.length - 1; ++t) pushAndClose(parts[t]);

            push(parts[parts.length - 1]);
          }
        }
      }
      break;

    case `*`:
      {
        const raw = opts.args.join(` `);

        if (segment.quoted) {
          push(raw);
        } else {
          for (const part of split(raw)) {
            pushAndClose(part);
          }
        }
      }
      break;

    case `RANDOM`:
      {
        push(String(Math.floor(Math.random() * 32768)));
      }
      break;

    default:
      {
        const argIndex = parseInt(segment.name, 10);

        if (Number.isFinite(argIndex)) {
          if (!(argIndex >= 0 && argIndex < opts.args.length)) {
            throw new Error(`Unbound argument #${argIndex}`);
          } else {
            push(opts.args[argIndex]);
          }
        } else {
          if (Object.prototype.hasOwnProperty.call(state.variables, segment.name)) {
            push(state.variables[segment.name]);
          } else if (Object.prototype.hasOwnProperty.call(state.environment, segment.name)) {
            push(state.environment[segment.name]);
          } else if (segment.defaultValue) {
            push((await interpolateArguments(segment.defaultValue, opts, state)).join(` `));
          } else {
            throw new Error(`Unbound variable "${segment.name}"`);
          }
        }
      }
      break;
  }
}

const operators = {
  addition: (left, right) => left + right,
  subtraction: (left, right) => left - right,
  multiplication: (left, right) => left * right,
  division: (left, right) => Math.trunc(left / right)
};

async function evaluateArithmetic(arithmetic, opts, state) {
  if (arithmetic.type === `number`) {
    if (!Number.isInteger(arithmetic.value)) {
      throw new Error(`Invalid number: "${arithmetic.value}", only integers are allowed`);
    } else {
      return arithmetic.value;
    }
  } else if (arithmetic.type === `variable`) {
    const parts = [];
    await evaluateVariable({ ...arithmetic,
      quoted: true
    }, opts, state, result => parts.push(result));
    const number = Number(parts.join(` `));

    if (Number.isNaN(number)) {
      return evaluateArithmetic({
        type: `variable`,
        name: parts.join(` `)
      }, opts, state);
    } else {
      return evaluateArithmetic({
        type: `number`,
        value: number
      }, opts, state);
    }
  } else {
    return operators[arithmetic.type](await evaluateArithmetic(arithmetic.left, opts, state), await evaluateArithmetic(arithmetic.right, opts, state));
  }
}

async function interpolateArguments(commandArgs, opts, state) {
  const redirections = new Map();
  const interpolated = [];
  let interpolatedSegments = [];

  const push = segment => {
    interpolatedSegments.push(segment);
  };

  const close = () => {
    if (interpolatedSegments.length > 0) interpolated.push(interpolatedSegments.join(``));
    interpolatedSegments = [];
  };

  const pushAndClose = segment => {
    push(segment);
    close();
  };

  const redirect = (type, target) => {
    let targets = redirections.get(type);
    if (typeof targets === `undefined`) redirections.set(type, targets = []);
    targets.push(target);
  };

  for (const commandArg of commandArgs) {
    switch (commandArg.type) {
      case `redirection`:
        {
          const interpolatedArgs = await interpolateArguments(commandArg.args, opts, state);

          for (const interpolatedArg of interpolatedArgs) {
            redirect(commandArg.subtype, interpolatedArg);
          }
        }
        break;

      case `argument`:
        {
          for (const segment of commandArg.segments) {
            switch (segment.type) {
              case `text`:
                {
                  push(segment.text);
                }
                break;

              case `glob`:
                {
                  const matches = await opts.glob.match(segment.pattern, {
                    cwd: state.cwd
                  });
                  if (!matches.length) throw new Error(`No file matches found: "${segment.pattern}". Note: Glob patterns currently only support files that exist on the filesystem (Help Wanted)`);

                  for (const match of matches.sort()) {
                    pushAndClose(match);
                  }
                }
                break;

              case `shell`:
                {
                  const raw = await executeBufferedSubshell(segment.shell, opts, state);

                  if (segment.quoted) {
                    push(raw);
                  } else {
                    const parts = split(raw);

                    for (let t = 0; t < parts.length - 1; ++t) pushAndClose(parts[t]);

                    push(parts[parts.length - 1]);
                  }
                }
                break;

              case `variable`:
                {
                  await evaluateVariable(segment, opts, state, push, pushAndClose);
                }
                break;

              case `arithmetic`:
                {
                  push(String(await evaluateArithmetic(segment.arithmetic, opts, state)));
                }
                break;
            }
          }
        }
        break;
    }

    close();
  }

  if (redirections.size > 0) {
    const redirectionArgs = [];

    for (const [subtype, targets] of redirections.entries()) redirectionArgs.splice(redirectionArgs.length, 0, subtype, String(targets.length), ...targets);

    interpolated.splice(0, 0, `__ysh_set_redirects`, ...redirectionArgs, `--`);
  }

  return interpolated;
}
/**
 * Executes a command chain. A command chain is a list of commands linked
 * together thanks to the use of either of the `|` or `|&` operators:
 *
 * $ cat hello | grep world | grep -v foobar
 */


function makeCommandAction(args, opts, state) {
  if (!opts.builtins.has(args[0])) args = [`command`, ...args];
  const nativeCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.fromPortablePath(state.cwd);
  let env = state.environment;
  if (typeof env.PWD !== `undefined`) env = { ...env,
    PWD: nativeCwd
  };
  const [name, ...rest] = args;

  if (name === `command`) {
    return (0,_pipe__WEBPACK_IMPORTED_MODULE_3__.makeProcess)(rest[0], rest.slice(1), opts, {
      cwd: nativeCwd,
      env
    });
  }

  const builtin = opts.builtins.get(name);
  if (typeof builtin === `undefined`) throw new Error(`Assertion failed: A builtin should exist for "${name}"`);
  return (0,_pipe__WEBPACK_IMPORTED_MODULE_3__.makeBuiltin)(async ({
    stdin,
    stdout,
    stderr
  }) => {
    state.stdin = stdin;
    state.stdout = stdout;
    state.stderr = stderr;
    return await builtin(rest, opts, state);
  });
}

function makeSubshellAction(ast, opts, state) {
  return stdio => {
    const stdin = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    const promise = executeShellLine(ast, opts, cloneState(state, {
      stdin
    }));
    return {
      stdin,
      promise
    };
  };
}

async function executeCommandChain(node, opts, state) {
  let current = node;
  let pipeType = null;
  let execution = null;

  while (current) {
    // Only the final segment is allowed to modify the shell state; all the
    // other ones are isolated
    const activeState = current.then ? { ...state
    } : state;
    let action;

    switch (current.type) {
      case `command`:
        {
          const args = await interpolateArguments(current.args, opts, state);
          const environment = await applyEnvVariables(current.envs, opts, state);
          action = current.envs.length ? makeCommandAction(args, opts, cloneState(activeState, {
            environment
          })) : makeCommandAction(args, opts, activeState);
        }
        break;

      case `subshell`:
        {
          const args = await interpolateArguments(current.args, opts, state); // We don't interpolate the subshell because it will be recursively
          // interpolated within its own context

          const procedure = makeSubshellAction(current.subshell, opts, activeState);

          if (args.length === 0) {
            action = procedure;
          } else {
            let key;

            do {
              key = String(Math.random());
            } while (Object.prototype.hasOwnProperty.call(activeState.procedures, key));

            activeState.procedures = { ...activeState.procedures
            };
            activeState.procedures[key] = procedure;
            action = makeCommandAction([...args, `__ysh_run_procedure`, key], opts, activeState);
          }
        }
        break;

      case `envs`:
        {
          const environment = await applyEnvVariables(current.envs, opts, state);
          activeState.environment = { ...activeState.environment,
            ...environment
          };
          action = makeCommandAction([`true`], opts, activeState);
        }
        break;
    }

    if (typeof action === `undefined`) throw new Error(`Assertion failed: An action should have been generated`);

    if (pipeType === null) {
      // If we're processing the left-most segment of the command, we start a
      // new execution pipeline
      execution = (0,_pipe__WEBPACK_IMPORTED_MODULE_3__.start)(action, {
        stdin: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(activeState.stdin),
        stdout: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(activeState.stdout),
        stderr: new _pipe__WEBPACK_IMPORTED_MODULE_3__.ProtectedStream(activeState.stderr)
      });
    } else {
      if (execution === null) throw new Error(`The execution pipeline should have been setup`); // Otherwise, depending on the exaxct pipe type, we either pipe stdout
      // only or stdout and stderr

      switch (pipeType) {
        case `|`:
          {
            execution = execution.pipeTo(action);
          }
          break;

        case `|&`:
          {
            execution = execution.pipeTo(action);
          }
          break;
      }
    }

    if (current.then) {
      pipeType = current.then.type;
      current = current.then.chain;
    } else {
      current = null;
    }
  }

  if (execution === null) throw new Error(`Assertion failed: The execution pipeline should have been setup`);
  return await execution.run();
}
/**
 * Execute a command line. A command line is a list of command shells linked
 * together thanks to the use of either of the `||` or `&&` operators.
 */


async function executeCommandLine(node, opts, state) {
  if (!node.then) return await executeCommandChain(node.chain, opts, state);
  const code = await executeCommandChain(node.chain, opts, state); // If the execution aborted (usually through "exit"), we must bailout

  if (state.exitCode !== null) return state.exitCode; // We must update $?, which always contains the exit code from
  // the right-most command

  state.variables[`?`] = String(code);

  switch (node.then.type) {
    case `&&`:
      {
        if (code === 0) {
          return await executeCommandLine(node.then.line, opts, state);
        } else {
          return code;
        }
      }
      break;

    case `||`:
      {
        if (code !== 0) {
          return await executeCommandLine(node.then.line, opts, state);
        } else {
          return code;
        }
      }
      break;

    default:
      {
        throw new Error(`Unsupported command type: "${node.then.type}"`);
      }
      break;
  }
}

async function executeShellLine(node, opts, state) {
  let rightMostExitCode = 0;

  for (const command of node) {
    rightMostExitCode = await executeCommandLine(command, opts, state); // If the execution aborted (usually through "exit"), we must bailout

    if (state.exitCode !== null) return state.exitCode; // We must update $?, which always contains the exit code from
    // the right-most command

    state.variables[`?`] = String(rightMostExitCode);
  }

  return rightMostExitCode;
}

function locateArgsVariableInSegment(segment) {
  switch (segment.type) {
    case `variable`:
      {
        return segment.name === `@` || segment.name === `#` || segment.name === `*` || Number.isFinite(parseInt(segment.name, 10)) || `defaultValue` in segment && !!segment.defaultValue && segment.defaultValue.some(arg => locateArgsVariableInArgument(arg));
      }
      break;

    case `arithmetic`:
      {
        return locateArgsVariableInArithmetic(segment.arithmetic);
      }
      break;

    case `shell`:
      {
        return locateArgsVariable(segment.shell);
      }
      break;

    default:
      {
        return false;
      }
      break;
  }
}

function locateArgsVariableInArgument(arg) {
  switch (arg.type) {
    case `redirection`:
      {
        return arg.args.some(arg => locateArgsVariableInArgument(arg));
      }
      break;

    case `argument`:
      {
        return arg.segments.some(segment => locateArgsVariableInSegment(segment));
      }
      break;

    default:
      throw new Error(`Unreacheable`);
  }
}

function locateArgsVariableInArithmetic(arg) {
  switch (arg.type) {
    case `variable`:
      {
        return locateArgsVariableInSegment(arg);
      }
      break;

    case `number`:
      {
        return false;
      }
      break;

    default:
      return locateArgsVariableInArithmetic(arg.left) || locateArgsVariableInArithmetic(arg.right);
  }
}

function locateArgsVariable(node) {
  return node.some(command => {
    while (command) {
      let chain = command.chain;

      while (chain) {
        let hasArgs;

        switch (chain.type) {
          case `subshell`:
            {
              hasArgs = locateArgsVariable(chain.subshell);
            }
            break;

          case `command`:
            {
              hasArgs = chain.envs.some(env => env.args.some(arg => {
                return locateArgsVariableInArgument(arg);
              })) || chain.args.some(arg => {
                return locateArgsVariableInArgument(arg);
              });
            }
            break;
        }

        if (hasArgs) return true;
        if (!chain.then) break;
        chain = chain.then.chain;
      }

      if (!command.then) break;
      command = command.then.line;
    }

    return false;
  });
}

async function execute(command, args = [], {
  builtins = {},
  cwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.toPortablePath(process.cwd()),
  env = process.env,
  stdin = process.stdin,
  stdout = process.stdout,
  stderr = process.stderr,
  variables = {},
  glob = {
    isGlobPattern: (fast_glob__WEBPACK_IMPORTED_MODULE_1___default().isDynamicPattern),
    match: (pattern, {
      cwd,
      fs = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs
    }) => fast_glob__WEBPACK_IMPORTED_MODULE_1___default()(pattern, {
      cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.fromPortablePath(cwd),
      // @ts-ignore: `fs` is wrapped in `PosixFS`
      fs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.PosixFS(fs)
    })
  }
} = {}) {
  const normalizedEnv = {};

  for (const [key, value] of Object.entries(env)) if (typeof value !== `undefined`) normalizedEnv[key] = value;

  const normalizedBuiltins = new Map(BUILTINS);

  for (const [key, builtin] of Object.entries(builtins)) normalizedBuiltins.set(key, builtin); // This is meant to be the equivalent of /dev/null


  if (stdin === null) {
    stdin = new stream__WEBPACK_IMPORTED_MODULE_2__.PassThrough();
    stdin.end();
  }

  const ast = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_0__.parseShell)(command, glob); // If the shell line doesn't use the args, inject it at the end of the
  // right-most command

  if (!locateArgsVariable(ast) && ast.length > 0 && args.length > 0) {
    let command = ast[ast.length - 1];

    while (command.then) command = command.then.line;

    let chain = command.chain;

    while (chain.then) chain = chain.then.chain;

    if (chain.type === `command`) {
      chain.args = chain.args.concat(args.map(arg => {
        return {
          type: `argument`,
          segments: [{
            type: `text`,
            text: arg
          }]
        };
      }));
    }
  }

  return await executeShellLine(ast, {
    args,
    builtins: normalizedBuiltins,
    initialStdin: stdin,
    initialStdout: stdout,
    initialStderr: stderr,
    glob
  }, {
    cwd,
    environment: normalizedEnv,
    exitCode: null,
    procedures: {},
    stdin,
    stdout,
    stderr,
    variables: Object.assign({}, variables, {
      [`?`]: 0
    })
  });
}

/***/ }),
/* 256 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeProcess": () => /* binding */ makeProcess,
/* harmony export */   "makeBuiltin": () => /* binding */ makeBuiltin,
/* harmony export */   "ProtectedStream": () => /* binding */ ProtectedStream,
/* harmony export */   "start": () => /* binding */ start
/* harmony export */ });
/* unused harmony export Handle */
/* harmony import */ var cross_spawn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(257);
/* harmony import */ var cross_spawn__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_spawn__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_1__);


var Pipe;

(function (Pipe) {
  Pipe[Pipe["STDOUT"] = 1] = "STDOUT";
  Pipe[Pipe["STDERR"] = 2] = "STDERR";
})(Pipe || (Pipe = {}));

function sigintHandler() {} // We don't want SIGINT to kill our process; we want it to kill the
// innermost process, whose end will cause our own to exit.
// Rather than attaching one SIGINT handler for each process, we
// attach a single one and use a refcount to detect once it's no
// longer needed.


let sigintRefCount = 0;
function makeProcess(name, args, opts, spawnOpts) {
  return stdio => {
    const stdin = stdio[0] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform ? `pipe` : stdio[0];
    const stdout = stdio[1] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform ? `pipe` : stdio[1];
    const stderr = stdio[2] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform ? `pipe` : stdio[2];
    const child = cross_spawn__WEBPACK_IMPORTED_MODULE_0___default()(name, args, { ...spawnOpts,
      stdio: [stdin, stdout, stderr]
    });
    if (sigintRefCount++ === 0) process.on(`SIGINT`, sigintHandler);
    if (stdio[0] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform) stdio[0].pipe(child.stdin);
    if (stdio[1] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform) child.stdout.pipe(stdio[1], {
      end: false
    });
    if (stdio[2] instanceof stream__WEBPACK_IMPORTED_MODULE_1__.Transform) child.stderr.pipe(stdio[2], {
      end: false
    });
    return {
      stdin: child.stdin,
      promise: new Promise(resolve => {
        child.on(`error`, error => {
          if (--sigintRefCount === 0) process.off(`SIGINT`, sigintHandler); // @ts-ignore

          switch (error.code) {
            case `ENOENT`:
              {
                stdio[2].write(`command not found: ${name}\n`);
                resolve(127);
              }
              break;

            case `EACCESS`:
              {
                stdio[2].write(`permission denied: ${name}\n`);
                resolve(128);
              }
              break;

            default:
              {
                stdio[2].write(`uncaught error: ${error.message}\n`);
                resolve(1);
              }
              break;
          }
        });
        child.on(`exit`, code => {
          if (--sigintRefCount === 0) process.off(`SIGINT`, sigintHandler);

          if (code !== null) {
            resolve(code);
          } else {
            resolve(129);
          }
        });
      })
    };
  };
}
function makeBuiltin(builtin) {
  return stdio => {
    const stdin = stdio[0] === `pipe` ? new stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough() : stdio[0];
    return {
      stdin,
      promise: Promise.resolve().then(() => builtin({
        stdin,
        stdout: stdio[1],
        stderr: stdio[2]
      }))
    };
  };
}
class ProtectedStream {
  constructor(stream) {
    this.stream = stream;
  }

  close() {// Ignore close request
  }

  get() {
    return this.stream;
  }

}

class PipeStream {
  constructor() {
    this.stream = null;
  }

  close() {
    if (this.stream === null) {
      throw new Error(`Assertion failed: No stream attached`);
    } else {
      this.stream.end();
    }
  }

  attach(stream) {
    this.stream = stream;
  }

  get() {
    if (this.stream === null) {
      throw new Error(`Assertion failed: No stream attached`);
    } else {
      return this.stream;
    }
  }

}

class Handle {
  constructor(ancestor, implementation) {
    this.stdin = null;
    this.stdout = null;
    this.stderr = null;
    this.pipe = null;
    this.ancestor = ancestor;
    this.implementation = implementation;
  }

  static start(implementation, {
    stdin,
    stdout,
    stderr
  }) {
    const chain = new Handle(null, implementation);
    chain.stdin = stdin;
    chain.stdout = stdout;
    chain.stderr = stderr;
    return chain;
  }

  pipeTo(implementation, source = Pipe.STDOUT) {
    const next = new Handle(this, implementation);
    const pipe = new PipeStream();
    next.pipe = pipe;
    next.stdout = this.stdout;
    next.stderr = this.stderr;
    if ((source & Pipe.STDOUT) === Pipe.STDOUT) this.stdout = pipe;else if (this.ancestor !== null) this.stderr = this.ancestor.stdout;
    if ((source & Pipe.STDERR) === Pipe.STDERR) this.stderr = pipe;else if (this.ancestor !== null) this.stderr = this.ancestor.stderr;
    return next;
  }

  async exec() {
    const stdio = [`ignore`, `ignore`, `ignore`];

    if (this.pipe) {
      stdio[0] = `pipe`;
    } else {
      if (this.stdin === null) {
        throw new Error(`Assertion failed: No input stream registered`);
      } else {
        stdio[0] = this.stdin.get();
      }
    }

    let stdoutLock;

    if (this.stdout === null) {
      throw new Error(`Assertion failed: No output stream registered`);
    } else {
      stdoutLock = this.stdout;
      stdio[1] = stdoutLock.get();
    }

    let stderrLock;

    if (this.stderr === null) {
      throw new Error(`Assertion failed: No error stream registered`);
    } else {
      stderrLock = this.stderr;
      stdio[2] = stderrLock.get();
    }

    const child = this.implementation(stdio);
    if (this.pipe) this.pipe.attach(child.stdin);
    return await child.promise.then(code => {
      stdoutLock.close();
      stderrLock.close();
      return code;
    });
  }

  async run() {
    const promises = [];

    for (let handle = this; handle; handle = handle.ancestor) promises.push(handle.exec());

    const exitCodes = await Promise.all(promises);
    return exitCodes[0];
  }

}
function start(p, opts) {
  return Handle.start(p, opts);
}

/***/ }),
/* 257 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const cp = __webpack_require__(4);
const parse = __webpack_require__(258);
const enoent = __webpack_require__(269);

function spawn(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);

    // Hook into child process "exit" event to emit an error if the command
    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    enoent.hookChildProcess(spawned, parsed);

    return spawned;
}

function spawnSync(command, args, options) {
    // Parse the arguments
    const parsed = parse(command, args, options);

    // Spawn the child process
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);

    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);

    return result;
}

module.exports = spawn;
module.exports.spawn = spawn;
module.exports.sync = spawnSync;

module.exports._parse = parse;
module.exports._enoent = enoent;


/***/ }),
/* 258 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(113);
const resolveCommand = __webpack_require__(259);
const escape = __webpack_require__(265);
const readShebang = __webpack_require__(266);

const isWin = process.platform === 'win32';
const isExecutableRegExp = /\.(?:com|exe)$/i;
const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;

function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);

    const shebang = parsed.file && readShebang(parsed.file);

    if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;

        return resolveCommand(parsed);
    }

    return parsed.file;
}

function parseNonShell(parsed) {
    if (!isWin) {
        return parsed;
    }

    // Detect & add support for shebangs
    const commandFile = detectShebang(parsed);

    // We don't need a shell if the command filename is an executable
    const needsShell = !isExecutableRegExp.test(commandFile);

    // If a shell is required, use cmd.exe and take care of escaping everything correctly
    // Note that `forceShell` is an hidden option used only in tests
    if (parsed.options.forceShell || needsShell) {
        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`
        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument
        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,
        // we need to double escape them
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);

        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\bar)
        // This is necessary otherwise it will always fail with ENOENT in those cases
        parsed.command = path.normalize(parsed.command);

        // Escape command & arguments
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));

        const shellCommand = [parsed.command].concat(parsed.args).join(' ');

        parsed.args = ['/d', '/s', '/c', `"${shellCommand}"`];
        parsed.command = process.env.comspec || 'cmd.exe';
        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped
    }

    return parsed;
}

function parse(command, args, options) {
    // Normalize arguments, similar to nodejs
    if (args && !Array.isArray(args)) {
        options = args;
        args = null;
    }

    args = args ? args.slice(0) : []; // Clone array to avoid changing the original
    options = Object.assign({}, options); // Clone object to avoid changing the original

    // Build our parsed object
    const parsed = {
        command,
        args,
        options,
        file: undefined,
        original: {
            command,
            args,
        },
    };

    // Delegate further parsing to shell or non-shell
    return options.shell ? parsed : parseNonShell(parsed);
}

module.exports = parse;


/***/ }),
/* 259 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(113);
const which = __webpack_require__(260);
const getPathKey = __webpack_require__(264);

function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    // Worker threads do not have process.chdir()
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;

    // If a custom `cwd` was specified, we need to change the process cwd
    // because `which` will do stat calls but does not support a custom cwd
    if (shouldSwitchCwd) {
        try {
            process.chdir(parsed.options.cwd);
        } catch (err) {
            /* Empty */
        }
    }

    let resolved;

    try {
        resolved = which.sync(parsed.command, {
            path: env[getPathKey({ env })],
            pathExt: withoutPathExt ? path.delimiter : undefined,
        });
    } catch (e) {
        /* Empty */
    } finally {
        if (shouldSwitchCwd) {
            process.chdir(cwd);
        }
    }

    // If we successfully resolved, ensure that an absolute path is returned
    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it
    if (resolved) {
        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
    }

    return resolved;
}

function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}

module.exports = resolveCommand;


/***/ }),
/* 260 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

const path = __webpack_require__(113)
const COLON = isWindows ? ';' : ':'
const isexe = __webpack_require__(261)

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    )
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : ''
  const pathExt = isWindows ? pathExtExe.split(colon) : ['']

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
}

const which = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }
  if (!opt)
    opt = {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    resolve(subStep(p, i, 0))
  })

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii]
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext)
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    })
  })

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
}

const whichSync = (cmd, opt) => {
  opt = opt || {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j]
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}

module.exports = which
which.sync = whichSync


/***/ }),
/* 261 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(6)
var core
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = __webpack_require__(262)
} else {
  core = __webpack_require__(263)
}

module.exports = isexe
isexe.sync = sync

function isexe (path, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er)
        } else {
          resolve(is)
        }
      })
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null
        is = false
      }
    }
    cb(er, is)
  })
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}


/***/ }),
/* 262 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(6)

function checkPathExt (path, options) {
  var pathext = options.pathExt !== undefined ?
    options.pathExt : process.env.PATHEXT

  if (!pathext) {
    return true
  }

  pathext = pathext.split(';')
  if (pathext.indexOf('') !== -1) {
    return true
  }
  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase()
    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true
    }
  }
  return false
}

function checkStat (stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false
  }
  return checkPathExt(path, options)
}

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), path, options)
}


/***/ }),
/* 263 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(6)

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), options)
}

function checkStat (stat, options) {
  return stat.isFile() && checkMode(stat, options)
}

function checkMode (stat, options) {
  var mod = stat.mode
  var uid = stat.uid
  var gid = stat.gid

  var myUid = options.uid !== undefined ?
    options.uid : process.getuid && process.getuid()
  var myGid = options.gid !== undefined ?
    options.gid : process.getgid && process.getgid()

  var u = parseInt('100', 8)
  var g = parseInt('010', 8)
  var o = parseInt('001', 8)
  var ug = u | g

  var ret = (mod & o) ||
    (mod & g) && gid === myGid ||
    (mod & u) && uid === myUid ||
    (mod & ug) && myUid === 0

  return ret
}


/***/ }),
/* 264 */
/***/ ((module) => {

"use strict";


const pathKey = (options = {}) => {
	const environment = options.env || process.env;
	const platform = options.platform || process.platform;

	if (platform !== 'win32') {
		return 'PATH';
	}

	return Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
};

module.exports = pathKey;
// TODO: Remove this for the next major release
module.exports.default = pathKey;


/***/ }),
/* 265 */
/***/ ((module) => {

"use strict";


// See http://www.robvanderwoude.com/escapechars.php
const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;

function escapeCommand(arg) {
    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    return arg;
}

function escapeArgument(arg, doubleEscapeMetaChars) {
    // Convert to string
    arg = `${arg}`;

    // Algorithm below is based on https://qntm.org/cmd

    // Sequence of backslashes followed by a double quote:
    // double up all the backslashes and escape the double quote
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');

    // Sequence of backslashes followed by the end of the string
    // (which will become a double quote later):
    // double up all the backslashes
    arg = arg.replace(/(\\*)$/, '$1$1');

    // All other backslashes occur literally

    // Quote the whole thing:
    arg = `"${arg}"`;

    // Escape meta chars
    arg = arg.replace(metaCharsRegExp, '^$1');

    // Double escape meta chars if necessary
    if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, '^$1');
    }

    return arg;
}

module.exports.command = escapeCommand;
module.exports.argument = escapeArgument;


/***/ }),
/* 266 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(6);
const shebangCommand = __webpack_require__(267);

function readShebang(command) {
    // Read the first 150 bytes from the file
    const size = 150;
    const buffer = Buffer.alloc(size);

    let fd;

    try {
        fd = fs.openSync(command, 'r');
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
    } catch (e) { /* Empty */ }

    // Attempt to extract shebang (null is returned if not a shebang)
    return shebangCommand(buffer.toString());
}

module.exports = readShebang;


/***/ }),
/* 267 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const shebangRegex = __webpack_require__(268);

module.exports = (string = '') => {
	const match = string.match(shebangRegex);

	if (!match) {
		return null;
	}

	const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
	const binary = path.split('/').pop();

	if (binary === 'env') {
		return argument;
	}

	return argument ? `${binary} ${argument}` : binary;
};


/***/ }),
/* 268 */
/***/ ((module) => {

"use strict";

module.exports = /^#!(.*)/;


/***/ }),
/* 269 */
/***/ ((module) => {

"use strict";


const isWin = process.platform === 'win32';

function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: 'ENOENT',
        errno: 'ENOENT',
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args,
    });
}

function hookChildProcess(cp, parsed) {
    if (!isWin) {
        return;
    }

    const originalEmit = cp.emit;

    cp.emit = function (name, arg1) {
        // If emitting "exit" event and exit code is 1, we need to check if
        // the command exists and emit an "error" instead
        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16
        if (name === 'exit') {
            const err = verifyENOENT(arg1, parsed, 'spawn');

            if (err) {
                return originalEmit.call(cp, 'error', err);
            }
        }

        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params
    };
}

function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawn');
    }

    return null;
}

function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, 'spawnSync');
    }

    return null;
}

module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError,
};


/***/ }),
/* 270 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YarnVersion": () => /* binding */ YarnVersion
/* harmony export */ });
const YarnVersion =  true ? "2.1.1-git.20200803.7d285e81" : undefined;

/***/ }),
/* 271 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EndStrategy": () => /* binding */ EndStrategy,
/* harmony export */   "pipevp": () => /* binding */ pipevp,
/* harmony export */   "execvp": () => /* binding */ execvp
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);
/* harmony import */ var cross_spawn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(257);
/* harmony import */ var cross_spawn__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_spawn__WEBPACK_IMPORTED_MODULE_0__);


var EndStrategy;

(function (EndStrategy) {
  EndStrategy[EndStrategy["Never"] = 0] = "Never";
  EndStrategy[EndStrategy["ErrorCode"] = 1] = "ErrorCode";
  EndStrategy[EndStrategy["Always"] = 2] = "Always";
})(EndStrategy || (EndStrategy = {}));

function hasFd(stream) {
  // @ts-ignore: Not sure how to typecheck this field
  return stream !== null && typeof stream.fd === `number`;
}

function sigintHandler() {} // We don't want SIGINT to kill our process; we want it to kill the
// innermost process, whose end will cause our own to exit.
// Rather than attaching one SIGINT handler for each process, we
// attach a single one and use a refcount to detect once it's no
// longer needed.


let sigintRefCount = 0;
async function pipevp(fileName, args, {
  cwd,
  env = process.env,
  strict = false,
  stdin = null,
  stdout,
  stderr,
  end = EndStrategy.Always
}) {
  const stdio = [`pipe`, `pipe`, `pipe`];
  if (stdin === null) stdio[0] = `ignore`;else if (hasFd(stdin)) stdio[0] = stdin;
  if (hasFd(stdout)) stdio[1] = stdout;
  if (hasFd(stderr)) stdio[2] = stderr;
  if (sigintRefCount++ === 0) process.on(`SIGINT`, sigintHandler);
  const child = cross_spawn__WEBPACK_IMPORTED_MODULE_0___default()(fileName, args, {
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.fromPortablePath(cwd),
    env: { ...env,
      PWD: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.fromPortablePath(cwd)
    },
    stdio
  });
  if (!hasFd(stdin) && stdin !== null) stdin.pipe(child.stdin);
  if (!hasFd(stdout)) child.stdout.pipe(stdout, {
    end: false
  });
  if (!hasFd(stderr)) child.stderr.pipe(stderr, {
    end: false
  });

  const closeStreams = () => {
    for (const stream of new Set([stdout, stderr])) {
      if (!hasFd(stream)) {
        stream.end();
      }
    }
  };

  return new Promise((resolve, reject) => {
    child.on(`error`, error => {
      if (--sigintRefCount === 0) process.off(`SIGINT`, sigintHandler);
      if (end === EndStrategy.Always || end === EndStrategy.ErrorCode) closeStreams();
      reject(error);
    });
    child.on(`close`, (code, sig) => {
      if (--sigintRefCount === 0) process.off(`SIGINT`, sigintHandler);
      if (end === EndStrategy.Always || end === EndStrategy.ErrorCode && code > 0) closeStreams();

      if (code === 0 || !strict) {
        resolve({
          code: getExitCode(code, sig)
        });
      } else if (code !== null) {
        reject(new Error(`Child "${fileName}" exited with exit code ${code}`));
      } else {
        reject(new Error(`Child "${fileName}" exited with signal ${sig}`));
      }
    });
  });
}
async function execvp(fileName, args, {
  cwd,
  env = process.env,
  encoding = `utf8`,
  strict = false
}) {
  const stdio = [`ignore`, `pipe`, `pipe`];
  const stdoutChunks = [];
  const stderrChunks = [];
  const nativeCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.fromPortablePath(cwd);
  if (typeof env.PWD !== `undefined`) env = { ...env,
    PWD: nativeCwd
  };
  const subprocess = cross_spawn__WEBPACK_IMPORTED_MODULE_0___default()(fileName, args, {
    cwd: nativeCwd,
    env,
    stdio
  });
  subprocess.stdout.on(`data`, chunk => {
    stdoutChunks.push(chunk);
  });
  subprocess.stderr.on(`data`, chunk => {
    stderrChunks.push(chunk);
  });
  return await new Promise((resolve, reject) => {
    subprocess.on(`close`, (code, signal) => {
      const stdout = encoding === `buffer` ? Buffer.concat(stdoutChunks) : Buffer.concat(stdoutChunks).toString(encoding);
      const stderr = encoding === `buffer` ? Buffer.concat(stderrChunks) : Buffer.concat(stderrChunks).toString(encoding);

      if (code === 0 || !strict) {
        resolve({
          code: getExitCode(code, signal),
          stdout,
          stderr
        });
      } else {
        reject(Object.assign(new Error(`Child "${fileName}" exited with exit code ${code}\n\n${stderr}`), {
          code: getExitCode(code, signal),
          stdout,
          stderr
        }));
      }
    });
  });
}
const signalToCodeMap = new Map([[`SIGINT`, 2], [`SIGQUIT`, 3], [`SIGKILL`, 9], [`SIGTERM`, 15]]);

function getExitCode(code, signal) {
  const signalCode = signalToCodeMap.get(signal);

  if (typeof signalCode !== `undefined`) {
    return 128 + signalCode;
  } else {
    return code !== null && code !== void 0 ? code : 1;
  }
}

/***/ }),
/* 272 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TelemetryManager": () => /* binding */ TelemetryManager
/* harmony export */ });
/* unused harmony export MetricName */
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _httpUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(273);
/* harmony import */ var _miscUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);



var MetricName;

(function (MetricName) {
  MetricName["VERSION"] = "version";
  MetricName["COMMAND_NAME"] = "commandName";
  MetricName["PLUGIN_NAME"] = "pluginName";
  MetricName["INSTALL_COUNT"] = "installCount";
  MetricName["PROJECT_COUNT"] = "projectCount";
  MetricName["WORKSPACE_COUNT"] = "workspaceCount";
  MetricName["DEPENDENCY_COUNT"] = "dependencyCount";
  MetricName["EXTENSION"] = "packageExtension";
})(MetricName || (MetricName = {}));

class TelemetryManager {
  constructor(configuration, accountId) {
    this.values = new Map();
    this.hits = new Map();
    this.enumerators = new Map();
    this.configuration = configuration;
    const registryFile = this.getRegistryPath();
    this.isNew = !_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.existsSync(registryFile);
    this.sendReport(accountId);
    this.startBuffer();
  }

  reportVersion(value) {
    this.reportValue(MetricName.VERSION, value);
  }

  reportCommandName(value) {
    this.reportValue(MetricName.COMMAND_NAME, value || `<none>`);
  }

  reportPluginName(value) {
    this.reportValue(MetricName.PLUGIN_NAME, value);
  }

  reportProject(cwd) {
    this.reportEnumerator(MetricName.PROJECT_COUNT, cwd);
  }

  reportInstall(nodeLinker) {
    this.reportHit(MetricName.INSTALL_COUNT, nodeLinker);
  }

  reportPackageExtension(value) {
    this.reportValue(MetricName.EXTENSION, value);
  }

  reportWorkspaceCount(count) {
    this.reportValue(MetricName.WORKSPACE_COUNT, String(count));
  }

  reportDependencyCount(count) {
    this.reportValue(MetricName.DEPENDENCY_COUNT, String(count));
  }

  reportValue(metric, value) {
    _miscUtils__WEBPACK_IMPORTED_MODULE_1__.getSetWithDefault(this.values, metric).add(value);
  }

  reportEnumerator(metric, value) {
    _miscUtils__WEBPACK_IMPORTED_MODULE_1__.getSetWithDefault(this.enumerators, metric).add(value);
  }

  reportHit(metric, extra = `*`) {
    const ns = _miscUtils__WEBPACK_IMPORTED_MODULE_1__.getMapWithDefault(this.hits, metric);
    const current = _miscUtils__WEBPACK_IMPORTED_MODULE_1__.getFactoryWithDefault(ns, extra, () => 0);
    ns.set(extra, current + 1);
  }

  getRegistryPath() {
    const registryFile = this.configuration.get(`globalFolder`);
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(registryFile, `telemetry.json`);
  }

  sendReport(accountId) {
    var _a, _b, _c;

    const registryFile = this.getRegistryPath();
    let content;

    try {
      content = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.readJsonSync(registryFile);
    } catch (_d) {
      content = {};
    }

    const now = Date.now();
    const interval = this.configuration.get(`telemetryInterval`) * 24 * 60 * 60 * 1000;
    const lastUpdate = (_a = content.lastUpdate) !== null && _a !== void 0 ? _a : now - Math.floor(interval * Math.random());
    const nextUpdate = lastUpdate + interval;
    if (nextUpdate > now && content.lastUpdate != null) return;
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.mkdirSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(registryFile), {
      recursive: true
    });
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.writeJsonSync(registryFile, {
      lastUpdate: now
    });
    if (nextUpdate > now) return;
    if (!content.blocks) return;

    for (const [userId, block] of Object.entries((_b = content.blocks) !== null && _b !== void 0 ? _b : {})) {
      if (Object.keys(block).length === 0) continue;
      const upload = block;
      upload.userId = userId;

      for (const key of Object.keys((_c = upload.enumerators) !== null && _c !== void 0 ? _c : {})) upload.enumerators = upload.enumerators[key].length;

      const rawUrl = `https://browser-http-intake.logs.datadoghq.eu/v1/input/${accountId}?ddsource=yarn`;
      _httpUtils__WEBPACK_IMPORTED_MODULE_3__.post(rawUrl, upload, {
        configuration: this.configuration
      }).catch(() => {// Nothing we can do
      });
    }
  }

  applyChanges() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;

    const registryFile = this.getRegistryPath();
    let content;

    try {
      content = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.readJsonSync(registryFile);
    } catch (_k) {
      content = {};
    }

    const userId = (_a = this.configuration.get(`telemetryUserId`)) !== null && _a !== void 0 ? _a : `*`;
    const blocks = content.blocks = (_b = content.blocks) !== null && _b !== void 0 ? _b : {};
    const block = blocks[userId] = (_c = blocks[userId]) !== null && _c !== void 0 ? _c : {};

    for (const key of this.hits.keys()) {
      const store = block.hits = (_d = block.hits) !== null && _d !== void 0 ? _d : {};
      const ns = store[key] = (_e = store[key]) !== null && _e !== void 0 ? _e : {};

      for (const [extra, value] of this.hits.get(key)) {
        ns[extra] = ((_f = ns[extra]) !== null && _f !== void 0 ? _f : 0) + value;
      }
    }

    for (const field of [`values`, `enumerators`]) {
      for (const key of this[field].keys()) {
        const store = block[field] = (_g = block[field]) !== null && _g !== void 0 ? _g : {};
        store[key] = [...new Set([...((_h = store[key]) !== null && _h !== void 0 ? _h : []), ...((_j = this[field].get(key)) !== null && _j !== void 0 ? _j : [])])];
      }
    }

    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.mkdirSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(registryFile), {
      recursive: true
    });
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.xfs.writeJsonSync(registryFile, content);
  }

  startBuffer() {
    process.on(`exit`, () => {
      try {
        this.applyChanges();
      } catch (_a) {// Explicitly ignore errors
      }
    });
  }

}

/***/ }),
/* 273 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Method": () => /* binding */ Method,
/* harmony export */   "request": () => /* binding */ request,
/* harmony export */   "get": () => /* binding */ get,
/* harmony export */   "put": () => /* binding */ put,
/* harmony export */   "post": () => /* binding */ post
/* harmony export */ });
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(274);
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(275);
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(122);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var tunnel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(276);
/* harmony import */ var tunnel__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(tunnel__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(281);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_4__);





const cache = new Map();
const globalHttpAgent = new http__WEBPACK_IMPORTED_MODULE_1__.Agent({
  keepAlive: true
});
const globalHttpsAgent = new https__WEBPACK_IMPORTED_MODULE_0__.Agent({
  keepAlive: true
});

function parseProxy(specifier) {
  const url = new url__WEBPACK_IMPORTED_MODULE_4__.URL(specifier);
  const proxy = {
    host: url.hostname,
    headers: {}
  };
  if (url.port) proxy.port = Number(url.port);
  return {
    proxy
  };
}

var Method;

(function (Method) {
  Method["GET"] = "GET";
  Method["PUT"] = "PUT";
  Method["POST"] = "POST";
})(Method || (Method = {}));

async function request(target, body, {
  configuration,
  headers,
  json,
  method = Method.GET
}) {
  if (!configuration.get(`enableNetwork`)) throw new Error(`Network access have been disabled by configuration (${method} ${target})`);
  const url = new url__WEBPACK_IMPORTED_MODULE_4__.URL(target);
  if (url.protocol === `http:` && !micromatch__WEBPACK_IMPORTED_MODULE_2___default().isMatch(url.hostname, configuration.get(`unsafeHttpWhitelist`))) throw new Error(`Unsafe http requests must be explicitly whitelisted in your configuration (${url.hostname})`);
  const httpProxy = configuration.get(`httpProxy`);
  const httpsProxy = configuration.get(`httpsProxy`);
  const agent = {
    http: httpProxy ? tunnel__WEBPACK_IMPORTED_MODULE_3___default().httpOverHttp(parseProxy(httpProxy)) : globalHttpAgent,
    https: httpsProxy ? tunnel__WEBPACK_IMPORTED_MODULE_3___default().httpsOverHttp(parseProxy(httpsProxy)) : globalHttpsAgent
  };
  const gotOptions = {
    agent,
    headers,
    method
  };
  gotOptions.responseType = json ? `json` : `buffer`;

  if (body !== null) {
    if (typeof body === `string` || Buffer.isBuffer(body)) {
      gotOptions.body = body;
    } else {
      gotOptions.json = body;
    }
  }

  const socketTimeout = configuration.get(`httpTimeout`);
  const retry = configuration.get(`httpRetry`);
  const {
    default: got
  } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 717, 7)); //@ts-ignore

  const gotClient = got.extend({
    timeout: {
      socket: socketTimeout
    },
    retry,
    ...gotOptions
  });
  return configuration.getLimit(`networkConcurrency`)(() => {
    return gotClient(target);
  });
}
async function get(target, {
  configuration,
  json,
  ...rest
}) {
  let entry = cache.get(target);

  if (!entry) {
    entry = request(target, null, {
      configuration,
      ...rest
    }).then(response => {
      cache.set(target, response.body);
      return response.body;
    });
    cache.set(target, entry);
  }

  if (Buffer.isBuffer(entry) === false) entry = await entry;

  if (json) {
    return JSON.parse(entry.toString());
  } else {
    return entry;
  }
}
async function put(target, body, options) {
  const response = await request(target, body, { ...options,
    method: Method.PUT
  });
  return response.body;
}
async function post(target, body, options) {
  const response = await request(target, body, { ...options,
    method: Method.POST
  });
  return response.body;
}

/***/ }),
/* 274 */
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),
/* 275 */
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),
/* 276 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(277);


/***/ }),
/* 277 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var net = __webpack_require__(278);
var tls = __webpack_require__(279);
var http = __webpack_require__(275);
var https = __webpack_require__(274);
var events = __webpack_require__(170);
var assert = __webpack_require__(280);
var util = __webpack_require__(115);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),
/* 278 */
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),
/* 279 */
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),
/* 280 */
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),
/* 281 */
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),
/* 282 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeArchiveFromDirectory": () => /* binding */ makeArchiveFromDirectory,
/* harmony export */   "convertToZip": () => /* binding */ convertToZip,
/* harmony export */   "extractArchiveTo": () => /* binding */ extractArchiveTo
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(119);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(114);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var tar_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(283);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(116);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_3__);





const gunzip = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)((zlib__WEBPACK_IMPORTED_MODULE_3___default().gunzip));
async function makeArchiveFromDirectory(source, {
  baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.NodeFS(),
  prefixPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PortablePath.root,
  compressionLevel
} = {}) {
  const tmpFolder = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise();
  const tmpFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(tmpFolder, `archive.zip`);
  const zipFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ZipFS(tmpFile, {
    create: true,
    libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)(),
    level: compressionLevel
  });
  const target = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PortablePath.root, prefixPath);
  await zipFs.copyPromise(target, source, {
    baseFs,
    stableTime: true,
    stableSort: true
  });
  return zipFs;
}
async function convertToZip(tgz, opts) {
  const tmpFolder = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mktempPromise();
  const tmpFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(tmpFolder, `archive.zip`);
  const {
    compressionLevel,
    ...bufferOpts
  } = opts;
  return await extractArchiveTo(tgz, new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ZipFS(tmpFile, {
    create: true,
    libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)(),
    level: compressionLevel
  }), bufferOpts);
}
async function extractArchiveTo(tgz, targetFs, {
  stripComponents = 0,
  prefixPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.PortablePath.dot
} = {}) {
  // 1980-01-01, like Fedora
  const defaultTime = 315532800;
  const parser = tar_stream__WEBPACK_IMPORTED_MODULE_1__.extract();

  function ignore(entry) {
    // Disallow absolute paths; might be malicious (ex: /etc/passwd)
    if (entry.name[0] === `/`) return true;
    const parts = entry.name.split(/\//g); // We also ignore paths that could lead to escaping outside the archive

    if (parts.some(part => part === `..`)) return true;
    if (parts.length <= stripComponents) return true;
    return false;
  }

  parser.on(`entry`, (header, stream, next) => {
    var _a, _b;

    if (ignore(header)) {
      next();
      return;
    }

    const parts = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.normalize(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(header.name)).replace(/\/$/, ``).split(/\//g);

    if (parts.length <= stripComponents) {
      stream.resume();
      next();
      return;
    }

    const slicePath = parts.slice(stripComponents).join(`/`);
    const mappedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(prefixPath, slicePath);
    let mode = 0o644; // If a single executable bit is set, normalize so that all are

    if (header.type === `directory` || (((_a = header.mode) !== null && _a !== void 0 ? _a : 0) & 0o111) !== 0) mode |= 0o111;

    switch (header.type) {
      case `directory`:
        {
          targetFs.mkdirpSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          targetFs.mkdirSync(mappedPath);
          targetFs.chmodSync(mappedPath, mode);
          targetFs.utimesSync(mappedPath, defaultTime, defaultTime);
          next();
        }
        break;

      case `file`:
        {
          targetFs.mkdirpSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          const chunks = [];
          stream.on(`data`, chunk => chunks.push(chunk));
          stream.on(`end`, () => {
            targetFs.writeFileSync(mappedPath, Buffer.concat(chunks));
            targetFs.chmodSync(mappedPath, mode);
            targetFs.utimesSync(mappedPath, defaultTime, defaultTime);
            next();
          });
        }
        break;

      case `symlink`:
        {
          targetFs.mkdirpSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.dirname(mappedPath), {
            chmod: 0o755,
            utimes: [defaultTime, defaultTime]
          });
          targetFs.symlinkSync(header.linkname, mappedPath);
          (_b = targetFs.lutimesSync) === null || _b === void 0 ? void 0 : _b.call(targetFs, mappedPath, defaultTime, defaultTime);
          next();
        }
        break;

      default:
        {
          stream.resume();
          next();
        }
    }
  });
  const gunzipped = await gunzip(tgz);
  return await new Promise((resolve, reject) => {
    parser.on(`error`, error => {
      reject(error);
    });
    parser.on(`finish`, () => {
      resolve(targetFs);
    });
    parser.end(gunzipped);
  });
}

/***/ }),
/* 283 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.extract = __webpack_require__(284)
exports.pack = __webpack_require__(307)


/***/ }),
/* 284 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(115)
var bl = __webpack_require__(285)
var headers = __webpack_require__(306)

var Writable = __webpack_require__(286).Writable
var PassThrough = __webpack_require__(286).PassThrough

var noop = function () {}

var overflow = function (size) {
  size &= 511
  return size && 512 - size
}

var emptyStream = function (self, offset) {
  var s = new Source(self, offset)
  s.end()
  return s
}

var mixinPax = function (header, pax) {
  if (pax.path) header.name = pax.path
  if (pax.linkpath) header.linkname = pax.linkpath
  if (pax.size) header.size = parseInt(pax.size, 10)
  header.pax = pax
  return header
}

var Source = function (self, offset) {
  this._parent = self
  this.offset = offset
  PassThrough.call(this)
}

util.inherits(Source, PassThrough)

Source.prototype.destroy = function (err) {
  this._parent.destroy(err)
}

var Extract = function (opts) {
  if (!(this instanceof Extract)) return new Extract(opts)
  Writable.call(this, opts)

  opts = opts || {}

  this._offset = 0
  this._buffer = bl()
  this._missing = 0
  this._partial = false
  this._onparse = noop
  this._header = null
  this._stream = null
  this._overflow = null
  this._cb = null
  this._locked = false
  this._destroyed = false
  this._pax = null
  this._paxGlobal = null
  this._gnuLongPath = null
  this._gnuLongLinkPath = null

  var self = this
  var b = self._buffer

  var oncontinue = function () {
    self._continue()
  }

  var onunlock = function (err) {
    self._locked = false
    if (err) return self.destroy(err)
    if (!self._stream) oncontinue()
  }

  var onstreamend = function () {
    self._stream = null
    var drain = overflow(self._header.size)
    if (drain) self._parse(drain, ondrain)
    else self._parse(512, onheader)
    if (!self._locked) oncontinue()
  }

  var ondrain = function () {
    self._buffer.consume(overflow(self._header.size))
    self._parse(512, onheader)
    oncontinue()
  }

  var onpaxglobalheader = function () {
    var size = self._header.size
    self._paxGlobal = headers.decodePax(b.slice(0, size))
    b.consume(size)
    onstreamend()
  }

  var onpaxheader = function () {
    var size = self._header.size
    self._pax = headers.decodePax(b.slice(0, size))
    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax)
    b.consume(size)
    onstreamend()
  }

  var ongnulongpath = function () {
    var size = self._header.size
    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var ongnulonglinkpath = function () {
    var size = self._header.size
    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var onheader = function () {
    var offset = self._offset
    var header
    try {
      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding)
    } catch (err) {
      self.emit('error', err)
    }
    b.consume(512)

    if (!header) {
      self._parse(512, onheader)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-path') {
      self._parse(header.size, ongnulongpath)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-link-path') {
      self._parse(header.size, ongnulonglinkpath)
      oncontinue()
      return
    }
    if (header.type === 'pax-global-header') {
      self._parse(header.size, onpaxglobalheader)
      oncontinue()
      return
    }
    if (header.type === 'pax-header') {
      self._parse(header.size, onpaxheader)
      oncontinue()
      return
    }

    if (self._gnuLongPath) {
      header.name = self._gnuLongPath
      self._gnuLongPath = null
    }

    if (self._gnuLongLinkPath) {
      header.linkname = self._gnuLongLinkPath
      self._gnuLongLinkPath = null
    }

    if (self._pax) {
      self._header = header = mixinPax(header, self._pax)
      self._pax = null
    }

    self._locked = true

    if (!header.size || header.type === 'directory') {
      self._parse(512, onheader)
      self.emit('entry', header, emptyStream(self, offset), onunlock)
      return
    }

    self._stream = new Source(self, offset)

    self.emit('entry', header, self._stream, onunlock)
    self._parse(header.size, onstreamend)
    oncontinue()
  }

  this._onheader = onheader
  this._parse(512, onheader)
}

util.inherits(Extract, Writable)

Extract.prototype.destroy = function (err) {
  if (this._destroyed) return
  this._destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
  if (this._stream) this._stream.emit('close')
}

Extract.prototype._parse = function (size, onparse) {
  if (this._destroyed) return
  this._offset += size
  this._missing = size
  if (onparse === this._onheader) this._partial = false
  this._onparse = onparse
}

Extract.prototype._continue = function () {
  if (this._destroyed) return
  var cb = this._cb
  this._cb = noop
  if (this._overflow) this._write(this._overflow, undefined, cb)
  else cb()
}

Extract.prototype._write = function (data, enc, cb) {
  if (this._destroyed) return

  var s = this._stream
  var b = this._buffer
  var missing = this._missing
  if (data.length) this._partial = true

  // we do not reach end-of-chunk now. just forward it

  if (data.length < missing) {
    this._missing -= data.length
    this._overflow = null
    if (s) return s.write(data, cb)
    b.append(data)
    return cb()
  }

  // end-of-chunk. the parser should call cb.

  this._cb = cb
  this._missing = 0

  var overflow = null
  if (data.length > missing) {
    overflow = data.slice(missing)
    data = data.slice(0, missing)
  }

  if (s) s.end(data)
  else b.append(data)

  this._overflow = overflow
  this._onparse()
}

Extract.prototype._final = function (cb) {
  if (this._partial) return this.destroy(new Error('Unexpected end of data'))
  cb()
}

module.exports = Extract


/***/ }),
/* 285 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DuplexStream = __webpack_require__(286).Duplex
  , util         = __webpack_require__(115)

function BufferList (callback) {
  if (!(this instanceof BufferList))
    return new BufferList(callback)

  this._bufs  = []
  this.length = 0

  if (typeof callback == 'function') {
    this._callback = callback

    var piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function onPipe (src) {
      src.on('error', piper)
    })
    this.on('unpipe', function onUnpipe (src) {
      src.removeListener('error', piper)
    })
  } else {
    this.append(callback)
  }

  DuplexStream.call(this)
}


util.inherits(BufferList, DuplexStream)


BufferList.prototype._offset = function _offset (offset) {
  var tot = 0, i = 0, _t
  if (offset === 0) return [ 0, 0 ]
  for (; i < this._bufs.length; i++) {
    _t = tot + this._bufs[i].length
    if (offset < _t || i == this._bufs.length - 1) {
      return [ i, offset - tot ]
    }
    tot = _t
  }
}

BufferList.prototype._reverseOffset = function (blOffset) {
  var bufferId = blOffset[0]
  var offset = blOffset[1]
  for (var i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length
  }
  return offset
}

BufferList.prototype.append = function append (buf) {
  var i = 0

  if (Buffer.isBuffer(buf)) {
    this._appendBuffer(buf)
  } else if (Array.isArray(buf)) {
    for (; i < buf.length; i++)
      this.append(buf[i])
  } else if (buf instanceof BufferList) {
    // unwrap argument into individual BufferLists
    for (; i < buf._bufs.length; i++)
      this.append(buf._bufs[i])
  } else if (buf != null) {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf == 'number')
      buf = buf.toString()

    this._appendBuffer(Buffer.from(buf))
  }

  return this
}


BufferList.prototype._appendBuffer = function appendBuffer (buf) {
  this._bufs.push(buf)
  this.length += buf.length
}


BufferList.prototype._write = function _write (buf, encoding, callback) {
  this._appendBuffer(buf)

  if (typeof callback == 'function')
    callback()
}


BufferList.prototype._read = function _read (size) {
  if (!this.length)
    return this.push(null)

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}


BufferList.prototype.end = function end (chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}


BufferList.prototype.get = function get (index) {
  if (index > this.length || index < 0) {
    return undefined
  }
  var offset = this._offset(index)
  return this._bufs[offset[0]][offset[1]]
}


BufferList.prototype.slice = function slice (start, end) {
  if (typeof start == 'number' && start < 0)
    start += this.length
  if (typeof end == 'number' && end < 0)
    end += this.length
  return this.copy(null, 0, start, end)
}


BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart != 'number' || srcStart < 0)
    srcStart = 0
  if (typeof srcEnd != 'number' || srcEnd > this.length)
    srcEnd = this.length
  if (srcStart >= this.length)
    return dst || Buffer.alloc(0)
  if (srcEnd <= 0)
    return dst || Buffer.alloc(0)

  var copy   = !!dst
    , off    = this._offset(srcStart)
    , len    = srcEnd - srcStart
    , bytes  = len
    , bufoff = (copy && dstStart) || 0
    , start  = off[1]
    , l
    , i

  // copy/slice everything
  if (srcStart === 0 && srcEnd == this.length) {
    if (!copy) { // slice, but full concat if multiple buffers
      return this._bufs.length === 1
        ? this._bufs[0]
        : Buffer.concat(this._bufs, this.length)
    }

    // copy, need to copy individual buffers
    for (i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) // a slice, we need something to copy in to
    dst = Buffer.allocUnsafe(len)

  for (i = off[0]; i < this._bufs.length; i++) {
    l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      break
    }

    bufoff += l
    bytes -= l

    if (start)
      start = 0
  }

  return dst
}

BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
  start = start || 0
  end = typeof end !== 'number' ? this.length : end

  if (start < 0)
    start += this.length
  if (end < 0)
    end += this.length

  if (start === end) {
    return new BufferList()
  }
  var startOffset = this._offset(start)
    , endOffset = this._offset(end)
    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  if (endOffset[1] == 0)
    buffers.pop()
  else
    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1])

  if (startOffset[1] != 0)
    buffers[0] = buffers[0].slice(startOffset[1])

  return new BufferList(buffers)
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }
  return this
}


BufferList.prototype.duplicate = function duplicate () {
  var i = 0
    , copy = new BufferList()

  for (; i < this._bufs.length; i++)
    copy.append(this._bufs[i])

  return copy
}


BufferList.prototype._destroy = function _destroy (err, cb) {
  this._bufs.length = 0
  this.length = 0
  cb(err)
}


BufferList.prototype.indexOf = function (search, offset, encoding) {
  if (encoding === undefined && typeof offset === 'string') {
    encoding = offset
    offset = undefined
  }
  if (typeof search === 'function' || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
  } else if (typeof search === 'number') {
      search = Buffer.from([search])
  } else if (typeof search === 'string') {
    search = Buffer.from(search, encoding)
  } else if (search instanceof BufferList) {
    search = search.slice()
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search)
  }

  offset = Number(offset || 0)
  if (isNaN(offset)) {
    offset = 0
  }

  if (offset < 0) {
    offset = this.length + offset
  }

  if (offset < 0) {
    offset = 0
  }

  if (search.length === 0) {
    return offset > this.length ? this.length : offset
  }

  var blOffset = this._offset(offset)
  var blIndex = blOffset[0] // index of which internal buffer we're working on
  var buffOffset = blOffset[1] // offset of the internal buffer we're working on

  // scan over each buffer
  for (blIndex; blIndex < this._bufs.length; blIndex++) {
    var buff = this._bufs[blIndex]
    while(buffOffset < buff.length) {
      var availableWindow = buff.length - buffOffset
      if (availableWindow >= search.length) {
        var nativeSearchResult = buff.indexOf(search, buffOffset)
        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult])
        }
        buffOffset = buff.length - search.length + 1 // end of native search window
      } else {
        var revOffset = this._reverseOffset([blIndex, buffOffset])
        if (this._match(revOffset, search)) {
          return revOffset
        }
        buffOffset++
      }
    }
    buffOffset = 0
  }
  return -1
}

BufferList.prototype._match = function(offset, search) {
  if (this.length - offset < search.length) {
    return false
  }
  for (var searchOffset = 0; searchOffset < search.length ; searchOffset++) {
    if(this.get(offset + searchOffset) !== search[searchOffset]){
      return false
    }
  }
  return true
}


;(function () {
  var methods = {
      'readDoubleBE' : 8
    , 'readDoubleLE' : 8
    , 'readFloatBE'  : 4
    , 'readFloatLE'  : 4
    , 'readInt32BE'  : 4
    , 'readInt32LE'  : 4
    , 'readUInt32BE' : 4
    , 'readUInt32LE' : 4
    , 'readInt16BE'  : 2
    , 'readInt16LE'  : 2
    , 'readUInt16BE' : 2
    , 'readUInt16LE' : 2
    , 'readInt8'     : 1
    , 'readUInt8'    : 1
    , 'readIntBE'    : null
    , 'readIntLE'    : null
    , 'readUIntBE'   : null
    , 'readUIntLE'   : null
  }

  for (var m in methods) {
    (function (m) {
      if (methods[m] === null) {
        BufferList.prototype[m] = function (offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m](0, byteLength)
        }
      }
      else {
        BufferList.prototype[m] = function (offset) {
          return this.slice(offset, offset + methods[m])[m](0)
        }
      }
    }(m))
  }
}())


module.exports = BufferList


/***/ }),
/* 286 */
/***/ ((module, exports, __webpack_require__) => {

var Stream = __webpack_require__(110);
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream.Readable;
  Object.assign(module.exports, Stream);
  module.exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__(287);
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__(297);
  exports.Duplex = __webpack_require__(296);
  exports.Transform = __webpack_require__(303);
  exports.PassThrough = __webpack_require__(304);
  exports.finished = __webpack_require__(302);
  exports.pipeline = __webpack_require__(305);
}


/***/ }),
/* 287 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(170).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(288);
/*</replacement>*/


var Buffer = __webpack_require__(40).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(115);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(289);

var destroyImpl = __webpack_require__(290);

var _require = __webpack_require__(291),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __webpack_require__(292).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

var _require2 = __webpack_require__(293),
    emitExperimentalWarning = _require2.emitExperimentalWarning; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;

__webpack_require__(294)(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(296);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(299).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(296);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(299).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc); // if setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    emitExperimentalWarning('Readable[Symbol.asyncIterator]');

    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(301);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),
/* 288 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(110);


/***/ }),
/* 289 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = __webpack_require__(40),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(115),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  var _proto = BufferList.prototype;

  _proto.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  _proto.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  _proto.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  _proto.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  _proto.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  _proto.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  } // Consumes a specified amount of bytes or characters from the buffered data.
  ;

  _proto.consume = function consume(n, hasStrings) {
    var ret;

    if (n < this.head.data.length) {
      // `slice` is the same for buffers and strings.
      ret = this.head.data.slice(0, n);
      this.head.data = this.head.data.slice(n);
    } else if (n === this.head.data.length) {
      // First chunk is a perfect match.
      ret = this.shift();
    } else {
      // Result spans more than one buffer.
      ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    }

    return ret;
  };

  _proto.first = function first() {
    return this.head.data;
  } // Consumes a specified amount of characters from the buffered data.
  ;

  _proto._getString = function _getString(n) {
    var p = this.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;

    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;

      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = str.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Consumes a specified amount of bytes from the buffered data.
  ;

  _proto._getBuffer = function _getBuffer(n) {
    var ret = Buffer.allocUnsafe(n);
    var p = this.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;

    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;

      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = buf.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Make sure the linked list only shows the minimal necessary information.
  ;

  _proto[custom] = function (_, options) {
    return inspect(this, _objectSpread({}, options, {
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    }));
  };

  return BufferList;
}();

/***/ }),
/* 290 */
/***/ ((module) => {

"use strict";
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      process.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      process.nextTick(emitErrorAndCloseNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 291 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = __webpack_require__(292).codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),
/* 292 */
/***/ ((module) => {

"use strict";


const codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error
  }

  function getMessage (arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message
    } else {
      return message(arg1, arg2, arg3)
    }
  }

  class NodeError extends Base {
    constructor (arg1, arg2, arg3) {
      super(getMessage(arg1, arg2, arg3));
    }
  }

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;

  codes[code] = NodeError;
}

// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    const len = expected.length;
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
             expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
	return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
	if (this_len === undefined || this_len > str.length) {
		this_len = str.length;
	}
	return str.substring(this_len - search.length, this_len) === search;
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"'
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = includes(name, '.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented'
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

module.exports.codes = codes;


/***/ }),
/* 293 */
/***/ ((module) => {

"use strict";


var experimentalWarnings = new Set();

function emitExperimentalWarning(feature) {
  if (experimentalWarnings.has(feature)) return;
  var msg = feature + ' is an experimental feature. This feature could ' +
       'change at any time';
  experimentalWarnings.add(feature);
  process.emitWarning(msg, 'ExperimentalWarning');
}

function noop() {}

module.exports.emitExperimentalWarning = process.emitWarning
  ? emitExperimentalWarning
  : noop;


/***/ }),
/* 294 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(115);
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  module.exports = __webpack_require__(295);
}


/***/ }),
/* 295 */
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 296 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(287);

var Writable = __webpack_require__(297);

__webpack_require__(294)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),
/* 297 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(298)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(288);
/*</replacement>*/


var Buffer = __webpack_require__(40).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(290);

var _require = __webpack_require__(291),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = __webpack_require__(292).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

__webpack_require__(294)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(296);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(296); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    stream.emit('error', er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),
/* 298 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __webpack_require__(115).deprecate;


/***/ }),
/* 299 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(300).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 300 */
/***/ ((module, exports, __webpack_require__) => {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(40)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 301 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __webpack_require__(302);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(null, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(null, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(null, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kLastPromise, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(null, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),
/* 302 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(292).codes.ERR_STREAM_PREMATURE_CLOSE;

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function once(callback) {
  var called = false;
  return function (err) {
    if (called) return;
    called = true;
    callback.call(this, err);
  };
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var ws = stream._writableState;
  var rs = stream._readableState;
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var onfinish = function onfinish() {
    writable = false;
    if (!readable) callback.call(stream);
  };

  var onend = function onend() {
    readable = false;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    if (readable && !(rs && rs.ended)) {
      return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
    }

    if (writable && !(ws && ws.ended)) {
      return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !ws) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),
/* 303 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = __webpack_require__(292).codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(296);

__webpack_require__(294)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),
/* 304 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(303);

__webpack_require__(294)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 305 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = __webpack_require__(292).codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(302);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),
/* 306 */
/***/ ((__unused_webpack_module, exports) => {

var alloc = Buffer.alloc

var ZEROS = '0000000000000000000'
var SEVENS = '7777777777777777777'
var ZERO_OFFSET = '0'.charCodeAt(0)
var USTAR = 'ustar\x0000'
var MASK = parseInt('7777', 8)

var clamp = function (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

var toType = function (flag) {
  switch (flag) {
    case 0:
      return 'file'
    case 1:
      return 'link'
    case 2:
      return 'symlink'
    case 3:
      return 'character-device'
    case 4:
      return 'block-device'
    case 5:
      return 'directory'
    case 6:
      return 'fifo'
    case 7:
      return 'contiguous-file'
    case 72:
      return 'pax-header'
    case 55:
      return 'pax-global-header'
    case 27:
      return 'gnu-long-link-path'
    case 28:
    case 30:
      return 'gnu-long-path'
  }

  return null
}

var toTypeflag = function (flag) {
  switch (flag) {
    case 'file':
      return 0
    case 'link':
      return 1
    case 'symlink':
      return 2
    case 'character-device':
      return 3
    case 'block-device':
      return 4
    case 'directory':
      return 5
    case 'fifo':
      return 6
    case 'contiguous-file':
      return 7
    case 'pax-header':
      return 72
  }

  return 0
}

var indexOf = function (block, num, offset, end) {
  for (; offset < end; offset++) {
    if (block[offset] === num) return offset
  }
  return end
}

var cksum = function (block) {
  var sum = 8 * 32
  for (var i = 0; i < 148; i++) sum += block[i]
  for (var j = 156; j < 512; j++) sum += block[j]
  return sum
}

var encodeOct = function (val, n) {
  val = val.toString(8)
  if (val.length > n) return SEVENS.slice(0, n) + ' '
  else return ZEROS.slice(0, n - val.length) + val + ' '
}

/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */
function parse256 (buf) {
  // first byte MUST be either 80 or FF
  // 80 for positive, FF for 2's comp
  var positive
  if (buf[0] === 0x80) positive = true
  else if (buf[0] === 0xFF) positive = false
  else return null

  // build up a base-256 tuple from the least sig to the highest
  var zero = false
  var tuple = []
  for (var i = buf.length - 1; i > 0; i--) {
    var byte = buf[i]
    if (positive) tuple.push(byte)
    else if (zero && byte === 0) tuple.push(0)
    else if (zero) {
      zero = false
      tuple.push(0x100 - byte)
    } else tuple.push(0xFF - byte)
  }

  var sum = 0
  var l = tuple.length
  for (i = 0; i < l; i++) {
    sum += tuple[i] * Math.pow(256, i)
  }

  return positive ? sum : -1 * sum
}

var decodeOct = function (val, offset, length) {
  val = val.slice(offset, offset + length)
  offset = 0

  // If prefixed with 0x80 then parse as a base-256 integer
  if (val[offset] & 0x80) {
    return parse256(val)
  } else {
    // Older versions of tar can prefix with spaces
    while (offset < val.length && val[offset] === 32) offset++
    var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)
    while (offset < end && val[offset] === 0) offset++
    if (end === offset) return 0
    return parseInt(val.slice(offset, end).toString(), 8)
  }
}

var decodeStr = function (val, offset, length, encoding) {
  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding)
}

var addLength = function (str) {
  var len = Buffer.byteLength(str)
  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1
  if (len + digits >= Math.pow(10, digits)) digits++

  return (len + digits) + str
}

exports.decodeLongPath = function (buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding)
}

exports.encodePax = function (opts) { // TODO: encode more stuff in pax
  var result = ''
  if (opts.name) result += addLength(' path=' + opts.name + '\n')
  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n')
  var pax = opts.pax
  if (pax) {
    for (var key in pax) {
      result += addLength(' ' + key + '=' + pax[key] + '\n')
    }
  }
  return Buffer.from(result)
}

exports.decodePax = function (buf) {
  var result = {}

  while (buf.length) {
    var i = 0
    while (i < buf.length && buf[i] !== 32) i++
    var len = parseInt(buf.slice(0, i).toString(), 10)
    if (!len) return result

    var b = buf.slice(i + 1, len - 1).toString()
    var keyIndex = b.indexOf('=')
    if (keyIndex === -1) return result
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)

    buf = buf.slice(len)
  }

  return result
}

exports.encode = function (opts) {
  var buf = alloc(512)
  var name = opts.name
  var prefix = ''

  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'
  if (Buffer.byteLength(name) !== name.length) return null // utf-8

  while (Buffer.byteLength(name) > 100) {
    var i = name.indexOf('/')
    if (i === -1) return null
    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)
    name = name.slice(i + 1)
  }

  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null
  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null

  buf.write(name)
  buf.write(encodeOct(opts.mode & MASK, 6), 100)
  buf.write(encodeOct(opts.uid, 6), 108)
  buf.write(encodeOct(opts.gid, 6), 116)
  buf.write(encodeOct(opts.size, 11), 124)
  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)

  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)

  if (opts.linkname) buf.write(opts.linkname, 157)

  buf.write(USTAR, 257)
  if (opts.uname) buf.write(opts.uname, 265)
  if (opts.gname) buf.write(opts.gname, 297)
  buf.write(encodeOct(opts.devmajor || 0, 6), 329)
  buf.write(encodeOct(opts.devminor || 0, 6), 337)

  if (prefix) buf.write(prefix, 345)

  buf.write(encodeOct(cksum(buf), 6), 148)

  return buf
}

exports.decode = function (buf, filenameEncoding) {
  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET

  var name = decodeStr(buf, 0, 100, filenameEncoding)
  var mode = decodeOct(buf, 100, 8)
  var uid = decodeOct(buf, 108, 8)
  var gid = decodeOct(buf, 116, 8)
  var size = decodeOct(buf, 124, 12)
  var mtime = decodeOct(buf, 136, 12)
  var type = toType(typeflag)
  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)
  var uname = decodeStr(buf, 265, 32)
  var gname = decodeStr(buf, 297, 32)
  var devmajor = decodeOct(buf, 329, 8)
  var devminor = decodeOct(buf, 337, 8)

  if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name

  // to support old tar versions that use trailing / to indicate dirs
  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5

  var c = cksum(buf)

  // checksum is still initial value if header was null.
  if (c === 8 * 32) return null

  // valid checksum
  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')

  return {
    name: name,
    mode: mode,
    uid: uid,
    gid: gid,
    size: size,
    mtime: new Date(1000 * mtime),
    type: type,
    linkname: linkname,
    uname: uname,
    gname: gname,
    devmajor: devmajor,
    devminor: devminor
  }
}


/***/ }),
/* 307 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constants = __webpack_require__(308)
var eos = __webpack_require__(310)
var inherits = __webpack_require__(294)
var alloc = Buffer.alloc

var Readable = __webpack_require__(286).Readable
var Writable = __webpack_require__(286).Writable
var StringDecoder = __webpack_require__(227).StringDecoder

var headers = __webpack_require__(306)

var DMODE = parseInt('755', 8)
var FMODE = parseInt('644', 8)

var END_OF_TAR = alloc(1024)

var noop = function () {}

var overflow = function (self, size) {
  size &= 511
  if (size) self.push(END_OF_TAR.slice(0, 512 - size))
}

function modeToType (mode) {
  switch (mode & constants.S_IFMT) {
    case constants.S_IFBLK: return 'block-device'
    case constants.S_IFCHR: return 'character-device'
    case constants.S_IFDIR: return 'directory'
    case constants.S_IFIFO: return 'fifo'
    case constants.S_IFLNK: return 'symlink'
  }

  return 'file'
}

var Sink = function (to) {
  Writable.call(this)
  this.written = 0
  this._to = to
  this._destroyed = false
}

inherits(Sink, Writable)

Sink.prototype._write = function (data, enc, cb) {
  this.written += data.length
  if (this._to.push(data)) return cb()
  this._to._drain = cb
}

Sink.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var LinkSink = function () {
  Writable.call(this)
  this.linkname = ''
  this._decoder = new StringDecoder('utf-8')
  this._destroyed = false
}

inherits(LinkSink, Writable)

LinkSink.prototype._write = function (data, enc, cb) {
  this.linkname += this._decoder.write(data)
  cb()
}

LinkSink.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Void = function () {
  Writable.call(this)
  this._destroyed = false
}

inherits(Void, Writable)

Void.prototype._write = function (data, enc, cb) {
  cb(new Error('No body allowed for this entry'))
}

Void.prototype.destroy = function () {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Pack = function (opts) {
  if (!(this instanceof Pack)) return new Pack(opts)
  Readable.call(this, opts)

  this._drain = noop
  this._finalized = false
  this._finalizing = false
  this._destroyed = false
  this._stream = null
}

inherits(Pack, Readable)

Pack.prototype.entry = function (header, buffer, callback) {
  if (this._stream) throw new Error('already piping an entry')
  if (this._finalized || this._destroyed) return

  if (typeof buffer === 'function') {
    callback = buffer
    buffer = null
  }

  if (!callback) callback = noop

  var self = this

  if (!header.size || header.type === 'symlink') header.size = 0
  if (!header.type) header.type = modeToType(header.mode)
  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE
  if (!header.uid) header.uid = 0
  if (!header.gid) header.gid = 0
  if (!header.mtime) header.mtime = new Date()

  if (typeof buffer === 'string') buffer = Buffer.from(buffer)
  if (Buffer.isBuffer(buffer)) {
    header.size = buffer.length
    this._encode(header)
    this.push(buffer)
    overflow(self, header.size)
    process.nextTick(callback)
    return new Void()
  }

  if (header.type === 'symlink' && !header.linkname) {
    var linkSink = new LinkSink()
    eos(linkSink, function (err) {
      if (err) { // stream was closed
        self.destroy()
        return callback(err)
      }

      header.linkname = linkSink.linkname
      self._encode(header)
      callback()
    })

    return linkSink
  }

  this._encode(header)

  if (header.type !== 'file' && header.type !== 'contiguous-file') {
    process.nextTick(callback)
    return new Void()
  }

  var sink = new Sink(this)

  this._stream = sink

  eos(sink, function (err) {
    self._stream = null

    if (err) { // stream was closed
      self.destroy()
      return callback(err)
    }

    if (sink.written !== header.size) { // corrupting tar
      self.destroy()
      return callback(new Error('size mismatch'))
    }

    overflow(self, header.size)
    if (self._finalizing) self.finalize()
    callback()
  })

  return sink
}

Pack.prototype.finalize = function () {
  if (this._stream) {
    this._finalizing = true
    return
  }

  if (this._finalized) return
  this._finalized = true
  this.push(END_OF_TAR)
  this.push(null)
}

Pack.prototype.destroy = function (err) {
  if (this._destroyed) return
  this._destroyed = true

  if (err) this.emit('error', err)
  this.emit('close')
  if (this._stream && this._stream.destroy) this._stream.destroy()
}

Pack.prototype._encode = function (header) {
  if (!header.pax) {
    var buf = headers.encode(header)
    if (buf) {
      this.push(buf)
      return
    }
  }
  this._encodePax(header)
}

Pack.prototype._encodePax = function (header) {
  var paxHeader = headers.encodePax({
    name: header.name,
    linkname: header.linkname,
    pax: header.pax
  })

  var newHeader = {
    name: 'PaxHeader',
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: 'pax-header',
    linkname: header.linkname && 'PaxHeader',
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  }

  this.push(headers.encode(newHeader))
  this.push(paxHeader)
  overflow(this, paxHeader.length)

  newHeader.size = header.size
  newHeader.type = header.type
  this.push(headers.encode(newHeader))
}

Pack.prototype._read = function (n) {
  var drain = this._drain
  this._drain = noop
  drain()
}

module.exports = Pack


/***/ }),
/* 308 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(6).constants || __webpack_require__(309)


/***/ }),
/* 309 */
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),
/* 310 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(311);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),
/* 311 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(312)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),
/* 312 */
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),
/* 313 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.getPluginConfiguration = () => ({
  modules: new Map([
    ["@yarnpkg/cli", __webpack_require__(314)],
    ["@yarnpkg/core", __webpack_require__(232)],
    ["@yarnpkg/fslib", __webpack_require__(206)],
    ["@yarnpkg/libzip", __webpack_require__(234)],
    ["@yarnpkg/parsers", __webpack_require__(12)],
    ["@yarnpkg/shell", __webpack_require__(255)],
    ["clipanion", __webpack_require__(5)],
    ["semver", __webpack_require__(67)],
    ["yup", __webpack_require__(319)],
    ["@yarnpkg/plugin-essentials", __webpack_require__(532)],
    ["@yarnpkg/plugin-compat", __webpack_require__(614)],
    ["@yarnpkg/plugin-dlx", __webpack_require__(619)],
    ["@yarnpkg/plugin-file", __webpack_require__(622)],
    ["@yarnpkg/plugin-git", __webpack_require__(628)],
    ["@yarnpkg/plugin-github", __webpack_require__(632)],
    ["@yarnpkg/plugin-http", __webpack_require__(635)],
    ["@yarnpkg/plugin-init", __webpack_require__(639)],
    ["@yarnpkg/plugin-link", __webpack_require__(658)],
    ["@yarnpkg/plugin-node-modules", __webpack_require__(664)],
    ["@yarnpkg/plugin-npm", __webpack_require__(689)],
    ["@yarnpkg/plugin-npm-cli", __webpack_require__(698)],
    ["@yarnpkg/plugin-pack", __webpack_require__(703)],
    ["@yarnpkg/plugin-patch", __webpack_require__(709)],
    ["@yarnpkg/plugin-pnp", __webpack_require__(666)],

  ]),
  plugins: new Set([
    "@yarnpkg/plugin-essentials",
    "@yarnpkg/plugin-compat",
    "@yarnpkg/plugin-dlx",
    "@yarnpkg/plugin-file",
    "@yarnpkg/plugin-git",
    "@yarnpkg/plugin-github",
    "@yarnpkg/plugin-http",
    "@yarnpkg/plugin-init",
    "@yarnpkg/plugin-link",
    "@yarnpkg/plugin-node-modules",
    "@yarnpkg/plugin-npm",
    "@yarnpkg/plugin-npm-cli",
    "@yarnpkg/plugin-pack",
    "@yarnpkg/plugin-patch",
    "@yarnpkg/plugin-pnp",

  ]),
});


/***/ }),
/* 314 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseCommand": () => /* reexport safe */ _tools_BaseCommand__WEBPACK_IMPORTED_MODULE_0__.BaseCommand,
/* harmony export */   "WorkspaceRequiredError": () => /* reexport safe */ _tools_WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_1__.WorkspaceRequiredError,
/* harmony export */   "getDynamicLibs": () => /* reexport safe */ _tools_getDynamicLibs__WEBPACK_IMPORTED_MODULE_2__.getDynamicLibs,
/* harmony export */   "getPluginConfiguration": () => /* reexport safe */ _tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_3__.getPluginConfiguration,
/* harmony export */   "openWorkspace": () => /* reexport safe */ _tools_openWorkspace__WEBPACK_IMPORTED_MODULE_4__.openWorkspace,
/* harmony export */   "main": () => /* reexport safe */ _main__WEBPACK_IMPORTED_MODULE_5__.main,
/* harmony export */   "pluginCommands": () => /* reexport safe */ _pluginCommands__WEBPACK_IMPORTED_MODULE_6__.pluginCommands
/* harmony export */ });
/* harmony import */ var _tools_BaseCommand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _tools_WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(315);
/* harmony import */ var _tools_getDynamicLibs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(316);
/* harmony import */ var _tools_getPluginConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(313);
/* harmony import */ var _tools_openWorkspace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(318);
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);
/* harmony import */ var _pluginCommands__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7);








/***/ }),
/* 315 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkspaceRequiredError": () => /* binding */ WorkspaceRequiredError
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);



class WorkspaceRequiredError extends clipanion__WEBPACK_IMPORTED_MODULE_0__.UsageError {
  constructor(projectCwd, cwd) {
    const relativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.relative(projectCwd, cwd);
    const manifestPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.join(projectCwd, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Manifest.fileName);
    super(`This command can only be run from within a workspace of your project (${relativePath} isn't a workspace of ${manifestPath}).`);
  }

}

/***/ }),
/* 316 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDynamicLibs": () => /* binding */ getDynamicLibs
/* harmony export */ });
const DYNAMIC_LIBS = [`@yarnpkg/cli`, `@yarnpkg/core`, `@yarnpkg/fslib`, `@yarnpkg/libzip`, `@yarnpkg/parsers`, `@yarnpkg/shell`, // Those ones are always useful
`clipanion`, `semver`, `yup`];
const getDynamicLibs = () => {
  return new Map(DYNAMIC_LIBS.map(name => {
    return [name, __webpack_require__(317)(name)];
  }));
};

/***/ }),
/* 317 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => [];
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 317;
module.exports = webpackEmptyContext;

/***/ }),
/* 318 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "openWorkspace": () => /* binding */ openWorkspace
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(242);
/* harmony import */ var _WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(315);


async function openWorkspace(configuration, cwd) {
  const {
    project,
    workspace
  } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.Project.find(configuration, cwd);
  if (!workspace) throw new _WorkspaceRequiredError__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, cwd);
  return workspace;
}

/***/ }),
/* 319 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.addMethod = addMethod;
exports.lazy = exports.ref = exports.boolean = void 0;

var _mixed = _interopRequireDefault(__webpack_require__(321));

exports.mixed = _mixed.default;

var _boolean = _interopRequireDefault(__webpack_require__(497));

exports.bool = _boolean.default;

var _string = _interopRequireDefault(__webpack_require__(499));

exports.string = _string.default;

var _number = _interopRequireDefault(__webpack_require__(501));

exports.number = _number.default;

var _date = _interopRequireDefault(__webpack_require__(502));

exports.date = _date.default;

var _object = _interopRequireDefault(__webpack_require__(504));

exports.object = _object.default;

var _array = _interopRequireDefault(__webpack_require__(529));

exports.array = _array.default;

var _Reference = _interopRequireDefault(__webpack_require__(494));

var _Lazy = _interopRequireDefault(__webpack_require__(530));

var _ValidationError = _interopRequireDefault(__webpack_require__(462));

exports.ValidationError = _ValidationError.default;

var _reach = _interopRequireDefault(__webpack_require__(496));

exports.reach = _reach.default;

var _isSchema = _interopRequireDefault(__webpack_require__(458));

exports.isSchema = _isSchema.default;

var _setLocale = _interopRequireDefault(__webpack_require__(531));

exports.setLocale = _setLocale.default;
var boolean = _boolean.default;
exports.boolean = boolean;

var ref = function ref(key, options) {
  return new _Reference.default(key, options);
};

exports.ref = ref;

var lazy = function lazy(fn) {
  return new _Lazy.default(fn);
};

exports.lazy = lazy;

function addMethod(schemaType, name, fn) {
  if (!schemaType || !(0, _isSchema.default)(schemaType.prototype)) throw new TypeError('You must provide a yup schema constructor function');
  if (typeof name !== 'string') throw new TypeError('A Method name must be provided');
  if (typeof fn !== 'function') throw new TypeError('Method function must be provided');
  schemaType.prototype[name] = fn;
}

/***/ }),
/* 320 */
/***/ ((module) => {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 321 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = SchemaType;

var _extends2 = _interopRequireDefault(__webpack_require__(322));

var _has = _interopRequireDefault(__webpack_require__(323));

var _cloneDeepWith = _interopRequireDefault(__webpack_require__(380));

var _toArray2 = _interopRequireDefault(__webpack_require__(444));

var _locale = __webpack_require__(455);

var _Condition = _interopRequireDefault(__webpack_require__(457));

var _runValidations = _interopRequireDefault(__webpack_require__(459));

var _prependDeep = _interopRequireDefault(__webpack_require__(463));

var _isSchema = _interopRequireDefault(__webpack_require__(458));

var _createValidation = _interopRequireDefault(__webpack_require__(464));

var _printValue = _interopRequireDefault(__webpack_require__(456));

var _Reference = _interopRequireDefault(__webpack_require__(494));

var _reach = __webpack_require__(496);

var RefSet =
/*#__PURE__*/
function () {
  function RefSet() {
    this.list = new Set();
    this.refs = new Map();
  }

  var _proto = RefSet.prototype;

  _proto.toArray = function toArray() {
    return (0, _toArray2.default)(this.list).concat((0, _toArray2.default)(this.refs.values()));
  };

  _proto.add = function add(value) {
    _Reference.default.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
  };

  _proto.delete = function _delete(value) {
    _Reference.default.isRef(value) ? this.refs.delete(value.key, value) : this.list.delete(value);
  };

  _proto.has = function has(value, resolve) {
    if (this.list.has(value)) return true;
    var item,
        values = this.refs.values();

    while (item = values.next(), !item.done) {
      if (resolve(item.value) === value) return true;
    }

    return false;
  };

  return RefSet;
}();

function SchemaType(options) {
  var _this = this;

  if (options === void 0) {
    options = {};
  }

  if (!(this instanceof SchemaType)) return new SchemaType();
  this._deps = [];
  this._conditions = [];
  this._options = {
    abortEarly: true,
    recursive: true
  };
  this._exclusive = Object.create(null);
  this._whitelist = new RefSet();
  this._blacklist = new RefSet();
  this.tests = [];
  this.transforms = [];
  this.withMutation(function () {
    _this.typeError(_locale.mixed.notType);
  });
  if ((0, _has.default)(options, 'default')) this._defaultDefault = options.default;
  this._type = options.type || 'mixed';
}

var proto = SchemaType.prototype = {
  __isYupSchema__: true,
  constructor: SchemaType,
  clone: function clone() {
    var _this2 = this;

    if (this._mutate) return this; // if the nested value is a schema we can skip cloning, since
    // they are already immutable

    return (0, _cloneDeepWith.default)(this, function (value) {
      if ((0, _isSchema.default)(value) && value !== _this2) return value;
    });
  },
  label: function label(_label) {
    var next = this.clone();
    next._label = _label;
    return next;
  },
  meta: function meta(obj) {
    if (arguments.length === 0) return this._meta;
    var next = this.clone();
    next._meta = (0, _extends2.default)(next._meta || {}, obj);
    return next;
  },
  withMutation: function withMutation(fn) {
    var before = this._mutate;
    this._mutate = true;
    var result = fn(this);
    this._mutate = before;
    return result;
  },
  concat: function concat(schema) {
    if (!schema || schema === this) return this;
    if (schema._type !== this._type && this._type !== 'mixed') throw new TypeError("You cannot `concat()` schema's of different types: " + this._type + " and " + schema._type);
    var next = (0, _prependDeep.default)(schema.clone(), this); // new undefined default is overriden by old non-undefined one, revert

    if ((0, _has.default)(schema, '_default')) next._default = schema._default;
    next.tests = this.tests;
    next._exclusive = this._exclusive; // manually add the new tests to ensure
    // the deduping logic is consistent

    next.withMutation(function (next) {
      schema.tests.forEach(function (fn) {
        next.test(fn.OPTIONS);
      });
    });
    return next;
  },
  isType: function isType(v) {
    if (this._nullable && v === null) return true;
    return !this._typeCheck || this._typeCheck(v);
  },
  resolve: function resolve(options) {
    var schema = this;

    if (schema._conditions.length) {
      var conditions = schema._conditions;
      schema = schema.clone();
      schema._conditions = [];
      schema = conditions.reduce(function (schema, condition) {
        return condition.resolve(schema, options);
      }, schema);
      schema = schema.resolve(options);
    }

    return schema;
  },
  cast: function cast(value, options) {
    if (options === void 0) {
      options = {};
    }

    var resolvedSchema = this.resolve((0, _extends2.default)({}, options, {
      value: value
    }));

    var result = resolvedSchema._cast(value, options);

    if (value !== undefined && options.assert !== false && resolvedSchema.isType(result) !== true) {
      var formattedValue = (0, _printValue.default)(value);
      var formattedResult = (0, _printValue.default)(result);
      throw new TypeError("The value of " + (options.path || 'field') + " could not be cast to a value " + ("that satisfies the schema type: \"" + resolvedSchema._type + "\". \n\n") + ("attempted value: " + formattedValue + " \n") + (formattedResult !== formattedValue ? "result of cast: " + formattedResult : ''));
    }

    return result;
  },
  _cast: function _cast(rawValue) {
    var _this3 = this;

    var value = rawValue === undefined ? rawValue : this.transforms.reduce(function (value, fn) {
      return fn.call(_this3, value, rawValue);
    }, rawValue);

    if (value === undefined && (0, _has.default)(this, '_default')) {
      value = this.default();
    }

    return value;
  },
  _validate: function _validate(_value, options) {
    var _this4 = this;

    if (options === void 0) {
      options = {};
    }

    var value = _value;
    var originalValue = options.originalValue != null ? options.originalValue : _value;

    var isStrict = this._option('strict', options);

    var endEarly = this._option('abortEarly', options);

    var sync = options.sync;
    var path = options.path;
    var label = this._label;

    if (!isStrict) {
      value = this._cast(value, (0, _extends2.default)({
        assert: false
      }, options));
    } // value is cast, we can check if it meets type requirements


    var validationParams = {
      value: value,
      path: path,
      schema: this,
      options: options,
      label: label,
      originalValue: originalValue,
      sync: sync
    };
    var initialTests = [];
    if (this._typeError) initialTests.push(this._typeError(validationParams));
    if (this._whitelistError) initialTests.push(this._whitelistError(validationParams));
    if (this._blacklistError) initialTests.push(this._blacklistError(validationParams));
    return (0, _runValidations.default)({
      validations: initialTests,
      endEarly: endEarly,
      value: value,
      path: path,
      sync: sync
    }).then(function (value) {
      return (0, _runValidations.default)({
        path: path,
        sync: sync,
        value: value,
        endEarly: endEarly,
        validations: _this4.tests.map(function (fn) {
          return fn(validationParams);
        })
      });
    });
  },
  validate: function validate(value, options) {
    if (options === void 0) {
      options = {};
    }

    var schema = this.resolve((0, _extends2.default)({}, options, {
      value: value
    }));
    return schema._validate(value, options);
  },
  validateSync: function validateSync(value, options) {
    if (options === void 0) {
      options = {};
    }

    var schema = this.resolve((0, _extends2.default)({}, options, {
      value: value
    }));
    var result, err;

    schema._validate(value, (0, _extends2.default)({}, options, {
      sync: true
    })).then(function (r) {
      return result = r;
    }).catch(function (e) {
      return err = e;
    });

    if (err) throw err;
    return result;
  },
  isValid: function isValid(value, options) {
    return this.validate(value, options).then(function () {
      return true;
    }).catch(function (err) {
      if (err.name === 'ValidationError') return false;
      throw err;
    });
  },
  isValidSync: function isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (err.name === 'ValidationError') return false;
      throw err;
    }
  },
  getDefault: function getDefault(options) {
    if (options === void 0) {
      options = {};
    }

    var schema = this.resolve(options);
    return schema.default();
  },
  default: function _default(def) {
    if (arguments.length === 0) {
      var defaultValue = (0, _has.default)(this, '_default') ? this._default : this._defaultDefault;
      return typeof defaultValue === 'function' ? defaultValue.call(this) : (0, _cloneDeepWith.default)(defaultValue);
    }

    var next = this.clone();
    next._default = def;
    return next;
  },
  strict: function strict(isStrict) {
    if (isStrict === void 0) {
      isStrict = true;
    }

    var next = this.clone();
    next._options.strict = isStrict;
    return next;
  },
  _isPresent: function _isPresent(value) {
    return value != null;
  },
  required: function required(message) {
    if (message === void 0) {
      message = _locale.mixed.required;
    }

    return this.test({
      message: message,
      name: 'required',
      exclusive: true,
      test: function test(value) {
        return this.schema._isPresent(value);
      }
    });
  },
  notRequired: function notRequired() {
    var next = this.clone();
    next.tests = next.tests.filter(function (test) {
      return test.OPTIONS.name !== 'required';
    });
    return next;
  },
  nullable: function nullable(isNullable) {
    if (isNullable === void 0) {
      isNullable = true;
    }

    var next = this.clone();
    next._nullable = isNullable;
    return next;
  },
  transform: function transform(fn) {
    var next = this.clone();
    next.transforms.push(fn);
    return next;
  },

  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test: function test() {
    var opts;

    if (arguments.length === 1) {
      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function') {
        opts = {
          test: arguments.length <= 0 ? undefined : arguments[0]
        };
      } else {
        opts = arguments.length <= 0 ? undefined : arguments[0];
      }
    } else if (arguments.length === 2) {
      opts = {
        name: arguments.length <= 0 ? undefined : arguments[0],
        test: arguments.length <= 1 ? undefined : arguments[1]
      };
    } else {
      opts = {
        name: arguments.length <= 0 ? undefined : arguments[0],
        message: arguments.length <= 1 ? undefined : arguments[1],
        test: arguments.length <= 2 ? undefined : arguments[2]
      };
    }

    if (opts.message === undefined) opts.message = _locale.mixed.default;
    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');
    var next = this.clone();
    var validate = (0, _createValidation.default)(opts);
    var isExclusive = opts.exclusive || opts.name && next._exclusive[opts.name] === true;

    if (opts.exclusive && !opts.name) {
      throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
    }

    next._exclusive[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter(function (fn) {
      if (fn.OPTIONS.name === opts.name) {
        if (isExclusive) return false;
        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
      }

      return true;
    });
    next.tests.push(validate);
    return next;
  },
  when: function when(keys, options) {
    if (arguments.length === 1) {
      options = keys;
      keys = '.';
    }

    var next = this.clone(),
        deps = [].concat(keys).map(function (key) {
      return new _Reference.default(key);
    });
    deps.forEach(function (dep) {
      if (dep.isSibling) next._deps.push(dep.key);
    });

    next._conditions.push(new _Condition.default(deps, options));

    return next;
  },
  typeError: function typeError(message) {
    var next = this.clone();
    next._typeError = (0, _createValidation.default)({
      message: message,
      name: 'typeError',
      test: function test(value) {
        if (value !== undefined && !this.schema.isType(value)) return this.createError({
          params: {
            type: this.schema._type
          }
        });
        return true;
      }
    });
    return next;
  },
  oneOf: function oneOf(enums, message) {
    if (message === void 0) {
      message = _locale.mixed.oneOf;
    }

    var next = this.clone();
    enums.forEach(function (val) {
      next._whitelist.add(val);

      next._blacklist.delete(val);
    });
    next._whitelistError = (0, _createValidation.default)({
      message: message,
      name: 'oneOf',
      test: function test(value) {
        if (value === undefined) return true;
        var valids = this.schema._whitelist;
        return valids.has(value, this.resolve) ? true : this.createError({
          params: {
            values: valids.toArray().join(', ')
          }
        });
      }
    });
    return next;
  },
  notOneOf: function notOneOf(enums, message) {
    if (message === void 0) {
      message = _locale.mixed.notOneOf;
    }

    var next = this.clone();
    enums.forEach(function (val) {
      next._blacklist.add(val);

      next._whitelist.delete(val);
    });
    next._blacklistError = (0, _createValidation.default)({
      message: message,
      name: 'notOneOf',
      test: function test(value) {
        var invalids = this.schema._blacklist;
        if (invalids.has(value, this.resolve)) return this.createError({
          params: {
            values: invalids.toArray().join(', ')
          }
        });
        return true;
      }
    });
    return next;
  },
  strip: function strip(_strip) {
    if (_strip === void 0) {
      _strip = true;
    }

    var next = this.clone();
    next._strip = _strip;
    return next;
  },
  _option: function _option(key, overrides) {
    return (0, _has.default)(overrides, key) ? overrides[key] : this._options[key];
  },
  describe: function describe() {
    var next = this.clone();
    return {
      type: next._type,
      meta: next._meta,
      label: next._label,
      tests: next.tests.map(function (fn) {
        return {
          name: fn.OPTIONS.name,
          params: fn.OPTIONS.params
        };
      }).filter(function (n, idx, list) {
        return list.findIndex(function (c) {
          return c.name === n.name;
        }) === idx;
      })
    };
  }
};
var _arr = ['validate', 'validateSync'];

var _loop = function _loop() {
  var method = _arr[_i];

  proto[method + "At"] = function (path, value, options) {
    if (options === void 0) {
      options = {};
    }

    var _getIn = (0, _reach.getIn)(this, path, value, options.context),
        parent = _getIn.parent,
        parentPath = _getIn.parentPath,
        schema = _getIn.schema;

    return schema[method](parent && parent[parentPath], (0, _extends2.default)({}, options, {
      parent: parent,
      path: path
    }));
  };
};

for (var _i = 0; _i < _arr.length; _i++) {
  _loop();
}

var _arr2 = ['equals', 'is'];

for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
  var alias = _arr2[_i2];
  proto[alias] = proto.oneOf;
}

var _arr3 = ['not', 'nope'];

for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
  var _alias = _arr3[_i3];
  proto[_alias] = proto.notOneOf;
}

proto.optional = proto.notRequired;
module.exports = exports["default"];

/***/ }),
/* 322 */
/***/ ((module) => {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),
/* 323 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHas = __webpack_require__(324),
    hasPath = __webpack_require__(325);

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),
/* 324 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),
/* 325 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(326),
    isArguments = __webpack_require__(375),
    isArray = __webpack_require__(327),
    isIndex = __webpack_require__(377),
    isLength = __webpack_require__(378),
    toKey = __webpack_require__(379);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 326 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(327),
    isKey = __webpack_require__(328),
    stringToPath = __webpack_require__(337),
    toString = __webpack_require__(372);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 327 */
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 328 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(327),
    isSymbol = __webpack_require__(329);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 329 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(330),
    isObjectLike = __webpack_require__(336);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 330 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(331),
    getRawTag = __webpack_require__(334),
    objectToString = __webpack_require__(335);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 331 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(332);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 332 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(333);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 333 */
/***/ ((module) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;


/***/ }),
/* 334 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(331);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 335 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 336 */
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 337 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(338);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 338 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(339);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 339 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(340);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 340 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(341),
    mapCacheDelete = __webpack_require__(366),
    mapCacheGet = __webpack_require__(369),
    mapCacheHas = __webpack_require__(370),
    mapCacheSet = __webpack_require__(371);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 341 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(342),
    ListCache = __webpack_require__(357),
    Map = __webpack_require__(365);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 342 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(343),
    hashDelete = __webpack_require__(353),
    hashGet = __webpack_require__(354),
    hashHas = __webpack_require__(355),
    hashSet = __webpack_require__(356);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 343 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(344);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 344 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(345);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 345 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(346),
    getValue = __webpack_require__(352);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 346 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(347),
    isMasked = __webpack_require__(349),
    isObject = __webpack_require__(348),
    toSource = __webpack_require__(351);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 347 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(330),
    isObject = __webpack_require__(348);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 348 */
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 349 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(350);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 350 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(332);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 351 */
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 352 */
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 353 */
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 354 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(344);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 355 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(344);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 356 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(344);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 357 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(358),
    listCacheDelete = __webpack_require__(359),
    listCacheGet = __webpack_require__(362),
    listCacheHas = __webpack_require__(363),
    listCacheSet = __webpack_require__(364);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 358 */
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 359 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(360);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 360 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(361);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 361 */
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 362 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(360);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 363 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(360);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 364 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(360);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 365 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(345),
    root = __webpack_require__(332);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 366 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(367);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 367 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(368);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 368 */
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 369 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(367);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 370 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(367);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 371 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(367);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 372 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(373);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 373 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(331),
    arrayMap = __webpack_require__(374),
    isArray = __webpack_require__(327),
    isSymbol = __webpack_require__(329);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 374 */
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 375 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(376),
    isObjectLike = __webpack_require__(336);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 376 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(330),
    isObjectLike = __webpack_require__(336);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 377 */
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 378 */
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 379 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(329);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 380 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(381);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
}

module.exports = cloneDeepWith;


/***/ }),
/* 381 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(382),
    arrayEach = __webpack_require__(388),
    assignValue = __webpack_require__(389),
    baseAssign = __webpack_require__(392),
    baseAssignIn = __webpack_require__(408),
    cloneBuffer = __webpack_require__(412),
    copyArray = __webpack_require__(413),
    copySymbols = __webpack_require__(414),
    copySymbolsIn = __webpack_require__(418),
    getAllKeys = __webpack_require__(422),
    getAllKeysIn = __webpack_require__(424),
    getTag = __webpack_require__(425),
    initCloneArray = __webpack_require__(430),
    initCloneByTag = __webpack_require__(431),
    initCloneObject = __webpack_require__(438),
    isArray = __webpack_require__(327),
    isBuffer = __webpack_require__(397),
    isMap = __webpack_require__(440),
    isObject = __webpack_require__(348),
    isSet = __webpack_require__(442),
    keys = __webpack_require__(394);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 382 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(357),
    stackClear = __webpack_require__(383),
    stackDelete = __webpack_require__(384),
    stackGet = __webpack_require__(385),
    stackHas = __webpack_require__(386),
    stackSet = __webpack_require__(387);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 383 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(357);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 384 */
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 385 */
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 386 */
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 387 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(357),
    Map = __webpack_require__(365),
    MapCache = __webpack_require__(340);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 388 */
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 389 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(390),
    eq = __webpack_require__(361);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 390 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(391);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 391 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(345);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 392 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(393),
    keys = __webpack_require__(394);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 393 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(389),
    baseAssignValue = __webpack_require__(390);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 394 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(395),
    baseKeys = __webpack_require__(403),
    isArrayLike = __webpack_require__(407);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 395 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(396),
    isArguments = __webpack_require__(375),
    isArray = __webpack_require__(327),
    isBuffer = __webpack_require__(397),
    isIndex = __webpack_require__(377),
    isTypedArray = __webpack_require__(399);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 396 */
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 397 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(332),
    stubFalse = __webpack_require__(398);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),
/* 398 */
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 399 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(400),
    baseUnary = __webpack_require__(401),
    nodeUtil = __webpack_require__(402);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 400 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(330),
    isLength = __webpack_require__(378),
    isObjectLike = __webpack_require__(336);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 401 */
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 402 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(333);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),
/* 403 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(404),
    nativeKeys = __webpack_require__(405);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 404 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 405 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(406);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 406 */
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 407 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(347),
    isLength = __webpack_require__(378);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 408 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(393),
    keysIn = __webpack_require__(409);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 409 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(395),
    baseKeysIn = __webpack_require__(410),
    isArrayLike = __webpack_require__(407);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 410 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(348),
    isPrototype = __webpack_require__(404),
    nativeKeysIn = __webpack_require__(411);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 411 */
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 412 */
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(332);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),
/* 413 */
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 414 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(393),
    getSymbols = __webpack_require__(415);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 415 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(416),
    stubArray = __webpack_require__(417);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 416 */
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 417 */
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 418 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(393),
    getSymbolsIn = __webpack_require__(419);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 419 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(420),
    getPrototype = __webpack_require__(421),
    getSymbols = __webpack_require__(415),
    stubArray = __webpack_require__(417);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 420 */
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 421 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(406);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 422 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(423),
    getSymbols = __webpack_require__(415),
    keys = __webpack_require__(394);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 423 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(420),
    isArray = __webpack_require__(327);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 424 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(423),
    getSymbolsIn = __webpack_require__(419),
    keysIn = __webpack_require__(409);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 425 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(426),
    Map = __webpack_require__(365),
    Promise = __webpack_require__(427),
    Set = __webpack_require__(428),
    WeakMap = __webpack_require__(429),
    baseGetTag = __webpack_require__(330),
    toSource = __webpack_require__(351);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 426 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(345),
    root = __webpack_require__(332);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 427 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(345),
    root = __webpack_require__(332);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 428 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(345),
    root = __webpack_require__(332);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 429 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(345),
    root = __webpack_require__(332);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 430 */
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 431 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(432),
    cloneDataView = __webpack_require__(434),
    cloneRegExp = __webpack_require__(435),
    cloneSymbol = __webpack_require__(436),
    cloneTypedArray = __webpack_require__(437);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 432 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(433);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 433 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(332);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 434 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(432);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 435 */
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 436 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(331);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 437 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(432);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 438 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(439),
    getPrototype = __webpack_require__(421),
    isPrototype = __webpack_require__(404);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 439 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(348);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 440 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(441),
    baseUnary = __webpack_require__(401),
    nodeUtil = __webpack_require__(402);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 441 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(425),
    isObjectLike = __webpack_require__(336);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 442 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(443),
    baseUnary = __webpack_require__(401),
    nodeUtil = __webpack_require__(402);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 443 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(425),
    isObjectLike = __webpack_require__(336);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 444 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(331),
    copyArray = __webpack_require__(413),
    getTag = __webpack_require__(425),
    isArrayLike = __webpack_require__(407),
    isString = __webpack_require__(445),
    iteratorToArray = __webpack_require__(446),
    mapToArray = __webpack_require__(447),
    setToArray = __webpack_require__(448),
    stringToArray = __webpack_require__(449),
    values = __webpack_require__(453);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Built-in value references. */
var symIterator = Symbol ? Symbol.iterator : undefined;

/**
 * Converts `value` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray(value[symIterator]());
  }
  var tag = getTag(value),
      func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

  return func(value);
}

module.exports = toArray;


/***/ }),
/* 445 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(330),
    isArray = __webpack_require__(327),
    isObjectLike = __webpack_require__(336);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),
/* 446 */
/***/ ((module) => {

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

module.exports = iteratorToArray;


/***/ }),
/* 447 */
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 448 */
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 449 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiToArray = __webpack_require__(450),
    hasUnicode = __webpack_require__(451),
    unicodeToArray = __webpack_require__(452);

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


/***/ }),
/* 450 */
/***/ ((module) => {

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


/***/ }),
/* 451 */
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),
/* 452 */
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


/***/ }),
/* 453 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseValues = __webpack_require__(454),
    keys = __webpack_require__(394);

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),
/* 454 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(374);

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),
/* 455 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = exports.array = exports.object = exports.boolean = exports.date = exports.number = exports.string = exports.mixed = void 0;

var _printValue = _interopRequireDefault(__webpack_require__(456));

var mixed = {
  default: '${path} is invalid',
  required: '${path} is a required field',
  oneOf: '${path} must be one of the following values: ${values}',
  notOneOf: '${path} must not be one of the following values: ${values}',
  notType: function notType(_ref) {
    var path = _ref.path,
        type = _ref.type,
        value = _ref.value,
        originalValue = _ref.originalValue;
    var isCast = originalValue != null && originalValue !== value;
    var msg = path + " must be a `" + type + "` type, " + ("but the final value was: `" + (0, _printValue.default)(value, true) + "`") + (isCast ? " (cast from the value `" + (0, _printValue.default)(originalValue, true) + "`)." : '.');

    if (value === null) {
      msg += "\n If \"null\" is intended as an empty value be sure to mark the schema as `.nullable()`";
    }

    return msg;
  }
};
exports.mixed = mixed;
var string = {
  length: '${path} must be exactly ${length} characters',
  min: '${path} must be at least ${min} characters',
  max: '${path} must be at most ${max} characters',
  matches: '${path} must match the following: "${regex}"',
  email: '${path} must be a valid email',
  url: '${path} must be a valid URL',
  trim: '${path} must be a trimmed string',
  lowercase: '${path} must be a lowercase string',
  uppercase: '${path} must be a upper case string'
};
exports.string = string;
var number = {
  min: '${path} must be greater than or equal to ${min}',
  max: '${path} must be less than or equal to ${max}',
  lessThan: '${path} must be less than ${less}',
  moreThan: '${path} must be greater than ${more}',
  notEqual: '${path} must be not equal to ${notEqual}',
  positive: '${path} must be a positive number',
  negative: '${path} must be a negative number',
  integer: '${path} must be an integer'
};
exports.number = number;
var date = {
  min: '${path} field must be later than ${min}',
  max: '${path} field must be at earlier than ${max}'
};
exports.date = date;
var boolean = {};
exports.boolean = boolean;
var object = {
  noUnknown: '${path} field cannot have keys not specified in the object shape'
};
exports.object = object;
var array = {
  min: '${path} field must have at least ${min} items',
  max: '${path} field must have less than or equal to ${max} items'
};
exports.array = array;
var _default = {
  mixed: mixed,
  string: string,
  number: number,
  date: date,
  object: object,
  array: array,
  boolean: boolean
};
exports.default = _default;

/***/ }),
/* 456 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = printValue;
var toString = Object.prototype.toString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
var symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : function () {
  return '';
};
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;

function printNumber(val) {
  if (val != +val) return 'NaN';
  var isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? '-0' : '' + val;
}

function printSimpleValue(val, quoteStrings) {
  if (quoteStrings === void 0) {
    quoteStrings = false;
  }

  if (val == null || val === true || val === false) return '' + val;
  var typeOf = typeof val;
  if (typeOf === 'number') return printNumber(val);
  if (typeOf === 'string') return quoteStrings ? "\"" + val + "\"" : val;
  if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';
  if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
  var tag = toString.call(val).slice(8, -1);
  if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
  if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';
  if (tag === 'RegExp') return regExpToString.call(val);
  return null;
}

function printValue(value, quoteStrings) {
  var result = printSimpleValue(value, quoteStrings);
  if (result !== null) return result;
  return JSON.stringify(value, function (key, value) {
    var result = printSimpleValue(this[key], quoteStrings);
    if (result !== null) return result;
    return value;
  }, 2);
}

module.exports = exports["default"];

/***/ }),
/* 457 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = void 0;

var _has = _interopRequireDefault(__webpack_require__(323));

var _isSchema = _interopRequireDefault(__webpack_require__(458));

var Condition =
/*#__PURE__*/
function () {
  function Condition(refs, options) {
    this.refs = refs;

    if (typeof options === 'function') {
      this.fn = options;
      return;
    }

    if (!(0, _has.default)(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');
    if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
    var is = options.is,
        then = options.then,
        otherwise = options.otherwise;
    var check = typeof is === 'function' ? is : function () {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      return values.every(function (value) {
        return value === is;
      });
    };

    this.fn = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var options = args.pop();
      var schema = args.pop();
      var branch = check.apply(void 0, args) ? then : otherwise;
      if (!branch) return undefined;
      if (typeof branch === 'function') return branch(schema);
      return schema.concat(branch.resolve(options));
    };
  }

  var _proto = Condition.prototype;

  _proto.resolve = function resolve(base, options) {
    var values = this.refs.map(function (ref) {
      return ref.getValue(options);
    });
    var schema = this.fn.apply(base, values.concat(base, options));
    if (schema === undefined || schema === base) return base;
    if (!(0, _isSchema.default)(schema)) throw new TypeError('conditions must return a schema object');
    return schema.resolve(options);
  };

  return Condition;
}();

var _default = Condition;
exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 458 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _default = function _default(obj) {
  return obj && obj.__isYupSchema__;
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 459 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.propagateErrors = propagateErrors;
exports.settled = settled;
exports.collectErrors = collectErrors;
exports.default = runValidations;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(460));

var _synchronousPromise = __webpack_require__(461);

var _ValidationError = _interopRequireDefault(__webpack_require__(462));

var promise = function promise(sync) {
  return sync ? _synchronousPromise.SynchronousPromise : Promise;
};

var unwrapError = function unwrapError(errors) {
  if (errors === void 0) {
    errors = [];
  }

  return errors.inner && errors.inner.length ? errors.inner : [].concat(errors);
};

function scopeToValue(promises, value, sync) {
  //console.log('scopeToValue', promises, value)
  var p = promise(sync).all(promises); //console.log('scopeToValue B', p)

  var b = p.catch(function (err) {
    if (err.name === 'ValidationError') err.value = value;
    throw err;
  }); //console.log('scopeToValue c', b)

  var c = b.then(function () {
    return value;
  }); //console.log('scopeToValue d', c)

  return c;
}
/**
 * If not failing on the first error, catch the errors
 * and collect them in an array
 */


function propagateErrors(endEarly, errors) {
  return endEarly ? null : function (err) {
    errors.push(err);
    return err.value;
  };
}

function settled(promises, sync) {
  var Promise = promise(sync);
  return Promise.all(promises.map(function (p) {
    return Promise.resolve(p).then(function (value) {
      return {
        fulfilled: true,
        value: value
      };
    }, function (value) {
      return {
        fulfilled: false,
        value: value
      };
    });
  }));
}

function collectErrors(_ref) {
  var validations = _ref.validations,
      value = _ref.value,
      path = _ref.path,
      sync = _ref.sync,
      errors = _ref.errors,
      sort = _ref.sort;
  errors = unwrapError(errors);
  return settled(validations, sync).then(function (results) {
    var nestedErrors = results.filter(function (r) {
      return !r.fulfilled;
    }).reduce(function (arr, _ref2) {
      var error = _ref2.value;

      // we are only collecting validation errors
      if (!_ValidationError.default.isError(error)) {
        throw error;
      }

      return arr.concat(error);
    }, []);
    if (sort) nestedErrors.sort(sort); //show parent errors after the nested ones: name.first, name

    errors = nestedErrors.concat(errors);
    if (errors.length) throw new _ValidationError.default(errors, value, path);
    return value;
  });
}

function runValidations(_ref3) {
  var endEarly = _ref3.endEarly,
      options = (0, _objectWithoutPropertiesLoose2.default)(_ref3, ["endEarly"]);
  if (endEarly) return scopeToValue(options.validations, options.value, options.sync);
  return collectErrors(options);
}

/***/ }),
/* 460 */
/***/ ((module) => {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),
/* 461 */
/***/ ((module) => {

"use strict";
/* jshint node: true */

function makeArrayFrom(obj) {
  return Array.prototype.slice.apply(obj);
}
var
  PENDING = "pending",
  RESOLVED = "resolved",
  REJECTED = "rejected";

function SynchronousPromise(handler) {
  this.status = PENDING;
  this._continuations = [];
  this._parent = null;
  this._paused = false;
  if (handler) {
    handler.call(
      this,
      this._continueWith.bind(this),
      this._failWith.bind(this)
    );
  }
}

function looksLikeAPromise(obj) {
  return obj && typeof (obj.then) === "function";
}

function passThrough(value) {
  return value;
}

SynchronousPromise.prototype = {
  then: function (nextFn, catchFn) {
    var next = SynchronousPromise.unresolved()._setParent(this);
    if (this._isRejected()) {
      if (this._paused) {
        this._continuations.push({
          promise: next,
          nextFn: nextFn,
          catchFn: catchFn
        });
        return next;
      }
      if (catchFn) {
        try {
          var catchResult = catchFn(this._error);
          if (looksLikeAPromise(catchResult)) {
            this._chainPromiseData(catchResult, next);
            return next;
          } else {
            return SynchronousPromise.resolve(catchResult)._setParent(this);
          }
        } catch (e) {
          return SynchronousPromise.reject(e)._setParent(this);
        }
      }
      return SynchronousPromise.reject(this._error)._setParent(this);
    }
    this._continuations.push({
      promise: next,
      nextFn: nextFn,
      catchFn: catchFn
    });
    this._runResolutions();
    return next;
  },
  catch: function (handler) {
    if (this._isResolved()) {
      return SynchronousPromise.resolve(this._data)._setParent(this);
    }
    var next = SynchronousPromise.unresolved()._setParent(this);
    this._continuations.push({
      promise: next,
      catchFn: handler
    });
    this._runRejections();
    return next;
  },
  finally: function(callback) {
    var ran = false;
    function runFinally(result, err) {
      if (!ran) {
        ran = true;
        if (!callback) {
          callback = passThrough;
        }
        var callbackResult = callback(result);
        if (looksLikeAPromise(callbackResult)) {
          return callbackResult.then(function() {
            if (err) {
              throw err;
            }
            return result;
          });
        } else {
          return result;
        }
      }
    }
    return this
      .then(function(result) {
        return runFinally(result);
      })
      .catch(function(err) {
        return runFinally(null, err);
      });
  },
  pause: function () {
    this._paused = true;
    return this;
  },
  resume: function () {
    var firstPaused = this._findFirstPaused();
    if (firstPaused) {
      firstPaused._paused = false;
      firstPaused._runResolutions();
      firstPaused._runRejections();
    }
    return this;
  },
  _findAncestry: function () {
    return this._continuations.reduce(function (acc, cur) {
      if (cur.promise) {
        var node = {
          promise: cur.promise,
          children: cur.promise._findAncestry()
        };
        acc.push(node);
      }
      return acc;
    }, []);
  },
  _setParent: function (parent) {
    if (this._parent) {
      throw new Error("parent already set");
    }
    this._parent = parent;
    return this;
  },
  _continueWith: function (data) {
    var firstPending = this._findFirstPending();
    if (firstPending) {
      firstPending._data = data;
      firstPending._setResolved();
    }
  },
  _findFirstPending: function () {
    return this._findFirstAncestor(function (test) {
      return test._isPending && test._isPending();
    });
  },
  _findFirstPaused: function () {
    return this._findFirstAncestor(function (test) {
      return test._paused;
    });
  },
  _findFirstAncestor: function (matching) {
    var test = this;
    var result;
    while (test) {
      if (matching(test)) {
        result = test;
      }
      test = test._parent;
    }
    return result;
  },
  _failWith: function (error) {
    var firstRejected = this._findFirstPending();
    if (firstRejected) {
      firstRejected._error = error;
      firstRejected._setRejected();
    }
  },
  _takeContinuations: function () {
    return this._continuations.splice(0, this._continuations.length);
  },
  _runRejections: function () {
    if (this._paused || !this._isRejected()) {
      return;
    }
    var
      error = this._error,
      continuations = this._takeContinuations(),
      self = this;
    continuations.forEach(function (cont) {
      if (cont.catchFn) {
        try {
          var catchResult = cont.catchFn(error);
          self._handleUserFunctionResult(catchResult, cont.promise);
        } catch (e) {
          cont.promise.reject(e);
        }
      } else {
        cont.promise.reject(error);
      }
    });
  },
  _runResolutions: function () {
    if (this._paused || !this._isResolved() || this._isPending()) {
      return;
    }
    var continuations = this._takeContinuations();
    if (looksLikeAPromise(this._data)) {
      return this._handleWhenResolvedDataIsPromise(this._data);
    }
    var data = this._data;
    var self = this;
    continuations.forEach(function (cont) {
      if (cont.nextFn) {
        try {
          var result = cont.nextFn(data);
          self._handleUserFunctionResult(result, cont.promise);
        } catch (e) {
          self._handleResolutionError(e, cont);
        }
      } else if (cont.promise) {
        cont.promise.resolve(data);
      }
    });
  },
  _handleResolutionError: function (e, continuation) {
    this._setRejected();
    if (continuation.catchFn) {
      try {
        continuation.catchFn(e);
        return;
      } catch (e2) {
        e = e2;
      }
    }
    if (continuation.promise) {
      continuation.promise.reject(e);
    }
  },
  _handleWhenResolvedDataIsPromise: function (data) {
    var self = this;
    return data.then(function (result) {
      self._data = result;
      self._runResolutions();
    }).catch(function (error) {
      self._error = error;
      self._setRejected();
      self._runRejections();
    });
  },
  _handleUserFunctionResult: function (data, nextSynchronousPromise) {
    if (looksLikeAPromise(data)) {
      this._chainPromiseData(data, nextSynchronousPromise);
    } else {
      nextSynchronousPromise.resolve(data);
    }
  },
  _chainPromiseData: function (promiseData, nextSynchronousPromise) {
    promiseData.then(function (newData) {
      nextSynchronousPromise.resolve(newData);
    }).catch(function (newError) {
      nextSynchronousPromise.reject(newError);
    });
  },
  _setResolved: function () {
    this.status = RESOLVED;
    if (!this._paused) {
      this._runResolutions();
    }
  },
  _setRejected: function () {
    this.status = REJECTED;
    if (!this._paused) {
      this._runRejections();
    }
  },
  _isPending: function () {
    return this.status === PENDING;
  },
  _isResolved: function () {
    return this.status === RESOLVED;
  },
  _isRejected: function () {
    return this.status === REJECTED;
  }
};

SynchronousPromise.resolve = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    if (looksLikeAPromise(result)) {
      result.then(function (newResult) {
        resolve(newResult);
      }).catch(function (error) {
        reject(error);
      });
    } else {
      resolve(result);
    }
  });
};

SynchronousPromise.reject = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    reject(result);
  });
};

SynchronousPromise.unresolved = function () {
  return new SynchronousPromise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  });
};

SynchronousPromise.all = function () {
  var args = makeArrayFrom(arguments);
  if (Array.isArray(args[0])) {
    args = args[0];
  }
  if (!args.length) {
    return SynchronousPromise.resolve([]);
  }
  return new SynchronousPromise(function (resolve, reject) {
    var
      allData = [],
      numResolved = 0,
      doResolve = function () {
        if (numResolved === args.length) {
          resolve(allData);
        }
      },
      rejected = false,
      doReject = function (err) {
        if (rejected) {
          return;
        }
        rejected = true;
        reject(err);
      };
    args.forEach(function (arg, idx) {
      SynchronousPromise.resolve(arg).then(function (thisResult) {
        allData[idx] = thisResult;
        numResolved += 1;
        doResolve();
      }).catch(function (err) {
        doReject(err);
      });
    });
  });
};

/* jshint ignore:start */
if (Promise === SynchronousPromise) {
  throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
}
var RealPromise = Promise;
SynchronousPromise.installGlobally = function(__awaiter) {
  if (Promise === SynchronousPromise) {
    return __awaiter;
  }
  var result = patchAwaiterIfRequired(__awaiter);
  Promise = SynchronousPromise;
  return result;
};

SynchronousPromise.uninstallGlobally = function() {
  if (Promise === SynchronousPromise) {
    Promise = RealPromise;
  }
};

function patchAwaiterIfRequired(__awaiter) {
  if (typeof(__awaiter) === "undefined" || __awaiter.__patched) {
    return __awaiter;
  }
  var originalAwaiter = __awaiter;
  __awaiter = function() {
    var Promise = RealPromise;
    originalAwaiter.apply(this, makeArrayFrom(arguments));
  };
  __awaiter.__patched = true;
  return __awaiter;
}
/* jshint ignore:end */

module.exports = {
  SynchronousPromise: SynchronousPromise
};


/***/ }),
/* 462 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = ValidationError;

var _printValue = _interopRequireDefault(__webpack_require__(456));

var strReg = /\$\{\s*(\w+)\s*\}/g;

var replace = function replace(str) {
  return function (params) {
    return str.replace(strReg, function (_, key) {
      return (0, _printValue.default)(params[key]);
    });
  };
};

function ValidationError(errors, value, field, type) {
  var _this = this;

  this.name = 'ValidationError';
  this.value = value;
  this.path = field;
  this.type = type;
  this.errors = [];
  this.inner = [];
  if (errors) [].concat(errors).forEach(function (err) {
    _this.errors = _this.errors.concat(err.errors || err);
    if (err.inner) _this.inner = _this.inner.concat(err.inner.length ? err.inner : err);
  });
  this.message = this.errors.length > 1 ? this.errors.length + " errors occurred" : this.errors[0];
  if (Error.captureStackTrace) Error.captureStackTrace(this, ValidationError);
}

ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;

ValidationError.isError = function (err) {
  return err && err.name === 'ValidationError';
};

ValidationError.formatError = function (message, params) {
  if (typeof message === 'string') message = replace(message);

  var fn = function fn(params) {
    params.path = params.label || params.path || 'this';
    return typeof message === 'function' ? message(params) : message;
  };

  return arguments.length === 1 ? fn : fn(params);
};

module.exports = exports["default"];

/***/ }),
/* 463 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = prependDeep;

var _has = _interopRequireDefault(__webpack_require__(323));

var _isSchema = _interopRequireDefault(__webpack_require__(458));

var isObject = function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
};

function prependDeep(target, source) {
  for (var key in source) {
    if ((0, _has.default)(source, key)) {
      var sourceVal = source[key],
          targetVal = target[key];

      if (targetVal === undefined) {
        target[key] = sourceVal;
      } else if (targetVal === sourceVal) {
        continue;
      } else if ((0, _isSchema.default)(targetVal)) {
        if ((0, _isSchema.default)(sourceVal)) target[key] = sourceVal.concat(targetVal);
      } else if (isObject(targetVal)) {
        if (isObject(sourceVal)) target[key] = prependDeep(targetVal, sourceVal);
      } else if (Array.isArray(targetVal)) {
        if (Array.isArray(sourceVal)) target[key] = sourceVal.concat(targetVal);
      }
    }
  }

  return target;
}

module.exports = exports["default"];

/***/ }),
/* 464 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.createErrorFactory = createErrorFactory;
exports.default = createValidation;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(460));

var _extends2 = _interopRequireDefault(__webpack_require__(322));

var _mapValues = _interopRequireDefault(__webpack_require__(465));

var _ValidationError = _interopRequireDefault(__webpack_require__(462));

var _Reference = _interopRequireDefault(__webpack_require__(494));

var _synchronousPromise = __webpack_require__(461);

var formatError = _ValidationError.default.formatError;

var thenable = function thenable(p) {
  return p && typeof p.then === 'function' && typeof p.catch === 'function';
};

function runTest(testFn, ctx, value, sync) {
  var result = testFn.call(ctx, value);
  if (!sync) return Promise.resolve(result);

  if (thenable(result)) {
    throw new Error("Validation test of type: \"" + ctx.type + "\" returned a Promise during a synchronous validate. " + "This test will finish after the validate call has returned");
  }

  return _synchronousPromise.SynchronousPromise.resolve(result);
}

function resolveParams(oldParams, newParams, resolve) {
  return (0, _mapValues.default)((0, _extends2.default)({}, oldParams, newParams), resolve);
}

function createErrorFactory(_ref) {
  var value = _ref.value,
      label = _ref.label,
      resolve = _ref.resolve,
      originalValue = _ref.originalValue,
      opts = (0, _objectWithoutPropertiesLoose2.default)(_ref, ["value", "label", "resolve", "originalValue"]);
  return function createError(_temp) {
    var _ref2 = _temp === void 0 ? {} : _temp,
        _ref2$path = _ref2.path,
        path = _ref2$path === void 0 ? opts.path : _ref2$path,
        _ref2$message = _ref2.message,
        message = _ref2$message === void 0 ? opts.message : _ref2$message,
        _ref2$type = _ref2.type,
        type = _ref2$type === void 0 ? opts.name : _ref2$type,
        params = _ref2.params;

    params = (0, _extends2.default)({
      path: path,
      value: value,
      originalValue: originalValue,
      label: label
    }, resolveParams(opts.params, params, resolve));
    return (0, _extends2.default)(new _ValidationError.default(formatError(message, params), value, path, type), {
      params: params
    });
  };
}

function createValidation(options) {
  var name = options.name,
      message = options.message,
      test = options.test,
      params = options.params;

  function validate(_ref3) {
    var value = _ref3.value,
        path = _ref3.path,
        label = _ref3.label,
        options = _ref3.options,
        originalValue = _ref3.originalValue,
        sync = _ref3.sync,
        rest = (0, _objectWithoutPropertiesLoose2.default)(_ref3, ["value", "path", "label", "options", "originalValue", "sync"]);
    var parent = options.parent;

    var resolve = function resolve(item) {
      return _Reference.default.isRef(item) ? item.getValue({
        value: value,
        parent: parent,
        context: options.context
      }) : item;
    };

    var createError = createErrorFactory({
      message: message,
      path: path,
      value: value,
      originalValue: originalValue,
      params: params,
      label: label,
      resolve: resolve,
      name: name
    });
    var ctx = (0, _extends2.default)({
      path: path,
      parent: parent,
      type: name,
      createError: createError,
      resolve: resolve,
      options: options
    }, rest);
    return runTest(test, ctx, value, sync).then(function (validOrError) {
      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();
    });
  }

  validate.OPTIONS = options;
  return validate;
}

/***/ }),
/* 465 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(390),
    baseForOwn = __webpack_require__(466),
    baseIteratee = __webpack_require__(469);

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;


/***/ }),
/* 466 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(467),
    keys = __webpack_require__(394);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),
/* 467 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(468);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 468 */
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 469 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(470),
    baseMatchesProperty = __webpack_require__(485),
    identity = __webpack_require__(490),
    isArray = __webpack_require__(327),
    property = __webpack_require__(491);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),
/* 470 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(471),
    getMatchData = __webpack_require__(482),
    matchesStrictComparable = __webpack_require__(484);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),
/* 471 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(382),
    baseIsEqual = __webpack_require__(472);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),
/* 472 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(473),
    isObjectLike = __webpack_require__(336);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 473 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(382),
    equalArrays = __webpack_require__(474),
    equalByTag = __webpack_require__(480),
    equalObjects = __webpack_require__(481),
    getTag = __webpack_require__(425),
    isArray = __webpack_require__(327),
    isBuffer = __webpack_require__(397),
    isTypedArray = __webpack_require__(399);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 474 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(475),
    arraySome = __webpack_require__(478),
    cacheHas = __webpack_require__(479);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 475 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(340),
    setCacheAdd = __webpack_require__(476),
    setCacheHas = __webpack_require__(477);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 476 */
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 477 */
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 478 */
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 479 */
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 480 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(331),
    Uint8Array = __webpack_require__(433),
    eq = __webpack_require__(361),
    equalArrays = __webpack_require__(474),
    mapToArray = __webpack_require__(447),
    setToArray = __webpack_require__(448);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 481 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(422);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 482 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(483),
    keys = __webpack_require__(394);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),
/* 483 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(348);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),
/* 484 */
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),
/* 485 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(472),
    get = __webpack_require__(486),
    hasIn = __webpack_require__(488),
    isKey = __webpack_require__(328),
    isStrictComparable = __webpack_require__(483),
    matchesStrictComparable = __webpack_require__(484),
    toKey = __webpack_require__(379);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),
/* 486 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(487);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 487 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(326),
    toKey = __webpack_require__(379);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 488 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(489),
    hasPath = __webpack_require__(325);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 489 */
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 490 */
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 491 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(492),
    basePropertyDeep = __webpack_require__(493),
    isKey = __webpack_require__(328),
    toKey = __webpack_require__(379);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),
/* 492 */
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),
/* 493 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(487);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),
/* 494 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(322));

var _propertyExpr = __webpack_require__(495);

var prefixes = {
  context: '$',
  value: '.'
};

var Reference =
/*#__PURE__*/
function () {
  function Reference(key, options) {
    if (options === void 0) {
      options = {};
    }

    if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);
    this.key = key.trim();
    if (key === '') throw new TypeError('ref must be a non-empty string');
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    var prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';
    this.path = this.key.slice(prefix.length);
    this.getter = this.path && (0, _propertyExpr.getter)(this.path, true);
    this.map = options.map;
  }

  var _proto = Reference.prototype;

  _proto.getValue = function getValue(options) {
    var result = this.isContext ? options.context : this.isValue ? options.value : options.parent;
    if (this.getter) result = this.getter(result || {});
    if (this.map) result = this.map(result);
    return result;
  };

  _proto.cast = function cast(value, options) {
    return this.getValue((0, _extends2.default)({}, options, {
      value: value
    }));
  };

  _proto.resolve = function resolve() {
    return this;
  };

  _proto.describe = function describe() {
    return {
      type: 'ref',
      key: this.key
    };
  };

  _proto.toString = function toString() {
    return "Ref(" + this.key + ")";
  };

  Reference.isRef = function isRef(value) {
    return value && value.__isYupRef;
  };

  return Reference;
}();

exports.default = Reference;
Reference.prototype.__isYupRef = true;
module.exports = exports["default"];

/***/ }),
/* 495 */
/***/ ((module) => {

"use strict";
/**
 * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
 */


function Cache(maxSize) {
  this._maxSize = maxSize
  this.clear()
}
Cache.prototype.clear = function() {
  this._size = 0
  this._values = {}
}
Cache.prototype.get = function(key) {
  return this._values[key]
}
Cache.prototype.set = function(key, value) {
  this._size >= this._maxSize && this.clear()
  if (!this._values.hasOwnProperty(key)) {
    this._size++
  }
  return this._values[key] = value
}

var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
  DIGIT_REGEX = /^\d+$/,
  LEAD_DIGIT_REGEX = /^\d/,
  SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
  CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/,
  MAX_CACHE_SIZE = 512

var contentSecurityPolicy = false,
  pathCache = new Cache(MAX_CACHE_SIZE),
  setCache = new Cache(MAX_CACHE_SIZE),
  getCache = new Cache(MAX_CACHE_SIZE)

try {
  new Function('')
} catch (error) {
  contentSecurityPolicy = true
}

module.exports = {
  Cache: Cache,

  expr: expr,

  split: split,

  normalizePath: normalizePath,

  setter: contentSecurityPolicy
    ? function(path) {
      var parts = normalizePath(path)
      return function(data, value) {
        return setterFallback(parts, data, value)
      }
    }
    : function(path) {
      return setCache.get(path) || setCache.set(
        path,
        new Function(
          'data, value',
          expr(path, 'data') + ' = value'
        )
      )
    },

  getter: contentSecurityPolicy
    ? function(path, safe) {
      var parts = normalizePath(path)
      return function(data) {
        return getterFallback(parts, safe, data)
      }
    }
    : function(path, safe) {
      var key = path + '_' + safe
      return getCache.get(key) || getCache.set(
        key,
        new Function('data', 'return ' + expr(path, safe, 'data'))
      )
    },

  join: function(segments) {
    return segments.reduce(function(path, part) {
      return (
        path +
        (isQuoted(part) || DIGIT_REGEX.test(part)
          ? '[' + part + ']'
          : (path ? '.' : '') + part)
      )
    }, '')
  },

  forEach: function(path, cb, thisArg) {
    forEach(split(path), cb, thisArg)
  }
}

function setterFallback(parts, data, value) {
  var index = 0,
    len = parts.length
  while (index < len - 1) {
    data = data[parts[index++]]
  }
  data[parts[index]] = value
}

function getterFallback(parts, safe, data) {
  var index = 0,
    len = parts.length
  while (index < len) {
    if (data != null || !safe) {
      data = data[parts[index++]]
    } else {
      return
    }
  }
  return data
}

function normalizePath(path) {
  return pathCache.get(path) || pathCache.set(
    path,
    split(path).map(function(part) {
      return part.replace(CLEAN_QUOTES_REGEX, '$2')
    })
  )
}

function split(path) {
  return path.match(SPLIT_REGEX)
}

function expr(expression, safe, param) {
  expression = expression || ''

  if (typeof safe === 'string') {
    param = safe
    safe = false
  }

  param = param || 'data'

  if (expression && expression.charAt(0) !== '[') expression = '.' + expression

  return safe ? makeSafe(expression, param) : param + expression
}

function forEach(parts, iter, thisArg) {
  var len = parts.length,
    part,
    idx,
    isArray,
    isBracket

  for (idx = 0; idx < len; idx++) {
    part = parts[idx]

    if (part) {
      if (shouldBeQuoted(part)) {
        part = '"' + part + '"'
      }

      isBracket = isQuoted(part)
      isArray = !isBracket && /^\d+$/.test(part)

      iter.call(thisArg, part, isBracket, isArray, idx, parts)
    }
  }
}

function isQuoted(str) {
  return (
    typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1
  )
}

function makeSafe(path, param) {
  var result = param,
    parts = split(path),
    isLast

  forEach(parts, function(part, isBracket, isArray, idx, parts) {
    isLast = idx === parts.length - 1

    part = isBracket || isArray ? '[' + part + ']' : '.' + part

    result += part + (!isLast ? ' || {})' : ')')
  })

  return new Array(parts.length + 1).join('(') + result
}

function hasLeadingNumber(part) {
  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)
}

function hasSpecialChars(part) {
  return SPEC_CHAR_REGEX.test(part)
}

function shouldBeQuoted(part) {
  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))
}


/***/ }),
/* 496 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.getIn = getIn;
exports.default = void 0;

var _propertyExpr = __webpack_require__(495);

var _has = _interopRequireDefault(__webpack_require__(323));

var trim = function trim(part) {
  return part.substr(0, part.length - 1).substr(1);
};

function getIn(schema, path, value, context) {
  var parent, lastPart, lastPartDebug; // if only one "value" arg then use it for both

  context = context || value;
  if (!path) return {
    parent: parent,
    parentPath: path,
    schema: schema
  };
  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {
    var part = isBracket ? trim(_part) : _part;

    if (isArray || (0, _has.default)(schema, '_subType')) {
      // we skipped an array: foo[].bar
      var idx = isArray ? parseInt(part, 10) : 0;
      schema = schema.resolve({
        context: context,
        parent: parent,
        value: value
      })._subType;

      if (value) {
        if (isArray && idx >= value.length) {
          throw new Error("Yup.reach cannot resolve an array item at index: " + _part + ", in the path: " + path + ". " + "because there is no value at that index. ");
        }

        value = value[idx];
      }
    }

    if (!isArray) {
      schema = schema.resolve({
        context: context,
        parent: parent,
        value: value
      });
      if (!(0, _has.default)(schema, 'fields') || !(0, _has.default)(schema.fields, part)) throw new Error("The schema does not contain the path: " + path + ". " + ("(failed at: " + lastPartDebug + " which is a type: \"" + schema._type + "\") "));
      schema = schema.fields[part];
      parent = value;
      value = value && value[part];
      lastPart = part;
      lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
    }
  });
  return {
    schema: schema,
    parent: parent,
    parentPath: lastPart
  };
}

var reach = function reach(obj, path, value, context) {
  return getIn(obj, path, value, context).schema;
};

var _default = reach;
exports.default = _default;

/***/ }),
/* 497 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = void 0;

var _inherits = _interopRequireDefault(__webpack_require__(498));

var _mixed = _interopRequireDefault(__webpack_require__(321));

var _default = BooleanSchema;
exports.default = _default;

function BooleanSchema() {
  var _this = this;

  if (!(this instanceof BooleanSchema)) return new BooleanSchema();

  _mixed.default.call(this, {
    type: 'boolean'
  });

  this.withMutation(function () {
    _this.transform(function (value) {
      if (!this.isType(value)) {
        if (/^(true|1)$/i.test(value)) return true;
        if (/^(false|0)$/i.test(value)) return false;
      }

      return value;
    });
  });
}

(0, _inherits.default)(BooleanSchema, _mixed.default, {
  _typeCheck: function _typeCheck(v) {
    if (v instanceof Boolean) v = v.valueOf();
    return typeof v === 'boolean';
  }
});
module.exports = exports["default"];

/***/ }),
/* 498 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = inherits;

var _extends2 = _interopRequireDefault(__webpack_require__(322));

function inherits(ctor, superCtor, spec) {
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  (0, _extends2.default)(ctor.prototype, spec);
}

module.exports = exports["default"];

/***/ }),
/* 499 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = StringSchema;

var _inherits = _interopRequireDefault(__webpack_require__(498));

var _mixed = _interopRequireDefault(__webpack_require__(321));

var _locale = __webpack_require__(455);

var _isAbsent = _interopRequireDefault(__webpack_require__(500));

// eslint-disable-next-line
var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i; // eslint-disable-next-line

var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;

var isTrimmed = function isTrimmed(value) {
  return (0, _isAbsent.default)(value) || value === value.trim();
};

function StringSchema() {
  var _this = this;

  if (!(this instanceof StringSchema)) return new StringSchema();

  _mixed.default.call(this, {
    type: 'string'
  });

  this.withMutation(function () {
    _this.transform(function (value) {
      if (this.isType(value)) return value;
      return value != null && value.toString ? value.toString() : value;
    });
  });
}

(0, _inherits.default)(StringSchema, _mixed.default, {
  _typeCheck: function _typeCheck(value) {
    if (value instanceof String) value = value.valueOf();
    return typeof value === 'string';
  },
  _isPresent: function _isPresent(value) {
    return _mixed.default.prototype._cast.call(this, value) && value.length > 0;
  },
  length: function length(_length, message) {
    if (message === void 0) {
      message = _locale.string.length;
    }

    return this.test({
      message: message,
      name: 'length',
      exclusive: true,
      params: {
        length: _length
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length === this.resolve(_length);
      }
    });
  },
  min: function min(_min, message) {
    if (message === void 0) {
      message = _locale.string.min;
    }

    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        min: _min
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length >= this.resolve(_min);
      }
    });
  },
  max: function max(_max, message) {
    if (message === void 0) {
      message = _locale.string.max;
    }

    return this.test({
      name: 'max',
      exclusive: true,
      message: message,
      params: {
        max: _max
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length <= this.resolve(_max);
      }
    });
  },
  matches: function matches(regex, options) {
    var excludeEmptyString = false;
    var message;

    if (options) {
      if (options.message || options.hasOwnProperty('excludeEmptyString')) {
        excludeEmptyString = options.excludeEmptyString;
        message = options.message;
      } else message = options;
    }

    return this.test({
      message: message || _locale.string.matches,
      params: {
        regex: regex
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value === '' && excludeEmptyString || regex.test(value);
      }
    });
  },
  email: function email(message) {
    if (message === void 0) {
      message = _locale.string.email;
    }

    return this.matches(rEmail, {
      message: message,
      excludeEmptyString: true
    });
  },
  url: function url(message) {
    if (message === void 0) {
      message = _locale.string.url;
    }

    return this.matches(rUrl, {
      message: message,
      excludeEmptyString: true
    });
  },
  //-- transforms --
  ensure: function ensure() {
    return this.default('').transform(function (val) {
      return val === null ? '' : val;
    });
  },
  trim: function trim(message) {
    if (message === void 0) {
      message = _locale.string.trim;
    }

    return this.transform(function (val) {
      return val != null ? val.trim() : val;
    }).test({
      message: message,
      name: 'trim',
      test: isTrimmed
    });
  },
  lowercase: function lowercase(message) {
    if (message === void 0) {
      message = _locale.string.lowercase;
    }

    return this.transform(function (value) {
      return !(0, _isAbsent.default)(value) ? value.toLowerCase() : value;
    }).test({
      message: message,
      name: 'string_case',
      exclusive: true,
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value === value.toLowerCase();
      }
    });
  },
  uppercase: function uppercase(message) {
    if (message === void 0) {
      message = _locale.string.uppercase;
    }

    return this.transform(function (value) {
      return !(0, _isAbsent.default)(value) ? value.toUpperCase() : value;
    }).test({
      message: message,
      name: 'string_case',
      exclusive: true,
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value === value.toUpperCase();
      }
    });
  }
});
module.exports = exports["default"];

/***/ }),
/* 500 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = void 0;

var _default = function _default(value) {
  return value == null;
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 501 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = NumberSchema;

var _inherits = _interopRequireDefault(__webpack_require__(498));

var _mixed = _interopRequireDefault(__webpack_require__(321));

var _locale = __webpack_require__(455);

var _isAbsent = _interopRequireDefault(__webpack_require__(500));

var isNaN = function isNaN(value) {
  return value != +value;
};

var isInteger = function isInteger(val) {
  return (0, _isAbsent.default)(val) || val === (val | 0);
};

function NumberSchema() {
  var _this = this;

  if (!(this instanceof NumberSchema)) return new NumberSchema();

  _mixed.default.call(this, {
    type: 'number'
  });

  this.withMutation(function () {
    _this.transform(function (value) {
      var parsed = value;

      if (typeof parsed === 'string') {
        parsed = parsed.replace(/\s/g, '');
        if (parsed === '') return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings

        parsed = +parsed;
      }

      if (this.isType(parsed)) return parsed;
      return parseFloat(parsed);
    });
  });
}

(0, _inherits.default)(NumberSchema, _mixed.default, {
  _typeCheck: function _typeCheck(value) {
    if (value instanceof Number) value = value.valueOf();
    return typeof value === 'number' && !isNaN(value);
  },
  min: function min(_min, message) {
    if (message === void 0) {
      message = _locale.number.min;
    }

    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        min: _min
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value >= this.resolve(_min);
      }
    });
  },
  max: function max(_max, message) {
    if (message === void 0) {
      message = _locale.number.max;
    }

    return this.test({
      message: message,
      name: 'max',
      exclusive: true,
      params: {
        max: _max
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value <= this.resolve(_max);
      }
    });
  },
  lessThan: function lessThan(less, message) {
    if (message === void 0) {
      message = _locale.number.lessThan;
    }

    return this.test({
      message: message,
      name: 'max',
      exclusive: true,
      params: {
        less: less
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value < this.resolve(less);
      }
    });
  },
  moreThan: function moreThan(more, message) {
    if (message === void 0) {
      message = _locale.number.moreThan;
    }

    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        more: more
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value > this.resolve(more);
      }
    });
  },
  positive: function positive(msg) {
    if (msg === void 0) {
      msg = _locale.number.positive;
    }

    return this.moreThan(0, msg);
  },
  negative: function negative(msg) {
    if (msg === void 0) {
      msg = _locale.number.negative;
    }

    return this.lessThan(0, msg);
  },
  integer: function integer(message) {
    if (message === void 0) {
      message = _locale.number.integer;
    }

    return this.test({
      name: 'integer',
      message: message,
      test: isInteger
    });
  },
  truncate: function truncate() {
    return this.transform(function (value) {
      return !(0, _isAbsent.default)(value) ? value | 0 : value;
    });
  },
  round: function round(method) {
    var avail = ['ceil', 'floor', 'round', 'trunc'];
    method = method && method.toLowerCase() || 'round'; // this exists for symemtry with the new Math.trunc

    if (method === 'trunc') return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
    return this.transform(function (value) {
      return !(0, _isAbsent.default)(value) ? Math[method](value) : value;
    });
  }
});
module.exports = exports["default"];

/***/ }),
/* 502 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = void 0;

var _mixed = _interopRequireDefault(__webpack_require__(321));

var _inherits = _interopRequireDefault(__webpack_require__(498));

var _isodate = _interopRequireDefault(__webpack_require__(503));

var _locale = __webpack_require__(455);

var _isAbsent = _interopRequireDefault(__webpack_require__(500));

var _Reference = _interopRequireDefault(__webpack_require__(494));

var invalidDate = new Date('');

var isDate = function isDate(obj) {
  return Object.prototype.toString.call(obj) === '[object Date]';
};

var _default = DateSchema;
exports.default = _default;

function DateSchema() {
  var _this = this;

  if (!(this instanceof DateSchema)) return new DateSchema();

  _mixed.default.call(this, {
    type: 'date'
  });

  this.withMutation(function () {
    _this.transform(function (value) {
      if (this.isType(value)) return value;
      value = (0, _isodate.default)(value);
      return value ? new Date(value) : invalidDate;
    });
  });
}

(0, _inherits.default)(DateSchema, _mixed.default, {
  _typeCheck: function _typeCheck(v) {
    return isDate(v) && !isNaN(v.getTime());
  },
  min: function min(_min, message) {
    if (message === void 0) {
      message = _locale.date.min;
    }

    var limit = _min;

    if (!_Reference.default.isRef(limit)) {
      limit = this.cast(_min);
      if (!this._typeCheck(limit)) throw new TypeError('`min` must be a Date or a value that can be `cast()` to a Date');
    }

    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        min: _min
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value >= this.resolve(limit);
      }
    });
  },
  max: function max(_max, message) {
    if (message === void 0) {
      message = _locale.date.max;
    }

    var limit = _max;

    if (!_Reference.default.isRef(limit)) {
      limit = this.cast(_max);
      if (!this._typeCheck(limit)) throw new TypeError('`max` must be a Date or a value that can be `cast()` to a Date');
    }

    return this.test({
      message: message,
      name: 'max',
      exclusive: true,
      params: {
        max: _max
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value <= this.resolve(limit);
      }
    });
  }
});
module.exports = exports["default"];

/***/ }),
/* 503 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = parseIsoDate;

/* eslint-disable */

/**
 *
 * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
 * NON-CONFORMANT EDITION.
 *  2011 Colin Snover <http://zetafleet.com>
 * Released under MIT license.
 */
//              1 YYYY                 2 MM        3 DD              4 HH     5 mm        6 ss            7 msec         8 Z 9     10 tzHH    11 tzmm
var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;

function parseIsoDate(date) {
  var numericKeys = [1, 4, 5, 6, 7, 10, 11],
      minutesOffset = 0,
      timestamp,
      struct;

  if (struct = isoReg.exec(date)) {
    // avoid NaN timestamps caused by undefined values being passed to Date.UTC
    for (var i = 0, k; k = numericKeys[i]; ++i) {
      struct[k] = +struct[k] || 0;
    } // allow undefined days and months


    struct[2] = (+struct[2] || 1) - 1;
    struct[3] = +struct[3] || 1; // allow arbitrary sub-second precision beyond milliseconds

    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0; // timestamps without timezone identifiers should be considered local time

    if ((struct[8] === undefined || struct[8] === '') && (struct[9] === undefined || struct[9] === '')) timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);else {
      if (struct[8] !== 'Z' && struct[9] !== undefined) {
        minutesOffset = struct[10] * 60 + struct[11];
        if (struct[9] === '+') minutesOffset = 0 - minutesOffset;
      }

      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
    }
  } else timestamp = Date.parse ? Date.parse(date) : NaN;

  return timestamp;
}

module.exports = exports["default"];

/***/ }),
/* 504 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = __webpack_require__(505);

var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = ObjectSchema;

var _taggedTemplateLiteralLoose2 = _interopRequireDefault(__webpack_require__(507));

var _extends2 = _interopRequireDefault(__webpack_require__(322));

var _has = _interopRequireDefault(__webpack_require__(323));

var _snakeCase2 = _interopRequireDefault(__webpack_require__(508));

var _camelCase2 = _interopRequireDefault(__webpack_require__(518));

var _mapKeys = _interopRequireDefault(__webpack_require__(524));

var _mapValues = _interopRequireDefault(__webpack_require__(465));

var _propertyExpr = __webpack_require__(495);

var _mixed = _interopRequireDefault(__webpack_require__(321));

var _locale = __webpack_require__(455);

var _sortFields = _interopRequireDefault(__webpack_require__(525));

var _sortByKeyOrder = _interopRequireDefault(__webpack_require__(527));

var _inherits = _interopRequireDefault(__webpack_require__(498));

var _makePath = _interopRequireDefault(__webpack_require__(528));

var _runValidations = _interopRequireWildcard(__webpack_require__(459));

function _templateObject2() {
  var data = (0, _taggedTemplateLiteralLoose2.default)(["", ".", ""]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0, _taggedTemplateLiteralLoose2.default)(["", ".", ""]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var isObject = function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
};

function unknown(ctx, value) {
  var known = Object.keys(ctx.fields);
  return Object.keys(value).filter(function (key) {
    return known.indexOf(key) === -1;
  });
}

function ObjectSchema(spec) {
  var _this2 = this;

  if (!(this instanceof ObjectSchema)) return new ObjectSchema(spec);

  _mixed.default.call(this, {
    type: 'object',
    default: function _default() {
      var _this = this;

      if (!this._nodes.length) return undefined;
      var dft = {};

      this._nodes.forEach(function (key) {
        dft[key] = _this.fields[key].default ? _this.fields[key].default() : undefined;
      });

      return dft;
    }
  });

  this.fields = Object.create(null);
  this._nodes = [];
  this._excludedEdges = [];
  this.withMutation(function () {
    _this2.transform(function coerce(value) {
      if (typeof value === 'string') {
        try {
          value = JSON.parse(value);
        } catch (err) {
          value = null;
        }
      }

      if (this.isType(value)) return value;
      return null;
    });

    if (spec) {
      _this2.shape(spec);
    }
  });
}

(0, _inherits.default)(ObjectSchema, _mixed.default, {
  _typeCheck: function _typeCheck(value) {
    return isObject(value) || typeof value === 'function';
  },
  _cast: function _cast(_value, options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    var value = _mixed.default.prototype._cast.call(this, _value, options); //should ignore nulls here


    if (value === undefined) return this.default();
    if (!this._typeCheck(value)) return value;
    var fields = this.fields;
    var strip = this._option('stripUnknown', options) === true;

    var props = this._nodes.concat(Object.keys(value).filter(function (v) {
      return _this3._nodes.indexOf(v) === -1;
    }));

    var intermediateValue = {}; // is filled during the transform below

    var innerOptions = (0, _extends2.default)({}, options, {
      parent: intermediateValue,
      __validating: false
    });
    var isChanged = false;
    props.forEach(function (prop) {
      var field = fields[prop];
      var exists = (0, _has.default)(value, prop);

      if (field) {
        var fieldValue;
        var strict = field._options && field._options.strict; // safe to mutate since this is fired in sequence

        innerOptions.path = (0, _makePath.default)(_templateObject(), options.path, prop);
        innerOptions.value = value[prop];
        field = field.resolve(innerOptions);

        if (field._strip === true) {
          isChanged = isChanged || prop in value;
          return;
        }

        fieldValue = !options.__validating || !strict ? field.cast(value[prop], innerOptions) : value[prop];
        if (fieldValue !== undefined) intermediateValue[prop] = fieldValue;
      } else if (exists && !strip) intermediateValue[prop] = value[prop];

      if (intermediateValue[prop] !== value[prop]) isChanged = true;
    });
    return isChanged ? intermediateValue : value;
  },
  _validate: function _validate(_value, opts) {
    var _this4 = this;

    if (opts === void 0) {
      opts = {};
    }

    var endEarly, recursive;
    var sync = opts.sync;
    var errors = [];
    var originalValue = opts.originalValue != null ? opts.originalValue : _value;
    endEarly = this._option('abortEarly', opts);
    recursive = this._option('recursive', opts);
    opts = (0, _extends2.default)({}, opts, {
      __validating: true,
      originalValue: originalValue
    });
    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {
      if (!recursive || !isObject(value)) {
        // only iterate though actual objects
        if (errors.length) throw errors[0];
        return value;
      }

      originalValue = originalValue || value;

      var validations = _this4._nodes.map(function (key) {
        var path = (0, _makePath.default)(_templateObject2(), opts.path, key);
        var field = _this4.fields[key];
        var innerOptions = (0, _extends2.default)({}, opts, {
          path: path,
          parent: value,
          originalValue: originalValue[key]
        });

        if (field && field.validate) {
          // inner fields are always strict:
          // 1. this isn't strict so the casting will also have cast inner values
          // 2. this is strict in which case the nested values weren't cast either
          innerOptions.strict = true;
          return field.validate(value[key], innerOptions);
        }

        return Promise.resolve(true);
      });

      return (0, _runValidations.default)({
        sync: sync,
        validations: validations,
        value: value,
        errors: errors,
        endEarly: endEarly,
        path: opts.path,
        sort: (0, _sortByKeyOrder.default)(_this4.fields)
      });
    });
  },
  concat: function concat(schema) {
    var next = _mixed.default.prototype.concat.call(this, schema);

    next._nodes = (0, _sortFields.default)(next.fields, next._excludedEdges);
    return next;
  },
  shape: function shape(schema, excludes) {
    if (excludes === void 0) {
      excludes = [];
    }

    var next = this.clone();
    var fields = (0, _extends2.default)(next.fields, schema);
    next.fields = fields;

    if (excludes.length) {
      if (!Array.isArray(excludes[0])) excludes = [excludes];
      var keys = excludes.map(function (_ref) {
        var first = _ref[0],
            second = _ref[1];
        return first + "-" + second;
      });
      next._excludedEdges = next._excludedEdges.concat(keys);
    }

    next._nodes = (0, _sortFields.default)(fields, next._excludedEdges);
    return next;
  },
  from: function from(_from, to, alias) {
    var fromGetter = (0, _propertyExpr.getter)(_from, true);
    return this.transform(function (obj) {
      if (obj == null) return obj;
      var newObj = obj;

      if ((0, _has.default)(obj, _from)) {
        newObj = (0, _extends2.default)({}, obj);
        if (!alias) delete newObj[_from];
        newObj[to] = fromGetter(obj);
      }

      return newObj;
    });
  },
  noUnknown: function noUnknown(noAllow, message) {
    if (noAllow === void 0) {
      noAllow = true;
    }

    if (message === void 0) {
      message = _locale.object.noUnknown;
    }

    if (typeof noAllow === 'string') {
      message = noAllow;
      noAllow = true;
    }

    var next = this.test({
      name: 'noUnknown',
      exclusive: true,
      message: message,
      test: function test(value) {
        return value == null || !noAllow || unknown(this.schema, value).length === 0;
      }
    });
    next._options.stripUnknown = noAllow;
    return next;
  },
  unknown: function unknown(allow, message) {
    if (allow === void 0) {
      allow = true;
    }

    if (message === void 0) {
      message = _locale.object.noUnknown;
    }

    return this.noUnknown(!allow, message);
  },
  transformKeys: function transformKeys(fn) {
    return this.transform(function (obj) {
      return obj && (0, _mapKeys.default)(obj, function (_, key) {
        return fn(key);
      });
    });
  },
  camelCase: function camelCase() {
    return this.transformKeys(_camelCase2.default);
  },
  snakeCase: function snakeCase() {
    return this.transformKeys(_snakeCase2.default);
  },
  constantCase: function constantCase() {
    return this.transformKeys(function (key) {
      return (0, _snakeCase2.default)(key).toUpperCase();
    });
  },
  describe: function describe() {
    var base = _mixed.default.prototype.describe.call(this);

    base.fields = (0, _mapValues.default)(this.fields, function (value) {
      return value.describe();
    });
    return base;
  }
});
module.exports = exports["default"];

/***/ }),
/* 505 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = __webpack_require__(506);

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),
/* 506 */
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 507 */
/***/ ((module) => {

function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  strings.raw = raw;
  return strings;
}

module.exports = _taggedTemplateLiteralLoose;

/***/ }),
/* 508 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createCompounder = __webpack_require__(509);

/**
 * Converts `string` to
 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the snake cased string.
 * @example
 *
 * _.snakeCase('Foo Bar');
 * // => 'foo_bar'
 *
 * _.snakeCase('fooBar');
 * // => 'foo_bar'
 *
 * _.snakeCase('--FOO-BAR--');
 * // => 'foo_bar'
 */
var snakeCase = createCompounder(function(result, word, index) {
  return result + (index ? '_' : '') + word.toLowerCase();
});

module.exports = snakeCase;


/***/ }),
/* 509 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__(510),
    deburr = __webpack_require__(511),
    words = __webpack_require__(514);

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;


/***/ }),
/* 510 */
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),
/* 511 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var deburrLetter = __webpack_require__(512),
    toString = __webpack_require__(372);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 512 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePropertyOf = __webpack_require__(513);

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;


/***/ }),
/* 513 */
/***/ ((module) => {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),
/* 514 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiWords = __webpack_require__(515),
    hasUnicodeWord = __webpack_require__(516),
    toString = __webpack_require__(372),
    unicodeWords = __webpack_require__(517);

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 515 */
/***/ ((module) => {

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;


/***/ }),
/* 516 */
/***/ ((module) => {

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;


/***/ }),
/* 517 */
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;


/***/ }),
/* 518 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var capitalize = __webpack_require__(519),
    createCompounder = __webpack_require__(509);

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

module.exports = camelCase;


/***/ }),
/* 519 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(372),
    upperFirst = __webpack_require__(520);

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;


/***/ }),
/* 520 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createCaseFirst = __webpack_require__(521);

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;


/***/ }),
/* 521 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castSlice = __webpack_require__(522),
    hasUnicode = __webpack_require__(451),
    stringToArray = __webpack_require__(449),
    toString = __webpack_require__(372);

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;


/***/ }),
/* 522 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSlice = __webpack_require__(523);

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;


/***/ }),
/* 523 */
/***/ ((module) => {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),
/* 524 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(390),
    baseForOwn = __webpack_require__(466),
    baseIteratee = __webpack_require__(469);

/**
 * The opposite of `_.mapValues`; this method creates an object with the
 * same values as `object` and keys generated by running each own enumerable
 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
 * with three arguments: (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapValues
 * @example
 *
 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
 *   return key + value;
 * });
 * // => { 'a1': 1, 'b2': 2 }
 */
function mapKeys(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, iteratee(value, key, object), value);
  });
  return result;
}

module.exports = mapKeys;


/***/ }),
/* 525 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = sortFields;

var _has = _interopRequireDefault(__webpack_require__(323));

var _toposort = _interopRequireDefault(__webpack_require__(526));

var _propertyExpr = __webpack_require__(495);

var _Reference = _interopRequireDefault(__webpack_require__(494));

var _isSchema = _interopRequireDefault(__webpack_require__(458));

function sortFields(fields, excludes) {
  if (excludes === void 0) {
    excludes = [];
  }

  var edges = [],
      nodes = [];

  function addNode(depPath, key) {
    var node = (0, _propertyExpr.split)(depPath)[0];
    if (!~nodes.indexOf(node)) nodes.push(node);
    if (!~excludes.indexOf(key + "-" + node)) edges.push([key, node]);
  }

  for (var key in fields) {
    if ((0, _has.default)(fields, key)) {
      var value = fields[key];
      if (!~nodes.indexOf(key)) nodes.push(key);
      if (_Reference.default.isRef(value) && value.isSibling) addNode(value.path, key);else if ((0, _isSchema.default)(value) && value._deps) value._deps.forEach(function (path) {
        return addNode(path, key);
      });
    }
  }

  return _toposort.default.array(nodes, edges).reverse();
}

module.exports = exports["default"];

/***/ }),
/* 526 */
/***/ ((module) => {


/**
 * Topological sorting function
 *
 * @param {Array} edges
 * @returns {Array}
 */

module.exports = function(edges) {
  return toposort(uniqueNodes(edges), edges)
}

module.exports.array = toposort

function toposort(nodes, edges) {
  var cursor = nodes.length
    , sorted = new Array(cursor)
    , visited = {}
    , i = cursor
    // Better data structures make algorithm much faster.
    , outgoingEdges = makeOutgoingEdges(edges)
    , nodesHash = makeNodesHash(nodes)

  // check for unknown nodes
  edges.forEach(function(edge) {
    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
      throw new Error('Unknown node. There is an unknown node in the supplied edges.')
    }
  })

  while (i--) {
    if (!visited[i]) visit(nodes[i], i, new Set())
  }

  return sorted

  function visit(node, i, predecessors) {
    if(predecessors.has(node)) {
      var nodeRep
      try {
        nodeRep = ", node was:" + JSON.stringify(node)
      } catch(e) {
        nodeRep = ""
      }
      throw new Error('Cyclic dependency' + nodeRep)
    }

    if (!nodesHash.has(node)) {
      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))
    }

    if (visited[i]) return;
    visited[i] = true

    var outgoing = outgoingEdges.get(node) || new Set()
    outgoing = Array.from(outgoing)

    if (i = outgoing.length) {
      predecessors.add(node)
      do {
        var child = outgoing[--i]
        visit(child, nodesHash.get(child), predecessors)
      } while (i)
      predecessors.delete(node)
    }

    sorted[--cursor] = node
  }
}

function uniqueNodes(arr){
  var res = new Set()
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i]
    res.add(edge[0])
    res.add(edge[1])
  }
  return Array.from(res)
}

function makeOutgoingEdges(arr){
  var edges = new Map()
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i]
    if (!edges.has(edge[0])) edges.set(edge[0], new Set())
    if (!edges.has(edge[1])) edges.set(edge[1], new Set())
    edges.get(edge[0]).add(edge[1])
  }
  return edges
}

function makeNodesHash(arr){
  var res = new Map()
  for (var i = 0, len = arr.length; i < len; i++) {
    res.set(arr[i], i)
  }
  return res
}


/***/ }),
/* 527 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = sortByKeyOrder;

function findIndex(arr, err) {
  var idx = Infinity;
  arr.some(function (key, ii) {
    if (err.path.indexOf(key) !== -1) {
      idx = ii;
      return true;
    }
  });
  return idx;
}

function sortByKeyOrder(fields) {
  var keys = Object.keys(fields);
  return function (a, b) {
    return findIndex(keys, a) - findIndex(keys, b);
  };
}

module.exports = exports["default"];

/***/ }),
/* 528 */
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports.default = makePath;

function makePath(strings) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }

  var path = strings.reduce(function (str, next) {
    var value = values.shift();
    return str + (value == null ? '' : value) + next;
  });
  return path.replace(/^\./, '');
}

module.exports = exports["default"];

/***/ }),
/* 529 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireWildcard = __webpack_require__(505);

var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(322));

var _taggedTemplateLiteralLoose2 = _interopRequireDefault(__webpack_require__(507));

var _inherits = _interopRequireDefault(__webpack_require__(498));

var _isAbsent = _interopRequireDefault(__webpack_require__(500));

var _isSchema = _interopRequireDefault(__webpack_require__(458));

var _makePath = _interopRequireDefault(__webpack_require__(528));

var _printValue = _interopRequireDefault(__webpack_require__(456));

var _mixed = _interopRequireDefault(__webpack_require__(321));

var _locale = __webpack_require__(455);

var _runValidations = _interopRequireWildcard(__webpack_require__(459));

function _templateObject() {
  var data = (0, _taggedTemplateLiteralLoose2.default)(["", "[", "]"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var _default = ArraySchema;
exports.default = _default;

function ArraySchema(type) {
  var _this = this;

  if (!(this instanceof ArraySchema)) return new ArraySchema(type);

  _mixed.default.call(this, {
    type: 'array'
  }); // `undefined` specifically means uninitialized, as opposed to
  // "no subtype"


  this._subType = undefined;
  this.withMutation(function () {
    _this.transform(function (values) {
      if (typeof values === 'string') try {
        values = JSON.parse(values);
      } catch (err) {
        values = null;
      }
      return this.isType(values) ? values : null;
    });

    if (type) _this.of(type);
  });
}

(0, _inherits.default)(ArraySchema, _mixed.default, {
  _typeCheck: function _typeCheck(v) {
    return Array.isArray(v);
  },
  _cast: function _cast(_value, _opts) {
    var _this2 = this;

    var value = _mixed.default.prototype._cast.call(this, _value, _opts); //should ignore nulls here


    if (!this._typeCheck(value) || !this._subType) return value;
    var isChanged = false;
    var castArray = value.map(function (v) {
      var castElement = _this2._subType.cast(v, _opts);

      if (castElement !== v) {
        isChanged = true;
      }

      return castElement;
    });
    return isChanged ? castArray : value;
  },
  _validate: function _validate(_value, options) {
    var _this3 = this;

    if (options === void 0) {
      options = {};
    }

    var errors = [];
    var sync = options.sync;
    var path = options.path;
    var subType = this._subType;

    var endEarly = this._option('abortEarly', options);

    var recursive = this._option('recursive', options);

    var originalValue = options.originalValue != null ? options.originalValue : _value;
    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {
      if (!recursive || !subType || !_this3._typeCheck(value)) {
        if (errors.length) throw errors[0];
        return value;
      }

      originalValue = originalValue || value;
      var validations = value.map(function (item, idx) {
        var path = (0, _makePath.default)(_templateObject(), options.path, idx); // object._validate note for isStrict explanation

        var innerOptions = (0, _extends2.default)({}, options, {
          path: path,
          strict: true,
          parent: value,
          originalValue: originalValue[idx]
        });
        if (subType.validate) return subType.validate(item, innerOptions);
        return true;
      });
      return (0, _runValidations.default)({
        sync: sync,
        path: path,
        value: value,
        errors: errors,
        endEarly: endEarly,
        validations: validations
      });
    });
  },
  _isPresent: function _isPresent(value) {
    return _mixed.default.prototype._cast.call(this, value) && value.length > 0;
  },
  of: function of(schema) {
    var next = this.clone();
    if (schema !== false && !(0, _isSchema.default)(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema, or `false` to negate a current sub-schema. ' + 'not: ' + (0, _printValue.default)(schema));
    next._subType = schema;
    return next;
  },
  min: function min(_min, message) {
    message = message || _locale.array.min;
    return this.test({
      message: message,
      name: 'min',
      exclusive: true,
      params: {
        min: _min
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length >= this.resolve(_min);
      }
    });
  },
  max: function max(_max, message) {
    message = message || _locale.array.max;
    return this.test({
      message: message,
      name: 'max',
      exclusive: true,
      params: {
        max: _max
      },
      test: function test(value) {
        return (0, _isAbsent.default)(value) || value.length <= this.resolve(_max);
      }
    });
  },
  ensure: function ensure() {
    var _this4 = this;

    return this.default(function () {
      return [];
    }).transform(function (val) {
      if (_this4.isType(val)) return val;
      return val === null ? [] : [].concat(val);
    });
  },
  compact: function compact(rejector) {
    var reject = !rejector ? function (v) {
      return !!v;
    } : function (v, i, a) {
      return !rejector(v, i, a);
    };
    return this.transform(function (values) {
      return values != null ? values.filter(reject) : values;
    });
  },
  describe: function describe() {
    var base = _mixed.default.prototype.describe.call(this);

    if (this._subType) base.innerType = this._subType.describe();
    return base;
  }
});
module.exports = exports["default"];

/***/ }),
/* 530 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = void 0;

var _isSchema = _interopRequireDefault(__webpack_require__(458));

var Lazy =
/*#__PURE__*/
function () {
  function Lazy(mapFn) {
    this._resolve = function (value, options) {
      var schema = mapFn(value, options);
      if (!(0, _isSchema.default)(schema)) throw new TypeError('lazy() functions must return a valid schema');
      return schema.resolve(options);
    };
  }

  var _proto = Lazy.prototype;

  _proto.resolve = function resolve(options) {
    return this._resolve(options.value, options);
  };

  _proto.cast = function cast(value, options) {
    return this._resolve(value, options).cast(value, options);
  };

  _proto.validate = function validate(value, options) {
    return this._resolve(value, options).validate(value, options);
  };

  _proto.validateSync = function validateSync(value, options) {
    return this._resolve(value, options).validateSync(value, options);
  };

  _proto.validateAt = function validateAt(path, value, options) {
    return this._resolve(value, options).validateAt(path, value, options);
  };

  _proto.validateSyncAt = function validateSyncAt(path, value, options) {
    return this._resolve(value, options).validateSyncAt(path, value, options);
  };

  return Lazy;
}();

Lazy.prototype.__isYupSchema__ = true;
var _default = Lazy;
exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 531 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(320);

exports.__esModule = true;
exports.default = setLocale;

var _locale = _interopRequireDefault(__webpack_require__(455));

function setLocale(custom) {
  Object.keys(custom).forEach(function (type) {
    Object.keys(custom[type]).forEach(function (method) {
      _locale.default[type][method] = custom[type][method];
    });
  });
}

module.exports = exports["default"];

/***/ }),
/* 532 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "suggestUtils": () => /* reexport module object */ _suggestUtils__WEBPACK_IMPORTED_MODULE_30__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(11);
/* harmony import */ var _commands_add__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(533);
/* harmony import */ var _commands_bin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(579);
/* harmony import */ var _commands_cache_clean__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(580);
/* harmony import */ var _commands_config_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(581);
/* harmony import */ var _commands_config_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(582);
/* harmony import */ var _commands_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(586);
/* harmony import */ var _commands_entries_clipanion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(587);
/* harmony import */ var _commands_entries_help__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(589);
/* harmony import */ var _commands_entries_run__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(590);
/* harmony import */ var _commands_entries_version__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(591);
/* harmony import */ var _commands_exec__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(592);
/* harmony import */ var _commands_install__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(593);
/* harmony import */ var _commands_link__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(594);
/* harmony import */ var _commands_node__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(595);
/* harmony import */ var _commands_plugin_import_sources__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(596);
/* harmony import */ var _commands_plugin_import__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(599);
/* harmony import */ var _commands_plugin_list__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(601);
/* harmony import */ var _commands_plugin_remove__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(602);
/* harmony import */ var _commands_plugin_runtime__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(603);
/* harmony import */ var _commands_rebuild__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(604);
/* harmony import */ var _commands_remove__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(605);
/* harmony import */ var _commands_runIndex__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(606);
/* harmony import */ var _commands_run__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(607);
/* harmony import */ var _commands_set_resolution__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(608);
/* harmony import */ var _commands_set_version_sources__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(597);
/* harmony import */ var _commands_set_version__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(598);
/* harmony import */ var _commands_up__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(609);
/* harmony import */ var _commands_why__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(610);
/* harmony import */ var _commands_workspaces_list__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(612);
/* harmony import */ var _commands_workspace__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(613);
/* harmony import */ var _suggestUtils__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(578);

































const plugin = {
  configuration: {
    enableImmutableInstalls: {
      description: `If true, prevents the install command from modifying the lockfile`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_31__.SettingsType.BOOLEAN,
      default: false
    },
    defaultSemverRangePrefix: {
      description: `The default save prefix: '^', '~' or ''`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_31__.SettingsType.STRING,
      default: _suggestUtils__WEBPACK_IMPORTED_MODULE_30__.Modifier.CARET
    }
  },
  commands: [_commands_cache_clean__WEBPACK_IMPORTED_MODULE_2__.default, _commands_config_get__WEBPACK_IMPORTED_MODULE_3__.default, _commands_config_set__WEBPACK_IMPORTED_MODULE_4__.default, _commands_set_resolution__WEBPACK_IMPORTED_MODULE_23__.default, _commands_set_version_sources__WEBPACK_IMPORTED_MODULE_24__.default, _commands_set_version__WEBPACK_IMPORTED_MODULE_25__.default, _commands_workspaces_list__WEBPACK_IMPORTED_MODULE_28__.default, _commands_entries_clipanion__WEBPACK_IMPORTED_MODULE_6__.default, _commands_entries_help__WEBPACK_IMPORTED_MODULE_7__.default, _commands_entries_run__WEBPACK_IMPORTED_MODULE_8__.default, _commands_entries_version__WEBPACK_IMPORTED_MODULE_9__.default, _commands_add__WEBPACK_IMPORTED_MODULE_0__.default, _commands_bin__WEBPACK_IMPORTED_MODULE_1__.default, _commands_config__WEBPACK_IMPORTED_MODULE_5__.default, _commands_exec__WEBPACK_IMPORTED_MODULE_10__.default, _commands_install__WEBPACK_IMPORTED_MODULE_11__.default, _commands_link__WEBPACK_IMPORTED_MODULE_12__.default, _commands_node__WEBPACK_IMPORTED_MODULE_13__.default, _commands_plugin_import_sources__WEBPACK_IMPORTED_MODULE_14__.default, _commands_plugin_import__WEBPACK_IMPORTED_MODULE_15__.default, _commands_plugin_remove__WEBPACK_IMPORTED_MODULE_17__.default, _commands_plugin_list__WEBPACK_IMPORTED_MODULE_16__.default, _commands_plugin_runtime__WEBPACK_IMPORTED_MODULE_18__.default, _commands_rebuild__WEBPACK_IMPORTED_MODULE_19__.default, _commands_remove__WEBPACK_IMPORTED_MODULE_20__.default, _commands_runIndex__WEBPACK_IMPORTED_MODULE_21__.default, _commands_run__WEBPACK_IMPORTED_MODULE_22__.default, _commands_up__WEBPACK_IMPORTED_MODULE_26__.default, _commands_why__WEBPACK_IMPORTED_MODULE_27__.default, _commands_workspace__WEBPACK_IMPORTED_MODULE_29__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 533 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ AddCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(238);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(534);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(enquirer__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _suggestUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(578);







 // eslint-disable-next-line arca/no-default-export

class AddCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.packages = [];
    this.json = false;
    this.exact = false;
    this.tilde = false;
    this.caret = false;
    this.dev = false;
    this.peer = false;
    this.optional = false;
    this.preferDev = false;
    this.interactive = null;
    this.cached = false;
  }

  async execute() {
    var _a;

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const interactive = (_a = this.interactive) !== null && _a !== void 0 ? _a : configuration.get(`preferInteractive`);
    const modifier = _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.getModifier(this, project);
    const strategies = [...(interactive ? [_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.REUSE] : []), _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.PROJECT, ...(this.cached ? [_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.CACHE] : []), _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Strategy.LATEST];
    const maxResults = interactive ? Infinity : 1;
    const allSuggestions = await Promise.all(this.packages.map(async pseudoDescriptor => {
      const request = pseudoDescriptor.match(/^\.{0,2}\//) ? await _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.extractDescriptorFromPath(pseudoDescriptor, {
        cache,
        cwd: this.context.cwd,
        workspace
      }) : _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseDescriptor(pseudoDescriptor);
      const target = suggestTarget(workspace, request, {
        dev: this.dev,
        peer: this.peer,
        preferDev: this.preferDev,
        optional: this.optional
      });
      const suggestions = await _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.getSuggestedDescriptors(request, {
        project,
        workspace,
        cache,
        target,
        modifier,
        strategies,
        maxResults
      });
      return [request, suggestions, target];
    }));
    const checkReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LightReport.start({
      configuration,
      stdout: this.context.stdout,
      suggestInstall: false
    }, async report => {
      for (const [request, suggestions] of allSuggestions) {
        const nonNullSuggestions = suggestions.filter(suggestion => {
          return suggestion.descriptor !== null;
        });

        if (nonNullSuggestions.length === 0) {
          if (!project.configuration.get(`enableNetwork`)) {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyDescriptor(configuration, request)} can't be resolved to a satisfying range (note: network resolution has been disabled)`);
          } else {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyDescriptor(configuration, request)} can't be resolved to a satisfying range`);
          }
        }
      }
    });
    if (checkReport.hasErrors()) return checkReport.exitCode();
    let askedQuestions = false;
    const afterWorkspaceDependencyAdditionList = [];
    const afterWorkspaceDependencyReplacementList = [];

    for (const [,
    /*request*/
    suggestions, target] of allSuggestions) {
      let selected;
      const nonNullSuggestions = suggestions.filter(suggestion => {
        return suggestion.descriptor !== null;
      });
      const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
      const areAllTheSame = nonNullSuggestions.every(suggestion => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));

      if (nonNullSuggestions.length === 1 || areAllTheSame) {
        selected = firstSuggestedDescriptor;
      } else {
        askedQuestions = true;
        ({
          answer: selected
        } = await (0,enquirer__WEBPACK_IMPORTED_MODULE_2__.prompt)({
          type: `select`,
          name: `answer`,
          message: `Which range do you want to use?`,
          choices: suggestions.map(({
            descriptor,
            name,
            reason
          }) => descriptor ? {
            name,
            hint: reason,
            descriptor
          } : {
            name,
            hint: reason,
            disabled: true
          }),
          onCancel: () => process.exit(130),

          result(name) {
            // @ts-expect-error: The enquirer types don't include find
            return this.find(name, `descriptor`);
          },

          stdin: this.context.stdin,
          stdout: this.context.stdout
        }));
      }

      const current = workspace.manifest[target].get(selected.identHash);

      if (typeof current === `undefined` || current.descriptorHash !== selected.descriptorHash) {
        workspace.manifest[target].set(selected.identHash, selected);

        if (this.optional) {
          if (target === `dependencies`) {
            workspace.manifest.ensureDependencyMeta({ ...selected,
              range: `unknown`
            }).optional = true;
          } else if (target === `peerDependencies`) {
            workspace.manifest.ensurePeerDependencyMeta({ ...selected,
              range: `unknown`
            }).optional = true;
          }
        }

        if (typeof current === `undefined`) {
          afterWorkspaceDependencyAdditionList.push([workspace, target, selected, strategies]);
        } else {
          afterWorkspaceDependencyReplacementList.push([workspace, target, current, selected]);
        }
      }
    }

    await configuration.triggerMultipleHooks(hooks => hooks.afterWorkspaceDependencyAddition, afterWorkspaceDependencyAdditionList);
    await configuration.triggerMultipleHooks(hooks => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
    if (askedQuestions) this.context.stdout.write(`\n`);
    const installReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout,
      includeLogs: !this.context.quiet
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return installReport.exitCode();
  }

}
AddCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `add dependencies to the project`,
  details: `
      This command adds a package to the package.json for the nearest workspace.

      - If it didn't exist before, the package will by default be added to the regular \`dependencies\` field, but this behavior can be overriden thanks to the \`-D,--dev\` flag (which will cause the dependency to be added to the \`devDependencies\` field instead) and the \`-P,--peer\` flag (which will do the same but for \`peerDependencies\`).

      - If the package was already listed in your dependencies, it will by default be upgraded whether it's part of your \`dependencies\` or \`devDependencies\` (it won't ever update \`peerDependencies\`, though).

      - If set, the \`--prefer-dev\` flag will operate as a more flexible \`-D,--dev\` in that it will add the package to your \`devDependencies\` if it isn't already listed in either \`dependencies\` or \`devDependencies\`, but it will also happily upgrade your \`dependencies\` if that's what you already use (whereas \`-D,--dev\` would throw an exception).

      - If set, the \`-O,--optional\` flag will add the package to the \`optionalDependencies\` field and, in combination with the \`-P,--peer\` flag, it will add the package as an optional peer dependency. If the package was already listed in your \`dependencies\`, it will be upgraded to \`optionalDependencies\`. If the package was already listed in your \`peerDependencies\`, in combination with the \`-P,--peer\` flag, it will be upgraded to an optional peer dependency: \`"peerDependenciesMeta": { "<package>": { "optional": true } }\`

      - If the added package doesn't specify a range at all its \`latest\` tag will be resolved and the returned version will be used to generate a new semver range (using the \`^\` modifier by default unless otherwise configured via the \`savePrefix\` configuration, or the \`~\` modifier if \`-T,--tilde\` is specified, or no modifier at all if \`-E,--exact\` is specified). Two exceptions to this rule: the first one is that if the package is a workspace then its local version will be used, and the second one is that if you use \`-P,--peer\` the default range will be \`*\` and won't be resolved at all.

      - If the added package specifies a tag range (such as \`latest\` or \`rc\`), Yarn will resolve this tag to a semver version and use that in the resulting package.json entry (meaning that \`yarn add foo@latest\` will have exactly the same effect as \`yarn add foo\`).

      If the \`--cached\` option is used, Yarn will preferably reuse the highest version already used somewhere within the project, even if through a transitive dependency.

      If the \`-i,--interactive\` option is used (or if the \`preferInteractive\` settings is toggled on) the command will first try to check whether other workspaces in the project use the specified package and, if so, will offer to reuse them.

      If the \`--json\` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).

      For a compilation of all the supported protocols, please consult the dedicated page from our website: .
    `,
  examples: [[`Add a regular package to the current workspace`, `$0 add lodash`], [`Add a specific version for a package to the current workspace`, `$0 add lodash@1.2.3`], [`Add a package from a GitHub repository (the master branch) to the current workspace using a URL`, `$0 add lodash@https://github.com/lodash/lodash`], [`Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol`, `$0 add lodash@github:lodash/lodash`], [`Add a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol (shorthand)`, `$0 add lodash@lodash/lodash`], [`Add a package from a specific branch of a GitHub repository to the current workspace using the GitHub protocol (shorthand)`, `$0 add lodash-es@lodash/lodash#es`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], AddCommand.prototype, "packages", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], AddCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-E,--exact`)], AddCommand.prototype, "exact", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-T,--tilde`)], AddCommand.prototype, "tilde", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-C,--caret`)], AddCommand.prototype, "caret", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-D,--dev`)], AddCommand.prototype, "dev", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-P,--peer`)], AddCommand.prototype, "peer", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-O,--optional`)], AddCommand.prototype, "optional", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--prefer-dev`)], AddCommand.prototype, "preferDev", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-i,--interactive`)], AddCommand.prototype, "interactive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--cached`)], AddCommand.prototype, "cached", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`add`)], AddCommand.prototype, "execute", null);

function suggestTarget(workspace, ident, {
  dev,
  peer,
  preferDev,
  optional
}) {
  const hasRegular = workspace.manifest[_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.REGULAR].has(ident.identHash);
  const hasDev = workspace.manifest[_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.DEVELOPMENT].has(ident.identHash);
  const hasPeer = workspace.manifest[_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.PEER].has(ident.identHash);
  if ((dev || peer) && hasRegular) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyIdent(workspace.project.configuration, ident)}" is already listed as a regular dependency - remove the -D,-P flags or remove it from your dependencies first`);
  if (!dev && !peer && hasPeer) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - use either of -D or -P, or remove it from your peer dependencies first`);
  if (optional && hasDev) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyIdent(workspace.project.configuration, ident)}" is already listed as a dev dependency - remove the -O flag or remove it from your dev dependencies first`);
  if (optional && !peer && hasPeer) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyIdent(workspace.project.configuration, ident)}" is already listed as a peer dependency - remove the -O flag or add the -P flag or remove it from your peer dependencies first`);
  if ((dev || preferDev) && optional) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyIdent(workspace.project.configuration, ident)}" cannot simultaneously be a dev dependency and an optional dependency`);
  if (peer) return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.PEER;
  if (dev || preferDev) return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.DEVELOPMENT;
  if (hasRegular) return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.REGULAR;
  if (hasDev) return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.DEVELOPMENT;
  return _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.REGULAR;
}

/***/ }),
/* 534 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(280);
const Events = __webpack_require__(170);
const utils = __webpack_require__(535);

/**
 * Create an instance of `Enquirer`.
 *
 * ```js
 * const Enquirer = require('enquirer');
 * const enquirer = new Enquirer();
 * ```
 * @name Enquirer
 * @param {Object} `options` (optional) Options to use with all prompts.
 * @param {Object} `answers` (optional) Answers object to initialize with.
 * @api public
 */

class Enquirer extends Events {
  constructor(options, answers) {
    super();
    this.options = utils.merge({}, options);
    this.answers = { ...answers };
  }

  /**
   * Register a custom prompt type.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   * enquirer.register('customType', require('./custom-prompt'));
   * ```
   * @name register()
   * @param {String} `type`
   * @param {Function|Prompt} `fn` `Prompt` class, or a function that returns a `Prompt` class.
   * @return {Object} Returns the Enquirer instance
   * @api public
   */

  register(type, fn) {
    if (utils.isObject(type)) {
      for (let key of Object.keys(type)) this.register(key, type[key]);
      return this;
    }
    assert.equal(typeof fn, 'function', 'expected a function');
    let name = type.toLowerCase();
    if (fn.prototype instanceof this.Prompt) {
      this.prompts[name] = fn;
    } else {
      this.prompts[name] = fn(this.Prompt, this);
    }
    return this;
  }

  /**
   * Prompt function that takes a "question" object or array of question objects,
   * and returns an object with responses from the user.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   *
   * const response = await enquirer.prompt({
   *   type: 'input',
   *   name: 'username',
   *   message: 'What is your username?'
   * });
   * console.log(response);
   * ```
   * @name prompt()
   * @param {Array|Object} `questions` Options objects for one or more prompts to run.
   * @return {Promise} Promise that returns an "answers" object with the user's responses.
   * @api public
   */

  async prompt(questions = []) {
    for (let question of [].concat(questions)) {
      try {
        if (typeof question === 'function') question = await question.call(this);
        await this.ask(utils.merge({}, this.options, question));
      } catch (err) {
        return Promise.reject(err);
      }
    }
    return this.answers;
  }

  async ask(question) {
    if (typeof question === 'function') {
      question = await question.call(this);
    }

    let opts = utils.merge({}, this.options, question);
    let { type, name } = question;
    let { set, get } = utils;

    if (typeof type === 'function') {
      type = await type.call(this, question, this.answers);
    }

    if (!type) return this.answers[name];

    assert(this.prompts[type], `Prompt "${type}" is not registered`);

    let prompt = new this.prompts[type](opts);
    let value = get(this.answers, name);

    prompt.state.answers = this.answers;
    prompt.enquirer = this;

    if (name) {
      prompt.on('submit', value => {
        this.emit('answer', name, value, prompt);
        set(this.answers, name, value);
      });
    }

    // bubble events
    let emit = prompt.emit.bind(prompt);
    prompt.emit = (...args) => {
      this.emit.call(this, ...args);
      return emit(...args);
    };

    this.emit('prompt', prompt, this);

    if (opts.autofill && value != null) {
      prompt.value = prompt.input = value;

      // if "autofill=show" render the prompt, otherwise stay "silent"
      if (opts.autofill === 'show') {
        await prompt.submit();
      }
    } else {
      value = prompt.value = await prompt.run();
    }

    return value;
  }

  /**
   * Use an enquirer plugin.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   * const plugin = enquirer => {
   *   // do stuff to enquire instance
   * };
   * enquirer.use(plugin);
   * ```
   * @name use()
   * @param {Function} `plugin` Plugin function that takes an instance of Enquirer.
   * @return {Object} Returns the Enquirer instance.
   * @api public
   */

  use(plugin) {
    plugin.call(this, this);
    return this;
  }

  set Prompt(value) {
    this._Prompt = value;
  }
  get Prompt() {
    return this._Prompt || this.constructor.Prompt;
  }

  get prompts() {
    return this.constructor.prompts;
  }

  static set Prompt(value) {
    this._Prompt = value;
  }
  static get Prompt() {
    return this._Prompt || __webpack_require__(538);
  }

  static get prompts() {
    return __webpack_require__(548);
  }

  static get types() {
    return __webpack_require__(577);
  }

  /**
   * Prompt function that takes a "question" object or array of question objects,
   * and returns an object with responses from the user.
   *
   * ```js
   * const { prompt } = require('enquirer');
   * const response = await prompt({
   *   type: 'input',
   *   name: 'username',
   *   message: 'What is your username?'
   * });
   * console.log(response);
   * ```
   * @name Enquirer#prompt
   * @param {Array|Object} `questions` Options objects for one or more prompts to run.
   * @return {Promise} Promise that returns an "answers" object with the user's responses.
   * @api public
   */

  static get prompt() {
    const fn = (questions, ...rest) => {
      let enquirer = new this(...rest);
      let emit = enquirer.emit.bind(enquirer);
      enquirer.emit = (...args) => {
        fn.emit(...args);
        return emit(...args);
      };
      return enquirer.prompt(questions);
    };
    utils.mixinEmitter(fn, new Events());
    return fn;
  }
}

utils.mixinEmitter(Enquirer, new Events());
const prompts = Enquirer.prompts;

for (let name of Object.keys(prompts)) {
  let key = name.toLowerCase();

  let run = options => new prompts[name](options).run();
  Enquirer.prompt[key] = run;
  Enquirer[key] = run;

  if (!Enquirer[name]) {
    Reflect.defineProperty(Enquirer, name, { get: () => prompts[name] });
  }
}

const exp = name => {
  utils.defineExport(Enquirer, name, () => Enquirer.types[name]);
};

exp('ArrayPrompt');
exp('AuthPrompt');
exp('BooleanPrompt');
exp('NumberPrompt');
exp('StringPrompt');

module.exports = Enquirer;


/***/ }),
/* 535 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const toString = Object.prototype.toString;
const colors = __webpack_require__(536);
let called = false;
let fns = [];

const complements = {
  'yellow': 'blue',
  'cyan': 'red',
  'green': 'magenta',
  'black': 'white',
  'blue': 'yellow',
  'red': 'cyan',
  'magenta': 'green',
  'white': 'black'
};

exports.longest = (arr, prop) => {
  return arr.reduce((a, v) => Math.max(a, prop ? v[prop].length : v.length), 0);
};

exports.hasColor = str => !!str && colors.hasColor(str);

const isObject = exports.isObject = val => {
  return val !== null && typeof val === 'object' && !Array.isArray(val);
};

exports.nativeType = val => {
  return toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, '');
};

exports.isAsyncFn = val => {
  return exports.nativeType(val) === 'asyncfunction';
};

exports.isPrimitive = val => {
  return val != null && typeof val !== 'object' && typeof val !== 'function';
};

exports.resolve = (context, value, ...rest) => {
  if (typeof value === 'function') {
    return value.call(context, ...rest);
  }
  return value;
};

exports.scrollDown = (choices = []) => [...choices.slice(1), choices[0]];
exports.scrollUp = (choices = []) => [choices.pop(), ...choices];

exports.reorder = (arr = []) => {
  let res = arr.slice();
  res.sort((a, b) => {
    if (a.index > b.index) return 1;
    if (a.index < b.index) return -1;
    return 0;
  });
  return res;
};

exports.swap = (arr, index, pos) => {
  let len = arr.length;
  let idx = pos === len ? 0 : pos < 0 ? len - 1 : pos;
  let choice = arr[index];
  arr[index] = arr[idx];
  arr[idx] = choice;
};

exports.width = (stream, fallback = 80) => {
  let columns = (stream && stream.columns) ? stream.columns : fallback;
  if (stream && typeof stream.getWindowSize === 'function') {
    columns = stream.getWindowSize()[0];
  }
  if (process.platform === 'win32') {
    return columns - 1;
  }
  return columns;
};

exports.height = (stream, fallback = 20) => {
  let rows = (stream && stream.rows) ? stream.rows : fallback;
  if (stream && typeof stream.getWindowSize === 'function') {
    rows = stream.getWindowSize()[1];
  }
  return rows;
};

exports.wordWrap = (str, options = {}) => {
  if (!str) return str;

  if (typeof options === 'number') {
    options = { width: options };
  }

  let { indent = '', newline = ('\n' + indent), width = 80 } = options;
  let spaces = (newline + indent).match(/[^\S\n]/g) || [];
  width -= spaces.length;
  let source = `.{1,${width}}([\\s\\u200B]+|$)|[^\\s\\u200B]+?([\\s\\u200B]+|$)`;
  let output = str.trim();
  let regex = new RegExp(source, 'g');
  let lines = output.match(regex) || [];
  lines = lines.map(line => line.replace(/\n$/, ''));
  if (options.padEnd) lines = lines.map(line => line.padEnd(width, ' '));
  if (options.padStart) lines = lines.map(line => line.padStart(width, ' '));
  return indent + lines.join(newline);
};

exports.unmute = color => {
  let name = color.stack.find(n => colors.keys.color.includes(n));
  if (name) {
    return colors[name];
  }
  let bg = color.stack.find(n => n.slice(2) === 'bg');
  if (bg) {
    return colors[name.slice(2)];
  }
  return str => str;
};

exports.pascal = str => str ? str[0].toUpperCase() + str.slice(1) : '';

exports.inverse = color => {
  if (!color || !color.stack) return color;
  let name = color.stack.find(n => colors.keys.color.includes(n));
  if (name) {
    let col = colors['bg' + exports.pascal(name)];
    return col ? col.black : color;
  }
  let bg = color.stack.find(n => n.slice(0, 2) === 'bg');
  if (bg) {
    return colors[bg.slice(2).toLowerCase()] || color;
  }
  return colors.none;
};

exports.complement = color => {
  if (!color || !color.stack) return color;
  let name = color.stack.find(n => colors.keys.color.includes(n));
  let bg = color.stack.find(n => n.slice(0, 2) === 'bg');
  if (name && !bg) {
    return colors[complements[name] || name];
  }
  if (bg) {
    let lower = bg.slice(2).toLowerCase();
    let comp = complements[lower];
    if (!comp) return color;
    return colors['bg' + exports.pascal(comp)] || color;
  }
  return colors.none;
};

exports.meridiem = date => {
  let hours = date.getHours();
  let minutes = date.getMinutes();
  let ampm = hours >= 12 ? 'pm' : 'am';
  hours = hours % 12;
  let hrs = hours === 0 ? 12 : hours;
  let min = minutes < 10 ? '0' + minutes : minutes;
  return hrs + ':' + min + ' ' + ampm;
};

/**
 * Set a value on the given object.
 * @param {Object} obj
 * @param {String} prop
 * @param {any} value
 */

exports.set = (obj = {}, prop = '', val) => {
  return prop.split('.').reduce((acc, k, i, arr) => {
    let value = arr.length - 1 > i ? (acc[k] || {}) : val;
    if (!exports.isObject(value) && i < arr.length - 1) value = {};
    return (acc[k] = value);
  }, obj);
};

/**
 * Get a value from the given object.
 * @param {Object} obj
 * @param {String} prop
 */

exports.get = (obj = {}, prop = '', fallback) => {
  let value = obj[prop] == null
    ? prop.split('.').reduce((acc, k) => acc && acc[k], obj)
    : obj[prop];
  return value == null ? fallback : value;
};

exports.mixin = (target, b) => {
  if (!isObject(target)) return b;
  if (!isObject(b)) return target;
  for (let key of Object.keys(b)) {
    let desc = Object.getOwnPropertyDescriptor(b, key);
    if (desc.hasOwnProperty('value')) {
      if (target.hasOwnProperty(key) && isObject(desc.value)) {
        let existing = Object.getOwnPropertyDescriptor(target, key);
        if (isObject(existing.value)) {
          target[key] = exports.merge({}, target[key], b[key]);
        } else {
          Reflect.defineProperty(target, key, desc);
        }
      } else {
        Reflect.defineProperty(target, key, desc);
      }
    } else {
      Reflect.defineProperty(target, key, desc);
    }
  }
  return target;
};

exports.merge = (...args) => {
  let target = {};
  for (let ele of args) exports.mixin(target, ele);
  return target;
};

exports.mixinEmitter = (obj, emitter) => {
  let proto = emitter.constructor.prototype;
  for (let key of Object.keys(proto)) {
    let val = proto[key];
    if (typeof val === 'function') {
      exports.define(obj, key, val.bind(emitter));
    } else {
      exports.define(obj, key, val);
    }
  }
};

exports.onExit = callback => {
  const onExit = (quit, code) => {
    if (called) return;

    called = true;
    fns.forEach(fn => fn());

    if (quit === true) {
      process.exit(128 + code);
    }
  };

  if (fns.length === 0) {
    process.once('SIGTERM', onExit.bind(null, true, 15));
    process.once('SIGINT', onExit.bind(null, true, 2));
    process.once('exit', onExit);
  }

  fns.push(callback);
};

exports.define = (obj, key, value) => {
  Reflect.defineProperty(obj, key, { value });
};

exports.defineExport = (obj, key, fn) => {
  let custom;
  Reflect.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    set(val) {
      custom = val;
    },
    get() {
      return custom ? custom() : fn();
    }
  });
};


/***/ }),
/* 536 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
const identity = val => val;

/* eslint-disable no-control-regex */
// this is a modified version of https://github.com/chalk/ansi-regex (MIT License)
const ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;

const create = () => {
  const colors = { enabled: true, visible: true, styles: {}, keys: {} };

  if ('FORCE_COLOR' in process.env) {
    colors.enabled = process.env.FORCE_COLOR !== '0';
  }

  const ansi = style => {
    let open = style.open = `\u001b[${style.codes[0]}m`;
    let close = style.close = `\u001b[${style.codes[1]}m`;
    let regex = style.regex = new RegExp(`\\u001b\\[${style.codes[1]}m`, 'g');
    style.wrap = (input, newline) => {
      if (input.includes(close)) input = input.replace(regex, close + open);
      let output = open + input + close;
      // see https://github.com/chalk/chalk/pull/92, thanks to the
      // chalk contributors for this fix. However, we've confirmed that
      // this issue is also present in Windows terminals
      return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
    };
    return style;
  };

  const wrap = (style, input, newline) => {
    return typeof style === 'function' ? style(input) : style.wrap(input, newline);
  };

  const style = (input, stack) => {
    if (input === '' || input == null) return '';
    if (colors.enabled === false) return input;
    if (colors.visible === false) return '';
    let str = '' + input;
    let nl = str.includes('\n');
    let n = stack.length;
    if (n > 0 && stack.includes('unstyle')) {
      stack = [...new Set(['unstyle', ...stack])].reverse();
    }
    while (n-- > 0) str = wrap(colors.styles[stack[n]], str, nl);
    return str;
  };

  const define = (name, codes, type) => {
    colors.styles[name] = ansi({ name, codes });
    let keys = colors.keys[type] || (colors.keys[type] = []);
    keys.push(name);

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias(name, value);
      },
      get() {
        let color = input => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(name) : [name];
        return color;
      }
    });
  };

  define('reset', [0, 0], 'modifier');
  define('bold', [1, 22], 'modifier');
  define('dim', [2, 22], 'modifier');
  define('italic', [3, 23], 'modifier');
  define('underline', [4, 24], 'modifier');
  define('inverse', [7, 27], 'modifier');
  define('hidden', [8, 28], 'modifier');
  define('strikethrough', [9, 29], 'modifier');

  define('black', [30, 39], 'color');
  define('red', [31, 39], 'color');
  define('green', [32, 39], 'color');
  define('yellow', [33, 39], 'color');
  define('blue', [34, 39], 'color');
  define('magenta', [35, 39], 'color');
  define('cyan', [36, 39], 'color');
  define('white', [37, 39], 'color');
  define('gray', [90, 39], 'color');
  define('grey', [90, 39], 'color');

  define('bgBlack', [40, 49], 'bg');
  define('bgRed', [41, 49], 'bg');
  define('bgGreen', [42, 49], 'bg');
  define('bgYellow', [43, 49], 'bg');
  define('bgBlue', [44, 49], 'bg');
  define('bgMagenta', [45, 49], 'bg');
  define('bgCyan', [46, 49], 'bg');
  define('bgWhite', [47, 49], 'bg');

  define('blackBright', [90, 39], 'bright');
  define('redBright', [91, 39], 'bright');
  define('greenBright', [92, 39], 'bright');
  define('yellowBright', [93, 39], 'bright');
  define('blueBright', [94, 39], 'bright');
  define('magentaBright', [95, 39], 'bright');
  define('cyanBright', [96, 39], 'bright');
  define('whiteBright', [97, 39], 'bright');

  define('bgBlackBright', [100, 49], 'bgBright');
  define('bgRedBright', [101, 49], 'bgBright');
  define('bgGreenBright', [102, 49], 'bgBright');
  define('bgYellowBright', [103, 49], 'bgBright');
  define('bgBlueBright', [104, 49], 'bgBright');
  define('bgMagentaBright', [105, 49], 'bgBright');
  define('bgCyanBright', [106, 49], 'bgBright');
  define('bgWhiteBright', [107, 49], 'bgBright');

  colors.ansiRegex = ANSI_REGEX;
  colors.hasColor = colors.hasAnsi = str => {
    colors.ansiRegex.lastIndex = 0;
    return typeof str === 'string' && str !== '' && colors.ansiRegex.test(str);
  };

  colors.alias = (name, color) => {
    let fn = typeof color === 'string' ? colors[color] : color;

    if (typeof fn !== 'function') {
      throw new TypeError('Expected alias to be the name of an existing color (string) or a function');
    }

    if (!fn.stack) {
      Reflect.defineProperty(fn, 'name', { value: name });
      colors.styles[name] = fn;
      fn.stack = [name];
    }

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias(name, value);
      },
      get() {
        let color = input => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
        return color;
      }
    });
  };

  colors.theme = custom => {
    if (!isObject(custom)) throw new TypeError('Expected theme to be an object');
    for (let name of Object.keys(custom)) {
      colors.alias(name, custom[name]);
    }
    return colors;
  };

  colors.alias('unstyle', str => {
    if (typeof str === 'string' && str !== '') {
      colors.ansiRegex.lastIndex = 0;
      return str.replace(colors.ansiRegex, '');
    }
    return '';
  });

  colors.alias('noop', str => str);
  colors.none = colors.clear = colors.noop;

  colors.stripColor = colors.unstyle;
  colors.symbols = __webpack_require__(537);
  colors.define = define;
  return colors;
};

module.exports = create();
module.exports.create = create;


/***/ }),
/* 537 */
/***/ ((module) => {

"use strict";


const isHyper = process.env.TERM_PROGRAM === 'Hyper';
const isWindows = process.platform === 'win32';
const isLinux = process.platform === 'linux';

const common = {
  ballotDisabled: '',
  ballotOff: '',
  ballotOn: '',
  bullet: '',
  bulletWhite: '',
  fullBlock: '',
  heart: '',
  identicalTo: '',
  line: '',
  mark: '',
  middot: '',
  minus: '',
  multiplication: '',
  obelus: '',
  pencilDownRight: '',
  pencilRight: '',
  pencilUpRight: '',
  percent: '%',
  pilcrow2: '',
  pilcrow: '',
  plusMinus: '',
  section: '',
  starsOff: '',
  starsOn: '',
  upDownArrow: ''
};

const windows = Object.assign({}, common, {
  check: '',
  cross: '',
  ellipsisLarge: '...',
  ellipsis: '...',
  info: 'i',
  question: '?',
  questionSmall: '?',
  pointer: '>',
  pointerSmall: '',
  radioOff: '( )',
  radioOn: '(*)',
  warning: ''
});

const other = Object.assign({}, common, {
  ballotCross: '',
  check: '',
  cross: '',
  ellipsisLarge: '',
  ellipsis: '',
  info: '',
  question: '?',
  questionFull: '',
  questionSmall: '',
  pointer: isLinux ? '' : '',
  pointerSmall: isLinux ? '' : '',
  radioOff: '',
  radioOn: '',
  warning: ''
});

module.exports = (isWindows && !isHyper) ? windows : other;
Reflect.defineProperty(module.exports, 'common', { enumerable: false, value: common });
Reflect.defineProperty(module.exports, 'windows', { enumerable: false, value: windows });
Reflect.defineProperty(module.exports, 'other', { enumerable: false, value: other });


/***/ }),
/* 538 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Events = __webpack_require__(170);
const colors = __webpack_require__(536);
const keypress = __webpack_require__(539);
const timer = __webpack_require__(542);
const State = __webpack_require__(543);
const theme = __webpack_require__(544);
const utils = __webpack_require__(535);
const ansi = __webpack_require__(547);

/**
 * Base class for creating a new Prompt.
 * @param {Object} `options` Question object.
 */

class Prompt extends Events {
  constructor(options = {}) {
    super();
    this.name = options.name;
    this.type = options.type;
    this.options = options;
    theme(this);
    timer(this);
    this.state = new State(this);
    this.initial = [options.initial, options.default].find(v => v != null);
    this.stdout = options.stdout || process.stdout;
    this.stdin = options.stdin || process.stdin;
    this.scale = options.scale || 1;
    this.term = this.options.term || process.env.TERM_PROGRAM;
    this.margin = margin(this.options.margin);
    this.setMaxListeners(0);
    setOptions(this);
  }

  async keypress(input, event = {}) {
    this.keypressed = true;
    let key = keypress.action(input, keypress(input, event), this.options.actions);
    this.state.keypress = key;
    this.emit('keypress', input, key);
    this.emit('state', this.state.clone());
    let fn = this.options[key.action] || this[key.action] || this.dispatch;
    if (typeof fn === 'function') {
      return await fn.call(this, input, key);
    }
    this.alert();
  }

  alert() {
    delete this.state.alert;
    if (this.options.show === false) {
      this.emit('alert');
    } else {
      this.stdout.write(ansi.code.beep);
    }
  }

  cursorHide() {
    this.stdout.write(ansi.cursor.hide());
    utils.onExit(() => this.cursorShow());
  }

  cursorShow() {
    this.stdout.write(ansi.cursor.show());
  }

  write(str) {
    if (!str) return;
    if (this.stdout && this.state.show !== false) {
      this.stdout.write(str);
    }
    this.state.buffer += str;
  }

  clear(lines = 0) {
    let buffer = this.state.buffer;
    this.state.buffer = '';
    if ((!buffer && !lines) || this.options.show === false) return;
    this.stdout.write(ansi.cursor.down(lines) + ansi.clear(buffer, this.width));
  }

  restore() {
    if (this.state.closed || this.options.show === false) return;

    let { prompt, after, rest } = this.sections();
    let { cursor, initial = '', input = '', value = '' } = this;

    let size = this.state.size = rest.length;
    let state = { after, cursor, initial, input, prompt, size, value };
    let codes = ansi.cursor.restore(state);
    if (codes) {
      this.stdout.write(codes);
    }
  }

  sections() {
    let { buffer, input, prompt } = this.state;
    prompt = colors.unstyle(prompt);
    let buf = colors.unstyle(buffer);
    let idx = buf.indexOf(prompt);
    let header = buf.slice(0, idx);
    let rest = buf.slice(idx);
    let lines = rest.split('\n');
    let first = lines[0];
    let last = lines[lines.length - 1];
    let promptLine = prompt + (input ? ' ' + input : '');
    let len = promptLine.length;
    let after = len < first.length ? first.slice(len + 1) : '';
    return { header, prompt: first, after, rest: lines.slice(1), last };
  }

  async submit() {
    this.state.submitted = true;
    this.state.validating = true;

    // this will only be called when the prompt is directly submitted
    // without initializing, i.e. when the prompt is skipped, etc. Otherwize,
    // "options.onSubmit" is will be handled by the "initialize()" method.
    if (this.options.onSubmit) {
      await this.options.onSubmit.call(this, this.name, this.value, this);
    }

    let result = this.state.error || await this.validate(this.value, this.state);
    if (result !== true) {
      let error = '\n' + this.symbols.pointer + ' ';

      if (typeof result === 'string') {
        error += result.trim();
      } else {
        error += 'Invalid input';
      }

      this.state.error = '\n' + this.styles.danger(error);
      this.state.submitted = false;
      await this.render();
      await this.alert();
      this.state.validating = false;
      this.state.error = void 0;
      return;
    }

    this.state.validating = false;
    await this.render();
    await this.close();

    this.value = await this.result(this.value);
    this.emit('submit', this.value);
  }

  async cancel(err) {
    this.state.cancelled = this.state.submitted = true;

    await this.render();
    await this.close();

    if (typeof this.options.onCancel === 'function') {
      await this.options.onCancel.call(this, this.name, this.value, this);
    }

    this.emit('cancel', await this.error(err));
  }

  async close() {
    this.state.closed = true;

    try {
      let sections = this.sections();
      let lines = Math.ceil(sections.prompt.length / this.width);
      if (sections.rest) {
        this.write(ansi.cursor.down(sections.rest.length));
      }
      this.write('\n'.repeat(lines));
    } catch (err) { /* do nothing */ }

    this.emit('close');
  }

  start() {
    if (!this.stop && this.options.show !== false) {
      this.stop = keypress.listen(this, this.keypress.bind(this));
      this.once('close', this.stop);
    }
  }

  async skip() {
    this.skipped = this.options.skip === true;
    if (typeof this.options.skip === 'function') {
      this.skipped = await this.options.skip.call(this, this.name, this.value);
    }
    return this.skipped;
  }

  async initialize() {
    let { format, options, result } = this;

    this.format = () => format.call(this, this.value);
    this.result = () => result.call(this, this.value);

    if (typeof options.initial === 'function') {
      this.initial = await options.initial.call(this, this);
    }

    if (typeof options.onRun === 'function') {
      await options.onRun.call(this, this);
    }

    // if "options.onSubmit" is defined, we wrap the "submit" method to guarantee
    // that "onSubmit" will always called first thing inside the submit
    // method, regardless of how it's handled in inheriting prompts.
    if (typeof options.onSubmit === 'function') {
      let onSubmit = options.onSubmit.bind(this);
      let submit = this.submit.bind(this);
      delete this.options.onSubmit;
      this.submit = async() => {
        await onSubmit(this.name, this.value, this);
        return submit();
      };
    }

    await this.start();
    await this.render();
  }

  render() {
    throw new Error('expected prompt to have a custom render method');
  }

  run() {
    return new Promise(async(resolve, reject) => {
      this.once('submit', resolve);
      this.once('cancel', reject);
      if (await this.skip()) {
        this.render = () => {};
        return this.submit();
      }
      await this.initialize();
      this.emit('run');
    });
  }

  async element(name, choice, i) {
    let { options, state, symbols, timers } = this;
    let timer = timers && timers[name];
    state.timer = timer;
    let value = options[name] || state[name] || symbols[name];
    let val = choice && choice[name] != null ? choice[name] : await value;
    if (val === '') return val;

    let res = await this.resolve(val, state, choice, i);
    if (!res && choice && choice[name]) {
      return this.resolve(value, state, choice, i);
    }
    return res;
  }

  async prefix() {
    let element = await this.element('prefix') || this.symbols;
    let timer = this.timers && this.timers.prefix;
    let state = this.state;
    state.timer = timer;
    if (utils.isObject(element)) element = element[state.status] || element.pending;
    if (!utils.hasColor(element)) {
      let style = this.styles[state.status] || this.styles.pending;
      return style(element);
    }
    return element;
  }

  async message() {
    let message = await this.element('message');
    if (!utils.hasColor(message)) {
      return this.styles.strong(message);
    }
    return message;
  }

  async separator() {
    let element = await this.element('separator') || this.symbols;
    let timer = this.timers && this.timers.separator;
    let state = this.state;
    state.timer = timer;
    let value = element[state.status] || element.pending || state.separator;
    let ele = await this.resolve(value, state);
    if (utils.isObject(ele)) ele = ele[state.status] || ele.pending;
    if (!utils.hasColor(ele)) {
      return this.styles.muted(ele);
    }
    return ele;
  }

  async pointer(choice, i) {
    let val = await this.element('pointer', choice, i);

    if (typeof val === 'string' && utils.hasColor(val)) {
      return val;
    }

    if (val) {
      let styles = this.styles;
      let focused = this.index === i;
      let style = focused ? styles.primary : val => val;
      let ele = await this.resolve(val[focused ? 'on' : 'off'] || val, this.state);
      let styled = !utils.hasColor(ele) ? style(ele) : ele;
      return focused ? styled : ' '.repeat(ele.length);
    }
  }

  async indicator(choice, i) {
    let val = await this.element('indicator', choice, i);
    if (typeof val === 'string' && utils.hasColor(val)) {
      return val;
    }
    if (val) {
      let styles = this.styles;
      let enabled = choice.enabled === true;
      let style = enabled ? styles.success : styles.dark;
      let ele = val[enabled ? 'on' : 'off'] || val;
      return !utils.hasColor(ele) ? style(ele) : ele;
    }
    return '';
  }

  body() {
    return null;
  }

  footer() {
    if (this.state.status === 'pending') {
      return this.element('footer');
    }
  }

  header() {
    if (this.state.status === 'pending') {
      return this.element('header');
    }
  }

  async hint() {
    if (this.state.status === 'pending' && !this.isValue(this.state.input)) {
      let hint = await this.element('hint');
      if (!utils.hasColor(hint)) {
        return this.styles.muted(hint);
      }
      return hint;
    }
  }

  error(err) {
    return !this.state.submitted ? (err || this.state.error) : '';
  }

  format(value) {
    return value;
  }

  result(value) {
    return value;
  }

  validate(value) {
    if (this.options.required === true) {
      return this.isValue(value);
    }
    return true;
  }

  isValue(value) {
    return value != null && value !== '';
  }

  resolve(value, ...args) {
    return utils.resolve(this, value, ...args);
  }

  get base() {
    return Prompt.prototype;
  }

  get style() {
    return this.styles[this.state.status];
  }

  get height() {
    return this.options.rows || utils.height(this.stdout, 25);
  }
  get width() {
    return this.options.columns || utils.width(this.stdout, 80);
  }
  get size() {
    return { width: this.width, height: this.height };
  }

  set cursor(value) {
    this.state.cursor = value;
  }
  get cursor() {
    return this.state.cursor;
  }

  set input(value) {
    this.state.input = value;
  }
  get input() {
    return this.state.input;
  }

  set value(value) {
    this.state.value = value;
  }
  get value() {
    let { input, value } = this.state;
    let result = [value, input].find(this.isValue.bind(this));
    return this.isValue(result) ? result : this.initial;
  }

  static get prompt() {
    return options => new this(options).run();
  }
}

function setOptions(prompt) {
  let isValidKey = key => {
    return prompt[key] === void 0 || typeof prompt[key] === 'function';
  };

  let ignore = [
    'actions',
    'choices',
    'initial',
    'margin',
    'roles',
    'styles',
    'symbols',
    'theme',
    'timers',
    'value'
  ];

  let ignoreFn = [
    'body',
    'footer',
    'error',
    'header',
    'hint',
    'indicator',
    'message',
    'prefix',
    'separator',
    'skip'
  ];

  for (let key of Object.keys(prompt.options)) {
    if (ignore.includes(key)) continue;
    if (/^on[A-Z]/.test(key)) continue;
    let option = prompt.options[key];
    if (typeof option === 'function' && isValidKey(key)) {
      if (!ignoreFn.includes(key)) {
        prompt[key] = option.bind(prompt);
      }
    } else if (typeof prompt[key] !== 'function') {
      prompt[key] = option;
    }
  }
}

function margin(value) {
  if (typeof value === 'number') {
    value = [value, value, value, value];
  }
  let arr = [].concat(value || []);
  let pad = i => i % 2 === 0 ? '\n' : ' ';
  let res = [];
  for (let i = 0; i < 4; i++) {
    let char = pad(i);
    if (arr[i]) {
      res.push(char.repeat(arr[i]));
    } else {
      res.push('');
    }
  }
  return res;
}

module.exports = Prompt;


/***/ }),
/* 539 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const readline = __webpack_require__(540);
const combos = __webpack_require__(541);

/* eslint-disable no-control-regex */
const metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
const fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
const keyName = {
    /* xterm/gnome ESC O letter */
    'OP': 'f1',
    'OQ': 'f2',
    'OR': 'f3',
    'OS': 'f4',
    /* xterm/rxvt ESC [ number ~ */
    '[11~': 'f1',
    '[12~': 'f2',
    '[13~': 'f3',
    '[14~': 'f4',
    /* from Cygwin and used in libuv */
    '[[A': 'f1',
    '[[B': 'f2',
    '[[C': 'f3',
    '[[D': 'f4',
    '[[E': 'f5',
    /* common */
    '[15~': 'f5',
    '[17~': 'f6',
    '[18~': 'f7',
    '[19~': 'f8',
    '[20~': 'f9',
    '[21~': 'f10',
    '[23~': 'f11',
    '[24~': 'f12',
    /* xterm ESC [ letter */
    '[A': 'up',
    '[B': 'down',
    '[C': 'right',
    '[D': 'left',
    '[E': 'clear',
    '[F': 'end',
    '[H': 'home',
    /* xterm/gnome ESC O letter */
    'OA': 'up',
    'OB': 'down',
    'OC': 'right',
    'OD': 'left',
    'OE': 'clear',
    'OF': 'end',
    'OH': 'home',
    /* xterm/rxvt ESC [ number ~ */
    '[1~': 'home',
    '[2~': 'insert',
    '[3~': 'delete',
    '[4~': 'end',
    '[5~': 'pageup',
    '[6~': 'pagedown',
    /* putty */
    '[[5~': 'pageup',
    '[[6~': 'pagedown',
    /* rxvt */
    '[7~': 'home',
    '[8~': 'end',
    /* rxvt keys with modifiers */
    '[a': 'up',
    '[b': 'down',
    '[c': 'right',
    '[d': 'left',
    '[e': 'clear',

    '[2$': 'insert',
    '[3$': 'delete',
    '[5$': 'pageup',
    '[6$': 'pagedown',
    '[7$': 'home',
    '[8$': 'end',

    'Oa': 'up',
    'Ob': 'down',
    'Oc': 'right',
    'Od': 'left',
    'Oe': 'clear',

    '[2^': 'insert',
    '[3^': 'delete',
    '[5^': 'pageup',
    '[6^': 'pagedown',
    '[7^': 'home',
    '[8^': 'end',
    /* misc. */
    '[Z': 'tab',
}

function isShiftKey(code) {
    return ['[a', '[b', '[c', '[d', '[e', '[2$', '[3$', '[5$', '[6$', '[7$', '[8$', '[Z'].includes(code)
}

function isCtrlKey(code) {
    return [ 'Oa', 'Ob', 'Oc', 'Od', 'Oe', '[2^', '[3^', '[5^', '[6^', '[7^', '[8^'].includes(code)
}

const keypress = (s = '', event = {}) => {
  let parts;
  let key = {
    name: event.name,
    ctrl: false,
    meta: false,
    shift: false,
    option: false,
    sequence: s,
    raw: s,
    ...event
  };

  if (Buffer.isBuffer(s)) {
    if (s[0] > 127 && s[1] === void 0) {
      s[0] -= 128;
      s = '\x1b' + String(s);
    } else {
      s = String(s);
    }
  } else if (s !== void 0 && typeof s !== 'string') {
    s = String(s);
  } else if (!s) {
    s = key.sequence || '';
  }

  key.sequence = key.sequence || s || key.name;

  if (s === '\r') {
    // carriage return
    key.raw = void 0;
    key.name = 'return';
  } else if (s === '\n') {
    // enter, should have been called linefeed
    key.name = 'enter';
  } else if (s === '\t') {
    // tab
    key.name = 'tab';
  } else if (s === '\b' || s === '\x7f' || s === '\x1b\x7f' || s === '\x1b\b') {
    // backspace or ctrl+h
    key.name = 'backspace';
    key.meta = s.charAt(0) === '\x1b';
  } else if (s === '\x1b' || s === '\x1b\x1b') {
    // escape key
    key.name = 'escape';
    key.meta = s.length === 2;
  } else if (s === ' ' || s === '\x1b ') {
    key.name = 'space';
    key.meta = s.length === 2;
  } else if (s <= '\x1a') {
    // ctrl+letter
    key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
    key.ctrl = true;
  } else if (s.length === 1 && s >= '0' && s <= '9') {
    // number
    key.name = 'number';
  } else if (s.length === 1 && s >= 'a' && s <= 'z') {
    // lowercase letter
    key.name = s;
  } else if (s.length === 1 && s >= 'A' && s <= 'Z') {
    // shift+letter
    key.name = s.toLowerCase();
    key.shift = true;
  } else if ((parts = metaKeyCodeRe.exec(s))) {
    // meta+character key
    key.meta = true;
    key.shift = /^[A-Z]$/.test(parts[1]);
  } else if ((parts = fnKeyRe.exec(s))) {
    let segs = [...s];

    if (segs[0] === '\u001b' && segs[1] === '\u001b') {
      key.option = true;
    }

    // ansi escape sequence
    // reassemble the key code leaving out leading \x1b's,
    // the modifier key bitflag and any meaningless "1;" sequence
    let code = [parts[1], parts[2], parts[4], parts[6]].filter(Boolean).join('');
    let modifier = (parts[3] || parts[5] || 1) - 1;

    // Parse the key modifier
    key.ctrl = !!(modifier & 4);
    key.meta = !!(modifier & 10);
    key.shift = !!(modifier & 1);
    key.code = code;

    key.name = keyName[code];
    key.shift = isShiftKey(code) || key.shift;
    key.ctrl = isCtrlKey(code) || key.ctrl;
  }
  return key;
};

keypress.listen = (options = {}, onKeypress) => {
  let { stdin } = options;

  if (!stdin || (stdin !== process.stdin && !stdin.isTTY)) {
    throw new Error('Invalid stream passed');
  }

  let rl = readline.createInterface({ terminal: true, input: stdin });
  readline.emitKeypressEvents(stdin, rl);

  let on = (buf, key) => onKeypress(buf, keypress(buf, key), rl);
  let isRaw = stdin.isRaw;

  if (stdin.isTTY) stdin.setRawMode(true);
  stdin.on('keypress', on);
  rl.resume();

  let off = () => {
    if (stdin.isTTY) stdin.setRawMode(isRaw);
    stdin.removeListener('keypress', on);
    rl.pause();
    rl.close();
  };

  return off;
};

keypress.action = (buf, key, customActions) => {
  let obj = { ...combos, ...customActions };
  if (key.ctrl) {
    key.action = obj.ctrl[key.name];
    return key;
  }

  if (key.option && obj.option) {
    key.action = obj.option[key.name];
    return key;
  }

  if (key.shift) {
    key.action = obj.shift[key.name];
    return key;
  }

  key.action = obj.keys[key.name];
  return key;
};

module.exports = keypress;


/***/ }),
/* 540 */
/***/ ((module) => {

"use strict";
module.exports = require("readline");

/***/ }),
/* 541 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Actions are mappings from keypress event names to method names
 * in the prompts.
 */

exports.ctrl = {
  a: 'first',
  b: 'backward',
  c: 'cancel',
  d: 'deleteForward',
  e: 'last',
  f: 'forward',
  g: 'reset',
  i: 'tab',
  k: 'cutForward',
  l: 'reset',
  n: 'newItem',
  m: 'cancel',
  j: 'submit',
  p: 'search',
  r: 'remove',
  s: 'save',
  u: 'undo',
  w: 'cutLeft',
  x: 'toggleCursor',
  v: 'paste'
};

exports.shift = {
  up: 'shiftUp',
  down: 'shiftDown',
  left: 'shiftLeft',
  right: 'shiftRight',
  tab: 'prev'
};

exports.fn = {
  up: 'pageUp',
  down: 'pageDown',
  left: 'pageLeft',
  right: 'pageRight',
  delete: 'deleteForward'
};

// <alt> on Windows
exports.option = {
  b: 'backward',
  f: 'forward',
  d: 'cutRight',
  left: 'cutLeft',
  up: 'altUp',
  down: 'altDown'
};

exports.keys = {
  pageup: 'pageUp', // <fn>+<up> (mac), <Page Up> (windows)
  pagedown: 'pageDown', // <fn>+<down> (mac), <Page Down> (windows)
  home: 'home', // <fn>+<left> (mac), <home> (windows)
  end: 'end', // <fn>+<right> (mac), <end> (windows)
  cancel: 'cancel',
  delete: 'deleteForward',
  backspace: 'delete',
  down: 'down',
  enter: 'submit',
  escape: 'cancel',
  left: 'left',
  space: 'space',
  number: 'number',
  return: 'submit',
  right: 'right',
  tab: 'next',
  up: 'up'
};


/***/ }),
/* 542 */
/***/ ((module) => {

"use strict";


module.exports = prompt => {
  prompt.timers = prompt.timers || {};

  let timers = prompt.options.timers;
  if (!timers) return;

  for (let key of Object.keys(timers)) {
    let opts = timers[key];
    if (typeof opts === 'number') {
      opts = { interval: opts };
    }
    create(prompt, key, opts);
  }
};

function create(prompt, name, options = {}) {
  let timer = prompt.timers[name] = { name, start: Date.now(), ms: 0, tick: 0 };
  let ms = options.interval || 120;
  timer.frames = options.frames || [];
  timer.loading = true;

  let interval = setInterval(() => {
    timer.ms = Date.now() - timer.start;
    timer.tick++;
    prompt.render();
  }, ms);

  timer.stop = () => {
    timer.loading = false;
    clearInterval(interval);
  };

  Reflect.defineProperty(timer, 'interval', { value: interval });
  prompt.once('close', () => timer.stop());
  return timer.stop;
}


/***/ }),
/* 543 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { define, width } = __webpack_require__(535);

class State {
  constructor(prompt) {
    let options = prompt.options;
    define(this, '_prompt', prompt);
    this.type = prompt.type;
    this.name = prompt.name;
    this.message = '';
    this.header = '';
    this.footer = '';
    this.error = '';
    this.hint = '';
    this.input = '';
    this.cursor = 0;
    this.index = 0;
    this.lines = 0;
    this.tick = 0;
    this.prompt = '';
    this.buffer = '';
    this.width = width(options.stdout || process.stdout);
    Object.assign(this, options);
    this.name = this.name || this.message;
    this.message = this.message || this.name;
    this.symbols = prompt.symbols;
    this.styles = prompt.styles;
    this.required = new Set();
    this.cancelled = false;
    this.submitted = false;
  }

  clone() {
    let state = { ...this };
    state.status = this.status;
    state.buffer = Buffer.from(state.buffer);
    delete state.clone;
    return state;
  }

  set color(val) {
    this._color = val;
  }
  get color() {
    let styles = this.prompt.styles;
    if (this.cancelled) return styles.cancelled;
    if (this.submitted) return styles.submitted;
    let color = this._color || styles[this.status];
    return typeof color === 'function' ? color : styles.pending;
  }

  set loading(value) {
    this._loading = value;
  }
  get loading() {
    if (typeof this._loading === 'boolean') return this._loading;
    if (this.loadingChoices) return 'choices';
    return false;
  }

  get status() {
    if (this.cancelled) return 'cancelled';
    if (this.submitted) return 'submitted';
    return 'pending';
  }
}

module.exports = State;


/***/ }),
/* 544 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const styles = __webpack_require__(545);
const symbols = __webpack_require__(546);
const utils = __webpack_require__(535);

module.exports = prompt => {
  prompt.options = utils.merge({}, prompt.options.theme, prompt.options);
  prompt.symbols = symbols.merge(prompt.options);
  prompt.styles = styles.merge(prompt.options);
};


/***/ }),
/* 545 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(535);
const colors = __webpack_require__(536);

const styles = {
  default: colors.noop,
  noop: colors.noop,

  /**
   * Modifiers
   */

  set inverse(custom) {
    this._inverse = custom;
  },
  get inverse() {
    return this._inverse || utils.inverse(this.primary);
  },

  set complement(custom) {
    this._complement = custom;
  },
  get complement() {
    return this._complement || utils.complement(this.primary);
  },

  /**
   * Main color
   */

  primary: colors.cyan,

  /**
   * Main palette
   */

  success: colors.green,
  danger: colors.magenta,
  strong: colors.bold,
  warning: colors.yellow,
  muted: colors.dim,
  disabled: colors.gray,
  dark: colors.dim.gray,
  underline: colors.underline,

  set info(custom) {
    this._info = custom;
  },
  get info() {
    return this._info || this.primary;
  },

  set em(custom) {
    this._em = custom;
  },
  get em() {
    return this._em || this.primary.underline;
  },

  set heading(custom) {
    this._heading = custom;
  },
  get heading() {
    return this._heading || this.muted.underline;
  },

  /**
   * Statuses
   */

  set pending(custom) {
    this._pending = custom;
  },
  get pending() {
    return this._pending || this.primary;
  },

  set submitted(custom) {
    this._submitted = custom;
  },
  get submitted() {
    return this._submitted || this.success;
  },

  set cancelled(custom) {
    this._cancelled = custom;
  },
  get cancelled() {
    return this._cancelled || this.danger;
  },

  /**
   * Special styling
   */

  set typing(custom) {
    this._typing = custom;
  },
  get typing() {
    return this._typing || this.dim;
  },

  set placeholder(custom) {
    this._placeholder = custom;
  },
  get placeholder() {
    return this._placeholder || this.primary.dim;
  },

  set highlight(custom) {
    this._highlight = custom;
  },
  get highlight() {
    return this._highlight || this.inverse;
  }
};

styles.merge = (options = {}) => {
  if (options.styles && typeof options.styles.enabled === 'boolean') {
    colors.enabled = options.styles.enabled;
  }
  if (options.styles && typeof options.styles.visible === 'boolean') {
    colors.visible = options.styles.visible;
  }

  let result = utils.merge({}, styles, options.styles);
  delete result.merge;

  for (let key of Object.keys(colors)) {
    if (!result.hasOwnProperty(key)) {
      Reflect.defineProperty(result, key, { get: () => colors[key] });
    }
  }

  for (let key of Object.keys(colors.styles)) {
    if (!result.hasOwnProperty(key)) {
      Reflect.defineProperty(result, key, { get: () => colors[key] });
    }
  }
  return result;
};

module.exports = styles;


/***/ }),
/* 546 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const isWindows = process.platform === 'win32';
const colors = __webpack_require__(536);
const utils = __webpack_require__(535);

const symbols = {
  ...colors.symbols,
  upDownDoubleArrow: '',
  upDownDoubleArrow2: '',
  upDownArrow: '',
  asterisk: '*',
  asterism: '',
  bulletWhite: '',
  electricArrow: '',
  ellipsisLarge: '',
  ellipsisSmall: '',
  fullBlock: '',
  identicalTo: '',
  indicator: colors.symbols.check,
  leftAngle: '',
  mark: '',
  minus: '',
  multiplication: '',
  obelus: '',
  percent: '%',
  pilcrow: '',
  pilcrow2: '',
  pencilUpRight: '',
  pencilDownRight: '',
  pencilRight: '',
  plus: '+',
  plusMinus: '',
  pointRight: '',
  rightAngle: '',
  section: '',
  hexagon: { off: '', on: '', disabled: '' },
  ballot: { on: '', off: '', disabled: '' },
  stars: { on: '', off: '', disabled: '' },
  folder: { on: '', off: '', disabled: '' },
  prefix: {
    pending: colors.symbols.question,
    submitted: colors.symbols.check,
    cancelled: colors.symbols.cross
  },
  separator: {
    pending: colors.symbols.pointerSmall,
    submitted: colors.symbols.middot,
    cancelled: colors.symbols.middot
  },
  radio: {
    off: isWindows ? '( )' : '',
    on: isWindows ? '(*)' : '',
    disabled: isWindows ? '(|)' : ''
  },
  numbers: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
};

symbols.merge = options => {
  let result = utils.merge({}, colors.symbols, symbols, options.symbols);
  delete result.merge;
  return result;
};

module.exports = symbols;



/***/ }),
/* 547 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


const isTerm = process.env.TERM_PROGRAM === 'Apple_Terminal';
const colors = __webpack_require__(536);
const utils = __webpack_require__(535);
const ansi = module.exports = exports;
const ESC = '\u001b[';
const BEL = '\u0007';
let hidden = false;

const code = ansi.code = {
  bell: BEL,
  beep: BEL,
  beginning: `${ESC}G`,
  down: `${ESC}J`,
  esc: ESC,
  getPosition: `${ESC}6n`,
  hide: `${ESC}?25l`,
  line: `${ESC}2K`,
  lineEnd: `${ESC}K`,
  lineStart: `${ESC}1K`,
  restorePosition: ESC + (isTerm ? '8' : 'u'),
  savePosition: ESC + (isTerm ? '7' : 's'),
  screen: `${ESC}2J`,
  show: `${ESC}?25h`,
  up: `${ESC}1J`
};

const cursor = ansi.cursor = {
  get hidden() {
    return hidden;
  },

  hide() {
    hidden = true;
    return code.hide;
  },
  show() {
    hidden = false;
    return code.show;
  },

  forward: (count = 1) => `${ESC}${count}C`,
  backward: (count = 1) => `${ESC}${count}D`,
  nextLine: (count = 1) => `${ESC}E`.repeat(count),
  prevLine: (count = 1) => `${ESC}F`.repeat(count),

  up: (count = 1) => count ? `${ESC}${count}A` : '',
  down: (count = 1) => count ? `${ESC}${count}B` : '',
  right: (count = 1) => count ? `${ESC}${count}C` : '',
  left: (count = 1) => count ? `${ESC}${count}D` : '',

  to(x, y) {
    return y ? `${ESC}${y + 1};${x + 1}H` : `${ESC}${x + 1}G`;
  },

  move(x = 0, y = 0) {
    let res = '';
    res += (x < 0) ? cursor.left(-x) : (x > 0) ? cursor.right(x) : '';
    res += (y < 0) ? cursor.up(-y) : (y > 0) ? cursor.down(y) : '';
    return res;
  },

  restore(state = {}) {
    let { after, cursor, initial, input, prompt, size, value } = state;
    initial = utils.isPrimitive(initial) ? String(initial) : '';
    input = utils.isPrimitive(input) ? String(input) : '';
    value = utils.isPrimitive(value) ? String(value) : '';

    if (size) {
      let codes = ansi.cursor.up(size) + ansi.cursor.to(prompt.length);
      let diff = input.length - cursor;
      if (diff > 0) {
        codes += ansi.cursor.left(diff);
      }
      return codes;
    }

    if (value || after) {
      let pos = (!input && !!initial) ? -initial.length : -input.length + cursor;
      if (after) pos -= after.length;
      if (input === '' && initial && !prompt.includes(initial)) {
        pos += initial.length;
      }
      return ansi.cursor.move(pos);
    }
  }
};

const erase = ansi.erase = {
  screen: code.screen,
  up: code.up,
  down: code.down,
  line: code.line,
  lineEnd: code.lineEnd,
  lineStart: code.lineStart,
  lines(n) {
    let str = '';
    for (let i = 0; i < n; i++) {
      str += ansi.erase.line + (i < n - 1 ? ansi.cursor.up(1) : '');
    }
    if (n) str += ansi.code.beginning;
    return str;
  }
};

ansi.clear = (input = '', columns = process.stdout.columns) => {
  if (!columns) return erase.line + cursor.to(0);
  let width = str => [...colors.unstyle(str)].length;
  let lines = input.split(/\r?\n/);
  let rows = 0;
  for (let line of lines) {
    rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / columns);
  }
  return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
};


/***/ }),
/* 548 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(535);

const define = (key, fn) => {
  utils.defineExport(exports, key, fn);
  utils.defineExport(exports, key.toLowerCase(), fn);
};

define('AutoComplete', () => __webpack_require__(549));
define('BasicAuth', () => __webpack_require__(553));
define('Confirm', () => __webpack_require__(557));
define('Editable', () => __webpack_require__(559));
define('Form', () => __webpack_require__(555));
define('Input', () => __webpack_require__(560));
define('Invisible', () => __webpack_require__(563));
define('List', () => __webpack_require__(564));
define('MultiSelect', () => __webpack_require__(565));
define('Numeral', () => __webpack_require__(566));
define('Password', () => __webpack_require__(568));
define('Scale', () => __webpack_require__(569));
define('Select', () => __webpack_require__(550));
define('Snippet', () => __webpack_require__(570));
define('Sort', () => __webpack_require__(572));
define('Survey', () => __webpack_require__(573));
define('Text', () => __webpack_require__(574));
define('Toggle', () => __webpack_require__(575));
define('Quiz', () => __webpack_require__(576));


/***/ }),
/* 549 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Select = __webpack_require__(550);

const highlight = (input, color) => {
  let val = input.toLowerCase();
  return str => {
    let s = str.toLowerCase();
    let i = s.indexOf(val);
    let colored = color(str.slice(i, i + val.length));
    return i >= 0 ? str.slice(0, i) + colored + str.slice(i + val.length) : str;
  };
};

class AutoComplete extends Select {
  constructor(options) {
    super(options);
    this.cursorShow();
  }

  moveCursor(n) {
    this.state.cursor += n;
  }

  dispatch(ch) {
    return this.append(ch);
  }

  space(ch) {
    return this.options.multiple ? super.space(ch) : this.append(ch);
  }

  append(ch) {
    let { cursor, input } = this.state;
    this.input = input.slice(0, cursor) + ch + input.slice(cursor);
    this.moveCursor(1);
    return this.complete();
  }

  delete() {
    let { cursor, input } = this.state;
    if (!input) return this.alert();
    this.input = input.slice(0, cursor - 1) + input.slice(cursor);
    this.moveCursor(-1);
    return this.complete();
  }

  deleteForward() {
    let { cursor, input } = this.state;
    if (input[cursor] === void 0) return this.alert();
    this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
    return this.complete();
  }

  number(ch) {
    return this.append(ch);
  }

  async complete() {
    this.completing = true;
    this.choices = await this.suggest(this.input, this.state._choices);
    this.state.limit = void 0; // allow getter/setter to reset limit
    this.index = Math.min(Math.max(this.visible.length - 1, 0), this.index);
    await this.render();
    this.completing = false;
  }

  suggest(input = this.input, choices = this.state._choices) {
    if (typeof this.options.suggest === 'function') {
      return this.options.suggest.call(this, input, choices);
    }
    let str = input.toLowerCase();
    return choices.filter(ch => ch.message.toLowerCase().includes(str));
  }

  pointer() {
    return '';
  }

  format() {
    if (!this.focused) return this.input;
    if (this.options.multiple && this.state.submitted) {
      return this.selected.map(ch => this.styles.primary(ch.message)).join(', ');
    }
    if (this.state.submitted) {
      let value = this.value = this.input = this.focused.value;
      return this.styles.primary(value);
    }
    return this.input;
  }

  async render() {
    if (this.state.status !== 'pending') return super.render();
    let style = this.options.highlight
      ? this.options.highlight.bind(this)
      : this.styles.placeholder;

    let color = highlight(this.input, style);
    let choices = this.choices;
    this.choices = choices.map(ch => ({ ...ch, message: color(ch.message) }));
    await super.render();
    this.choices = choices;
  }

  submit() {
    if (this.options.multiple) {
      this.value = this.selected.map(ch => ch.name);
    }
    return super.submit();
  }
}

module.exports = AutoComplete;


/***/ }),
/* 550 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ArrayPrompt = __webpack_require__(551);
const utils = __webpack_require__(535);

class SelectPrompt extends ArrayPrompt {
  constructor(options) {
    super(options);
    this.emptyError = this.options.emptyError || 'No items were selected';
  }

  async dispatch(s, key) {
    if (this.multiple) {
      return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
    }
    this.alert();
  }

  separator() {
    if (this.options.separator) return super.separator();
    let sep = this.styles.muted(this.symbols.ellipsis);
    return this.state.submitted ? super.separator() : sep;
  }

  pointer(choice, i) {
    return (!this.multiple || this.options.pointer) ? super.pointer(choice, i) : '';
  }

  indicator(choice, i) {
    return this.multiple ? super.indicator(choice, i) : '';
  }

  choiceMessage(choice, i) {
    let message = this.resolve(choice.message, this.state, choice, i);
    if (choice.role === 'heading' && !utils.hasColor(message)) {
      message = this.styles.strong(message);
    }
    return this.resolve(message, this.state, choice, i);
  }

  choiceSeparator() {
    return ':';
  }

  async renderChoice(choice, i) {
    await this.onChoice(choice, i);

    let focused = this.index === i;
    let pointer = await this.pointer(choice, i);
    let check = await this.indicator(choice, i) + (choice.pad || '');
    let hint = await this.resolve(choice.hint, this.state, choice, i);

    if (hint && !utils.hasColor(hint)) {
      hint = this.styles.muted(hint);
    }

    let ind = this.indent(choice);
    let msg = await this.choiceMessage(choice, i);
    let line = () => [this.margin[3], ind + pointer + check, msg, this.margin[1], hint].filter(Boolean).join(' ');

    if (choice.role === 'heading') {
      return line();
    }

    if (choice.disabled) {
      if (!utils.hasColor(msg)) {
        msg = this.styles.disabled(msg);
      }
      return line();
    }

    if (focused) {
      msg = this.styles.em(msg);
    }

    return line();
  }

  async renderChoices() {
    if (this.state.loading === 'choices') {
      return this.styles.warning('Loading choices');
    }

    if (this.state.submitted) return '';
    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
    let visible = await Promise.all(choices);
    if (!visible.length) visible.push(this.styles.danger('No matching choices'));
    let result = this.margin[0] + visible.join('\n');
    let header;

    if (this.options.choicesHeader) {
      header = await this.resolve(this.options.choicesHeader, this.state);
    }

    return [header, result].filter(Boolean).join('\n');
  }

  format() {
    if (!this.state.submitted || this.state.cancelled) return '';
    if (Array.isArray(this.selected)) {
      return this.selected.map(choice => this.styles.primary(choice.name)).join(', ');
    }
    return this.styles.primary(this.selected.name);
  }

  async render() {
    let { submitted, size } = this.state;

    let prompt = '';
    let header = await this.header();
    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    if (this.options.promptLine !== false) {
      prompt = [prefix, message, separator, ''].join(' ');
      this.state.prompt = prompt;
    }

    let output = await this.format();
    let help = (await this.error()) || (await this.hint());
    let body = await this.renderChoices();
    let footer = await this.footer();

    if (output) prompt += output;
    if (help && !prompt.includes(help)) prompt += ' ' + help;

    if (submitted && !output && !body.trim() && this.multiple && this.emptyError != null) {
      prompt += this.styles.danger(this.emptyError);
    }

    this.clear(size);
    this.write([header, prompt, body, footer].filter(Boolean).join('\n'));
    this.write(this.margin[2]);
    this.restore();
  }
}

module.exports = SelectPrompt;


/***/ }),
/* 551 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(536);
const Prompt = __webpack_require__(538);
const roles = __webpack_require__(552);
const utils = __webpack_require__(535);
const { reorder, scrollUp, scrollDown, isObject, swap } = utils;

class ArrayPrompt extends Prompt {
  constructor(options) {
    super(options);
    this.cursorHide();
    this.maxSelected = options.maxSelected || Infinity;
    this.multiple = options.multiple || false;
    this.initial = options.initial || 0;
    this.delay = options.delay || 0;
    this.longest = 0;
    this.num = '';
  }

  async initialize() {
    if (typeof this.options.initial === 'function') {
      this.initial = await this.options.initial.call(this);
    }
    await this.reset(true);
    await super.initialize();
  }

  async reset() {
    let { choices, initial, autofocus, suggest } = this.options;
    this.state._choices = [];
    this.state.choices = [];

    this.choices = await Promise.all(await this.toChoices(choices));
    this.choices.forEach(ch => (ch.enabled = false));

    if (typeof suggest !== 'function' && this.selectable.length === 0) {
      throw new Error('At least one choice must be selectable');
    }

    if (isObject(initial)) initial = Object.keys(initial);
    if (Array.isArray(initial)) {
      if (autofocus != null) this.index = this.findIndex(autofocus);
      initial.forEach(v => this.enable(this.find(v)));
      await this.render();
    } else {
      if (autofocus != null) initial = autofocus;
      if (typeof initial === 'string') initial = this.findIndex(initial);
      if (typeof initial === 'number' && initial > -1) {
        this.index = Math.max(0, Math.min(initial, this.choices.length));
        this.enable(this.find(this.index));
      }
    }

    if (this.isDisabled(this.focused)) {
      await this.down();
    }
  }

  async toChoices(value, parent) {
    this.state.loadingChoices = true;
    let choices = [];
    let index = 0;

    let toChoices = async(items, parent) => {
      if (typeof items === 'function') items = await items.call(this);
      if (items instanceof Promise) items = await items;

      for (let i = 0; i < items.length; i++) {
        let choice = items[i] = await this.toChoice(items[i], index++, parent);
        choices.push(choice);

        if (choice.choices) {
          await toChoices(choice.choices, choice);
        }
      }
      return choices;
    };

    return toChoices(value, parent)
      .then(choices => {
        this.state.loadingChoices = false;
        return choices;
      });
  }

  async toChoice(ele, i, parent) {
    if (typeof ele === 'function') ele = await ele.call(this, this);
    if (ele instanceof Promise) ele = await ele;
    if (typeof ele === 'string') ele = { name: ele };

    if (ele.normalized) return ele;
    ele.normalized = true;

    let origVal = ele.value;
    let role = roles(ele.role, this.options);
    ele = role(this, ele);

    if (typeof ele.disabled === 'string' && !ele.hint) {
      ele.hint = ele.disabled;
      ele.disabled = true;
    }

    if (ele.disabled === true && ele.hint == null) {
      ele.hint = '(disabled)';
    }

    // if the choice was already normalized, return it
    if (ele.index != null) return ele;
    ele.name = ele.name || ele.key || ele.title || ele.value || ele.message;
    ele.message = ele.message || ele.name || '';
    ele.value = [ele.value, ele.name].find(this.isValue.bind(this));

    ele.input = '';
    ele.index = i;
    ele.cursor = 0;

    utils.define(ele, 'parent', parent);
    ele.level = parent ? parent.level + 1 : 1;
    if (ele.indent == null) {
      ele.indent = parent ? parent.indent + '  ' : (ele.indent || '');
    }

    ele.path = parent ? parent.path + '.' + ele.name : ele.name;
    ele.enabled = !!(this.multiple && !this.isDisabled(ele) && (ele.enabled || this.isSelected(ele)));

    if (!this.isDisabled(ele)) {
      this.longest = Math.max(this.longest, colors.unstyle(ele.message).length);
    }

    // shallow clone the choice first
    let choice = { ...ele };

    // then allow the choice to be reset using the "original" values
    ele.reset = (input = choice.input, value = choice.value) => {
      for (let key of Object.keys(choice)) ele[key] = choice[key];
      ele.input = input;
      ele.value = value;
    };

    if (origVal == null && typeof ele.initial === 'function') {
      ele.input = await ele.initial.call(this, this.state, ele, i);
    }

    return ele;
  }

  async onChoice(choice, i) {
    this.emit('choice', choice, i, this);

    if (typeof choice.onChoice === 'function') {
      await choice.onChoice.call(this, this.state, choice, i);
    }
  }

  async addChoice(ele, i, parent) {
    let choice = await this.toChoice(ele, i, parent);
    this.choices.push(choice);
    this.index = this.choices.length - 1;
    this.limit = this.choices.length;
    return choice;
  }

  async newItem(item, i, parent) {
    let ele = { name: 'New choice name?', editable: true, newChoice: true, ...item };
    let choice = await this.addChoice(ele, i, parent);

    choice.updateChoice = () => {
      delete choice.newChoice;
      choice.name = choice.message = choice.input;
      choice.input = '';
      choice.cursor = 0;
    };

    return this.render();
  }

  indent(choice) {
    if (choice.indent == null) {
      return choice.level > 1 ? '  '.repeat(choice.level - 1) : '';
    }
    return choice.indent;
  }

  dispatch(s, key) {
    if (this.multiple && this[key.name]) return this[key.name]();
    this.alert();
  }

  focus(choice, enabled) {
    if (typeof enabled !== 'boolean') enabled = choice.enabled;
    if (enabled && !choice.enabled && this.selected.length >= this.maxSelected) {
      return this.alert();
    }
    this.index = choice.index;
    choice.enabled = enabled && !this.isDisabled(choice);
    return choice;
  }

  space() {
    if (!this.multiple) return this.alert();
    this.toggle(this.focused);
    return this.render();
  }

  a() {
    if (this.maxSelected < this.choices.length) return this.alert();
    let enabled = this.selectable.every(ch => ch.enabled);
    this.choices.forEach(ch => (ch.enabled = !enabled));
    return this.render();
  }

  i() {
    // don't allow choices to be inverted if it will result in
    // more than the maximum number of allowed selected items.
    if (this.choices.length - this.selected.length > this.maxSelected) {
      return this.alert();
    }
    this.choices.forEach(ch => (ch.enabled = !ch.enabled));
    return this.render();
  }

  g(choice = this.focused) {
    if (!this.choices.some(ch => !!ch.parent)) return this.a();
    this.toggle((choice.parent && !choice.choices) ? choice.parent : choice);
    return this.render();
  }

  toggle(choice, enabled) {
    if (!choice.enabled && this.selected.length >= this.maxSelected) {
      return this.alert();
    }

    if (typeof enabled !== 'boolean') enabled = !choice.enabled;
    choice.enabled = enabled;

    if (choice.choices) {
      choice.choices.forEach(ch => this.toggle(ch, enabled));
    }

    let parent = choice.parent;
    while (parent) {
      let choices = parent.choices.filter(ch => this.isDisabled(ch));
      parent.enabled = choices.every(ch => ch.enabled === true);
      parent = parent.parent;
    }

    reset(this, this.choices);
    this.emit('toggle', choice, this);
    return choice;
  }

  enable(choice) {
    if (this.selected.length >= this.maxSelected) return this.alert();
    choice.enabled = !this.isDisabled(choice);
    choice.choices && choice.choices.forEach(this.enable.bind(this));
    return choice;
  }

  disable(choice) {
    choice.enabled = false;
    choice.choices && choice.choices.forEach(this.disable.bind(this));
    return choice;
  }

  number(n) {
    this.num += n;

    let number = num => {
      let i = Number(num);
      if (i > this.choices.length - 1) return this.alert();

      let focused = this.focused;
      let choice = this.choices.find(ch => i === ch.index);

      if (!choice.enabled && this.selected.length >= this.maxSelected) {
        return this.alert();
      }

      if (this.visible.indexOf(choice) === -1) {
        let choices = reorder(this.choices);
        let actualIdx = choices.indexOf(choice);

        if (focused.index > actualIdx) {
          let start = choices.slice(actualIdx, actualIdx + this.limit);
          let end = choices.filter(ch => !start.includes(ch));
          this.choices = start.concat(end);
        } else {
          let pos = actualIdx - this.limit + 1;
          this.choices = choices.slice(pos).concat(choices.slice(0, pos));
        }
      }

      this.index = this.choices.indexOf(choice);
      this.toggle(this.focused);
      return this.render();
    };

    clearTimeout(this.numberTimeout);

    return new Promise(resolve => {
      let len = this.choices.length;
      let num = this.num;

      let handle = (val = false, res) => {
        clearTimeout(this.numberTimeout);
        if (val) res = number(num);
        this.num = '';
        resolve(res);
      };

      if (num === '0' || (num.length === 1 && Number(num + '0') > len)) {
        return handle(true);
      }

      if (Number(num) > len) {
        return handle(false, this.alert());
      }

      this.numberTimeout = setTimeout(() => handle(true), this.delay);
    });
  }

  home() {
    this.choices = reorder(this.choices);
    this.index = 0;
    return this.render();
  }

  end() {
    let pos = this.choices.length - this.limit;
    let choices = reorder(this.choices);
    this.choices = choices.slice(pos).concat(choices.slice(0, pos));
    this.index = this.limit - 1;
    return this.render();
  }

  first() {
    this.index = 0;
    return this.render();
  }

  last() {
    this.index = this.visible.length - 1;
    return this.render();
  }

  prev() {
    if (this.visible.length <= 1) return this.alert();
    return this.up();
  }

  next() {
    if (this.visible.length <= 1) return this.alert();
    return this.down();
  }

  right() {
    if (this.cursor >= this.input.length) return this.alert();
    this.cursor++;
    return this.render();
  }

  left() {
    if (this.cursor <= 0) return this.alert();
    this.cursor--;
    return this.render();
  }

  up() {
    let len = this.choices.length;
    let vis = this.visible.length;
    let idx = this.index;
    if (this.options.scroll === false && idx === 0) {
      return this.alert();
    }
    if (len > vis && idx === 0) {
      return this.scrollUp();
    }
    this.index = ((idx - 1 % len) + len) % len;
    if (this.isDisabled()) {
      return this.up();
    }
    return this.render();
  }

  down() {
    let len = this.choices.length;
    let vis = this.visible.length;
    let idx = this.index;
    if (this.options.scroll === false && idx === vis - 1) {
      return this.alert();
    }
    if (len > vis && idx === vis - 1) {
      return this.scrollDown();
    }
    this.index = (idx + 1) % len;
    if (this.isDisabled()) {
      return this.down();
    }
    return this.render();
  }

  scrollUp(i = 0) {
    this.choices = scrollUp(this.choices);
    this.index = i;
    if (this.isDisabled()) {
      return this.up();
    }
    return this.render();
  }

  scrollDown(i = this.visible.length - 1) {
    this.choices = scrollDown(this.choices);
    this.index = i;
    if (this.isDisabled()) {
      return this.down();
    }
    return this.render();
  }

  async shiftUp() {
    if (this.options.sort === true) {
      this.sorting = true;
      this.swap(this.index - 1);
      await this.up();
      this.sorting = false;
      return;
    }
    return this.scrollUp(this.index);
  }

  async shiftDown() {
    if (this.options.sort === true) {
      this.sorting = true;
      this.swap(this.index + 1);
      await this.down();
      this.sorting = false;
      return;
    }
    return this.scrollDown(this.index);
  }

  pageUp() {
    if (this.visible.length <= 1) return this.alert();
    this.limit = Math.max(this.limit - 1, 0);
    this.index = Math.min(this.limit - 1, this.index);
    this._limit = this.limit;
    if (this.isDisabled()) {
      return this.up();
    }
    return this.render();
  }

  pageDown() {
    if (this.visible.length >= this.choices.length) return this.alert();
    this.index = Math.max(0, this.index);
    this.limit = Math.min(this.limit + 1, this.choices.length);
    this._limit = this.limit;
    if (this.isDisabled()) {
      return this.down();
    }
    return this.render();
  }

  swap(pos) {
    swap(this.choices, this.index, pos);
  }

  isDisabled(choice = this.focused) {
    let keys = ['disabled', 'collapsed', 'hidden', 'completing', 'readonly'];
    if (choice && keys.some(key => choice[key] === true)) {
      return true;
    }
    return choice && choice.role === 'heading';
  }

  isEnabled(choice = this.focused) {
    if (Array.isArray(choice)) return choice.every(ch => this.isEnabled(ch));
    if (choice.choices) {
      let choices = choice.choices.filter(ch => !this.isDisabled(ch));
      return choice.enabled && choices.every(ch => this.isEnabled(ch));
    }
    return choice.enabled && !this.isDisabled(choice);
  }

  isChoice(choice, value) {
    return choice.name === value || choice.index === Number(value);
  }

  isSelected(choice) {
    if (Array.isArray(this.initial)) {
      return this.initial.some(value => this.isChoice(choice, value));
    }
    return this.isChoice(choice, this.initial);
  }

  map(names = [], prop = 'value') {
    return [].concat(names || []).reduce((acc, name) => {
      acc[name] = this.find(name, prop);
      return acc;
    }, {});
  }

  filter(value, prop) {
    let isChoice = (ele, i) => [ele.name, i].includes(value);
    let fn = typeof value === 'function' ? value : isChoice;
    let choices = this.options.multiple ? this.state._choices : this.choices;
    let result = choices.filter(fn);
    if (prop) {
      return result.map(ch => ch[prop]);
    }
    return result;
  }

  find(value, prop) {
    if (isObject(value)) return prop ? value[prop] : value;
    let isChoice = (ele, i) => [ele.name, i].includes(value);
    let fn = typeof value === 'function' ? value : isChoice;
    let choice = this.choices.find(fn);
    if (choice) {
      return prop ? choice[prop] : choice;
    }
  }

  findIndex(value) {
    return this.choices.indexOf(this.find(value));
  }

  async submit() {
    let choice = this.focused;
    if (!choice) return this.alert();

    if (choice.newChoice) {
      if (!choice.input) return this.alert();
      choice.updateChoice();
      return this.render();
    }

    if (this.choices.some(ch => ch.newChoice)) {
      return this.alert();
    }

    let { reorder, sort } = this.options;
    let multi = this.multiple === true;
    let value = this.selected;
    if (value === void 0) {
      return this.alert();
    }

    // re-sort choices to original order
    if (Array.isArray(value) && reorder !== false && sort !== true) {
      value = utils.reorder(value);
    }

    this.value = multi ? value.map(ch => ch.name) : value.name;
    return super.submit();
  }

  set choices(choices = []) {
    this.state._choices = this.state._choices || [];
    this.state.choices = choices;

    for (let choice of choices) {
      if (!this.state._choices.some(ch => ch.name === choice.name)) {
        this.state._choices.push(choice);
      }
    }

    if (!this._initial && this.options.initial) {
      this._initial = true;
      let init = this.initial;
      if (typeof init === 'string' || typeof init === 'number') {
        let choice = this.find(init);
        if (choice) {
          this.initial = choice.index;
          this.focus(choice, true);
        }
      }
    }
  }
  get choices() {
    return reset(this, this.state.choices || []);
  }

  set visible(visible) {
    this.state.visible = visible;
  }
  get visible() {
    return (this.state.visible || this.choices).slice(0, this.limit);
  }

  set limit(num) {
    this.state.limit = num;
  }
  get limit() {
    let { state, options, choices } = this;
    let limit = state.limit || this._limit || options.limit || choices.length;
    return Math.min(limit, this.height);
  }

  set value(value) {
    super.value = value;
  }
  get value() {
    if (typeof super.value !== 'string' && super.value === this.initial) {
      return this.input;
    }
    return super.value;
  }

  set index(i) {
    this.state.index = i;
  }
  get index() {
    return Math.max(0, this.state ? this.state.index : 0);
  }

  get enabled() {
    return this.filter(this.isEnabled.bind(this));
  }

  get focused() {
    let choice = this.choices[this.index];
    if (choice && this.state.submitted && this.multiple !== true) {
      choice.enabled = true;
    }
    return choice;
  }

  get selectable() {
    return this.choices.filter(choice => !this.isDisabled(choice));
  }

  get selected() {
    return this.multiple ? this.enabled : this.focused;
  }
}

function reset(prompt, choices) {
  if (choices instanceof Promise) return choices;
  if (typeof choices === 'function') {
    if (utils.isAsyncFn(choices)) return choices;
    choices = choices.call(prompt, prompt);
  }
  for (let choice of choices) {
    if (Array.isArray(choice.choices)) {
      let items = choice.choices.filter(ch => !prompt.isDisabled(ch));
      choice.enabled = items.every(ch => ch.enabled === true);
    }
    if (prompt.isDisabled(choice) === true) {
      delete choice.enabled;
    }
  }
  return choices;
}

module.exports = ArrayPrompt;


/***/ }),
/* 552 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(535);
const roles = {
  default(prompt, choice) {
    return choice;
  },
  checkbox(prompt, choice) {
    throw new Error('checkbox role is not implemented yet');
  },
  editable(prompt, choice) {
    throw new Error('editable role is not implemented yet');
  },
  expandable(prompt, choice) {
    throw new Error('expandable role is not implemented yet');
  },
  heading(prompt, choice) {
    choice.disabled = '';
    choice.indicator = [choice.indicator, ' '].find(v => v != null);
    choice.message = choice.message || '';
    return choice;
  },
  input(prompt, choice) {
    throw new Error('input role is not implemented yet');
  },
  option(prompt, choice) {
    return roles.default(prompt, choice);
  },
  radio(prompt, choice) {
    throw new Error('radio role is not implemented yet');
  },
  separator(prompt, choice) {
    choice.disabled = '';
    choice.indicator = [choice.indicator, ' '].find(v => v != null);
    choice.message = choice.message || prompt.symbols.line.repeat(5);
    return choice;
  },
  spacer(prompt, choice) {
    return choice;
  }
};

module.exports = (name, options = {}) => {
  let role = utils.merge({}, roles, options.roles);
  return role[name] || role.default;
};


/***/ }),
/* 553 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const AuthPrompt = __webpack_require__(554);

function defaultAuthenticate(value, state) {
  if (value.username === this.options.username && value.password === this.options.password) {
    return true;
  }
  return false;
}

const factory = (authenticate = defaultAuthenticate) => {
  const choices = [
    { name: 'username', message: 'username' },
    {
      name: 'password',
      message: 'password',
      format(input) {
        if (this.options.showPassword) {
          return input;
        }
        let color = this.state.submitted ? this.styles.primary : this.styles.muted;
        return color(this.symbols.asterisk.repeat(input.length));
      }
    }
  ];

  class BasicAuthPrompt extends AuthPrompt.create(authenticate) {
    constructor(options) {
      super({ ...options, choices });
    }

    static create(authenticate) {
      return factory(authenticate);
    }
  }

  return BasicAuthPrompt;
};

module.exports = factory();


/***/ }),
/* 554 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const FormPrompt = __webpack_require__(555);

const defaultAuthenticate = () => {
  throw new Error('expected prompt to have a custom authenticate method');
};

const factory = (authenticate = defaultAuthenticate) => {

  class AuthPrompt extends FormPrompt {
    constructor(options) {
      super(options);
    }

    async submit() {
      this.value = await authenticate.call(this, this.values, this.state);
      super.base.submit.call(this);
    }

    static create(authenticate) {
      return factory(authenticate);
    }
  }

  return AuthPrompt;
};

module.exports = factory();


/***/ }),
/* 555 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(536);
const SelectPrompt = __webpack_require__(550);
const placeholder = __webpack_require__(556);

class FormPrompt extends SelectPrompt {
  constructor(options) {
    super({ ...options, multiple: true });
    this.type = 'form';
    this.initial = this.options.initial;
    this.align = [this.options.align, 'right'].find(v => v != null);
    this.emptyError = '';
    this.values = {};
  }

  async reset(first) {
    await super.reset();
    if (first === true) this._index = this.index;
    this.index = this._index;
    this.values = {};
    this.choices.forEach(choice => choice.reset && choice.reset());
    return this.render();
  }

  dispatch(char) {
    return !!char && this.append(char);
  }

  append(char) {
    let choice = this.focused;
    if (!choice) return this.alert();
    let { cursor, input } = choice;
    choice.value = choice.input = input.slice(0, cursor) + char + input.slice(cursor);
    choice.cursor++;
    return this.render();
  }

  delete() {
    let choice = this.focused;
    if (!choice || choice.cursor <= 0) return this.alert();
    let { cursor, input } = choice;
    choice.value = choice.input = input.slice(0, cursor - 1) + input.slice(cursor);
    choice.cursor--;
    return this.render();
  }

  deleteForward() {
    let choice = this.focused;
    if (!choice) return this.alert();
    let { cursor, input } = choice;
    if (input[cursor] === void 0) return this.alert();
    let str = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
    choice.value = choice.input = str;
    return this.render();
  }

  right() {
    let choice = this.focused;
    if (!choice) return this.alert();
    if (choice.cursor >= choice.input.length) return this.alert();
    choice.cursor++;
    return this.render();
  }

  left() {
    let choice = this.focused;
    if (!choice) return this.alert();
    if (choice.cursor <= 0) return this.alert();
    choice.cursor--;
    return this.render();
  }

  space(ch, key) {
    return this.dispatch(ch, key);
  }

  number(ch, key) {
    return this.dispatch(ch, key);
  }

  next() {
    let ch = this.focused;
    if (!ch) return this.alert();
    let { initial, input } = ch;
    if (initial && initial.startsWith(input) && input !== initial) {
      ch.value = ch.input = initial;
      ch.cursor = ch.value.length;
      return this.render();
    }
    return super.next();
  }

  prev() {
    let ch = this.focused;
    if (!ch) return this.alert();
    if (ch.cursor === 0) return super.prev();
    ch.value = ch.input = '';
    ch.cursor = 0;
    return this.render();
  }

  separator() {
    return '';
  }

  format(value) {
    return !this.state.submitted ? super.format(value) : '';
  }

  pointer() {
    return '';
  }

  indicator(choice) {
    return choice.input ? '' : '';
  }

  async choiceSeparator(choice, i) {
    let sep = await this.resolve(choice.separator, this.state, choice, i) || ':';
    return sep ? ' ' + this.styles.disabled(sep) : '';
  }

  async renderChoice(choice, i) {
    await this.onChoice(choice, i);

    let { state, styles } = this;
    let { cursor, initial = '', name, hint, input = '' } = choice;
    let { muted, submitted, primary, danger } = styles;

    let help = hint;
    let focused = this.index === i;
    let validate = choice.validate || (() => true);
    let sep = await this.choiceSeparator(choice, i);
    let msg = choice.message;

    if (this.align === 'right') msg = msg.padStart(this.longest + 1, ' ');
    if (this.align === 'left') msg = msg.padEnd(this.longest + 1, ' ');

    // re-populate the form values (answers) object
    let value = this.values[name] = (input || initial);
    let color = input ? 'success' : 'dark';

    if ((await validate.call(choice, value, this.state)) !== true) {
      color = 'danger';
    }

    let style = styles[color];
    let indicator = style(await this.indicator(choice, i)) + (choice.pad || '');

    let indent = this.indent(choice);
    let line = () => [indent, indicator, msg + sep, input, help].filter(Boolean).join(' ');

    if (state.submitted) {
      msg = colors.unstyle(msg);
      input = submitted(input);
      help = '';
      return line();
    }

    if (choice.format) {
      input = await choice.format.call(this, input, choice, i);
    } else {
      let color = this.styles.muted;
      let options = { input, initial, pos: cursor, showCursor: focused, color };
      input = placeholder(this, options);
    }

    if (!this.isValue(input)) {
      input = this.styles.muted(this.symbols.ellipsis);
    }

    if (choice.result) {
      this.values[name] = await choice.result.call(this, value, choice, i);
    }

    if (focused) {
      msg = primary(msg);
    }

    if (choice.error) {
      input += (input ? ' ' : '') + danger(choice.error.trim());
    } else if (choice.hint) {
      input += (input ? ' ' : '') + muted(choice.hint.trim());
    }

    return line();
  }

  async submit() {
    this.value = this.values;
    return super.base.submit.call(this);
  }
}

module.exports = FormPrompt;


/***/ }),
/* 556 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(535);

/**
 * Render a placeholder value with cursor and styling based on the
 * position of the cursor.
 *
 * @param {Object} `prompt` Prompt instance.
 * @param {String} `input` Input string.
 * @param {String} `initial` The initial user-provided value.
 * @param {Number} `pos` Current cursor position.
 * @param {Boolean} `showCursor` Render a simulated cursor using the inverse primary style.
 * @return {String} Returns the styled placeholder string.
 * @api public
 */

module.exports = (prompt, options = {}) => {
  prompt.cursorHide();

  let { input = '', initial = '', pos, showCursor = true, color } = options;
  let style = color || prompt.styles.placeholder;
  let inverse = utils.inverse(prompt.styles.primary);
  let blinker = str => inverse(prompt.styles.black(str));
  let output = input;
  let char = ' ';
  let reverse = blinker(char);

  if (prompt.blink && prompt.blink.off === true) {
    blinker = str => str;
    reverse = '';
  }

  if (showCursor && pos === 0 && initial === '' && input === '') {
    return blinker(char);
  }

  if (showCursor && pos === 0 && (input === initial || input === '')) {
    return blinker(initial[0]) + style(initial.slice(1));
  }

  initial = utils.isPrimitive(initial) ? `${initial}` : '';
  input = utils.isPrimitive(input) ? `${input}` : '';

  let placeholder = initial && initial.startsWith(input) && initial !== input;
  let cursor = placeholder ? blinker(initial[input.length]) : reverse;

  if (pos !== input.length && showCursor === true) {
    output = input.slice(0, pos) + blinker(input[pos]) + input.slice(pos + 1);
    cursor = '';
  }

  if (showCursor === false) {
    cursor = '';
  }

  if (placeholder) {
    let raw = prompt.styles.unstyle(output + cursor);
    return output + cursor + style(initial.slice(raw.length));
  }

  return output + cursor;
};


/***/ }),
/* 557 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BooleanPrompt = __webpack_require__(558);

class ConfirmPrompt extends BooleanPrompt {
  constructor(options) {
    super(options);
    this.default = this.options.default || (this.initial ? '(Y/n)' : '(y/N)');
  }
}

module.exports = ConfirmPrompt;



/***/ }),
/* 558 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Prompt = __webpack_require__(538);
const { isPrimitive, hasColor } = __webpack_require__(535);

class BooleanPrompt extends Prompt {
  constructor(options) {
    super(options);
    this.cursorHide();
  }

  async initialize() {
    let initial = await this.resolve(this.initial, this.state);
    this.input = await this.cast(initial);
    await super.initialize();
  }

  dispatch(ch) {
    if (!this.isValue(ch)) return this.alert();
    this.input = ch;
    return this.submit();
  }

  format(value) {
    let { styles, state } = this;
    return !state.submitted ? styles.primary(value) : styles.success(value);
  }

  cast(input) {
    return this.isTrue(input);
  }

  isTrue(input) {
    return /^[ty1]/i.test(input);
  }

  isFalse(input) {
    return /^[fn0]/i.test(input);
  }

  isValue(value) {
    return isPrimitive(value) && (this.isTrue(value) || this.isFalse(value));
  }

  async hint() {
    if (this.state.status === 'pending') {
      let hint = await this.element('hint');
      if (!hasColor(hint)) {
        return this.styles.muted(hint);
      }
      return hint;
    }
  }

  async render() {
    let { input, size } = this.state;

    let prefix = await this.prefix();
    let sep = await this.separator();
    let msg = await this.message();
    let hint = this.styles.muted(this.default);

    let promptLine = [prefix, msg, hint, sep].filter(Boolean).join(' ');
    this.state.prompt = promptLine;

    let header = await this.header();
    let value = this.value = this.cast(input);
    let output = await this.format(value);
    let help = (await this.error()) || (await this.hint());
    let footer = await this.footer();

    if (help && !promptLine.includes(help)) output += ' ' + help;
    promptLine += ' ' + output;

    this.clear(size);
    this.write([header, promptLine, footer].filter(Boolean).join('\n'));
    this.restore();
  }

  set value(value) {
    super.value = value;
  }
  get value() {
    return this.cast(super.value);
  }
}

module.exports = BooleanPrompt;


/***/ }),
/* 559 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Select = __webpack_require__(550);
const Form = __webpack_require__(555);
const form = Form.prototype;

class Editable extends Select {
  constructor(options) {
    super({ ...options, multiple: true });
    this.align = [this.options.align, 'left'].find(v => v != null);
    this.emptyError = '';
    this.values = {};
  }

  dispatch(char, key) {
    let choice = this.focused;
    let parent = choice.parent || {};
    if (!choice.editable && !parent.editable) {
      if (char === 'a' || char === 'i') return super[char]();
    }
    return form.dispatch.call(this, char, key);
  }

  append(char, key) {
    return form.append.call(this, char, key);
  }

  delete(char, key) {
    return form.delete.call(this, char, key);
  }

  space(char) {
    return this.focused.editable ? this.append(char) : super.space();
  }

  number(char) {
    return this.focused.editable ? this.append(char) : super.number(char);
  }

  next() {
    return this.focused.editable ? form.next.call(this) : super.next();
  }

  prev() {
    return this.focused.editable ? form.prev.call(this) : super.prev();
  }

  async indicator(choice, i) {
    let symbol = choice.indicator || '';
    let value = choice.editable ? symbol : super.indicator(choice, i);
    return await this.resolve(value, this.state, choice, i) || '';
  }

  indent(choice) {
    return choice.role === 'heading' ? '' : (choice.editable ? ' ' : '  ');
  }

  async renderChoice(choice, i) {
    choice.indent = '';
    if (choice.editable) return form.renderChoice.call(this, choice, i);
    return super.renderChoice(choice, i);
  }

  error() {
    return '';
  }

  footer() {
    return this.state.error;
  }

  async validate() {
    let result = true;

    for (let choice of this.choices) {
      if (typeof choice.validate !== 'function') {
        continue;
      }

      if (choice.role === 'heading') {
        continue;
      }

      let val = choice.parent ? this.value[choice.parent.name] : this.value;

      if (choice.editable) {
        val = choice.value === choice.name ? choice.initial || '' : choice.value;
      } else if (!this.isDisabled(choice)) {
        val = choice.enabled === true;
      }

      result = await choice.validate(val, this.state);

      if (result !== true) {
        break;
      }
    }

    if (result !== true) {
      this.state.error = typeof result === 'string' ? result : 'Invalid Input';
    }

    return result;
  }

  submit() {
    if (this.focused.newChoice === true) return super.submit();
    if (this.choices.some(ch => ch.newChoice)) {
      return this.alert();
    }

    this.value = {};

    for (let choice of this.choices) {
      let val = choice.parent ? this.value[choice.parent.name] : this.value;

      if (choice.role === 'heading') {
        this.value[choice.name] = {};
        continue;
      }

      if (choice.editable) {
        val[choice.name] = choice.value === choice.name
          ? (choice.initial || '')
          : choice.value;

      } else if (!this.isDisabled(choice)) {
        val[choice.name] = choice.enabled === true;
      }
    }

    return this.base.submit.call(this);
  }
}

module.exports = Editable;


/***/ }),
/* 560 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Prompt = __webpack_require__(561);
const completer = __webpack_require__(562);

class Input extends Prompt {
  constructor(options) {
    super(options);
    let history = this.options.history;
    if (history && history.store) {
      let initial = history.values || this.initial;
      this.autosave = !!history.autosave;
      this.store = history.store;
      this.data = this.store.get('values') || { past: [], present: initial };
      this.initial = this.data.present || this.data.past[this.data.past.length - 1];
    }
  }

  completion(action) {
    if (!this.store) return this.alert();
    this.data = completer(action, this.data, this.input);
    if (!this.data.present) return this.alert();
    this.input = this.data.present;
    this.cursor = this.input.length;
    return this.render();
  }

  altUp() {
    return this.completion('prev');
  }

  altDown() {
    return this.completion('next');
  }

  prev() {
    this.save();
    return super.prev();
  }

  save() {
    if (!this.store) return;
    this.data = completer('save', this.data, this.input);
    this.store.set('values', this.data);
  }

  submit() {
    if (this.store && this.autosave === true) {
      this.save();
    }
    return super.submit();
  }
}

module.exports = Input;


/***/ }),
/* 561 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Prompt = __webpack_require__(538);
const placeholder = __webpack_require__(556);
const { isPrimitive } = __webpack_require__(535);

class StringPrompt extends Prompt {
  constructor(options) {
    super(options);
    this.initial = isPrimitive(this.initial) ? String(this.initial) : '';
    if (this.initial) this.cursorHide();
    this.state.prevCursor = 0;
    this.state.clipboard = [];
  }

  async keypress(input, key = {}) {
    let prev = this.state.prevKeypress;
    this.state.prevKeypress = key;
    if (this.options.multiline === true && key.name === 'return') {
      if (!prev || prev.name !== 'return') {
        return this.append('\n', key);
      }
    }
    return super.keypress(input, key);
  }

  moveCursor(n) {
    this.cursor += n;
  }

  reset() {
    this.input = this.value = '';
    this.cursor = 0;
    return this.render();
  }

  dispatch(ch, key) {
    if (!ch || key.ctrl || key.code) return this.alert();
    this.append(ch);
  }

  append(ch) {
    let { cursor, input } = this.state;
    this.input = `${input}`.slice(0, cursor) + ch + `${input}`.slice(cursor);
    this.moveCursor(String(ch).length);
    this.render();
  }

  insert(str) {
    this.append(str);
  }

  delete() {
    let { cursor, input } = this.state;
    if (cursor <= 0) return this.alert();
    this.input = `${input}`.slice(0, cursor - 1) + `${input}`.slice(cursor);
    this.moveCursor(-1);
    this.render();
  }

  deleteForward() {
    let { cursor, input } = this.state;
    if (input[cursor] === void 0) return this.alert();
    this.input = `${input}`.slice(0, cursor) + `${input}`.slice(cursor + 1);
    this.render();
  }

  cutForward() {
    let pos = this.cursor;
    if (this.input.length <= pos) return this.alert();
    this.state.clipboard.push(this.input.slice(pos));
    this.input = this.input.slice(0, pos);
    this.render();
  }

  cutLeft() {
    let pos = this.cursor;
    if (pos === 0) return this.alert();
    let before = this.input.slice(0, pos);
    let after = this.input.slice(pos);
    let words = before.split(' ');
    this.state.clipboard.push(words.pop());
    this.input = words.join(' ');
    this.cursor = this.input.length;
    this.input += after;
    this.render();
  }

  paste() {
    if (!this.state.clipboard.length) return this.alert();
    this.insert(this.state.clipboard.pop());
    this.render();
  }

  toggleCursor() {
    if (this.state.prevCursor) {
      this.cursor = this.state.prevCursor;
      this.state.prevCursor = 0;
    } else {
      this.state.prevCursor = this.cursor;
      this.cursor = 0;
    }
    this.render();
  }

  first() {
    this.cursor = 0;
    this.render();
  }

  last() {
    this.cursor = this.input.length - 1;
    this.render();
  }

  next() {
    let init = this.initial != null ? String(this.initial) : '';
    if (!init || !init.startsWith(this.input)) return this.alert();
    this.input = this.initial;
    this.cursor = this.initial.length;
    this.render();
  }

  prev() {
    if (!this.input) return this.alert();
    this.reset();
  }

  backward() {
    return this.left();
  }

  forward() {
    return this.right();
  }

  right() {
    if (this.cursor >= this.input.length) return this.alert();
    this.moveCursor(1);
    return this.render();
  }

  left() {
    if (this.cursor <= 0) return this.alert();
    this.moveCursor(-1);
    return this.render();
  }

  isValue(value) {
    return !!value;
  }

  async format(input = this.value) {
    let initial = await this.resolve(this.initial, this.state);
    if (!this.state.submitted) {
      return placeholder(this, { input, initial, pos: this.cursor });
    }
    return this.styles.submitted(input || initial);
  }

  async render() {
    let size = this.state.size;

    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
    this.state.prompt = prompt;

    let header = await this.header();
    let output = await this.format();
    let help = (await this.error()) || (await this.hint());
    let footer = await this.footer();

    if (help && !output.includes(help)) output += ' ' + help;
    prompt += ' ' + output;

    this.clear(size);
    this.write([header, prompt, footer].filter(Boolean).join('\n'));
    this.restore();
  }
}

module.exports = StringPrompt;


/***/ }),
/* 562 */
/***/ ((module) => {

"use strict";


const unique = arr => arr.filter((v, i) => arr.lastIndexOf(v) === i);
const compact = arr => unique(arr).filter(Boolean);

module.exports = (action, data = {}, value = '') => {
  let { past = [], present = '' } = data;
  let rest, prev;

  switch (action) {
    case 'prev':
    case 'undo':
      rest = past.slice(0, past.length - 1);
      prev = past[past.length - 1] || '';
      return {
        past: compact([value, ...rest]),
        present: prev
      };

    case 'next':
    case 'redo':
      rest = past.slice(1);
      prev = past[0] || '';
      return {
        past: compact([...rest, value]),
        present: prev
      };

    case 'save':
      return {
        past: compact([...past, value]),
        present: ''
      };

    case 'remove':
      prev = compact(past.filter(v => v !== value));
      present = '';

      if (prev.length) {
        present = prev.pop();
      }

      return {
        past: prev,
        present
      };

    default: {
      throw new Error(`Invalid action: "${action}"`);
    }
  }
};


/***/ }),
/* 563 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const StringPrompt = __webpack_require__(561);

class InvisiblePrompt extends StringPrompt {
  format() {
    return '';
  }
}

module.exports = InvisiblePrompt;


/***/ }),
/* 564 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const StringPrompt = __webpack_require__(561);

class ListPrompt extends StringPrompt {
  constructor(options = {}) {
    super(options);
    this.sep = this.options.separator || /, */;
    this.initial = options.initial || '';
  }

  split(input = this.value) {
    return input ? String(input).split(this.sep) : [];
  }

  format() {
    let style = this.state.submitted ? this.styles.primary : val => val;
    return this.list.map(style).join(', ');
  }

  async submit(value) {
    let result = this.state.error || await this.validate(this.list, this.state);
    if (result !== true) {
      this.state.error = result;
      return super.submit();
    }
    this.value = this.list;
    return super.submit();
  }

  get list() {
    return this.split();
  }
}

module.exports = ListPrompt;


/***/ }),
/* 565 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Select = __webpack_require__(550);

class MultiSelect extends Select {
  constructor(options) {
    super({ ...options, multiple: true });
  }
}

module.exports = MultiSelect;


/***/ }),
/* 566 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(567);


/***/ }),
/* 567 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const StringPrompt = __webpack_require__(561);

class NumberPrompt extends StringPrompt {
  constructor(options = {}) {
    super({ style: 'number', ...options });
    this.min = this.isValue(options.min) ? this.toNumber(options.min) : -Infinity;
    this.max = this.isValue(options.max) ? this.toNumber(options.max) : Infinity;
    this.delay = options.delay != null ? options.delay : 1000;
    this.float = options.float !== false;
    this.round = options.round === true || options.float === false;
    this.major = options.major || 10;
    this.minor = options.minor || 1;
    this.initial = options.initial != null ? options.initial : '';
    this.input = String(this.initial);
    this.cursor = this.input.length;
    this.cursorShow();
  }

  append(ch) {
    if (!/[-+.]/.test(ch) || (ch === '.' && this.input.includes('.'))) {
      return this.alert('invalid number');
    }
    return super.append(ch);
  }

  number(ch) {
    return super.append(ch);
  }

  next() {
    if (this.input && this.input !== this.initial) return this.alert();
    if (!this.isValue(this.initial)) return this.alert();
    this.input = this.initial;
    this.cursor = String(this.initial).length;
    return this.render();
  }

  up(number) {
    let step = number || this.minor;
    let num = this.toNumber(this.input);
    if (num > this.max + step) return this.alert();
    this.input = `${num + step}`;
    return this.render();
  }

  down(number) {
    let step = number || this.minor;
    let num = this.toNumber(this.input);
    if (num < this.min - step) return this.alert();
    this.input = `${num - step}`;
    return this.render();
  }

  shiftDown() {
    return this.down(this.major);
  }

  shiftUp() {
    return this.up(this.major);
  }

  format(input = this.input) {
    if (typeof this.options.format === 'function') {
      return this.options.format.call(this, input);
    }
    return this.styles.info(input);
  }

  toNumber(value = '') {
    return this.float ? +value : Math.round(+value);
  }

  isValue(value) {
    return /^[-+]?[0-9]+((\.)|(\.[0-9]+))?$/.test(value);
  }

  submit() {
    let value = [this.input, this.initial].find(v => this.isValue(v));
    this.value = this.toNumber(value || 0);
    return super.submit();
  }
}

module.exports = NumberPrompt;


/***/ }),
/* 568 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const StringPrompt = __webpack_require__(561);

class PasswordPrompt extends StringPrompt {
  constructor(options) {
    super(options);
    this.cursorShow();
  }

  format(input = this.input) {
    if (!this.keypressed) return '';
    let color = this.state.submitted ? this.styles.primary : this.styles.muted;
    return color(this.symbols.asterisk.repeat(input.length));
  }
}

module.exports = PasswordPrompt;


/***/ }),
/* 569 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(536);
const ArrayPrompt = __webpack_require__(551);
const utils = __webpack_require__(535);

class LikertScale extends ArrayPrompt {
  constructor(options = {}) {
    super(options);
    this.widths = [].concat(options.messageWidth || 50);
    this.align = [].concat(options.align || 'left');
    this.linebreak = options.linebreak || false;
    this.edgeLength = options.edgeLength || 3;
    this.newline = options.newline || '\n   ';
    let start = options.startNumber || 1;
    if (typeof this.scale === 'number') {
      this.scaleKey = false;
      this.scale = Array(this.scale).fill(0).map((v, i) => ({ name: i + start }));
    }
  }

  async reset() {
    this.tableized = false;
    await super.reset();
    return this.render();
  }

  tableize() {
    if (this.tableized === true) return;
    this.tableized = true;
    let longest = 0;

    for (let ch of this.choices) {
      longest = Math.max(longest, ch.message.length);
      ch.scaleIndex = ch.initial || 2;
      ch.scale = [];

      for (let i = 0; i < this.scale.length; i++) {
        ch.scale.push({ index: i });
      }
    }
    this.widths[0] = Math.min(this.widths[0], longest + 3);
  }

  async dispatch(s, key) {
    if (this.multiple) {
      return this[key.name] ? await this[key.name](s, key) : await super.dispatch(s, key);
    }
    this.alert();
  }

  heading(msg, item, i) {
    return this.styles.strong(msg);
  }

  separator() {
    return this.styles.muted(this.symbols.ellipsis);
  }

  right() {
    let choice = this.focused;
    if (choice.scaleIndex >= this.scale.length - 1) return this.alert();
    choice.scaleIndex++;
    return this.render();
  }

  left() {
    let choice = this.focused;
    if (choice.scaleIndex <= 0) return this.alert();
    choice.scaleIndex--;
    return this.render();
  }

  indent() {
    return '';
  }

  format() {
    if (this.state.submitted) {
      let values = this.choices.map(ch => this.styles.info(ch.index));
      return values.join(', ');
    }
    return '';
  }

  pointer() {
    return '';
  }

  /**
   * Render the scale "Key". Something like:
   * @return {String}
   */

  renderScaleKey() {
    if (this.scaleKey === false) return '';
    if (this.state.submitted) return '';
    let scale = this.scale.map(item => `   ${item.name} - ${item.message}`);
    let key = ['', ...scale].map(item => this.styles.muted(item));
    return key.join('\n');
  }

  /**
   * Render the heading row for the scale.
   * @return {String}
   */

  renderScaleHeading(max) {
    let keys = this.scale.map(ele => ele.name);
    if (typeof this.options.renderScaleHeading === 'function') {
      keys = this.options.renderScaleHeading.call(this, max);
    }
    let diff = this.scaleLength - keys.join('').length;
    let spacing = Math.round(diff / (keys.length - 1));
    let names = keys.map(key => this.styles.strong(key));
    let headings = names.join(' '.repeat(spacing));
    let padding = ' '.repeat(this.widths[0]);
    return this.margin[3] + padding + this.margin[1] + headings;
  }

  /**
   * Render a scale indicator =>  or  by default
   */

  scaleIndicator(choice, item, i) {
    if (typeof this.options.scaleIndicator === 'function') {
      return this.options.scaleIndicator.call(this, choice, item, i);
    }
    let enabled = choice.scaleIndex === item.index;
    if (item.disabled) return this.styles.hint(this.symbols.radio.disabled);
    if (enabled) return this.styles.success(this.symbols.radio.on);
    return this.symbols.radio.off;
  }

  /**
   * Render the actual scale => 
   */

  renderScale(choice, i) {
    let scale = choice.scale.map(item => this.scaleIndicator(choice, item, i));
    let padding = this.term === 'Hyper' ? '' : ' ';
    return scale.join(padding + this.symbols.line.repeat(this.edgeLength));
  }

  /**
   * Render a choice, including scale =>
   *   "The website is easy to navigate. "
   */

  async renderChoice(choice, i) {
    await this.onChoice(choice, i);

    let focused = this.index === i;
    let pointer = await this.pointer(choice, i);
    let hint = await choice.hint;

    if (hint && !utils.hasColor(hint)) {
      hint = this.styles.muted(hint);
    }

    let pad = str => this.margin[3] + str.replace(/\s+$/, '').padEnd(this.widths[0], ' ');
    let newline = this.newline;
    let ind = this.indent(choice);
    let message = await this.resolve(choice.message, this.state, choice, i);
    let scale = await this.renderScale(choice, i);
    let margin = this.margin[1] + this.margin[3];
    this.scaleLength = colors.unstyle(scale).length;
    this.widths[0] = Math.min(this.widths[0], this.width - this.scaleLength - margin.length);
    let msg = utils.wordWrap(message, { width: this.widths[0], newline });
    let lines = msg.split('\n').map(line => pad(line) + this.margin[1]);

    if (focused) {
      scale = this.styles.info(scale);
      lines = lines.map(line => this.styles.info(line));
    }

    lines[0] += scale;

    if (this.linebreak) lines.push('');
    return [ind + pointer, lines.join('\n')].filter(Boolean);
  }

  async renderChoices() {
    if (this.state.submitted) return '';
    this.tableize();
    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
    let visible = await Promise.all(choices);
    let heading = await this.renderScaleHeading();
    return this.margin[0] + [heading, ...visible.map(v => v.join(' '))].join('\n');
  }

  async render() {
    let { submitted, size } = this.state;

    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let prompt = '';
    if (this.options.promptLine !== false) {
      prompt = [prefix, message, separator, ''].join(' ');
      this.state.prompt = prompt;
    }

    let header = await this.header();
    let output = await this.format();
    let key = await this.renderScaleKey();
    let help = await this.error() || await this.hint();
    let body = await this.renderChoices();
    let footer = await this.footer();
    let err = this.emptyError;

    if (output) prompt += output;
    if (help && !prompt.includes(help)) prompt += ' ' + help;

    if (submitted && !output && !body.trim() && this.multiple && err != null) {
      prompt += this.styles.danger(err);
    }

    this.clear(size);
    this.write([header, prompt, key, body, footer].filter(Boolean).join('\n'));
    if (!this.state.submitted) {
      this.write(this.margin[2]);
    }
    this.restore();
  }

  submit() {
    this.value = {};
    for (let choice of this.choices) {
      this.value[choice.name] = choice.scaleIndex;
    }
    return this.base.submit.call(this);
  }
}

module.exports = LikertScale;


/***/ }),
/* 570 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(536);
const interpolate = __webpack_require__(571);
const Prompt = __webpack_require__(538);

class SnippetPrompt extends Prompt {
  constructor(options) {
    super(options);
    this.cursorHide();
    this.reset(true);
  }

  async initialize() {
    this.interpolate = await interpolate(this);
    await super.initialize();
  }

  async reset(first) {
    this.state.keys = [];
    this.state.invalid = new Map();
    this.state.missing = new Set();
    this.state.completed = 0;
    this.state.values = {};

    if (first !== true) {
      await this.initialize();
      await this.render();
    }
  }

  moveCursor(n) {
    let item = this.getItem();
    this.cursor += n;
    item.cursor += n;
  }

  dispatch(ch, key) {
    if (!key.code && !key.ctrl && ch != null && this.getItem()) {
      this.append(ch, key);
      return;
    }
    this.alert();
  }

  append(ch, key) {
    let item = this.getItem();
    let prefix = item.input.slice(0, this.cursor);
    let suffix = item.input.slice(this.cursor);
    this.input = item.input = `${prefix}${ch}${suffix}`;
    this.moveCursor(1);
    this.render();
  }

  delete() {
    let item = this.getItem();
    if (this.cursor <= 0 || !item.input) return this.alert();
    let suffix = item.input.slice(this.cursor);
    let prefix = item.input.slice(0, this.cursor - 1);
    this.input = item.input = `${prefix}${suffix}`;
    this.moveCursor(-1);
    this.render();
  }

  increment(i) {
    return i >= this.state.keys.length - 1 ? 0 : i + 1;
  }

  decrement(i) {
    return i <= 0 ? this.state.keys.length - 1 : i - 1;
  }

  first() {
    this.state.index = 0;
    this.render();
  }

  last() {
    this.state.index = this.state.keys.length - 1;
    this.render();
  }

  right() {
    if (this.cursor >= this.input.length) return this.alert();
    this.moveCursor(1);
    this.render();
  }

  left() {
    if (this.cursor <= 0) return this.alert();
    this.moveCursor(-1);
    this.render();
  }

  prev() {
    this.state.index = this.decrement(this.state.index);
    this.getItem();
    this.render();
  }

  next() {
    this.state.index = this.increment(this.state.index);
    this.getItem();
    this.render();
  }

  up() {
    this.prev();
  }

  down() {
    this.next();
  }

  format(value) {
    let color = this.state.completed < 100 ? this.styles.warning : this.styles.success;
    if (this.state.submitted === true && this.state.completed !== 100) {
      color = this.styles.danger;
    }
    return color(`${this.state.completed}% completed`);
  }

  async render() {
    let { index, keys = [], submitted, size } = this.state;

    let newline = [this.options.newline, '\n'].find(v => v != null);
    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
    this.state.prompt = prompt;

    let header = await this.header();
    let error = (await this.error()) || '';
    let hint = (await this.hint()) || '';
    let body = submitted ? '' : await this.interpolate(this.state);

    let key = this.state.key = keys[index] || '';
    let input = await this.format(key);
    let footer = await this.footer();
    if (input) prompt += ' ' + input;
    if (hint && !input && this.state.completed === 0) prompt += ' ' + hint;

    this.clear(size);
    let lines = [header, prompt, body, footer, error.trim()];
    this.write(lines.filter(Boolean).join(newline));
    this.restore();
  }

  getItem(name) {
    let { items, keys, index } = this.state;
    let item = items.find(ch => ch.name === keys[index]);
    if (item && item.input != null) {
      this.input = item.input;
      this.cursor = item.cursor;
    }
    return item;
  }

  async submit() {
    if (typeof this.interpolate !== 'function') await this.initialize();
    await this.interpolate(this.state, true);

    let { invalid, missing, output, values } = this.state;
    if (invalid.size) {
      let err = '';
      for (let [key, value] of invalid) err += `Invalid ${key}: ${value}\n`;
      this.state.error = err;
      return super.submit();
    }

    if (missing.size) {
      this.state.error = 'Required: ' + [...missing.keys()].join(', ');
      return super.submit();
    }

    let lines = colors.unstyle(output).split('\n');
    let result = lines.map(v => v.slice(1)).join('\n');
    this.value = { values, result };
    return super.submit();
  }
}

module.exports = SnippetPrompt;


/***/ }),
/* 571 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const colors = __webpack_require__(536);
const clean = (str = '') => {
  return typeof str === 'string' ? str.replace(/^['"]|['"]$/g, '') : '';
};

/**
 * This file contains the interpolation and rendering logic for
 * the Snippet prompt.
 */

class Item {
  constructor(token) {
    this.name = token.key;
    this.field = token.field || {};
    this.value = clean(token.initial || this.field.initial || '');
    this.message = token.message || this.name;
    this.cursor = 0;
    this.input = '';
    this.lines = [];
  }
}

const tokenize = async(options = {}, defaults = {}, fn = token => token) => {
  let unique = new Set();
  let fields = options.fields || [];
  let input = options.template;
  let tabstops = [];
  let items = [];
  let keys = [];
  let line = 1;

  if (typeof input === 'function') {
    input = await input();
  }

  let i = -1;
  let next = () => input[++i];
  let peek = () => input[i + 1];
  let push = token => {
    token.line = line;
    tabstops.push(token);
  };

  push({ type: 'bos', value: '' });

  while (i < input.length - 1) {
    let value = next();

    if (/^[^\S\n ]$/.test(value)) {
      push({ type: 'text', value });
      continue;
    }

    if (value === '\n') {
      push({ type: 'newline', value });
      line++;
      continue;
    }

    if (value === '\\') {
      value += next();
      push({ type: 'text', value });
      continue;
    }

    if ((value === '$' || value === '#' || value === '{') && peek() === '{') {
      let n = next();
      value += n;

      let token = { type: 'template', open: value, inner: '', close: '', value };
      let ch;

      while ((ch = next())) {
        if (ch === '}') {
          if (peek() === '}') ch += next();
          token.value += ch;
          token.close = ch;
          break;
        }

        if (ch === ':') {
          token.initial = '';
          token.key = token.inner;
        } else if (token.initial !== void 0) {
          token.initial += ch;
        }

        token.value += ch;
        token.inner += ch;
      }

      token.template = token.open + (token.initial || token.inner) + token.close;
      token.key = token.key || token.inner;

      if (defaults.hasOwnProperty(token.key)) {
        token.initial = defaults[token.key];
      }

      token = fn(token);
      push(token);

      keys.push(token.key);
      unique.add(token.key);

      let item = items.find(item => item.name === token.key);
      token.field = fields.find(ch => ch.name === token.key);

      if (!item) {
        item = new Item(token);
        items.push(item);
      }

      item.lines.push(token.line - 1);
      continue;
    }

    let last = tabstops[tabstops.length - 1];
    if (last.type === 'text' && last.line === line) {
      last.value += value;
    } else {
      push({ type: 'text', value });
    }
  }

  push({ type: 'eos', value: '' });
  return { input, tabstops, unique, keys, items };
};

module.exports = async prompt => {
  let options = prompt.options;
  let required = new Set(options.required === true ? [] : (options.required || []));
  let defaults = { ...options.values, ...options.initial };
  let { tabstops, items, keys } = await tokenize(options, defaults);

  let result = createFn('result', prompt, options);
  let format = createFn('format', prompt, options);
  let isValid = createFn('validate', prompt, options, true);
  let isVal = prompt.isValue.bind(prompt);

  return async(state = {}, submitted = false) => {
    let index = 0;

    state.required = required;
    state.items = items;
    state.keys = keys;
    state.output = '';

    let validate = async(value, state, item, index) => {
      let error = await isValid(value, state, item, index);
      if (error === false) {
        return 'Invalid field ' + item.name;
      }
      return error;
    };

    for (let token of tabstops) {
      let value = token.value;
      let key = token.key;

      if (token.type !== 'template') {
        if (value) state.output += value;
        continue;
      }

      if (token.type === 'template') {
        let item = items.find(ch => ch.name === key);

        if (options.required === true) {
          state.required.add(item.name);
        }

        let val = [item.input, state.values[item.value], item.value, value].find(isVal);
        let field = item.field || {};
        let message = field.message || token.inner;

        if (submitted) {
          let error = await validate(state.values[key], state, item, index);
          if ((error && typeof error === 'string') || error === false) {
            state.invalid.set(key, error);
            continue;
          }

          state.invalid.delete(key);
          let res = await result(state.values[key], state, item, index);
          state.output += colors.unstyle(res);
          continue;
        }

        item.placeholder = false;

        let before = value;
        value = await format(value, state, item, index);

        if (val !== value) {
          state.values[key] = val;
          value = prompt.styles.typing(val);
          state.missing.delete(message);

        } else {
          state.values[key] = void 0;
          val = `<${message}>`;
          value = prompt.styles.primary(val);
          item.placeholder = true;

          if (state.required.has(key)) {
            state.missing.add(message);
          }
        }

        if (state.missing.has(message) && state.validating) {
          value = prompt.styles.warning(val);
        }

        if (state.invalid.has(key) && state.validating) {
          value = prompt.styles.danger(val);
        }

        if (index === state.index) {
          if (before !== value) {
            value = prompt.styles.underline(value);
          } else {
            value = prompt.styles.heading(colors.unstyle(value));
          }
        }

        index++;
      }

      if (value) {
        state.output += value;
      }
    }

    let lines = state.output.split('\n').map(l => ' ' + l);
    let len = items.length;
    let done = 0;

    for (let item of items) {
      if (state.invalid.has(item.name)) {
        item.lines.forEach(i => {
          if (lines[i][0] !== ' ') return;
          lines[i] = state.styles.danger(state.symbols.bullet) + lines[i].slice(1);
        });
      }

      if (prompt.isValue(state.values[item.name])) {
        done++;
      }
    }

    state.completed = ((done / len) * 100).toFixed(0);
    state.output = lines.join('\n');
    return state.output;
  };
};

function createFn(prop, prompt, options, fallback) {
  return (value, state, item, index) => {
    if (typeof item.field[prop] === 'function') {
      return item.field[prop].call(prompt, value, state, item, index);
    }
    return [fallback, value].find(v => prompt.isValue(v));
  };
}


/***/ }),
/* 572 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const hint = '(Use <shift>+<up/down> to sort)';
const Prompt = __webpack_require__(550);

class Sort extends Prompt {
  constructor(options) {
    super({ ...options, reorder: false, sort: true, multiple: true });
    this.state.hint = [this.options.hint, hint].find(this.isValue.bind(this));
  }

  indicator() {
    return '';
  }

  async renderChoice(choice, i) {
    let str = await super.renderChoice(choice, i);
    let sym = this.symbols.identicalTo + ' ';
    let pre = (this.index === i && this.sorting) ? this.styles.muted(sym) : '  ';
    if (this.options.drag === false) pre = '';
    if (this.options.numbered === true) {
      return pre + `${i + 1} - ` + str;
    }
    return pre + str;
  }

  get selected() {
    return this.choices;
  }

  submit() {
    this.value = this.choices.map(choice => choice.value);
    return super.submit();
  }
}

module.exports = Sort;


/***/ }),
/* 573 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ArrayPrompt = __webpack_require__(551);

class Survey extends ArrayPrompt {
  constructor(options = {}) {
    super(options);
    this.emptyError = options.emptyError || 'No items were selected';
    this.term = process.env.TERM_PROGRAM;

    if (!this.options.header) {
      let header = ['', '4 - Strongly Agree', '3 - Agree', '2 - Neutral', '1 - Disagree', '0 - Strongly Disagree', ''];
      header = header.map(ele => this.styles.muted(ele));
      this.state.header = header.join('\n   ');
    }
  }

  async toChoices(...args) {
    if (this.createdScales) return false;
    this.createdScales = true;
    let choices = await super.toChoices(...args);
    for (let choice of choices) {
      choice.scale = createScale(5, this.options);
      choice.scaleIdx = 2;
    }
    return choices;
  }

  dispatch() {
    this.alert();
  }

  space() {
    let choice = this.focused;
    let ele = choice.scale[choice.scaleIdx];
    let selected = ele.selected;
    choice.scale.forEach(e => (e.selected = false));
    ele.selected = !selected;
    return this.render();
  }

  indicator() {
    return '';
  }

  pointer() {
    return '';
  }

  separator() {
    return this.styles.muted(this.symbols.ellipsis);
  }

  right() {
    let choice = this.focused;
    if (choice.scaleIdx >= choice.scale.length - 1) return this.alert();
    choice.scaleIdx++;
    return this.render();
  }

  left() {
    let choice = this.focused;
    if (choice.scaleIdx <= 0) return this.alert();
    choice.scaleIdx--;
    return this.render();
  }

  indent() {
    return '   ';
  }

  async renderChoice(item, i) {
    await this.onChoice(item, i);
    let focused = this.index === i;
    let isHyper = this.term === 'Hyper';
    let n = !isHyper ? 8 : 9;
    let s = !isHyper ? ' ' : '';
    let ln = this.symbols.line.repeat(n);
    let sp = ' '.repeat(n + (isHyper ? 0 : 1));
    let dot = enabled => (enabled ? this.styles.success('') : '') + s;

    let num = i + 1 + '.';
    let color = focused ? this.styles.heading : this.styles.noop;
    let msg = await this.resolve(item.message, this.state, item, i);
    let indent = this.indent(item);
    let scale = indent + item.scale.map((e, i) => dot(i === item.scaleIdx)).join(ln);
    let val = i => i === item.scaleIdx ? color(i) : i;
    let next = indent + item.scale.map((e, i) => val(i)).join(sp);

    let line = () => [num, msg].filter(Boolean).join(' ');
    let lines = () => [line(), scale, next, ' '].filter(Boolean).join('\n');

    if (focused) {
      scale = this.styles.cyan(scale);
      next = this.styles.cyan(next);
    }

    return lines();
  }

  async renderChoices() {
    if (this.state.submitted) return '';
    let choices = this.visible.map(async(ch, i) => await this.renderChoice(ch, i));
    let visible = await Promise.all(choices);
    if (!visible.length) visible.push(this.styles.danger('No matching choices'));
    return visible.join('\n');
  }

  format() {
    if (this.state.submitted) {
      let values = this.choices.map(ch => this.styles.info(ch.scaleIdx));
      return values.join(', ');
    }
    return '';
  }

  async render() {
    let { submitted, size } = this.state;

    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let prompt = [prefix, message, separator].filter(Boolean).join(' ');
    this.state.prompt = prompt;

    let header = await this.header();
    let output = await this.format();
    let help = await this.error() || await this.hint();
    let body = await this.renderChoices();
    let footer = await this.footer();

    if (output || !help) prompt += ' ' + output;
    if (help && !prompt.includes(help)) prompt += ' ' + help;

    if (submitted && !output && !body && this.multiple && this.type !== 'form') {
      prompt += this.styles.danger(this.emptyError);
    }

    this.clear(size);
    this.write([prompt, header, body, footer].filter(Boolean).join('\n'));
    this.restore();
  }

  submit() {
    this.value = {};
    for (let choice of this.choices) {
      this.value[choice.name] = choice.scaleIdx;
    }
    return this.base.submit.call(this);
  }
}

function createScale(n, options = {}) {
  if (Array.isArray(options.scale)) {
    return options.scale.map(ele => ({ ...ele }));
  }
  let scale = [];
  for (let i = 1; i < n + 1; i++) scale.push({ i, selected: false });
  return scale;
}

module.exports = Survey;


/***/ }),
/* 574 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(560);


/***/ }),
/* 575 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const BooleanPrompt = __webpack_require__(558);

class TogglePrompt extends BooleanPrompt {
  async initialize() {
    await super.initialize();
    this.value = this.initial = !!this.options.initial;
    this.disabled = this.options.disabled || 'no';
    this.enabled = this.options.enabled || 'yes';
    await this.render();
  }

  reset() {
    this.value = this.initial;
    this.render();
  }

  delete() {
    this.alert();
  }

  toggle() {
    this.value = !this.value;
    this.render();
  }

  enable() {
    if (this.value === true) return this.alert();
    this.value = true;
    this.render();
  }
  disable() {
    if (this.value === false) return this.alert();
    this.value = false;
    this.render();
  }

  up() {
    this.toggle();
  }
  down() {
    this.toggle();
  }
  right() {
    this.toggle();
  }
  left() {
    this.toggle();
  }
  next() {
    this.toggle();
  }
  prev() {
    this.toggle();
  }

  dispatch(ch = '', key) {
    switch (ch.toLowerCase()) {
      case ' ':
        return this.toggle();
      case '1':
      case 'y':
      case 't':
        return this.enable();
      case '0':
      case 'n':
      case 'f':
        return this.disable();
      default: {
        return this.alert();
      }
    }
  }

  format() {
    let active = str => this.styles.primary.underline(str);
    let value = [
      this.value ? this.disabled : active(this.disabled),
      this.value ? active(this.enabled) : this.enabled
    ];
    return value.join(this.styles.muted(' / '));
  }

  async render() {
    let { size } = this.state;

    let header = await this.header();
    let prefix = await this.prefix();
    let separator = await this.separator();
    let message = await this.message();

    let output = await this.format();
    let help = (await this.error()) || (await this.hint());
    let footer = await this.footer();

    let prompt = [prefix, message, separator, output].join(' ');
    this.state.prompt = prompt;

    if (help && !prompt.includes(help)) prompt += ' ' + help;

    this.clear(size);
    this.write([header, prompt, footer].filter(Boolean).join('\n'));
    this.write(this.margin[2]);
    this.restore();
  }
}

module.exports = TogglePrompt;


/***/ }),
/* 576 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const SelectPrompt = __webpack_require__(550);

class Quiz extends SelectPrompt {
  constructor(options) {
    super(options);
    if (typeof this.options.correctChoice !== 'number' || this.options.correctChoice < 0) {
      throw new Error('Please specify the index of the correct answer from the list of choices');
    }
  }

  async toChoices(value, parent) {
    let choices = await super.toChoices(value, parent);
    if (choices.length < 2) {
      throw new Error('Please give at least two choices to the user');
    }
    if (this.options.correctChoice > choices.length) {
      throw new Error('Please specify the index of the correct answer from the list of choices');
    }
    return choices;
  }

  check(state) {
    return state.index === this.options.correctChoice;
  }

  async result(selected) {
    return {
      selectedAnswer: selected,
      correctAnswer: this.options.choices[this.options.correctChoice].value,
      correct: await this.check(this.state)
    };
  }
}

module.exports = Quiz;


/***/ }),
/* 577 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  ArrayPrompt: __webpack_require__(551),
  AuthPrompt: __webpack_require__(554),
  BooleanPrompt: __webpack_require__(558),
  NumberPrompt: __webpack_require__(567),
  StringPrompt: __webpack_require__(561)
};


/***/ }),
/* 578 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Target": () => /* binding */ Target,
/* harmony export */   "Modifier": () => /* binding */ Modifier,
/* harmony export */   "Strategy": () => /* binding */ Strategy,
/* harmony export */   "getModifier": () => /* binding */ getModifier,
/* harmony export */   "extractRangeModifier": () => /* binding */ extractRangeModifier,
/* harmony export */   "applyModifier": () => /* binding */ applyModifier,
/* harmony export */   "findProjectDescriptors": () => /* binding */ findProjectDescriptors,
/* harmony export */   "extractDescriptorFromPath": () => /* binding */ extractDescriptorFromPath,
/* harmony export */   "getSuggestedDescriptors": () => /* binding */ getSuggestedDescriptors,
/* harmony export */   "fetchDescriptorFrom": () => /* binding */ fetchDescriptorFrom
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(250);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);




var Target;

(function (Target) {
  Target["REGULAR"] = "dependencies";
  Target["DEVELOPMENT"] = "devDependencies";
  Target["PEER"] = "peerDependencies";
})(Target || (Target = {}));

var Modifier;

(function (Modifier) {
  Modifier["CARET"] = "^";
  Modifier["TILDE"] = "~";
  Modifier["EXACT"] = "";
})(Modifier || (Modifier = {}));

var Strategy;

(function (Strategy) {
  /**
   * If set, the suggest engine will offer to keep the current version if the
   * local workspace already depends on it.
   */
  Strategy["KEEP"] = "keep";
  /**
   * If set, the suggest engine will offer to fulfill the request by looking at
   * the ranges currently used by the other workspaces in the project.
   */

  Strategy["REUSE"] = "reuse";
  /**
   * If set, the suggest engine will offer to fulfill the request by using any
   * workspace whose name would match the request.
   */

  Strategy["PROJECT"] = "project";
  /**
   * If set, the suggest engine will offer to fulfill the request by using
   * whatever `<request-name>@latest` would return.
   */

  Strategy["LATEST"] = "latest";
  /**
   * If set, the suggest engine will offer to fulfill the request based on the
   * versions of the package that are already within our cache.
   */

  Strategy["CACHE"] = "cache";
})(Strategy || (Strategy = {}));

function getModifier(flags, project) {
  if (flags.exact) return Modifier.EXACT;
  if (flags.caret) return Modifier.CARET;
  if (flags.tilde) return Modifier.TILDE;
  return project.configuration.get(`defaultSemverRangePrefix`);
}
const SIMPLE_SEMVER = /^([\^~]?)[0-9]+(?:\.[0-9]+){0,2}(?:-\S+)?$/;
function extractRangeModifier(range, {
  project
}) {
  const match = range.match(SIMPLE_SEMVER);
  return match ? match[1] : project.configuration.get(`defaultSemverRangePrefix`);
}
function applyModifier(descriptor, modifier) {
  let {
    protocol,
    source,
    params,
    selector
  } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseRange(descriptor.range);
  if (semver__WEBPACK_IMPORTED_MODULE_0___default().valid(selector)) selector = `${modifier}${descriptor.range}`;
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeDescriptor(descriptor, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeRange({
    protocol,
    source,
    params,
    selector
  }));
}
async function findProjectDescriptors(ident, {
  project,
  target
}) {
  const matches = new Map();

  const getDescriptorEntry = descriptor => {
    let entry = matches.get(descriptor.descriptorHash);

    if (!entry) {
      matches.set(descriptor.descriptorHash, entry = {
        descriptor,
        locators: []
      });
    }

    return entry;
  };

  for (const workspace of project.workspaces) {
    if (target === Target.PEER) {
      const peerDescriptor = workspace.manifest.peerDependencies.get(ident.identHash);

      if (peerDescriptor !== undefined) {
        getDescriptorEntry(peerDescriptor).locators.push(workspace.locator);
      }
    } else {
      const regularDescriptor = workspace.manifest.dependencies.get(ident.identHash);
      const developmentDescriptor = workspace.manifest.devDependencies.get(ident.identHash);

      if (target === Target.DEVELOPMENT) {
        if (developmentDescriptor !== undefined) {
          getDescriptorEntry(developmentDescriptor).locators.push(workspace.locator);
        } else if (regularDescriptor !== undefined) {
          getDescriptorEntry(regularDescriptor).locators.push(workspace.locator);
        }
      } else {
        if (regularDescriptor !== undefined) {
          getDescriptorEntry(regularDescriptor).locators.push(workspace.locator);
        } else if (developmentDescriptor !== undefined) {
          getDescriptorEntry(developmentDescriptor).locators.push(workspace.locator);
        }
      }
    }
  }

  return matches;
}
async function extractDescriptorFromPath(path, {
  cache,
  cwd,
  workspace
}) {
  if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path)) path = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(cwd, path);
  const project = workspace.project;
  const descriptor = await fetchDescriptorFrom(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeIdent(null, `archive`), path, {
    project: workspace.project,
    cache
  });
  if (!descriptor) throw new Error(`Assertion failed: The descriptor should have been found`);
  const report = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ThrowReport();
  const resolver = project.configuration.makeResolver();
  const fetcher = project.configuration.makeFetcher();
  const resolverOptions = {
    checksums: project.storedChecksums,
    project,
    cache,
    fetcher,
    report,
    resolver
  }; // While not useful since it's an absolute path, descriptor always have to be bound before being sent to the fetchers

  const boundDescriptor = resolver.bindDescriptor(descriptor, workspace.anchoredLocator, resolverOptions); // Since it's a file, we assume the returned descriptor is a valid locator

  const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.convertDescriptorToLocator(boundDescriptor);
  const fetchResult = await fetcher.fetch(locator, resolverOptions);
  const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Manifest.find(fetchResult.prefixPath, {
    baseFs: fetchResult.packageFs
  });
  if (!manifest.name) throw new Error(`Target path doesn't have a name`);
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeDescriptor(manifest.name, path);
}
async function getSuggestedDescriptors(request, {
  project,
  workspace,
  cache,
  target,
  modifier,
  strategies,
  maxResults = Infinity
}) {
  if (!(maxResults >= 0)) throw new Error(`Invalid maxResults (${maxResults})`);

  if (request.range !== `unknown`) {
    return [{
      descriptor: request,
      name: `Use ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyDescriptor(project.configuration, request)}`,
      reason: `(unambiguous explicit request)`
    }];
  }

  const existing = typeof workspace !== `undefined` && workspace !== null ? workspace.manifest[target].get(request.identHash) || null : null;
  const suggested = [];

  for (const strategy of strategies) {
    if (suggested.length >= maxResults) break;

    switch (strategy) {
      case Strategy.KEEP:
        {
          if (existing) {
            suggested.push({
              descriptor: existing,
              name: `Keep ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyDescriptor(project.configuration, existing)}`,
              reason: `(no changes)`
            });
          }
        }
        break;

      case Strategy.REUSE:
        {
          for (const {
            descriptor,
            locators
          } of (await findProjectDescriptors(request, {
            project,
            target
          })).values()) {
            // We don't print the "reuse" key for the current workspace if the KEEP strategy is set since that would be redundant
            if (locators.length === 1 && locators[0].locatorHash === workspace.anchoredLocator.locatorHash) if (strategies.includes(Strategy.KEEP)) continue;
            let reason = `(originally used by ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(project.configuration, locators[0])}`;
            reason += locators.length > 1 ? ` and ${locators.length - 1} other${locators.length > 2 ? `s` : ``})` : `)`;
            suggested.push({
              descriptor,
              name: `Reuse ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyDescriptor(project.configuration, descriptor)}`,
              reason
            });
          }
        }
        break;

      case Strategy.CACHE:
        {
          for (const descriptor of project.storedDescriptors.values()) {
            if (descriptor.identHash === request.identHash) {
              suggested.push({
                descriptor,
                name: `Reuse ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyDescriptor(project.configuration, descriptor)}`,
                reason: `(already used somewhere in the lockfile)`
              });
            }
          }
        }
        break;

      case Strategy.PROJECT:
        {
          // Don't suggest a workspace to depend on itself
          if (workspace.manifest.name !== null && request.identHash === workspace.manifest.name.identHash) continue;
          const candidateWorkspace = project.tryWorkspaceByIdent(request);
          if (candidateWorkspace === null) continue;
          suggested.push({
            descriptor: candidateWorkspace.anchoredDescriptor,
            name: `Attach ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyWorkspace(project.configuration, candidateWorkspace)}`,
            reason: `(local workspace at ${candidateWorkspace.cwd})`
          });
        }
        break;

      case Strategy.LATEST:
        {
          if (request.range !== `unknown`) {
            suggested.push({
              descriptor: request,
              name: `Use ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyRange(project.configuration, request.range)}`,
              reason: `(explicit range requested)`
            });
          } else if (target === Target.PEER) {
            suggested.push({
              descriptor: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeDescriptor(request, `*`),
              name: `Use *`,
              reason: `(catch-all peer dependency pattern)`
            });
          } else if (!project.configuration.get(`enableNetwork`)) {
            suggested.push({
              descriptor: null,
              name: `Resolve from latest`,
              reason: project.configuration.format(`(unavailable because enableNetwork is toggled off)`, `grey`)
            });
          } else {
            let latest;

            try {
              latest = await fetchDescriptorFrom(request, `latest`, {
                project,
                cache,
                preserveModifier: false
              });
            } catch (_a) {// Just ignore errors
            }

            if (latest) {
              latest = applyModifier(latest, modifier);
              suggested.push({
                descriptor: latest,
                name: `Use ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyDescriptor(project.configuration, latest)}`,
                reason: `(resolved from latest)`
              });
            }
          }
        }
        break;
    }
  }

  return suggested.slice(0, maxResults);
}
async function fetchDescriptorFrom(ident, range, {
  project,
  cache,
  preserveModifier = true
}) {
  const latestDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeDescriptor(ident, range);
  const report = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ThrowReport();
  const fetcher = project.configuration.makeFetcher();
  const resolver = project.configuration.makeResolver();
  const resolverOptions = {
    checksums: project.storedChecksums,
    project,
    cache,
    fetcher,
    report,
    resolver
  };
  let candidateLocators;

  try {
    candidateLocators = await resolver.getCandidates(latestDescriptor, new Map(), resolverOptions);
  } catch (_a) {
    return null;
  }

  if (candidateLocators.length === 0) return null; // Per the requirements exposed in Resolver.ts, the best is the first one

  const bestLocator = candidateLocators[0];
  let {
    protocol,
    source,
    params,
    selector
  } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseRange(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.convertToManifestRange(bestLocator.reference));
  if (protocol === project.configuration.get(`defaultProtocol`)) protocol = null;

  if (semver__WEBPACK_IMPORTED_MODULE_0___default().valid(selector) && preserveModifier !== false) {
    const referenceRange = typeof preserveModifier === `string` ? preserveModifier : latestDescriptor.range;
    const modifier = extractRangeModifier(referenceRange, {
      project
    });
    selector = modifier + selector;
  }

  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeDescriptor(bestLocator, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeRange({
    protocol,
    source,
    params,
    selector
  }));
}

/***/ }),
/* 579 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ BinCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);




 // eslint-disable-next-line arca/no-default-export

class BinCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.verbose = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      locator
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    await project.restoreInstallState();

    if (this.name) {
      const binaries = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.getPackageAccessibleBinaries(locator, {
        project
      });
      const binary = binaries.get(this.name);
      if (!binary) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a binary named "${this.name}" for package "${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.prettyLocator(configuration, locator)}"`);
      const [,
      /*pkg*/
      binaryFile] = binary;
      this.context.stdout.write(`${binaryFile}\n`);
      return 0;
    }

    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      const binaries = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.getPackageAccessibleBinaries(locator, {
        project
      });
      const keys = Array.from(binaries.keys());
      const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);

      for (const [name, [pkg, binaryFile]] of binaries) {
        report.reportJson({
          name,
          source: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.stringifyIdent(pkg),
          path: binaryFile
        });
      }

      if (this.verbose) {
        for (const [name, [pkg]] of binaries) {
          report.reportInfo(null, `${name.padEnd(maxKeyLength, ` `)}   ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.prettyLocator(configuration, pkg)}`);
        }
      } else {
        for (const name of binaries.keys()) {
          report.reportInfo(null, name);
        }
      }
    });
    return report.exitCode();
  }

}
BinCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `get the path to a binary script`,
  details: `
      When used without arguments, this command will print the list of all the binaries available in the current workspace. Adding the \`-v,--verbose\` flag will cause the output to contain both the binary name and the locator of the package that provides the binary.

      When an argument is specified, this command will just print the path to the binary on the standard output and exit. Note that the reported path may be stored within a zip archive.

      If the \`--json\` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).
    `,
  examples: [[`List all the available binaries`, `$0 bin`], [`Print the path to a specific binary`, `$0 bin eslint`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String({
  required: false
})], BinCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-v,--verbose`)], BinCommand.prototype, "verbose", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], BinCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`bin`)], BinCommand.prototype, "execute", null);

/***/ }),
/* 580 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ CacheCleanCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(206);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);




 // eslint-disable-next-line arca/no-default-export

class CacheCleanCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.mirror = false;
    this.all = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Cache.find(configuration);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async () => {
      const cleanMirror = (this.all || this.mirror) && cache.mirrorCwd !== null;
      const cleanCache = !this.mirror;
      if (cleanMirror) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.removePromise(cache.mirrorCwd);

      if (cleanCache) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.removePromise(cache.cwd);
      }
    });
    return report.exitCode();
  }

}
CacheCleanCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `remove the shared cache files`,
  details: `
      This command will remove all the files from the cache.

      By default only the local cache will be cleaned. This behavior can be disabled with the \`--mirror\`, which will lead to the removal of the global cache files instead, or \`--all\` (which will remove both the local and global caches for the current project).
    `,
  examples: [[`Remove all the local archives`, `$0 cache clean`], [`Remove all the archives stored in the ~/.yarn directory`, `$0 cache clean --mirror`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--mirror`)], CacheCleanCommand.prototype, "mirror", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--all`)], CacheCleanCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`cache`, `clean`)], CacheCleanCommand.prototype, "execute", null);

/***/ }),
/* 581 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ConfigSetCommand,
/* harmony export */   "convertMapsToObjects": () => /* binding */ convertMapsToObjects
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(239);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(486);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);





 // eslint-disable-next-line arca/no-default-export

class ConfigSetCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
    this.unsafe = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const name = this.name.replace(/[.[].*$/, ``);
    const path = this.name.replace(/^[^.[]*/, ``);
    const setting = configuration.settings.get(name);
    if (typeof setting === `undefined`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a configuration settings named "${name}"`);
    const displayedValue = configuration.getSpecial(name, {
      hideSecrets: !this.unsafe,
      getNativePaths: true
    });
    const asObject = convertMapsToObjects(displayedValue);
    const requestedObject = path ? lodash_get__WEBPACK_IMPORTED_MODULE_2___default()(asObject, path) : asObject;
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      includeFooter: false,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      report.reportJson(requestedObject);
    });

    if (!this.json) {
      if (typeof requestedObject === `string`) {
        this.context.stdout.write(`${requestedObject}\n`);
        return report.exitCode();
      } // @ts-ignore: The Node typings forgot one field


      util__WEBPACK_IMPORTED_MODULE_3__.inspect.styles.name = `cyan`;
      this.context.stdout.write(`${(0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(requestedObject, {
        depth: Infinity,
        colors: true,
        compact: false
      })}\n`);
    }

    return report.exitCode();
  }

}
ConfigSetCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `read a configuration settings`,
  details: `
      This command will print a configuration setting.

      Secrets (such as tokens) will be redacted from the output by default. If this behavior isn't desired, set the \`--no-redacted\` to get the untransformed value.
    `,
  examples: [[`Print a simple configuration setting`, `yarn config get yarnPath`], [`Print a complex configuration setting`, `yarn config get packageExtensions`], [`Print a nested field from the configuration`, `yarn config get 'npmScopes["my-company"].npmRegistryServer'`], [`Print a token from the configuration`, `yarn config get npmAuthToken --no-redacted`], [`Print a configuration setting as JSON`, `yarn config get packageExtensions --json`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], ConfigSetCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], ConfigSetCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--no-redacted`)], ConfigSetCommand.prototype, "unsafe", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`config`, `get`)], ConfigSetCommand.prototype, "execute", null);
/**
 * Converts `Maps` to `Objects` recursively.
 */


function convertMapsToObjects(arg) {
  if (arg instanceof Map) arg = Object.fromEntries(arg);

  if (typeof arg === `object` && arg !== null) {
    for (const key of Object.keys(arg)) {
      const value = arg[key];

      if (typeof value === `object` && value !== null) {
        arg[key] = convertMapsToObjects(value);
      }
    }
  }

  return arg;
}

/***/ }),
/* 582 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ConfigSetCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(217);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(583);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(486);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(584);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _get__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(581);








 // eslint-disable-next-line arca/no-default-export

class ConfigSetCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
    this.home = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.find(this.context.cwd, this.context.plugins);
    if (!configuration.projectCwd) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`This command must be run from within a project folder`);
    const name = this.name.replace(/[.[].*$/, ``);
    const path = this.name.replace(/^[^.[]*/, ``);
    const setting = configuration.settings.get(name);
    if (typeof setting === `undefined`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a configuration settings named "${name}"`);
    const value = this.json ? JSON.parse(this.value) : this.value;
    const updateConfiguration = this.home ? patch => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.updateHomeConfiguration(patch) : patch => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.updateConfiguration(configuration.projectCwd, patch);
    await updateConfiguration(current => {
      if (path) {
        const clone = lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_2___default()(current);
        lodash_set__WEBPACK_IMPORTED_MODULE_4___default()(clone, this.name, value);
        return clone;
      } else {
        return { ...current,
          [name]: value
        };
      }
    });
    const updatedConfiguration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.find(this.context.cwd, this.context.plugins);
    const displayedValue = updatedConfiguration.getSpecial(name, {
      hideSecrets: true,
      getNativePaths: true
    });
    const asObject = (0,_get__WEBPACK_IMPORTED_MODULE_6__.convertMapsToObjects)(displayedValue);
    const requestedObject = path ? lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(asObject, path) : asObject;
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      includeFooter: false,
      stdout: this.context.stdout
    }, async report => {
      // @ts-ignore: The Node typings forgot one field
      util__WEBPACK_IMPORTED_MODULE_5__.inspect.styles.name = `cyan`;
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Successfully set ${this.name} to ${(0,util__WEBPACK_IMPORTED_MODULE_5__.inspect)(requestedObject, {
        depth: Infinity,
        colors: true,
        compact: false
      })}`);
    });
    return report.exitCode();
  }

}
ConfigSetCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `change a configuration settings`,
  details: `
      This command will set a configuration setting.

      - If set, the \`-H,--home\` flag will update the home configuration instead of the project configuration.

      When used without the \`--json\` flag, it can only set a simple configuration setting (a string, a number, or a boolean).

      When used with the \`--json\` flag, it can set both simple and complex configuration settings, including Arrays and Objects.
    `,
  examples: [[`Set a simple configuration setting (a string, a number, or a boolean)`, `yarn config set initScope myScope`], [`Set a simple configuration setting (a string, a number, or a boolean) using the \`--json\` flag`, `yarn config set initScope --json \\"myScope\\"`], [`Set a complex configuration setting (an Array) using the \`--json\` flag`, `yarn config set unsafeHttpWhitelist --json '["*.example.com", "example.com"]'`], [`Set a complex configuration setting (an Object) using the \`--json\` flag`, `yarn config set packageExtensions --json '{ "@babel/parser@*": { "dependencies": { "@babel/types": "*" } } }'`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], ConfigSetCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], ConfigSetCommand.prototype, "value", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], ConfigSetCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-H,--home`)], ConfigSetCommand.prototype, "home", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`config`, `set`)], ConfigSetCommand.prototype, "execute", null);

/***/ }),
/* 583 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(381);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),
/* 584 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSet = __webpack_require__(585);

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),
/* 585 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(389),
    castPath = __webpack_require__(326),
    isIndex = __webpack_require__(377),
    isObject = __webpack_require__(348),
    toKey = __webpack_require__(379);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 586 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ConfigCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);





 // eslint-disable-next-line arca/no-default-export

class ConfigCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.verbose = false;
    this.why = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins, {
      strict: false
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      if (configuration.invalid.size > 0 && !this.json) {
        for (const [key, source] of configuration.invalid) report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.INVALID_CONFIGURATION_KEY, `Invalid configuration key "${key}" in ${source}`);

        report.reportSeparator();
      }

      if (this.json) {
        const keys = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.miscUtils.sortMap(configuration.settings.keys(), key => key);

        for (const key of keys) {
          const data = configuration.settings.get(key);
          const effective = configuration.getSpecial(key, {
            hideSecrets: true,
            getNativePaths: true
          });
          const source = configuration.sources.get(key);

          if (this.verbose) {
            report.reportJson({
              key,
              effective,
              source
            });
          } else {
            report.reportJson({
              key,
              effective,
              source,
              ...data
            });
          }
        }
      } else {
        const keys = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.miscUtils.sortMap(configuration.settings.keys(), key => key);
        const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);
        const inspectConfig = {
          breakLength: Infinity,
          colors: configuration.get(`enableColors`),
          maxArrayLength: 2
        };

        if (this.why || this.verbose) {
          const keysAndDescriptions = keys.map(key => {
            const setting = configuration.settings.get(key);
            if (!setting) throw new Error(`Assertion failed: This settings ("${key}") should have been registered`);
            const description = this.why ? configuration.sources.get(key) || `<default>` : setting.description;
            return [key, description];
          });
          const maxDescriptionLength = keysAndDescriptions.reduce((max, [, description]) => {
            return Math.max(max, description.length);
          }, 0);

          for (const [key, description] of keysAndDescriptions) {
            report.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${description.padEnd(maxDescriptionLength, ` `)}   ${(0,util__WEBPACK_IMPORTED_MODULE_2__.inspect)(configuration.getSpecial(key, {
              hideSecrets: true,
              getNativePaths: true
            }), inspectConfig)}`);
          }
        } else {
          for (const key of keys) {
            report.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${(0,util__WEBPACK_IMPORTED_MODULE_2__.inspect)(configuration.getSpecial(key, {
              hideSecrets: true,
              getNativePaths: true
            }), inspectConfig)}`);
          }
        }
      }
    });
    return report.exitCode();
  }

}
ConfigCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `display the current configuration`,
  details: `
      This command prints the current active configuration settings.

      When used together with the \`-v,--verbose\` option, the output will contain the settings description on top of the regular key/value information.

      When used together with the \`--why\` flag, the output will also contain the reason why a settings is set a particular way.

      If the \`--json\` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).

      Note that the paths settings will be normalized - especially on Windows. It means that paths such as \`C:\\project\` will be transparently shown as \`/mnt/c/project\`.
    `,
  examples: [[`Print the active configuration settings`, `$0 config`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-v,--verbose`)], ConfigCommand.prototype, "verbose", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--why`)], ConfigCommand.prototype, "why", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], ConfigCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`config`)], ConfigCommand.prototype, "execute", null);

/***/ }),
/* 587 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ClipanionCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);


 // eslint-disable-next-line arca/no-default-export

class ClipanionCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {
  async execute() {
    const {
      plugins
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.Configuration.find(this.context.cwd, this.context.plugins);
    const pluginDefinitions = [];

    for (const plugin of plugins) {
      const {
        commands
      } = plugin[1];

      if (commands) {
        const cli = clipanion__WEBPACK_IMPORTED_MODULE_0__.Cli.from(commands);
        const definitions = cli.definitions();
        pluginDefinitions.push([plugin[0], definitions]);
      }
    }

    const clipanionDefinitions = this.cli.definitions();

    const arePathsEqual = (path1, path2) => path1.split(` `).slice(1).join() === path2.split(` `).slice(1).join();

    const defaultPlugins = __webpack_require__(588)[`@yarnpkg/builder`].bundles.standard;

    for (const pluginDefinition of pluginDefinitions) {
      const definitions = pluginDefinition[1];

      for (const definition of definitions) {
        clipanionDefinitions.find(clipanionDefinition => arePathsEqual(clipanionDefinition.path, definition.path)).plugin = {
          name: pluginDefinition[0],
          isDefault: defaultPlugins.includes(pluginDefinition[0])
        };
      }
    }

    this.context.stdout.write(`${JSON.stringify({
      commands: clipanionDefinitions
    }, null, 2)}\n`);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--clipanion=definitions`)], ClipanionCommand.prototype, "execute", null);

/***/ }),
/* 588 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse("{\"name\":\"@yarnpkg/cli\",\"version\":\"2.1.1\",\"license\":\"BSD-2-Clause\",\"main\":\"./sources/index.ts\",\"dependencies\":{\"@yarnpkg/core\":\"workspace:^2.1.1\",\"@yarnpkg/fslib\":\"workspace:^2.1.0\",\"@yarnpkg/libzip\":\"workspace:^2.1.0\",\"@yarnpkg/parsers\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-compat\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-dlx\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-essentials\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-file\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-git\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-github\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-http\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-init\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-link\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-node-modules\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-npm\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-npm-cli\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-pack\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-patch\":\"workspace:^2.1.0\",\"@yarnpkg/plugin-pnp\":\"workspace:^2.1.0\",\"@yarnpkg/shell\":\"workspace:^2.1.0\",\"chalk\":\"^3.0.0\",\"clipanion\":\"^2.4.4\",\"fromentries\":\"^1.2.0\",\"semver\":\"^7.1.2\",\"tslib\":\"^1.13.0\",\"yup\":\"^0.27.0\"},\"devDependencies\":{\"@types/yup\":\"0.26.12\",\"@yarnpkg/builder\":\"workspace:^2.1.0\",\"@yarnpkg/monorepo\":\"workspace:0.0.0\",\"@yarnpkg/pnpify\":\"workspace:^2.1.0\",\"micromatch\":\"^4.0.2\",\"typescript\":\"^3.9.5\"},\"peerDependencies\":{\"@yarnpkg/core\":\"^2.1.1\"},\"scripts\":{\"postpack\":\"rm -rf lib\",\"prepack\":\"run build:compile \\\"$(pwd)\\\"\",\"build:cli+hook\":\"run build:pnp:hook && builder build bundle\",\"build:cli\":\"builder build bundle\",\"run:cli\":\"builder run\",\"update-local\":\"run build:cli --no-git-hash && rsync -a --delete bundles/ bin/\"},\"publishConfig\":{\"main\":\"./lib/index.js\",\"types\":\"./lib/index.d.ts\",\"bin\":null},\"files\":[\"/lib/**/*\",\"!/lib/pluginConfiguration.*\",\"!/lib/cli.*\"],\"@yarnpkg/builder\":{\"bundles\":{\"standard\":[\"@yarnpkg/plugin-essentials\",\"@yarnpkg/plugin-compat\",\"@yarnpkg/plugin-dlx\",\"@yarnpkg/plugin-file\",\"@yarnpkg/plugin-git\",\"@yarnpkg/plugin-github\",\"@yarnpkg/plugin-http\",\"@yarnpkg/plugin-init\",\"@yarnpkg/plugin-link\",\"@yarnpkg/plugin-node-modules\",\"@yarnpkg/plugin-npm\",\"@yarnpkg/plugin-npm-cli\",\"@yarnpkg/plugin-pack\",\"@yarnpkg/plugin-patch\",\"@yarnpkg/plugin-pnp\"]}},\"repository\":{\"type\":\"git\",\"url\":\"ssh://git@github.com/yarnpkg/berry.git\"},\"engines\":{\"node\":\">=10.19.0\"}}");

/***/ }),
/* 589 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ HelpCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);

 // eslint-disable-next-line arca/no-default-export

class HelpCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {
  async execute() {
    this.context.stdout.write(this.cli.usage(null));
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_1__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`help`), clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--help`), clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`-h`)], HelpCommand.prototype, "execute", null);

/***/ }),
/* 590 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ EntryCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);



 // eslint-disable-next-line arca/no-default-export

class EntryCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {
  constructor() {
    super(...arguments);
    this.args = [];
  }

  async execute() {
    if (this.leadingArgument.match(/[\\/]/) && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.tryParseIdent(this.leadingArgument)) {
      const newCwd = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(this.leadingArgument));
      return await this.cli.run(this.args, {
        cwd: newCwd
      });
    } else {
      return await this.cli.run([`run`, this.leadingArgument, ...this.args]);
    }
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.String()], EntryCommand.prototype, "leadingArgument", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Proxy()], EntryCommand.prototype, "args", void 0);

/***/ }),
/* 591 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ VersionCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(270);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);


 // eslint-disable-next-line arca/no-default-export

class VersionCommand extends clipanion__WEBPACK_IMPORTED_MODULE_0__.Command {
  async execute() {
    this.context.stdout.write(`${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.YarnVersion || `<unknown>`}\n`);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`-v`), clipanion__WEBPACK_IMPORTED_MODULE_0__.Command.Path(`--version`)], VersionCommand.prototype, "execute", null);

/***/ }),
/* 592 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ ExecCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(206);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);





 // eslint-disable-next-line arca/no-default-export

class ExecCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.args = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async binFolder => {
      const {
        code
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.execUtils.pipevp(this.commandName, this.args, {
        cwd: this.context.cwd,
        stdin: this.context.stdin,
        stdout: this.context.stdout,
        stderr: this.context.stderr,
        env: await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.scriptUtils.makeScriptEnv({
          project,
          binFolder
        })
      });
      return code;
    });
  }

}
ExecCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `execute a shell command`,
  details: `
      This command simply executes a shell binary within the context of the root directory of the active workspace.

      It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).
    `,
  examples: [[`Execute a shell command`, `$0 exec echo Hello World`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], ExecCommand.prototype, "commandName", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], ExecCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`exec`)], ExecCommand.prototype, "execute", null);

/***/ }),
/* 593 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ YarnCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);





 // eslint-disable-next-line arca/no-default-export

class YarnCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
    this.checkCache = false;
    this.silent = false;
  }

  async execute() {
    var _a, _b, _c;

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    if (typeof this.inlineBuilds !== `undefined`) configuration.useWithSource(`<cli>`, {
      enableInlineBuilds: this.inlineBuilds
    }, configuration.startingCwd, {
      overwrite: true
    });
    const isZeitNow = !!process.env.NOW_BUILDER;
    const isNetlify = !!process.env.NETLIFY;
    const isGCF = !!process.env.FUNCTION_TARGET;

    const reportDeprecation = async (message, {
      error
    }) => {
      const deprecationReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
        configuration,
        stdout: this.context.stdout,
        includeFooter: false
      }, async report => {
        if (error) {
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.DEPRECATED_CLI_SETTINGS, message);
        } else {
          report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.DEPRECATED_CLI_SETTINGS, message);
        }
      });

      if (deprecationReport.hasErrors()) {
        return deprecationReport.exitCode();
      } else {
        return null;
      }
    }; // The ignoreEngines flag isn't implemented at the moment. I'm still
    // considering how it should work in the context of plugins - would it
    // make sense to allow them (or direct dependencies) to define new
    // "engine check"? Since it has implications regarding the architecture,
    // I prefer to postpone the decision to later. Also it wouldn't be a flag,
    // it would definitely be a configuration setting.


    if (typeof this.ignoreEngines !== `undefined`) {
      const exitCode = await reportDeprecation(`The --ignore-engines option is deprecated; engine checking isn't a core feature anymore`, {
        error: !isZeitNow
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // The registry flag isn't supported anymore because it makes little sense
    // to use a registry for a single install. You instead want to configure it
    // for all installs inside a project, so through the .yarnrc.yml file. Note
    // that if absolutely necessary, the old behavior can be emulated by adding
    // the YARN_NPM_REGISTRY_SERVER variable to the environment.


    if (typeof this.registry !== `undefined`) {
      const exitCode = await reportDeprecation(`The --registry option is deprecated; prefer setting npmRegistryServer in your .yarnrc.yml file`, {
        error: false
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // The preferOffline flag doesn't make much sense with our architecture.
    // It would require the fetchers to also act as resolvers, which is
    // doable but quirky. Since a similar behavior is available via the
    // --cached flag in yarn add, I prefer to move it outside of the core and
    // let someone implement this "resolver-that-reads-the-cache" logic.


    if (typeof this.preferOffline !== `undefined`) {
      const exitCode = await reportDeprecation(`The --prefer-offline flag is deprecated; use the --cached flag with 'yarn add' instead`, {
        error: !isZeitNow
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // Since the production flag would yield a different lockfile than the
    // regular installs, it's not part of the regular `install` command anymore.
    // Instead, we expect users to use it with `yarn workspaces focus` (which can
    // be used even outside of monorepos).


    if (typeof this.production !== `undefined`) {
      const exitCode = await reportDeprecation(`The --production option is deprecated on 'install'; use 'yarn workspaces focus' instead`, {
        error: true
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // Yarn 2 isn't interactive during installs anyway, so there's no real point
    // to this flag at the moment.


    if (typeof this.nonInteractive !== `undefined`) {
      const exitCode = await reportDeprecation(`The --non-interactive option is deprecated`, {
        error: !isGCF
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // We want to prevent people from using --frozen-lockfile
    // Note: it's been deprecated because we're now locking more than just the
    // lockfile - for example the PnP artifacts will also be locked.


    if (typeof this.frozenLockfile !== `undefined`) {
      const exitCode = await reportDeprecation(`The --frozen-lockfile option is deprecated; use --immutable and/or --immutable-cache instead`, {
        error: !isGCF
      });

      if (exitCode !== null) {
        return exitCode;
      }
    } // We also want to prevent them from using --cache-folder
    // Note: it's been deprecated because the cache folder should be set from
    // the settings. Otherwise there would be a very high chance that multiple
    // Yarn commands would use different caches, causing unexpected behaviors.


    if (typeof this.cacheFolder !== `undefined`) {
      const exitCode = await reportDeprecation(`The cache-folder option has been deprecated; use rc settings instead`, {
        error: !isNetlify
      });

      if (exitCode !== null) {
        return exitCode;
      }
    }

    const immutable = typeof this.immutable === `undefined` && typeof this.frozenLockfile === `undefined` ? (_a = configuration.get(`enableImmutableInstalls`)) !== null && _a !== void 0 ? _a : false : (_c = (_b = this.immutable) !== null && _b !== void 0 ? _b : this.frozenLockfile) !== null && _c !== void 0 ? _c : false;

    if (configuration.projectCwd !== null) {
      const fixReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        includeFooter: false
      }, async report => {
        if (await autofixMergeConflicts(configuration, immutable)) {
          report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.AUTOMERGE_SUCCESS, `Automatically fixed merge conflicts `);
          report.reportSeparator();
        }
      });

      if (fixReport.hasErrors()) {
        return fixReport.exitCode();
      }
    }

    if (configuration.projectCwd !== null) {
      const telemetryReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
        configuration,
        json: this.json,
        stdout: this.context.stdout,
        includeFooter: false
      }, async report => {
        var _a;

        if ((_a = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.telemetry) === null || _a === void 0 ? void 0 : _a.isNew) {
          report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.TELEMETRY_NOTICE, `Yarn will periodically gather anonymous telemetry: https://yarnpkg.com/advanced/telemetry`);
          report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.TELEMETRY_NOTICE, `Run ${configuration.format(`yarn config set --home enableTelemetry 0`, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.FormatType.CODE)} to disable`);
          report.reportSeparator();
        }
      });

      if (telemetryReport.hasErrors()) {
        return telemetryReport.exitCode();
      }
    }

    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Cache.find(configuration, {
      immutable: this.immutableCache,
      check: this.checkCache
    });
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd); // Important: Because other commands also need to run installs, if you
    // get in a situation where you need to change this file in order to
    // customize the install it's very likely you're doing something wrong.
    // This file should stay super super simple, and the configuration and
    // install logic should be implemented elsewhere (probably in either of
    // the Configuration and Install classes). Feel free to open an issue
    // in order to ask for design feedback before writing features.

    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout,
      includeLogs: true
    }, async report => {
      await project.install({
        cache,
        report,
        immutable
      });
    });
    return report.exitCode();
  }

}
YarnCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  description: `install the project dependencies`,
  details: `
      This command setup your project if needed. The installation is splitted in four different steps that each have their own characteristics:

      - **Resolution:** First the package manager will resolve your dependencies. The exact way a dependency version is privileged over another isn't standardized outside of the regular semver guarantees. If a package doesn't resolve to what you would expect, check that all dependencies are correctly declared (also check our website for more information: ).

      - **Fetch:** Then we download all the dependencies if needed, and make sure that they're all stored within our cache (check the value of \`cacheFolder\` in \`yarn config\` to see where are stored the cache files).

      - **Link:** Then we send the dependency tree information to internal plugins tasked from writing them on the disk in some form (for example by generating the .pnp.js file you might know).

      - **Build:** Once the dependency tree has been written on the disk, the package manager will now be free to run the build scripts for all packages that might need it, in a topological order compatible with the way they depend on one another.

      Note that running this command is not part of the recommended workflow. Yarn supports zero-installs, which means that as long as you store your cache and your .pnp.js file inside your repository, everything will work without requiring any install right after cloning your repository or switching branches.

      If the \`--immutable\` option is set, Yarn will abort with an error exit code if the lockfile was to be modified (other paths can be added using the \`immutablePaths\` configuration setting). For backward compatibility we offer an alias under the name of \`--frozen-lockfile\`, but it will be removed in a later release.

      If the \`--immutable-cache\` option is set, Yarn will abort with an error exit code if the cache folder was to be modified (either because files would be added, or because they'd be removed).

      If the \`--check-cache\` option is set, Yarn will always refetch the packages and will ensure that their checksum matches what's 1/ described in the lockfile 2/ inside the existing cache files (if present). This is recommended as part of your CI workflow if you're both following the Zero-Installs model and accepting PRs from third-parties, as they'd otherwise have the ability to alter the checked-in packages before submitting them.

      If the \`--inline-builds\` option is set, Yarn will verbosely print the output of the build steps of your dependencies (instead of writing them into individual files). This is likely useful mostly for debug purposes only when using Docker-like environments.

      If the \`--json\` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).
    `,
  examples: [[`Install the project`, `$0 install`], [`Validate a project when using Zero-Installs`, `$0 install --immutable --immutable-cache`], [`Validate a project when using Zero-Installs (slightly safer if you accept external PRs)`, `$0 install --immutable --immutable-cache --check-cache`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--json`)], YarnCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--immutable`)], YarnCommand.prototype, "immutable", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--immutable-cache`)], YarnCommand.prototype, "immutableCache", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--check-cache`)], YarnCommand.prototype, "checkCache", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--production`, {
  hidden: true
})], YarnCommand.prototype, "production", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--non-interactive`, {
  hidden: true
})], YarnCommand.prototype, "nonInteractive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--frozen-lockfile`, {
  hidden: true
})], YarnCommand.prototype, "frozenLockfile", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--prefer-offline`, {
  hidden: true
})], YarnCommand.prototype, "preferOffline", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--ignore-engines`, {
  hidden: true
})], YarnCommand.prototype, "ignoreEngines", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`--registry`, {
  hidden: true
})], YarnCommand.prototype, "registry", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--inline-builds`)], YarnCommand.prototype, "inlineBuilds", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`--cache-folder`, {
  hidden: true
})], YarnCommand.prototype, "cacheFolder", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--silent`, {
  hidden: true
})], YarnCommand.prototype, "silent", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(), clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`install`)], YarnCommand.prototype, "execute", null);

const MERGE_CONFLICT_ANCESTOR = `|||||||`;
const MERGE_CONFLICT_END = `>>>>>>>`;
const MERGE_CONFLICT_SEP = `=======`;
const MERGE_CONFLICT_START = `<<<<<<<`;

async function autofixMergeConflicts(configuration, immutable) {
  if (!configuration.projectCwd) return false;
  const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.join(configuration.projectCwd, configuration.get(`lockfileFilename`));
  if (!(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsPromise(lockfilePath))) return false;
  const file = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(lockfilePath, `utf8`);
  if (!file.includes(MERGE_CONFLICT_START)) return false;
  if (immutable) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.AUTOMERGE_IMMUTABLE, `Cannot autofix a lockfile when running an immutable install`);
  const [left, right] = getVariants(file);
  let parsedLeft;
  let parsedRight;

  try {
    parsedLeft = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(left);
    parsedRight = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(right);
  } catch (error) {
    throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.AUTOMERGE_FAILED_TO_PARSE, `The individual variants of the lockfile failed to parse`);
  }

  const merged = { ...parsedLeft,
    ...parsedRight
  }; // Old-style lockfiles should be filtered out (for example when switching
  // from a Yarn 2 branch to a Yarn 1 branch). Fortunately (?), they actually
  // parse as valid YAML except that the objects become strings. We can use
  // that to detect them. Damn, it's really ugly though.

  for (const [key, value] of Object.entries(merged)) if (typeof value === `string`) delete merged[key];

  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.changeFilePromise(lockfilePath, (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.stringifySyml)(merged), {
    automaticNewlines: true
  });
  return true;
}

function getVariants(file) {
  const variants = [[], []];
  const lines = file.split(/\r?\n/g);
  let skip = false;

  while (lines.length > 0) {
    const line = lines.shift();
    if (typeof line === `undefined`) throw new Error(`Assertion failed: Some lines should remain`);

    if (line.startsWith(MERGE_CONFLICT_START)) {
      // get the first variant
      while (lines.length > 0) {
        const conflictLine = lines.shift();
        if (typeof conflictLine === `undefined`) throw new Error(`Assertion failed: Some lines should remain`);

        if (conflictLine === MERGE_CONFLICT_SEP) {
          skip = false;
          break;
        } else if (skip || conflictLine.startsWith(MERGE_CONFLICT_ANCESTOR)) {
          skip = true;
          continue;
        } else {
          variants[0].push(conflictLine);
        }
      } // get the second variant


      while (lines.length > 0) {
        const conflictLine = lines.shift();
        if (typeof conflictLine === `undefined`) throw new Error(`Assertion failed: Some lines should remain`);

        if (conflictLine.startsWith(MERGE_CONFLICT_END)) {
          break;
        } else {
          variants[1].push(conflictLine);
        }
      }
    } else {
      variants[0].push(line);
      variants[1].push(line);
    }
  }

  return [variants[0].join(`\n`), variants[1].join(`\n`)];
}

/***/ }),
/* 594 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ LinkCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);




 // eslint-disable-next-line arca/no-default-export

class LinkCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.all = false;
    this.private = false;
    this.relative = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const absoluteDestination = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(this.destination));
    const configuration2 = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(absoluteDestination, this.context.plugins);
    const {
      project: project2,
      workspace: workspace2
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration2, absoluteDestination);
    if (!workspace2) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project2.cwd, absoluteDestination);
    const topLevelWorkspace = project.topLevelWorkspace;
    const linkedWorkspaces = [];

    if (this.all) {
      for (const workspace of project2.workspaces) if (workspace.manifest.name && (!workspace.manifest.private || this.private)) linkedWorkspaces.push(workspace);

      if (linkedWorkspaces.length === 0) {
        throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No workspace found to be linked in the target project`);
      }
    } else {
      if (!workspace2.manifest.name) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The target workspace doesn't have a name and thus cannot be linked`);
      if (workspace2.manifest.private && !this.private) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The target workspace is marked private - use the --private flag to link it anyway`);
      linkedWorkspaces.push(workspace2);
    }

    for (const workspace of linkedWorkspaces) {
      const fullName = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.stringifyIdent(workspace.locator);
      const target = this.relative ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.relative(project.cwd, workspace.cwd) : workspace.cwd;
      topLevelWorkspace.manifest.resolutions.push({
        pattern: {
          descriptor: {
            fullName
          }
        },
        reference: `portal:${target}`
      });
    }

    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return report.exitCode();
  }

}
LinkCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `connect the local project to another one`,
  details: `
      This command will set a new \`resolutions\` field in the project-level manifest and point it to the workspace at the specified location (even if part of another project).

      If the \`--all\` option is set, all workspaces belonging to the target project will be linked to the current one.

      There is no \`yarn unlink\` command. To unlink the workspaces from the current project one must revert the changes made to the \`resolutions\` field.
    `,
  examples: [[`Register a remote workspace for use in the current project`, `$0 link ~/ts-loader`], [`Register all workspaces from a remote project for use in the current project`, `$0 link ~/jest --all`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], LinkCommand.prototype, "destination", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-A,--all`)], LinkCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-p,--private`)], LinkCommand.prototype, "private", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-r,--relative`)], LinkCommand.prototype, "relative", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`link`)], LinkCommand.prototype, "execute", null);

/***/ }),
/* 595 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NodeCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);


 // eslint-disable-next-line arca/no-default-export

class NodeCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.args = [];
  }

  async execute() {
    return this.cli.run([`exec`, `node`, ...this.args]);
  }

}
NodeCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `run node with the hook already setup`,
  details: `
      This command simply runs Node. It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).

      The Node process will use the exact same version of Node as the one used to run Yarn itself, which might be a good way to ensure that your commands always use a consistent Node version.
    `,
  examples: [[`Run a Node script`, `$0 node ./my-script.js`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], NodeCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`node`)], NodeCommand.prototype, "execute", null);

/***/ }),
/* 596 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PluginDlSourcesCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(206);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _set_version_sources__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(597);
/* harmony import */ var _import__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(599);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(601);











const BUILD_WORKFLOW = ({
  pluginName,
  noMinify
}, target) => [[`yarn`, `build:${pluginName}`, ...(noMinify ? [`--no-minify`] : []), `|`]]; // eslint-disable-next-line arca/no-default-export


class PluginDlSourcesCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.repository = `https://github.com/yarnpkg/berry.git`;
    this.branch = `master`;
    this.noMinify = false;
    this.force = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    const target = typeof this.installPath !== `undefined` ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(this.installPath)) : _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath((0,os__WEBPACK_IMPORTED_MODULE_2__.tmpdir)()), `yarnpkg-sources`, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.hashUtils.makeHash(this.repository).slice(0, 6));
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const {
        project
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.Project.find(configuration, this.context.cwd);
      const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
      const identStr = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.stringifyIdent(ident);
      const data = await (0,_list__WEBPACK_IMPORTED_MODULE_5__.getAvailablePlugins)(configuration);
      if (!Object.prototype.hasOwnProperty.call(data, identStr)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be built and imported from sources.`);
      const pluginSpec = identStr;
      const pluginName = pluginSpec.replace(/@yarnpkg\//, ``);
      await (0,_set_version_sources__WEBPACK_IMPORTED_MODULE_3__.prepareRepo)(this, {
        configuration,
        report,
        target
      });
      report.reportSeparator();
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.MessageName.UNNAMED, `Building a fresh ${pluginName}`);
      report.reportSeparator();
      await (0,_set_version_sources__WEBPACK_IMPORTED_MODULE_3__.runWorkflow)(BUILD_WORKFLOW({
        pluginName,
        noMinify: this.noMinify
      }, target), {
        configuration,
        context: this.context,
        target
      });
      report.reportSeparator();
      const pluginPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(target, `packages/${pluginName}/bundles/${pluginSpec}.js`);
      const pluginBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_13__.xfs.readFilePromise(pluginPath);
      await (0,_import__WEBPACK_IMPORTED_MODULE_4__.savePlugin)(pluginSpec, pluginBuffer, {
        project,
        report
      });
    });
    return report.exitCode();
  }

}
PluginDlSourcesCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Plugin-related commands`,
  description: `build a plugin from sources`,
  details: `
      This command clones the Yarn repository into a temporary folder, builds the specified contrib plugin and updates the configuration to reference it in further CLI invocations.

      The plugins can be referenced by their short name if sourced from the official Yarn repository.
    `,
  examples: [[`Build and activate the "@yarnpkg/plugin-exec" plugin`, `$0 plugin import from sources @yarnpkg/plugin-exec`], [`Build and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`, `$0 plugin import from sources exec`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PluginDlSourcesCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--path`)], PluginDlSourcesCommand.prototype, "installPath", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--repository`)], PluginDlSourcesCommand.prototype, "repository", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--branch`)], PluginDlSourcesCommand.prototype, "branch", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--no-minify`)], PluginDlSourcesCommand.prototype, "noMinify", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-f,--force`)], PluginDlSourcesCommand.prototype, "force", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_14__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`plugin`, `import`, `from`, `sources`)], PluginDlSourcesCommand.prototype, "execute", null);

/***/ }),
/* 597 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ SetVersionSourcesCommand,
/* harmony export */   "runWorkflow": () => /* binding */ runWorkflow,
/* harmony export */   "prepareRepo": () => /* binding */ prepareRepo
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(206);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(113);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(598);








const PR_REGEXP = /^[0-9]+$/;

function getBranchRef(branch) {
  if (PR_REGEXP.test(branch)) {
    return `pull/${branch}/head`;
  } else {
    return branch;
  }
}

const CLONE_WORKFLOW = ({
  repository,
  branch
}, target) => [[`git`, `init`, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.fromPortablePath(target)], [`git`, `remote`, `add`, `origin`, repository], [`git`, `fetch`, `origin`, getBranchRef(branch)], [`git`, `reset`, `--hard`, `FETCH_HEAD`]];

const UPDATE_WORKFLOW = ({
  branch
}) => [[`git`, `fetch`, `origin`, getBranchRef(branch), `--force`], [`git`, `reset`, `--hard`, `FETCH_HEAD`], [`git`, `clean`, `-dfx`]];

const BUILD_WORKFLOW = ({
  plugins,
  noMinify
}, target) => [[`yarn`, `build:cli`, ...new Array().concat(...plugins.map(plugin => [`--plugin`, path__WEBPACK_IMPORTED_MODULE_3___default().resolve(target, plugin)])), ...(noMinify ? [`--no-minify`] : []), `|`]]; // eslint-disable-next-line arca/no-default-export


class SetVersionSourcesCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.repository = `https://github.com/yarnpkg/berry.git`;
    this.branch = `master`;
    this.plugins = [];
    this.noMinify = false;
    this.force = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    const target = typeof this.installPath !== `undefined` ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath(this.installPath)) : _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.npath.toPortablePath((0,os__WEBPACK_IMPORTED_MODULE_2__.tmpdir)()), `yarnpkg-sources`, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.hashUtils.makeHash(this.repository).slice(0, 6));
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await prepareRepo(this, {
        configuration,
        report,
        target
      });
      report.reportSeparator();
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Building a fresh bundle`);
      report.reportSeparator();
      await runWorkflow(BUILD_WORKFLOW(this, target), {
        configuration,
        context: this.context,
        target
      });
      report.reportSeparator();
      const bundlePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.resolve(target, `packages/yarnpkg-cli/bundles/yarn.js`);
      const bundleBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.readFilePromise(bundlePath);
      await (0,_version__WEBPACK_IMPORTED_MODULE_4__.setVersion)(configuration, `sources`, bundleBuffer, {
        report
      });
    });
    return report.exitCode();
  }

}
SetVersionSourcesCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `build Yarn from master`,
  details: `
      This command will clone the Yarn repository into a temporary folder, then build it. The resulting bundle will then be copied into the local project.
    `,
  examples: [[`Build Yarn from master`, `$0 set version from sources`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--path`)], SetVersionSourcesCommand.prototype, "installPath", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--repository`)], SetVersionSourcesCommand.prototype, "repository", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--branch`)], SetVersionSourcesCommand.prototype, "branch", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Array(`--plugin`)], SetVersionSourcesCommand.prototype, "plugins", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--no-minify`)], SetVersionSourcesCommand.prototype, "noMinify", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-f,--force`)], SetVersionSourcesCommand.prototype, "force", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`set`, `version`, `from`, `sources`)], SetVersionSourcesCommand.prototype, "execute", null);

async function runWorkflow(workflow, {
  configuration,
  context,
  target
}) {
  for (const [fileName, ...args] of workflow) {
    const usePipe = args[args.length - 1] === `|`;
    if (usePipe) args.pop();

    if (usePipe) {
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.execUtils.pipevp(fileName, args, {
        cwd: target,
        stdin: context.stdin,
        stdout: context.stdout,
        stderr: context.stderr,
        strict: true
      });
    } else {
      context.stdout.write(`${configuration.format(`  $ ${[fileName, ...args].join(` `)}`, `grey`)}\n`);

      try {
        await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.execUtils.execvp(fileName, args, {
          cwd: target,
          strict: true
        });
      } catch (error) {
        context.stdout.write(error.stdout || error.stack);
        throw error;
      }
    }
  }
}
async function prepareRepo(spec, {
  configuration,
  report,
  target
}) {
  let ready = false;

  if (!spec.force && _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(target, `.git`))) {
    report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Fetching the latest commits`);
    report.reportSeparator();

    try {
      await runWorkflow(UPDATE_WORKFLOW(spec), {
        configuration,
        context: spec.context,
        target
      });
      ready = true;
    } catch (error) {
      report.reportSeparator();
      report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Repository update failed; we'll try to regenerate it`);
    }
  }

  if (!ready) {
    report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.UNNAMED, `Cloning the remote repository`);
    report.reportSeparator();
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.removePromise(target);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.xfs.mkdirPromise(target, {
      recursive: true
    });
    await runWorkflow(CLONE_WORKFLOW(spec, target), {
      configuration,
      context: spec.context,
      target
    });
  }
}

/***/ }),
/* 598 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ SetVersionCommand,
/* harmony export */   "setVersion": () => /* binding */ setVersion
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(112);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_2__);






 // eslint-disable-next-line arca/no-default-export

class SetVersionCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.onlyIfNeeded = false;
  } // TODO: Remove alias in next major


  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    if (configuration.get(`yarnPath`) && this.onlyIfNeeded) return 0;
    let bundleUrl;
    if (this.version === `latest` || this.version === `berry`) bundleUrl = `https://github.com/yarnpkg/berry/raw/master/packages/yarnpkg-cli/bin/yarn.js`;else if (this.version === `classic`) bundleUrl = `https://nightly.yarnpkg.com/latest.js`;else if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.semverUtils.satisfiesWithPrereleases(this.version, `>=2.0.0`)) bundleUrl = `https://github.com/yarnpkg/berry/raw/%40yarnpkg/cli/${this.version}/packages/yarnpkg-cli/bin/yarn.js`;else if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.semverUtils.satisfiesWithPrereleases(this.version, `^0.x || ^1.x`)) bundleUrl = `https://github.com/yarnpkg/yarn/releases/download/v${this.version}/yarn-${this.version}.js`;else if (semver__WEBPACK_IMPORTED_MODULE_2___default().validRange(this.version)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Support for ranges got removed - please use the exact version you want to install, or 'latest' to get the latest build available`);else throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Invalid version descriptor "${this.version}"`);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `Downloading ${configuration.format(bundleUrl, `green`)}`);
      const bundleBuffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.httpUtils.get(bundleUrl, {
        configuration
      });
      await setVersion(configuration, null, bundleBuffer, {
        report
      });
    });
    return report.exitCode();
  }

}
SetVersionCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `lock the Yarn version used by the project`,
  details: `
      This command will download a specific release of Yarn directly from the Yarn GitHub repository, will store it inside your project, and will change the \`yarnPath\` settings from your project \`.yarnrc.yml\` file to point to the new file.

      A very good use case for this command is to enforce the version of Yarn used by the any single member of your team inside a same project - by doing this you ensure that you have control on Yarn upgrades and downgrades (including on your deployment servers), and get rid of most of the headaches related to someone using a slightly different version and getting a different behavior than you.
    `,
  examples: [[`Download the latest release from the Yarn repository`, `$0 set version latest`], [`Download the latest classic release from the Yarn repository`, `$0 set version classic`], [`Download a specific Yarn 2 build`, `$0 set version 2.0.0-rc.30`], [`Switch back to a specific Yarn 1 release`, `$0 set version 1.22.1`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--only-if-needed`)], SetVersionCommand.prototype, "onlyIfNeeded", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], SetVersionCommand.prototype, "version", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`policies`, `set-version`), clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`set`, `version`)], SetVersionCommand.prototype, "execute", null);

async function setVersion(configuration, bundleVersion, bundleBuffer, {
  report
}) {
  const projectCwd = configuration.projectCwd ? configuration.projectCwd : configuration.startingCwd;

  if (bundleVersion === null) {
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.mktempPromise(async tmpDir => {
      const temporaryPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.join(tmpDir, `yarn.cjs`);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.writeFilePromise(temporaryPath, bundleBuffer);
      const {
        stdout
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.execUtils.execvp(process.execPath, [_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.npath.fromPortablePath(temporaryPath), `--version`], {
        cwd: projectCwd,
        env: { ...process.env,
          YARN_IGNORE_PATH: `1`
        }
      });
      bundleVersion = stdout.trim();

      if (!semver__WEBPACK_IMPORTED_MODULE_2___default().valid(bundleVersion)) {
        throw new Error(`Invalid semver version`);
      }
    });
  }

  const releaseFolder = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.resolve(projectCwd, `.yarn/releases`);
  const absolutePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.resolve(releaseFolder, `yarn-${bundleVersion}.cjs`);
  const displayPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.relative(configuration.startingCwd, absolutePath);
  const projectPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.relative(projectCwd, absolutePath);
  const yarnPath = configuration.get(`yarnPath`);
  const updateConfig = yarnPath === null || yarnPath.startsWith(`${releaseFolder}/`);
  report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `Saving the new release in ${configuration.format(displayPath, `magenta`)}`);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.removePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.dirname(absolutePath));
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.dirname(absolutePath), {
    recursive: true
  });
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.writeFilePromise(absolutePath, bundleBuffer);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.chmodPromise(absolutePath, 0o755);

  if (updateConfig) {
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.updateConfiguration(projectCwd, {
      yarnPath: projectPath
    });
  }
}

/***/ }),
/* 599 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PluginDlCommand,
/* harmony export */   "savePlugin": () => /* binding */ savePlugin
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(206);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(600);
/* harmony import */ var vm__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vm__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(601);







 // eslint-disable-next-line arca/no-default-export

class PluginDlCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const {
        project
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
      let pluginSpec;
      let pluginBuffer;

      if (this.name.match(/^\.{0,2}[\\/]/) || _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.isAbsolute(this.name)) {
        const candidatePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(this.name));
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Reading ${configuration.format(candidatePath, `green`)}`);
        pluginSpec = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(project.cwd, candidatePath);
        pluginBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.readFilePromise(candidatePath);
      } else {
        let pluginUrl;

        if (this.name.match(/^https?:/)) {
          try {
            // @ts-ignore We don't want to add the dom to the TS env just for this line
            new URL(this.name);
          } catch (_a) {
            throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.INVALID_PLUGIN_REFERENCE, `Plugin specifier "${this.name}" is neither a plugin name nor a valid url`);
          }

          pluginSpec = this.name;
          pluginUrl = this.name;
        } else {
          const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.structUtils.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
          const identStr = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.structUtils.stringifyIdent(ident);
          const data = await (0,_list__WEBPACK_IMPORTED_MODULE_3__.getAvailablePlugins)(configuration);
          if (!Object.prototype.hasOwnProperty.call(data, identStr)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be referenced by their name; any other plugin will have to be referenced through its public url (for example https://github.com/yarnpkg/berry/raw/master/packages/plugin-typescript/bin/%40yarnpkg/plugin-typescript.js).`);
          pluginSpec = identStr;
          pluginUrl = data[identStr].url;
        }

        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Downloading ${configuration.format(pluginUrl, `green`)}`);
        pluginBuffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.httpUtils.get(pluginUrl, {
          configuration
        });
      }

      await savePlugin(pluginSpec, pluginBuffer, {
        project,
        report
      });
    });
    return report.exitCode();
  }

}
PluginDlCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Plugin-related commands`,
  description: `download a plugin`,
  details: `
      This command downloads the specified plugin from its remote location and updates the configuration to reference it in further CLI invocations.

      Three types of plugin references are accepted:

      - If the plugin is stored within the Yarn repository, it can be referenced by name.
      - Third-party plugins can be referenced directly through their public urls.
      - Local plugins can be referenced by their path on the disk.

      Plugins cannot be downloaded from the npm registry, and aren't allowed to have dependencies (they need to be bundled into a single file, possibly thanks to the \`@yarnpkg/builder\` package).
    `,
  examples: [[`Download and activate the "@yarnpkg/plugin-exec" plugin`, `$0 plugin import @yarnpkg/plugin-exec`], [`Download and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`, `$0 plugin import exec`], [`Download and activate a community plugin`, `$0 plugin import https://example.org/path/to/plugin.js`], [`Activate a local plugin`, `$0 plugin import ./path/to/plugin.js`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PluginDlCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`plugin`, `import`)], PluginDlCommand.prototype, "execute", null);

async function savePlugin(pluginSpec, pluginBuffer, {
  project,
  report
}) {
  const {
    configuration
  } = project;
  const vmExports = {};
  const vmModule = {
    exports: vmExports
  };
  (0,vm__WEBPACK_IMPORTED_MODULE_2__.runInNewContext)(pluginBuffer.toString(), {
    module: vmModule,
    exports: vmExports
  });
  const pluginName = vmModule.exports.name;
  const relativePath = `.yarn/plugins/${pluginName}.cjs`;
  const absolutePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(project.cwd, relativePath);
  report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Saving the new plugin in ${configuration.format(relativePath, `magenta`)}`);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(absolutePath), {
    recursive: true
  });
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.writeFilePromise(absolutePath, pluginBuffer);
  const pluginMeta = {
    path: relativePath,
    spec: pluginSpec
  };
  await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.updateConfiguration(project.cwd, current => {
    const plugins = [];
    let hasBeenReplaced = false;

    for (const entry of current.plugins || []) {
      const userProvidedPath = typeof entry !== `string` ? entry.path : entry;
      const pluginPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(project.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(userProvidedPath));
      const {
        name
      } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.miscUtils.dynamicRequire(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(pluginPath));

      if (name !== pluginName) {
        plugins.push(entry);
      } else {
        plugins.push(pluginMeta);
        hasBeenReplaced = true;
      }
    }

    if (!hasBeenReplaced) plugins.push(pluginMeta);
    return {
      plugins
    };
  });
}

/***/ }),
/* 600 */
/***/ ((module) => {

"use strict";
module.exports = require("vm");

/***/ }),
/* 601 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAvailablePlugins": () => /* binding */ getAvailablePlugins,
/* harmony export */   "default": () => /* binding */ PluginDlCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);





const REMOTE_REGISTRY = `https://raw.githubusercontent.com/yarnpkg/berry/master/plugins.yml`;
async function getAvailablePlugins(configuration) {
  const raw = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.httpUtils.get(REMOTE_REGISTRY, {
    configuration
  });
  const data = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(raw.toString());
  return data;
} // eslint-disable-next-line arca/no-default-export

class PluginDlCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      const data = await getAvailablePlugins(configuration);

      for (const [name, {
        experimental,
        ...rest
      }] of Object.entries(data)) {
        let label = name;
        if (experimental) label += ` [experimental]`;
        report.reportJson({
          name,
          experimental,
          ...rest
        });
        report.reportInfo(null, label);
      }
    });
    return report.exitCode();
  }

}
PluginDlCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Plugin-related commands`,
  description: `list the available official plugins`,
  details: `
      This command prints the plugins available directly from the Yarn repository. Only those plugins can be referenced by name in \`yarn plugin import\`.
    `,
  examples: [[`List the official plugins`, `$0 plugin list`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--json`)], PluginDlCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`plugin`, `list`)], PluginDlCommand.prototype, "execute", null);

/***/ }),
/* 602 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PluginRemoveCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(206);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);




 // eslint-disable-next-line arca/no-default-export

class PluginRemoveCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const pluginName = this.name;
      const pluginIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.parseIdent(pluginName);
      if (!configuration.plugins.has(pluginName)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyIdent(configuration, pluginIdent)} isn't referenced by the current configuration`);
      const relativePath = `.yarn/plugins/${pluginName}.cjs`;
      const absolutePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(project.cwd, relativePath);

      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.existsSync(absolutePath)) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Removing ${configuration.format(relativePath, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.FormatType.PATH)}...`);
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.removePromise(absolutePath);
      }

      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Updating the configuration...`);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.updateConfiguration(project.cwd, current => {
        if (!Array.isArray(current.plugins)) return {};
        const plugins = current.plugins.filter(plugin => plugin.path !== relativePath);
        return {
          plugins
        };
      });
    });
    return report.exitCode();
  }

}
PluginRemoveCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Plugin-related commands`,
  description: `remove a plugin`,
  details: `
      This command deletes the specified plugin from the .yarn/plugins folder and removes it from the configuration.

      **Note:** The plugins have to be referenced by their name property, which can be obtained using the \`yarn plugin runtime\` command. Shorthands are not allowed.
   `,
  examples: [[`Remove a plugin imported from the Yarn repository`, `$0 plugin remove @yarnpkg/plugin-typescript`], [`Remove a plugin imported from a local file`, `$0 plugin remove my-local-plugin`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PluginRemoveCommand.prototype, "name", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`plugin`, `remove`)], PluginRemoveCommand.prototype, "execute", null);

/***/ }),
/* 603 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PluginListCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(239);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);



 // eslint-disable-next-line arca/no-default-export

class PluginListCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      for (const name of configuration.plugins.keys()) {
        const builtin = this.context.plugins.plugins.has(name);
        let label = name;
        if (builtin) label += ` [builtin]`;
        report.reportJson({
          name,
          builtin
        });
        report.reportInfo(null, `${label}`);
      }
    });
    return report.exitCode();
  }

}
PluginListCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Plugin-related commands`,
  description: `list the active plugins`,
  details: `
      This command prints the currently active plugins. Will be displayed both builtin plugins and external plugins.
    `,
  examples: [[`List the currently active plugins`, `$0 plugin runtime`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], PluginListCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_4__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`plugin`, `runtime`)], PluginListCommand.prototype, "execute", null);

/***/ }),
/* 604 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ RunCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(250);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);





 // eslint-disable-next-line arca/no-default-export

class RunCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.idents = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const filteredIdents = new Set();

    for (const identStr of this.idents) filteredIdents.add(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.parseIdent(identStr).identHash);

    await project.resolveEverything({
      cache,
      report: new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.ThrowReport()
    });
    const bstatePath = configuration.get(`bstatePath`);
    const bstate = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.existsSync(bstatePath) ? (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.readFilePromise(bstatePath, `utf8`)) : {};
    const nextBState = new Map();

    for (const pkg of project.storedPackages.values()) {
      if (!Object.prototype.hasOwnProperty.call(bstate, pkg.locatorHash)) continue;
      if (filteredIdents.size === 0 || filteredIdents.has(pkg.identHash)) continue;
      const buildHash = bstate[pkg.locatorHash];
      nextBState.set(pkg.locatorHash, buildHash);
    }

    if (nextBState.size > 0) {
      const bstatePath = configuration.get(`bstatePath`);
      const bstateFile = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.generateBuildStateFile(nextBState, project.storedPackages);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.ppath.dirname(bstatePath), {
        recursive: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.changeFilePromise(bstatePath, bstateFile, {
        automaticNewlines: true
      });
    } else {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.removePromise(bstatePath);
    }

    const installReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.StreamReport.start({
      configuration,
      stdout: this.context.stdout,
      includeLogs: !this.context.quiet
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return installReport.exitCode();
  }

}
RunCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  description: `rebuild the project's native packages`,
  details: `
      This command will automatically cause Yarn to forget about previous compilations of the given packages and to run them again.

      Note that while Yarn forgets the compilation, the previous artifacts aren't erased from the filesystem and may affect the next builds (in good or bad). To avoid this, you may remove the .yarn/unplugged folder, or any other relevant location where packages might have been stored (Yarn may offer a way to do that automatically in the future).

      By default all packages will be rebuilt, but you can filter the list by specifying the names of the packages you want to clear from memory.
    `,
  examples: [[`Rebuild all packages`, `$0 rebuild`], [`Rebuild fsevents only`, `$0 rebuild fsevents`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Rest()], RunCommand.prototype, "idents", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`rebuild`)], RunCommand.prototype, "execute", null);

/***/ }),
/* 605 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ RemoveCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(122);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _suggestUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(578);







 // eslint-disable-next-line arca/no-default-export

class RemoveCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.all = false;
    this.patterns = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const affectedWorkspaces = this.all ? project.workspaces : [workspace];
    const targets = [_suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.REGULAR, _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.DEVELOPMENT, _suggestUtils__WEBPACK_IMPORTED_MODULE_3__.Target.PEER];
    const unreferencedPatterns = [];
    let hasChanged = false;
    const afterWorkspaceDependencyRemovalList = [];

    for (const pattern of this.patterns) {
      let isReferenced = false; // This isn't really needed - It's just for consistency:
      // All patterns are either valid or not for all commands (e.g. remove, up)

      const pseudoIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseIdent(pattern);

      for (const workspace of affectedWorkspaces) {
        const peerDependenciesMeta = [...workspace.manifest.peerDependenciesMeta.keys()];

        for (const stringifiedIdent of micromatch__WEBPACK_IMPORTED_MODULE_2___default()(peerDependenciesMeta, pattern)) {
          workspace.manifest.peerDependenciesMeta.delete(stringifiedIdent);
          hasChanged = true;
          isReferenced = true;
        }

        for (const target of targets) {
          const descriptors = workspace.manifest.getForScope(target);
          const stringifiedIdents = [...descriptors.values()].map(descriptor => {
            return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.stringifyIdent(descriptor);
          });

          for (const stringifiedIdent of micromatch__WEBPACK_IMPORTED_MODULE_2___default()(stringifiedIdents, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.stringifyIdent(pseudoIdent))) {
            const {
              identHash
            } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseIdent(stringifiedIdent);
            const removedDescriptor = descriptors.get(identHash);
            if (typeof removedDescriptor === `undefined`) throw new Error(`Assertion failed: Expected the descriptor to be registered`);
            workspace.manifest[target].delete(identHash);
            afterWorkspaceDependencyRemovalList.push([workspace, target, removedDescriptor]);
            hasChanged = true;
            isReferenced = true;
          }
        }
      }

      if (!isReferenced) {
        unreferencedPatterns.push(pattern);
      }
    }

    const patterns = unreferencedPatterns.length > 1 ? `Patterns` : `Pattern`;
    const dont = unreferencedPatterns.length > 1 ? `don't` : `doesn't`;
    const which = this.all ? `any` : `this`;
    if (unreferencedPatterns.length > 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`${patterns} ${unreferencedPatterns.join(`, `)} ${dont} match packages referenced by ${which} workspace`);

    if (hasChanged) {
      await configuration.triggerMultipleHooks(hooks => hooks.afterWorkspaceDependencyRemoval, afterWorkspaceDependencyRemovalList);
      const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
        configuration,
        stdout: this.context.stdout
      }, async report => {
        await project.install({
          cache,
          report
        });
      });
      return report.exitCode();
    }

    return 0;
  }

}
RemoveCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `remove dependencies from the project`,
  details: `
      This command will remove the packages matching the specified patterns from the current workspace.

      If the \`-A,--all\` option is set, the operation will be applied to all workspaces from the current project.

      This command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.
    `,
  examples: [[`Remove a dependency from the current project`, `$0 remove lodash`], [`Remove a dependency from all workspaces at once`, `$0 remove lodash --all`], [`Remove all dependencies starting with \`eslint-\``, `$0 remove 'eslint-*'`], [`Remove all dependencies with the \`@babel\` scope`, `$0 remove '@babel/*'`], [`Remove all dependencies matching \`react-dom\` or \`react-helmet\``, `$0 remove 'react-{dom,helmet}'`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-A,--all`)], RemoveCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], RemoveCommand.prototype, "patterns", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`remove`)], RemoveCommand.prototype, "execute", null);

/***/ }),
/* 606 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ RunCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);





 // eslint-disable-next-line arca/no-default-export

class RunCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const scripts = workspace.manifest.scripts;
      const keys = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.miscUtils.sortMap(scripts.keys(), key => key);
      const inspectConfig = {
        breakLength: Infinity,
        colors: configuration.get(`enableColors`),
        maxArrayLength: 2
      };
      const maxKeyLength = keys.reduce((max, key) => {
        return Math.max(max, key.length);
      }, 0);

      for (const [key, value] of scripts.entries()) {
        report.reportInfo(null, `${key.padEnd(maxKeyLength, ` `)}   ${(0,util__WEBPACK_IMPORTED_MODULE_2__.inspect)(value, inspectConfig)}`);
      }
    });
    return report.exitCode();
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`run`)], RunCommand.prototype, "execute", null);

/***/ }),
/* 607 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ RunCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);




 // eslint-disable-next-line arca/no-default-export

class RunCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.inspect = false;
    this.inspectBrk = false; // This flag is mostly used to give users a way to configure node-gyp. They
    // just have to add it as a top-level workspace.

    this.topLevel = false; // Some tools (for example text editors) want to call the real binaries, not
    // what their users might have remapped them to in their `scripts` field.

    this.binariesOnly = false;
    this.args = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace,
      locator
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    await project.restoreInstallState();
    const effectiveLocator = this.topLevel ? project.topLevelWorkspace.anchoredLocator : locator; // First we check to see whether a script exist inside the current package
    // for the given name

    if (!this.binariesOnly && (await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.hasPackageScript(effectiveLocator, this.scriptName, {
      project
    }))) return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.executePackageScript(effectiveLocator, this.scriptName, this.args, {
      project,
      stdin: this.context.stdin,
      stdout: this.context.stdout,
      stderr: this.context.stderr
    }); // If we can't find it, we then check whether one of the dependencies of the
    // current package exports a binary with the requested name

    const binaries = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.getPackageAccessibleBinaries(effectiveLocator, {
      project
    });
    const binary = binaries.get(this.scriptName);

    if (binary) {
      const nodeArgs = [];

      if (this.inspect) {
        if (typeof this.inspect === `string`) {
          nodeArgs.push(`--inspect=${this.inspect}`);
        } else {
          nodeArgs.push(`--inspect`);
        }
      }

      if (this.inspectBrk) {
        if (typeof this.inspectBrk === `string`) {
          nodeArgs.push(`--inspect-brk=${this.inspectBrk}`);
        } else {
          nodeArgs.push(`--inspect-brk`);
        }
      }

      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.executePackageAccessibleBinary(effectiveLocator, this.scriptName, this.args, {
        cwd: this.context.cwd,
        project,
        stdin: this.context.stdin,
        stdout: this.context.stdout,
        stderr: this.context.stderr,
        nodeArgs
      });
    } // When it fails, we try to check whether it's a global script (ie we look
    // into all the workspaces to find one that exports this script). We only do
    // this if the script name contains a colon character (":"), and we skip
    // this logic if multiple workspaces share the same script name.
    //
    // We also disable this logic for packages coming from third-parties (ie
    // not workspaces). No particular reason except maybe security concerns.


    if (!this.topLevel && !this.binariesOnly && workspace && this.scriptName.includes(`:`)) {
      const candidateWorkspaces = await Promise.all(project.workspaces.map(async workspace => {
        return workspace.manifest.scripts.has(this.scriptName) ? workspace : null;
      }));
      const filteredWorkspaces = candidateWorkspaces.filter(workspace => {
        return workspace !== null;
      });

      if (filteredWorkspaces.length === 1) {
        return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.executeWorkspaceScript(filteredWorkspaces[0], this.scriptName, this.args, {
          stdin: this.context.stdin,
          stdout: this.context.stdout,
          stderr: this.context.stderr
        });
      }
    }

    if (this.topLevel) {
      if (this.scriptName === `node-gyp`) {
        throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a script name "${this.scriptName}" in the top-level (used by ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.prettyLocator(configuration, locator)}). This typically happens because some package depends on "node-gyp" to build itself, but didn't list it in their dependencies. To fix that, please run "yarn add node-gyp" into your top-level workspace. You also can open an issue on the repository of the specified package to suggest them to use an optional peer dependency.`);
      } else {
        throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a script name "${this.scriptName}" in the top-level (used by ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.prettyLocator(configuration, locator)}).`);
      }
    } else {
      if (this.scriptName === `global`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The 'yarn global' commands have been removed in 2.x - consider using 'yarn dlx' or a third-party plugin instead`);
      const userCommand = [this.scriptName].concat(this.args);

      for (const [pluginName, candidates] of _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.pluginCommands) for (const candidate of candidates) if (userCommand.length >= candidate.length && JSON.stringify(userCommand.slice(0, candidate.length)) === JSON.stringify(candidate)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a script named "${this.scriptName}", but a matching command can be found in the ${pluginName} plugin. You can install it with "yarn plugin import ${pluginName}".`);

      throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find a script named "${this.scriptName}".`);
    }
  }

}
RunCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `run a script defined in the package.json`,
  details: `
      This command will run a tool. The exact tool that will be executed will depend on the current state of your workspace:

      - If the \`scripts\` field from your local package.json contains a matching script name, its definition will get executed.

      - Otherwise, if one of the local workspace's dependencies exposes a binary with a matching name, this binary will get executed (the \`--inspect\` and \`--inspect-brk\` options will then be forwarded to the underlying Node process).

      - Otherwise, if the specified name contains a colon character and if one of the workspaces in the project contains exactly one script with a matching name, then this script will get executed.

      Whatever happens, the cwd of the spawned process will be the workspace that declares the script (which makes it possible to call commands cross-workspaces using the third syntax).
    `,
  examples: [[`Run the tests from the local workspace`, `$0 run test`], [`Same thing, but without the "run" keyword`, `$0 test`], [`Inspect Webpack while running`, `$0 run --inspect-brk webpack`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--inspect`, {
  tolerateBoolean: true
})], RunCommand.prototype, "inspect", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--inspect-brk`, {
  tolerateBoolean: true
})], RunCommand.prototype, "inspectBrk", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-T,--top-level`, {
  hidden: true
})], RunCommand.prototype, "topLevel", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-B,--binaries-only`, {
  hidden: true
})], RunCommand.prototype, "binariesOnly", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--silent`, {
  hidden: true
})], RunCommand.prototype, "silent", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], RunCommand.prototype, "scriptName", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], RunCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`run`)], RunCommand.prototype, "execute", null);

/***/ }),
/* 608 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ SetResolutionCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);




 // eslint-disable-next-line arca/no-default-export

class SetResolutionCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.save = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const fromDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.parseDescriptor(this.descriptor, true);
    const toDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.makeDescriptor(fromDescriptor, this.resolution);
    project.storedDescriptors.set(fromDescriptor.descriptorHash, fromDescriptor);
    project.storedDescriptors.set(toDescriptor.descriptorHash, toDescriptor);
    project.resolutionAliases.set(fromDescriptor.descriptorHash, toDescriptor.descriptorHash);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return report.exitCode();
  }

}
SetResolutionCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `enforce a package resolution`,
  details: `
      This command updates the resolution table so that \`descriptor\` is resolved by \`resolution\`.

      Note that by default this command only affect the current resolution table - meaning that this "manual override" will disappear if you remove the lockfile, or if the package disappear from the table. If you wish to make the enforced resolution persist whatever happens, add the \`-s,--save\` flag which will also edit the \`resolutions\` field from your top-level manifest.

      Note that no attempt is made at validating that \`resolution\` is a valid resolution entry for \`descriptor\`.
    `,
  examples: [[`Force all instances of lodash@^1.2.3 to resolve to 1.5.0`, `$0 set resolution lodash@^1.2.3 1.5.0`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], SetResolutionCommand.prototype, "descriptor", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], SetResolutionCommand.prototype, "resolution", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-s,--save`)], SetResolutionCommand.prototype, "save", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`set`, `resolution`)], SetResolutionCommand.prototype, "execute", null);

/***/ }),
/* 609 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ UpCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(238);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(534);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(enquirer__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(122);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _suggestUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(578);








 // eslint-disable-next-line arca/no-default-export

class UpCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.patterns = [];
    this.interactive = null;
    this.verbose = false;
    this.exact = false;
    this.tilde = false;
    this.caret = false;
  }

  async execute() {
    var _a;

    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const interactive = (_a = this.interactive) !== null && _a !== void 0 ? _a : configuration.get(`preferInteractive`);
    const modifier = _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.getModifier(this, project);
    const strategies = interactive ? [_suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.KEEP, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.REUSE, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.PROJECT, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.LATEST] : [_suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.PROJECT, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Strategy.LATEST];
    const allSuggestionsPromises = [];
    const unreferencedPatterns = [];

    for (const pattern of this.patterns) {
      let isReferenced = false; // The range has to be static

      const pseudoDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.parseDescriptor(pattern);

      for (const workspace of project.workspaces) {
        for (const target of [_suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Target.REGULAR, _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.Target.DEVELOPMENT]) {
          const descriptors = workspace.manifest.getForScope(target);
          const stringifiedIdents = [...descriptors.values()].map(descriptor => {
            return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.stringifyIdent(descriptor);
          });

          for (const stringifiedIdent of micromatch__WEBPACK_IMPORTED_MODULE_3___default()(stringifiedIdents, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.stringifyIdent(pseudoDescriptor))) {
            const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.parseIdent(stringifiedIdent);
            const existingDescriptor = workspace.manifest[target].get(ident.identHash);
            if (typeof existingDescriptor === `undefined`) throw new Error(`Assertion failed: Expected the descriptor to be registered`);
            const request = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.makeDescriptor(ident, pseudoDescriptor.range);
            allSuggestionsPromises.push(Promise.resolve().then(async () => {
              return [workspace, target, existingDescriptor, await _suggestUtils__WEBPACK_IMPORTED_MODULE_4__.getSuggestedDescriptors(request, {
                project,
                workspace,
                cache,
                target,
                modifier,
                strategies
              })];
            }));
            isReferenced = true;
          }
        }
      }

      if (!isReferenced) {
        unreferencedPatterns.push(pattern);
      }
    }

    if (unreferencedPatterns.length > 1) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Patterns ${unreferencedPatterns.join(`, `)} don't match any packages referenced by any workspace`);
    if (unreferencedPatterns.length > 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Pattern ${unreferencedPatterns[0]} doesn't match any packages referenced by any workspace`);
    const allSuggestions = await Promise.all(allSuggestionsPromises);
    const checkReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.LightReport.start({
      configuration,
      stdout: this.context.stdout,
      suggestInstall: false
    }, async report => {
      for (const [,,
      /*workspace*/

      /*target*/
      existing, suggestions] of allSuggestions) {
        const nonNullSuggestions = suggestions.filter(suggestion => {
          return suggestion.descriptor !== null;
        });

        if (nonNullSuggestions.length === 0) {
          if (!project.configuration.get(`enableNetwork`)) {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range (note: network resolution has been disabled)`);
          } else {
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range`);
          }
        } else if (nonNullSuggestions.length > 1 && !interactive) {
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.CANT_SUGGEST_RESOLUTIONS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.prettyDescriptor(configuration, existing)} has multiple possible upgrade strategies; use -i to disambiguate manually`);
        }
      }
    });
    if (checkReport.hasErrors()) return checkReport.exitCode();
    let askedQuestions = false;
    const afterWorkspaceDependencyReplacementList = [];

    for (const [workspace, target,,
    /*existing*/
    suggestions] of allSuggestions) {
      let selected;
      const nonNullSuggestions = suggestions.filter(suggestion => {
        return suggestion.descriptor !== null;
      });
      const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
      const areAllTheSame = nonNullSuggestions.every(suggestion => _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));

      if (nonNullSuggestions.length === 1 || areAllTheSame) {
        selected = firstSuggestedDescriptor;
      } else {
        askedQuestions = true;
        ({
          answer: selected
        } = await (0,enquirer__WEBPACK_IMPORTED_MODULE_2__.prompt)({
          type: `select`,
          name: `answer`,
          message: `Which range to you want to use in ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.prettyWorkspace(configuration, workspace)}  ${target}?`,
          choices: suggestions.map(({
            descriptor,
            name,
            reason
          }) => descriptor ? {
            name,
            hint: reason,
            descriptor
          } : {
            name,
            hint: reason,
            disabled: true
          }),
          onCancel: () => process.exit(130),

          result(name) {
            // @ts-expect-error: The enquirer types don't include find
            return this.find(name, `descriptor`);
          },

          stdin: this.context.stdin,
          stdout: this.context.stdout
        }));
      }

      const current = workspace.manifest[target].get(selected.identHash);
      if (typeof current === `undefined`) throw new Error(`Assertion failed: This descriptor should have a matching entry`);

      if (current.descriptorHash !== selected.descriptorHash) {
        workspace.manifest[target].set(selected.identHash, selected);
        afterWorkspaceDependencyReplacementList.push([workspace, target, current, selected]);
      } else {
        const resolver = configuration.makeResolver();
        const resolveOptions = {
          project,
          resolver
        };
        const bound = resolver.bindDescriptor(current, workspace.anchoredLocator, resolveOptions);
        project.forgetResolution(bound);
      }
    }

    await configuration.triggerMultipleHooks(hooks => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
    if (askedQuestions) this.context.stdout.write(`\n`);
    const installReport = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await project.install({
        cache,
        report
      });
    });
    return installReport.exitCode();
  }

}
UpCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `upgrade dependencies across the project`,
  details: `
      This command upgrades the packages matching the list of specified patterns to their latest available version across the whole project (regardless of whether they're part of \`dependencies\` or \`devDependencies\` - \`peerDependencies\` won't be affected). This is a project-wide command: all workspaces will be upgraded in the process.

      If \`-i,--interactive\` is set (or if the \`preferInteractive\` settings is toggled on) the command will offer various choices, depending on the detected upgrade paths. Some upgrades require this flag in order to resolve ambiguities.

      The, \`-C,--caret\`, \`-E,--exact\` and  \`-T,--tilde\` options have the same meaning as in the \`add\` command (they change the modifier used when the range is missing or a tag, and are ignored when the range is explicitly set).

      This command accepts glob patterns as arguments (if valid Descriptors and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.

      **Note:** The ranges have to be static, only the package scopes and names can contain glob patterns.
    `,
  examples: [[`Upgrade all instances of lodash to the latest release`, `$0 up lodash`], [`Upgrade all instances of lodash to the latest release, but ask confirmation for each`, `$0 up lodash -i`], [`Upgrade all instances of lodash to 1.2.3`, `$0 up lodash@1.2.3`], [`Upgrade all instances of packages with the \`@babel\` scope to the latest release`, `$0 up '@babel/*'`], [`Upgrade all instances of packages containing the word \`jest\` to the latest release`, `$0 up '*jest*'`], [`Upgrade all instances of packages with the \`@babel\` scope to 7.0.0`, `$0 up '@babel/*@7.0.0'`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], UpCommand.prototype, "patterns", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-i,--interactive`)], UpCommand.prototype, "interactive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-v,--verbose`)], UpCommand.prototype, "verbose", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-E,--exact`)], UpCommand.prototype, "exact", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-T,--tilde`)], UpCommand.prototype, "tilde", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-C,--caret`)], UpCommand.prototype, "caret", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`up`)], UpCommand.prototype, "execute", null);

/***/ }),
/* 610 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ WhyCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var treeify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(611);
/* harmony import */ var treeify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(treeify__WEBPACK_IMPORTED_MODULE_2__);






 // eslint-disable-next-line arca/no-default-export

class WhyCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.recursive = false;
    this.peers = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState();
    const identHash = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.parseIdent(this.package).identHash;
    const whyTree = this.recursive ? whyRecursive(project, identHash, {
      configuration,
      peers: this.peers
    }) : whySimple(project, identHash, {
      configuration,
      peers: this.peers
    });
    printTree(this.context.stdout, whyTree);
  }

}
WhyCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `display the reason why a package is needed`,
  details: `
      This command prints the exact reasons why a package appears in the dependency tree.

      If \`-R,--recursive\` is set, the listing will go in depth and will list, for each workspaces, what are all the paths that lead to the dependency. Note that the display is somewhat optimized in that it will not print the package listing twice for a single package, so if you see a leaf named "Foo" when looking for "Bar", it means that "Foo" already got printed higher in the tree.

      If \`--peers\` is set, the command will also print the peer dependencies that match the specified name.
    `,
  examples: [[`Explain why lodash is used in your project`, `$0 why lodash`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], WhyCommand.prototype, "package", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-R,--recursive`)], WhyCommand.prototype, "recursive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--peers`)], WhyCommand.prototype, "peers", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`why`)], WhyCommand.prototype, "execute", null);

function whySimple(project, identHash, {
  configuration,
  peers
}) {
  const sortedPackages = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.miscUtils.sortMap(project.storedPackages.values(), pkg => {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.stringifyLocator(pkg);
  });
  const tree = {};

  for (const pkg of sortedPackages) {
    let node = null;

    for (const dependency of pkg.dependencies.values()) {
      if (!peers && pkg.peerDependencies.has(dependency.identHash)) continue;
      const resolution = project.storedResolutions.get(dependency.descriptorHash);
      if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
      const nextPkg = project.storedPackages.get(resolution);
      if (!nextPkg) throw new Error(`Assertion failed: The package should have been registered`);
      if (nextPkg.identHash !== identHash) continue;

      if (node === null) {
        node = {};
        const label = `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyLocator(configuration, pkg)}`;
        tree[label] = node;
      }

      const label = `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyLocator(configuration, nextPkg)} (via ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyRange(configuration, dependency.range)})`;
      node[label] = {};
    }
  }

  return tree;
}

function whyRecursive(project, identHash, {
  configuration,
  peers
}) {
  const sortedWorkspaces = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.miscUtils.sortMap(project.workspaces, workspace => {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.stringifyLocator(workspace.anchoredLocator);
  });
  const seen = new Set();
  const dependents = new Set();

  const markAllDependents = pkg => {
    if (seen.has(pkg.locatorHash)) return dependents.has(pkg.locatorHash);
    seen.add(pkg.locatorHash);

    if (pkg.identHash === identHash) {
      dependents.add(pkg.locatorHash);
      return true;
    }

    let depends = false;
    if (pkg.identHash === identHash) depends = true;

    for (const dependency of pkg.dependencies.values()) {
      if (!peers && pkg.peerDependencies.has(dependency.identHash)) continue;
      const resolution = project.storedResolutions.get(dependency.descriptorHash);
      if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
      const nextPkg = project.storedPackages.get(resolution);
      if (!nextPkg) throw new Error(`Assertion failed: The package should have been registered`);

      if (markAllDependents(nextPkg)) {
        depends = true;
      }
    }

    if (depends) dependents.add(pkg.locatorHash);
    return depends;
  };

  for (const workspace of sortedWorkspaces) {
    const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
    if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
    markAllDependents(pkg);
  }

  const printed = new Set();
  const tree = {};

  const printAllDependents = (pkg, tree, range) => {
    if (!dependents.has(pkg.locatorHash)) return;
    const label = range !== null ? `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyLocator(configuration, pkg)} (via ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyRange(configuration, range)})` : `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyLocator(configuration, pkg)}`;
    const node = {};
    tree[label] = node; // We don't want to reprint the children for a package that already got
    // printed as part of another branch

    if (printed.has(pkg.locatorHash)) return;
    printed.add(pkg.locatorHash); // We don't want to print the children of our transitive workspace
    // dependencies, as they will be printed in their own top-level branch

    if (range !== null && project.tryWorkspaceByLocator(pkg)) return;

    for (const dependency of pkg.dependencies.values()) {
      if (!peers && pkg.peerDependencies.has(dependency.identHash)) continue;
      const resolution = project.storedResolutions.get(dependency.descriptorHash);
      if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
      const nextPkg = project.storedPackages.get(resolution);
      if (!nextPkg) throw new Error(`Assertion failed: The package should have been registered`);
      printAllDependents(nextPkg, node, dependency.range);
    }
  };

  for (const workspace of sortedWorkspaces) {
    const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
    if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
    printAllDependents(pkg, tree, null);
  }

  return tree;
}

function printTree(stdout, tree) {
  let treeOutput = (0,treeify__WEBPACK_IMPORTED_MODULE_2__.asTree)(tree, false, false); // A slight hack to add line returns between two workspaces

  treeOutput = treeOutput.replace(/^([])/gm, `\n$1`).replace(/^\n/, ``);
  stdout.write(treeOutput);
}

/***/ }),
/* 611 */
/***/ (function(module) {

//     treeify.js
//     Luke Plaster <notatestuser@gmail.com>
//     https://github.com/notatestuser/treeify.js

// do the universal module definition dance
(function (root, factory) {

  if (true) {
    module.exports = factory();
  } else {}

}(this, function() {

  function makePrefix(key, last) {
    var str = (last ? '' : '');
    if (key) {
      str += ' ';
    } else {
      str += '';
    }
    return str;
  }

  function filterKeys(obj, hideFunctions) {
    var keys = [];
    for (var branch in obj) {
      // always exclude anything in the object's prototype
      if (!obj.hasOwnProperty(branch)) {
        continue;
      }
      // ... and hide any keys mapped to functions if we've been told to
      if (hideFunctions && ((typeof obj[branch])==="function")) {
        continue;
      }
      keys.push(branch);
    }
    return keys;
  }

  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
    var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);

    if (lastStatesCopy.push([ root, last ]) && lastStates.length > 0) {
      // based on the "was last element" states of whatever we're nested within,
      // we need to append either blankness or a branch to our line
      lastStates.forEach(function(lastState, idx) {
        if (idx > 0) {
          line += (lastState[1] ? ' ' : '') + '  ';
        }
        if ( ! circular && lastState[0] === root) {
          circular = true;
        }
      });

      // the prefix varies based on whether the key contains something to show and
      // whether we're dealing with the last element in this collection
      line += makePrefix(key, last) + key;

      // append values and the circular reference indicator
      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);
      circular && (line += ' (circular ref.)');

      callback(line);
    }

    // can we descend into the next item?
    if ( ! circular && typeof root === 'object') {
      var keys = filterKeys(root, hideFunctions);
      keys.forEach(function(branch){
        // the last key is always printed with a different prefix, so we'll need to know if we have it
        lastKey = ++index === keys.length;

        // hold your breath for recursive action
        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
      });
    }
  };

  // --------------------

  var Treeify = {};

  // Treeify.asLines
  // --------------------
  // Outputs the tree line-by-line, calling the lineCallback when each one is available.

  Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */
    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;
    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
  };

  // Treeify.asTree
  // --------------------
  // Outputs the entire tree, returning it as a string with line breaks.

  Treeify.asTree = function(obj, showValues, hideFunctions) {
    var tree = '';
    growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {
      tree += line + '\n';
    });
    return tree;
  };

  // --------------------

  return Treeify;

}));


/***/ }),
/* 612 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ WorkspacesListCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);



 // eslint-disable-next-line arca/no-default-export

class WorkspacesListCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.verbose = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      for (const workspace of project.workspaces) {
        const {
          manifest
        } = workspace;
        let extra;

        if (this.verbose) {
          const workspaceDependencies = new Set();
          const mismatchedWorkspaceDependencies = new Set();

          for (const dependencyType of _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Manifest.hardDependencies) {
            for (const [identHash, descriptor] of manifest.getForScope(dependencyType)) {
              const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);

              if (matchingWorkspace === null) {
                if (project.workspacesByIdent.has(identHash)) {
                  mismatchedWorkspaceDependencies.add(descriptor);
                }
              } else {
                workspaceDependencies.add(matchingWorkspace);
              }
            }
          }

          extra = {
            workspaceDependencies: Array.from(workspaceDependencies).map(workspace => {
              return workspace.relativeCwd;
            }),
            mismatchedWorkspaceDependencies: Array.from(mismatchedWorkspaceDependencies).map(descriptor => {
              return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.stringifyDescriptor(descriptor);
            })
          };
        }

        report.reportInfo(null, `${workspace.relativeCwd}`);
        report.reportJson({
          location: workspace.relativeCwd,
          name: manifest.name ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.stringifyIdent(manifest.name) : null,
          ...extra
        });
      }
    });
    return report.exitCode();
  }

}
WorkspacesListCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Workspace-related commands`,
  description: `list all available workspaces`,
  details: `
      This command will print the list of all workspaces in the project. If both the \`-v,--verbose\` and \`--json\` options are set, Yarn will also return the cross-dependencies between each workspaces (useful when you wish to automatically generate Buck / Bazel rules).

      If the \`--json\` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).
    `
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-v,--verbose`)], WorkspacesListCommand.prototype, "verbose", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], WorkspacesListCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`workspaces`, `list`)], WorkspacesListCommand.prototype, "execute", null);

/***/ }),
/* 613 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ WorkspaceCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);




 // eslint-disable-next-line arca/no-default-export

class WorkspaceCommand extends clipanion__WEBPACK_IMPORTED_MODULE_1__.Command {
  constructor() {
    super(...arguments);
    this.args = [];
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace: cwdWorkspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Project.find(configuration, this.context.cwd);
    if (!cwdWorkspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    const candidates = project.workspaces;
    const candidatesByName = new Map(candidates.map(workspace => {
      const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.convertToIdent(workspace.locator);
      return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.stringifyIdent(ident), workspace];
    }));
    const workspace = candidatesByName.get(this.workspaceName);

    if (workspace === undefined) {
      const otherNames = Array.from(candidatesByName.keys()).sort();
      throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Workspace '${this.workspaceName}' not found. Did you mean any of the following:\n  - ${otherNames.join(`\n  - `)}?`);
    }

    return this.cli.run([this.commandName, ...this.args], {
      cwd: workspace.cwd
    });
  }

}
WorkspaceCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Workspace-related commands`,
  description: `run a command within the specified workspace`,
  details: `
      This command will run a given sub-command on a single workspace.
    `,
  examples: [[`Add a package to a single workspace`, `yarn workspace components add -D react`], [`Run build script on a single workspace`, `yarn workspace components run build`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], WorkspaceCommand.prototype, "workspaceName", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], WorkspaceCommand.prototype, "commandName", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], WorkspaceCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_5__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`workspace`)], WorkspaceCommand.prototype, "execute", null);

/***/ }),
/* 614 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(232);
/* harmony import */ var _extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(615);
/* harmony import */ var _patches_fsevents_patch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(616);
/* harmony import */ var _patches_resolve_patch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(617);
/* harmony import */ var _patches_typescript_patch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(618);





const PATCHES = new Map([[_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.makeIdent(null, `fsevents`).identHash, _patches_fsevents_patch__WEBPACK_IMPORTED_MODULE_1__.getPatch], [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.makeIdent(null, `resolve`).identHash, _patches_resolve_patch__WEBPACK_IMPORTED_MODULE_2__.getPatch], [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.makeIdent(null, `typescript`).identHash, _patches_typescript_patch__WEBPACK_IMPORTED_MODULE_3__.getPatch]]);
const plugin = {
  hooks: {
    registerPackageExtensions: async (configuration, registerPackageExtension) => {
      for (const [descriptorStr, extensionData] of _extensions__WEBPACK_IMPORTED_MODULE_0__.packageExtensions) {
        registerPackageExtension(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.parseDescriptor(descriptorStr, true), extensionData);
      }
    },
    getBuiltinPatch: async (project, name) => {
      var _a;

      const TAG = `compat/`;
      if (!name.startsWith(TAG)) return undefined;
      const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.parseIdent(name.slice(TAG.length));
      const patch = (_a = PATCHES.get(ident.identHash)) === null || _a === void 0 ? void 0 : _a();
      return typeof patch !== `undefined` ? patch : null;
    },
    reduceDependency: async (dependency, project, locator, initialDescriptor) => {
      const patch = PATCHES.get(dependency.identHash);
      if (typeof patch === `undefined`) return dependency;
      return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.makeDescriptor(dependency, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.makeRange({
        protocol: `patch:`,
        source: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.stringifyDescriptor(dependency),
        selector: `builtin<compat/${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.stringifyIdent(dependency)}>`,
        params: null
      }));
    }
  }
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 615 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "packageExtensions": () => /* binding */ packageExtensions
/* harmony export */ });
// To extend this list, please open a PR on the relevant repository that adds
// the same fields as you add here and prefix your changes with the relevant
// PR url.
const optionalPeerDep = {
  optional: true
};
const packageExtensions = [// https://github.com/SamVerschueren/stream-to-observable/pull/5
[`@samverschueren/stream-to-observable@*`, {
  peerDependenciesMeta: {
    [`rxjs`]: optionalPeerDep,
    [`zenObservable`]: optionalPeerDep
  }
}], // https://github.com/sindresorhus/any-observable/pull/25
[`any-observable@<0.5.1`, {
  peerDependenciesMeta: {
    [`rxjs`]: optionalPeerDep,
    [`zenObservable`]: optionalPeerDep
  }
}], // https://github.com/keymetrics/pm2-io-agent/pull/125
[`@pm2/agent@<1.0.4`, {
  dependencies: {
    [`debug`]: `*`
  }
}], // https://github.com/visionmedia/debug/pull/727
[`debug@*`, {
  peerDependenciesMeta: {
    [`supports-color`]: optionalPeerDep
  }
}], // https://github.com/sindresorhus/got/pull/1125
[`got@<11`, {
  dependencies: {
    [`@types/responselike`]: `^1.0.0`,
    [`@types/keyv`]: `^3.1.1`
  }
}], // https://github.com/szmarczak/cacheable-lookup/pull/12
[`cacheable-lookup@<4.1.2`, {
  dependencies: {
    [`@types/keyv`]: `^3.1.1`
  }
}], // https://github.com/prisma-labs/http-link-dataloader/pull/22
[`http-link-dataloader@*`, {
  peerDependencies: {
    [`graphql`]: `^0.13.1 || ^14.0.0`
  }
}], // https://github.com/theia-ide/typescript-language-server/issues/144
[`typescript-language-server@*`, {
  dependencies: {
    [`vscode-jsonrpc`]: `^5.0.1`,
    [`vscode-languageserver-protocol`]: `^3.15.0`
  }
}], // https://github.com/gucong3000/postcss-syntax/pull/46
[`postcss-syntax@*`, {
  peerDependenciesMeta: {
    [`postcss-html`]: optionalPeerDep,
    [`postcss-jsx`]: optionalPeerDep,
    [`postcss-less`]: optionalPeerDep,
    [`postcss-markdown`]: optionalPeerDep,
    [`postcss-scss`]: optionalPeerDep
  }
}], // https://github.com/cssinjs/jss/pull/1315
[`jss-plugin-rule-value-function@<=10.1.1`, {
  dependencies: {
    [`tiny-warning`]: `^1.0.2`
  }
}], // https://github.com/vadimdemedes/ink-select-input/pull/26
[`ink-select-input@*`, {
  peerDependencies: {
    react: `^16.8.2`
  }
}]];

/***/ }),
/* 616 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPatch": () => /* binding */ getPatch
/* harmony export */ });
let patch;
function getPatch() {
  if (typeof patch === `undefined`) patch = __webpack_require__(116).brotliDecompressSync(Buffer.from(`G8EIABwHuTnyDkxeQiomXep01zJ90cJ3iFSgGcnN+dVTE5YC1CBsZn0bRMFnq2+/bPJOWLRlcCblbWaytN6yn94lDuHQVXEMzob/mhDOafB/uXcOjPnzEX5TF8I/4H+A7n4PCzSY0xTuWjDfxxV8F1neM4x7jymltl+dnYEp13SxCOpkQxUClagaNItavHVUdwD73pT3+c52oJFtOTmagkX/GAaKFyr1bLfAnKMY+OZmY+0YsC6Sci7AJQI2zADQHhdIcc03Dz+GOC05kpj3M0kiNKsdFu1U3ornmwco/hOeYDp3IUlCIQqaE6eg8ho+SQaBwAeE4PktvsKmDJJy8fXAx0jTz4Oj2wWKVgNnuMz/CR5AZNuo2eZk0HwujkkFQBytGPu+p1RoCpRBYVcTf7REjfuVBUIa+MgTpb+ZaKgASLlmw2dFNlIsdYEsSntc1vhEJfQLSkVdBXXK67OUoZjcjVu8DPd8oSwu1vK52tVmsLNeekvJW3ss4Z1+thxuul1A0bzLBLT7MQMQxaGNFQUpvaAsmmOVo1hZFKHViytsKRvkULx6+VpOghLO9W/tHqSTQkqQkLWIKtzBlsPNUviOym6eOz3jjDM43Jfi2pXbla5apaLf+jR3njZPcG1zp9bxgi6Acg2V4n8rU8+1ANM2CXkW5tkqS6QfhnL1z8/s5G8r/f4omOaXOkzbHh9HdPhfxz9Tftr698n6L7UYF/L089Ch+9QgeDSlUXdaBAyLU3G6bkC5ygWmNqZMBYJHB6iFj4uo0iI9yR5r3KUooI0Zg1IkiYsgqxR8jMug6VgwtyIaxNxP30CqZH3zo/g16/wof1VdCLhd+YIOeBHFhA/D2eAvyld7FIAT8EiOA1Msg41mq8UNYCwZt2Pc519uZYhp9gP6kOwhcU+Ydc0CsPIqfy0ZGgbIKNYGZ+RP4ESfRzdDW6vhSsXuu2VB29YEdri/7CbQ7XCsVevHtY2mms7dVEMb6Wa/Ln6ZokATZTjZ/kMMNoWEp0AqBKG0DaCyBxlBsylqymr/6xM+mxOAAVREIXXGnW4IXuQ5oSGimw0C7BKZb3ZDLEWtkWXM5FB7jjp37QA=`, `base64`)).toString();
  return patch;
}

/***/ }),
/* 617 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPatch": () => /* binding */ getPatch
/* harmony export */ });
let patch;
function getPatch() {
  if (typeof patch === `undefined`) patch = __webpack_require__(116).brotliDecompressSync(Buffer.from(`G1QTIIzURnVBnGa0VPvr81orV8AFIqdU0sqrdcVgCdukgAZwi8a50gLk9+19Z2NcUILjmzXkzt4dzm5a6Yoys+/9qnKiaApXukOiuoyUaMcynG4X7X4vBaIE/PL30gwG6HSGJkLxb9PnLjfMr+748n7sM6C/NycK6ber/bX1reVVxta6W/31tZIhfrS+upoE/TPRHj0S/l0T59gTGdtKOp1OmMOJt9rhfucDdLJ2tgyfnO+u4YMkQAcYq/nebTcDmbXhqhgo6iQA4M3m4xya4Cos3p6klmkmQT+S4DLDZfwfMF+sUCx36KleOtaHLQfEIz0Bmncj/Ngi3lqOl4391EWEfIss6gVp3oDUGwsSZJKeOVONJWZg+Mue3KUMV3aMqYJ+7b2219D+GFDi8EV5y/Y+5J+He0oNjKAgqLsJziEsS9uIaCu3BHBKSXxNKKa2ShbfglcWoiiVT2kfGI7Gw+YJ/Sqy1H6wdFWtyVUQIa82JPwbeV25YKLzc5ZIFM6GCPSA+J9dTvJbs5LuuKnLP3f09gCu2jxqsAv6CA+ZySVaUJr2d3A70BC/uBCKr2OVrWgC3fSwb7NlfkgSEEiejrMGvhya9lMbVI6lMsFKN330A1/FOaefHQdNGLEZ3IwFF87H3xVlM0Xxsmbi/7A60oymRcIe0tH90alG6ez/yA7jwYotxuHWZdR+1HlMcddGHAV6QD/gXYPV0wnNv47I+5FGevzZFMqWSO8GU4nQ3FjsdgdJcD+c1rvudERKuLyd7bxiBpnsMDHsvPP4nXdXkld/gUNks3GAE1Otmb90bavDyiw4Mrx496Iw+jbLTgsCZGZXSZ9vM55C7KGe4HyJAKXEk0iT/Cj/PFwLJBN7pcP7ZFfYtUApGTWKkYhI9IE2zt/5ByH72wdvH+88b71zuv/FMCX3w6x5nzhY44Cg5IYv9LeKwHuHIWgPbfgrAcUxOlKkPRdQOIDF/aBuLPJAXD+TgxCNXx4jQxeR/qlBWVikFPfEI4rXMUc4kZ2w9KbPKYRvFUag0dVlVoyUP4zfidbTXAdZF88jAckl+NHjLFCNdX7EQ1PbLSOl+P+MqgwEOCi6dxgWZ7NCwJBjWKpk1LaxwKrhZ4aEC/0lMPJYe5S8xAakDcmA2kSS86GjEMTrv3VEu0S0YGZcxToMV524G4WAc4CReePePdipvs4aXRL5p+aeN96yfMGjsiTbQNxgbdRKc+keQ+NxYIEm1mBtEO29WrcbrqNbQRMR66KpGG4aG0NtmRyZ2JhUvu0paCklRlID8PT3gSiwZrqr4XZXoBBzBMrveWCuOg7iTgGDXDdbGi8XHkQf5KXDGFUxWueu5wkSa6gMWY1599g2piQjwBKIAPt4N5cOZdFBidz2feGwEAy1j1UydGxDSCCUsh314cUIIRV/dWCheceubL2gU8CibewmP7UxmN5kN4I7zfQhPxkP0NCcei8GXQpw4c3krEzW7PR2hgi/hqqqR58UJ/ZVfWxfcH5ZKMo4itkmPK0FCGxzzIRP20lK/gz28Y03sY233KvSVWUKl9rcbX6MbHjpUG8MvNlw72p6FwTejv92zgpnCxVJnIHHZhCBxNcHF5RTveRp513hUtTHHq4BIndlytZT5xoTSYfHKqKNr4o9kcGINIz6tZSKRdtbON3Ydr9cgqxHIeisMNIsvPg/IFMZuBbSqqDLeSO5dak1cGr76FtH2PC7hs0S0Oq3GsmF1Ga4YABAMGcdPAWzTk26B7cKV91I2b0V/GYvnsEQ1YGntRqi5EQqTlgZszbV/32GuZtUF49JOA/r4jAdwUOsbPo6mNoBlJPYjM5axrZaWQf33bFsLWqiyvvDOM4x0Ng802T7cuP2a3q98GWq6yiq6q3M77hcZlOUnmryctRYmI4Hb2F5XixFohkBmySCjU+M7/WQVE5YAtnlxiUJDhFN0y1tNeMWY9E0MfZi2rQ4eC72WXjsAA==`, `base64`)).toString();
  return patch;
}

/***/ }),
/* 618 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPatch": () => /* binding */ getPatch
/* harmony export */ });
let patch;
function getPatch() {
  if (typeof patch === `undefined`) patch = __webpack_require__(116).brotliDecompressSync(Buffer.from(`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`, `base64`)).toString();
  return patch;
}

/***/ }),
/* 619 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _commands_create__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(620);
/* harmony import */ var _commands_dlx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(621);


const plugin = {
  commands: [_commands_create__WEBPACK_IMPORTED_MODULE_0__.default, _commands_dlx__WEBPACK_IMPORTED_MODULE_1__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 620 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ CreateCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);



 // eslint-disable-next-line arca/no-default-export

class CreateCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.quiet = false;
    this.args = [];
  }

  async execute() {
    const flags = [];
    if (this.pkg) flags.push(`--package`, this.pkg);
    if (this.quiet) flags.push(`--quiet`);
    const ident = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseIdent(this.command);
    const modified = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.makeIdent(ident.scope, `create-${ident.name}`);
    return this.cli.run([`dlx`, ...flags, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.stringifyIdent(modified), ...this.args]);
  }

}

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-p,--package`)], CreateCommand.prototype, "pkg", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-q,--quiet`)], CreateCommand.prototype, "quiet", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], CreateCommand.prototype, "command", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], CreateCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`create`)], CreateCommand.prototype, "execute", null);

/***/ }),
/* 621 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ DlxCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);





 // eslint-disable-next-line arca/no-default-export

class DlxCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.quiet = false;
    this.args = [];
  }

  async execute() {
    // Disable telemetry to prevent each `dlx` call from counting as a project
    _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.telemetry = null;
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.mktempPromise(async baseDir => {
      const tmpDir = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(baseDir, `dlx-${process.pid}`);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.mkdirPromise(tmpDir);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tmpDir, `package.json`), `{}\n`);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.writeFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tmpDir, `yarn.lock`), ``);
      const targetYarnrc = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tmpDir, `.yarnrc.yml`);
      const projectCwd = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.findProjectCwd(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.Filename.lockfile);
      const sourceYarnrc = projectCwd !== null ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(projectCwd, `.yarnrc.yml`) : null;

      if (sourceYarnrc !== null && _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.existsSync(sourceYarnrc)) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.copyFilePromise(sourceYarnrc, targetYarnrc);
        await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.updateConfiguration(tmpDir, current => {
          if (typeof current.plugins === `undefined`) return {
            enableGlobalCache: true,
            enableTelemetry: false
          };
          return {
            enableGlobalCache: true,
            enableTelemetry: false,
            plugins: current.plugins.map(plugin => {
              const sourcePath = typeof plugin === `string` ? plugin : plugin.path;
              const remapPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.isAbsolute(sourcePath) ? sourcePath : _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.fromPortablePath(projectCwd), sourcePath);

              if (typeof plugin === `string`) {
                return remapPath;
              } else {
                return {
                  path: remapPath,
                  spec: plugin.spec
                };
              }
            })
          };
        });
      } else {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.writeFilePromise(targetYarnrc, `enableGlobalCache: true\nenableTelemetry: false\n`);
      }

      const pkgs = typeof this.pkg !== `undefined` ? [this.pkg] : [this.command];
      const command = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.parseDescriptor(this.command).name;
      const addExitCode = await this.cli.run([`add`, `--`, ...pkgs], {
        cwd: tmpDir,
        quiet: this.quiet
      });
      if (addExitCode !== 0) return addExitCode;
      if (!this.quiet) this.context.stdout.write(`\n`);
      const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Configuration.find(tmpDir, this.context.plugins);
      const {
        project,
        workspace
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, tmpDir);
      if (workspace === null) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, tmpDir);
      await project.restoreInstallState();
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.scriptUtils.executeWorkspaceAccessibleBinary(workspace, command, this.args, {
        cwd: this.context.cwd,
        stdin: this.context.stdin,
        stdout: this.context.stdout,
        stderr: this.context.stderr
      });
    });
  }

}
DlxCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `run a package in a temporary environment`,
  details: `
      This command will install a package within a temporary environment, and run its binary script if it contains any. The binary will run within the current cwd.

      By default Yarn will download the package named \`command\`, but this can be changed through the use of the \`-p,--package\` flag which will instruct Yarn to still run the same command but from a different package.

      Also by default Yarn will print the full install logs when installing the given package. This behavior can be disabled by using the \`-q,--quiet\` flag which will instruct Yarn to only report critical errors.

      Using \`yarn dlx\` as a replacement of \`yarn add\` isn't recommended, as it makes your project non-deterministic (Yarn doesn't keep track of the packages installed through \`dlx\` - neither their name, nor their version).
    `,
  examples: [[`Use create-react-app to create a new React app`, `yarn dlx create-react-app ./my-app`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-p,--package`)], DlxCommand.prototype, "pkg", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-q,--quiet`)], DlxCommand.prototype, "quiet", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], DlxCommand.prototype, "command", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Proxy()], DlxCommand.prototype, "args", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`dlx`)], DlxCommand.prototype, "execute", null);

/***/ }),
/* 622 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _FileFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(623);
/* harmony import */ var _FileResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(625);
/* harmony import */ var _TarballFileFetcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(626);
/* harmony import */ var _TarballFileResolver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(627);




const plugin = {
  fetchers: [_TarballFileFetcher__WEBPACK_IMPORTED_MODULE_2__.TarballFileFetcher, _FileFetcher__WEBPACK_IMPORTED_MODULE_0__.FileFetcher],
  resolvers: [_TarballFileResolver__WEBPACK_IMPORTED_MODULE_3__.TarballFileResolver, _FileResolver__WEBPACK_IMPORTED_MODULE_1__.FileResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 623 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileFetcher": () => /* binding */ FileFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(209);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(624);



class FileFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL
    });
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path)) return path;
    const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
    if (parentLocalPath === null) return null;
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(parentLocalPath, path);
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
      loader: () => this.fetchFromDisk(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.getIdentVendorPath(locator),
      localPath: this.getLocalPath(locator, opts),
      checksum
    };
  }

  async fetchFromDisk(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL
    }); // If the file target is an absolute path we can directly access it via its
    // location on the disk. Otherwise we must go through the package fs.

    const parentFetch = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path) ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root
    } : await opts.fetcher.fetch(parentLocator, opts); // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.

    const effectiveParentFetch = parentFetch.localPath ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root, parentFetch.localPath)
    } : parentFetch; // Discard the parent fs unless we really need it to access the files

    if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs();
    const sourceFs = effectiveParentFetch.packageFs;
    const sourcePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(effectiveParentFetch.prefixPath, path);
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.tgzUtils.makeArchiveFromDirectory(sourcePath, {
        baseFs: sourceFs,
        prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.getIdentVendorPath(locator),
        compressionLevel: opts.project.configuration.get(`compressionLevel`)
      });
    }, effectiveParentFetch.releaseFs);
  }

}

/***/ }),
/* 624 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FILE_REGEXP": () => /* binding */ FILE_REGEXP,
/* harmony export */   "TARBALL_REGEXP": () => /* binding */ TARBALL_REGEXP,
/* harmony export */   "PROTOCOL": () => /* binding */ PROTOCOL
/* harmony export */ });
const FILE_REGEXP = /^(?:[a-zA-Z]:[\\/]|\.{0,2}\/)/;
const TARBALL_REGEXP = /^[^?]*\.(?:tar\.gz|tgz)(?:::.*)?$/;
const PROTOCOL = `file:`;

/***/ }),
/* 625 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileResolver": () => /* binding */ FileResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(624);





class FileResolver {
  supportsDescriptor(descriptor, opts) {
    if (descriptor.range.match(_constants__WEBPACK_IMPORTED_MODULE_0__.FILE_REGEXP)) return true;
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.FILE_REGEXP.test(descriptor.range)) descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeDescriptor(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL}${descriptor.range}`);
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    let path = descriptor.range;
    if (path.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) path = path.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length);
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path)}`)];
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 626 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarballFileFetcher": () => /* binding */ TarballFileFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(209);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(624);



class TarballFileFetcher {
  supports(locator, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(locator.reference)) return false;
    if (locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return true;
    return false;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
      loader: () => this.fetchFromDisk(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromDisk(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL
    }); // If the file target is an absolute path we can directly access it via its
    // location on the disk. Otherwise we must go through the package fs.

    const parentFetch = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path) ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root
    } : await opts.fetcher.fetch(parentLocator, opts); // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.

    const effectiveParentFetch = parentFetch.localPath ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root, parentFetch.localPath)
    } : parentFetch; // Discard the parent fs unless we really need it to access the files

    if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs();
    const sourceFs = effectiveParentFetch.packageFs;
    const sourcePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(effectiveParentFetch.prefixPath, path);
    const sourceBuffer = await sourceFs.readFilePromise(sourcePath);
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.tgzUtils.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.getIdentVendorPath(locator),
        stripComponents: 1
      });
    }, effectiveParentFetch.releaseFs);
  }

}

/***/ }),
/* 627 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarballFileResolver": () => /* binding */ TarballFileResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(624);





class TarballFileResolver {
  supportsDescriptor(descriptor, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(descriptor.range)) return false;
    if (descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return true;
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.FILE_REGEXP.test(descriptor.range)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(locator.reference)) return false;
    if (locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.FILE_REGEXP.test(descriptor.range)) descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeDescriptor(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL}${descriptor.range}`);
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    let path = descriptor.range;
    if (path.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) path = path.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length);
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path)}`)];
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 628 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gitUtils": () => /* reexport module object */ _gitUtils__WEBPACK_IMPORTED_MODULE_2__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _GitFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(629);
/* harmony import */ var _GitResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(631);
/* harmony import */ var _gitUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(630);




const plugin = {
  configuration: {
    cloneConcurrency: {
      description: `Maximal number of concurrent clones`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.SettingsType.NUMBER,
      default: 2
    }
  },
  fetchers: [_GitFetcher__WEBPACK_IMPORTED_MODULE_0__.GitFetcher],
  resolvers: [_GitResolver__WEBPACK_IMPORTED_MODULE_1__.GitResolver]
};
 // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 629 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GitFetcher": () => /* binding */ GitFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(206);
/* harmony import */ var _gitUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(630);



class GitFetcher {
  supports(locator, opts) {
    return _gitUtils__WEBPACK_IMPORTED_MODULE_0__.isGitUrl(locator.reference);
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const normalizedLocator = _gitUtils__WEBPACK_IMPORTED_MODULE_0__.normalizeLocator(locator);
    const checksums = new Map(opts.checksums);
    checksums.set(normalizedLocator.locatorHash, expectedChecksum);
    const nextOpts = { ...opts,
      checksums
    };
    const result = await this.downloadHosted(normalizedLocator, nextOpts);
    if (result !== null) return result;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote repository`),
      loader: () => this.cloneFromRemote(normalizedLocator, nextOpts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.getIdentVendorPath(locator),
      checksum
    };
  }

  async downloadHosted(locator, opts) {
    return opts.project.configuration.reduceHook(hooks => {
      return hooks.fetchHostedRepository;
    }, null, locator, opts);
  }

  async cloneFromRemote(locator, opts) {
    const cloneTarget = await _gitUtils__WEBPACK_IMPORTED_MODULE_0__.clone(locator.reference, opts.project.configuration);
    const repoUrlParts = _gitUtils__WEBPACK_IMPORTED_MODULE_0__.splitRepoUrl(locator.reference);
    const packagePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(cloneTarget, `package.tgz`);
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.scriptUtils.prepareExternalProject(cloneTarget, packagePath, {
      configuration: opts.project.configuration,
      report: opts.report,
      workspace: repoUrlParts.extra.workspace
    });
    const sourceBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.readFilePromise(packagePath);
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.tgzUtils.convertToZip(sourceBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.getIdentVendorPath(locator),
        stripComponents: 1
      });
    });
  }

}

/***/ }),
/* 630 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TreeishProtocols": () => /* binding */ TreeishProtocols,
/* harmony export */   "isGitUrl": () => /* binding */ isGitUrl,
/* harmony export */   "splitRepoUrl": () => /* binding */ splitRepoUrl,
/* harmony export */   "normalizeRepoUrl": () => /* binding */ normalizeRepoUrl,
/* harmony export */   "normalizeLocator": () => /* binding */ normalizeLocator,
/* harmony export */   "lsRemote": () => /* binding */ lsRemote,
/* harmony export */   "resolveUrl": () => /* binding */ resolveUrl,
/* harmony export */   "clone": () => /* binding */ clone
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);





function makeGitEnvironment() {
  return { ...process.env,
    // An option passed to SSH by Git to prevent SSH from asking for data (which would cause installs to hang when the SSH keys are missing)
    GIT_SSH_COMMAND: `ssh -o BatchMode=yes`
  };
}

const gitPatterns = [/^ssh:/, /^git(?:\+[^:]+)?:/, // `git+` is optional, `.git` is required
/^(?:git\+)?https?:[^#]+\/[^#]+(?:\.git)(?:#.*)?$/, /^git@[^#]+\/[^#]+\.git(?:#.*)?$/, /^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z._0-9-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z._0-9-]+?)(?:\.git)?(?:#.*)?$/, // GitHub `/tarball/` URLs
/^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/];
var TreeishProtocols;

(function (TreeishProtocols) {
  TreeishProtocols["Commit"] = "commit";
  TreeishProtocols["Head"] = "head";
  TreeishProtocols["Tag"] = "tag";
  TreeishProtocols["Semver"] = "semver";
})(TreeishProtocols || (TreeishProtocols = {}));
/**
 * Determines whether a given url is a valid github git url via regex
 */


function isGitUrl(url) {
  return url ? gitPatterns.some(pattern => !!url.match(pattern)) : false;
}
function splitRepoUrl(url) {
  url = normalizeRepoUrl(url);
  const hashIndex = url.indexOf(`#`);

  if (hashIndex === -1) {
    return {
      repo: url,
      treeish: {
        protocol: TreeishProtocols.Head,
        request: `master`
      },
      extra: {}
    };
  }

  const repo = url.slice(0, hashIndex);
  const subsequent = url.slice(hashIndex + 1); // New-style: "#commit=abcdef&workspace=foobar"

  if (subsequent.match(/^[a-z]+=/)) {
    const extra = querystring__WEBPACK_IMPORTED_MODULE_0___default().parse(subsequent);

    for (const [key, value] of Object.entries(extra)) if (typeof value !== `string`) throw new Error(`Assertion failed: The ${key} parameter must be a literal string`);

    const requestedProtocol = Object.values(TreeishProtocols).find(protocol => {
      return Object.prototype.hasOwnProperty.call(extra, protocol);
    });
    let protocol;
    let request;

    if (typeof requestedProtocol !== `undefined`) {
      protocol = requestedProtocol;
      request = extra[requestedProtocol];
    } else {
      protocol = TreeishProtocols.Head;
      request = `master`;
    }

    for (const key of Object.values(TreeishProtocols)) delete extra[key];

    return {
      repo,
      treeish: {
        protocol,
        request
      },
      extra: extra
    };
  } // Old-style: "#commit:abcdef" or "#abcdef"
  else {
      const colonIndex = subsequent.indexOf(`:`);
      let protocol;
      let request;

      if (colonIndex === -1) {
        protocol = null;
        request = subsequent;
      } else {
        protocol = subsequent.slice(0, colonIndex);
        request = subsequent.slice(colonIndex + 1);
      }

      return {
        repo,
        treeish: {
          protocol,
          request
        },
        extra: {}
      };
    }
}
function normalizeRepoUrl(url, {
  git = false
} = {}) {
  // "git+https://" isn't an actual Git protocol. It's just a way to
  // disambiguate that this URL points to a Git repository.
  url = url.replace(/^git\+https:/, `https:`); // We support this as an alias to GitHub repositories

  url = url.replace(/^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)(?:\.git)?(#.*)?$/, `https://github.com/$1/$2.git$3`); // We support GitHub `/tarball/` URLs

  url = url.replace(/^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/, `https://github.com/$1/$2.git#$3`); // The `git+` prefix doesn't mean anything at all for Git

  if (git) url = url.replace(/^git\+([^:]+):/, `$1:`);
  return url;
}
function normalizeLocator(locator) {
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.makeLocator(locator, normalizeRepoUrl(locator.reference));
}
async function lsRemote(repo, configuration) {
  if (!configuration.get(`enableNetwork`)) throw new Error(`Network access has been disabled by configuration (${repo})`);
  let res;

  try {
    res = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.execUtils.execvp(`git`, [`ls-remote`, `--refs`, normalizeRepoUrl(repo, {
      git: true
    })], {
      cwd: configuration.startingCwd,
      env: makeGitEnvironment(),
      strict: true
    });
  } catch (error) {
    error.message = `Listing the refs for ${repo} failed`;
    throw error;
  }

  const refs = new Map();
  const matcher = /^([a-f0-9]{40})\t(refs\/[^\n]+)/gm;
  let match;

  while ((match = matcher.exec(res.stdout)) !== null) refs.set(match[2], match[1]);

  return refs;
}
async function resolveUrl(url, configuration) {
  const {
    repo,
    treeish: {
      protocol,
      request
    },
    extra
  } = splitRepoUrl(url);
  const refs = await lsRemote(repo, configuration);

  const resolve = (protocol, request) => {
    switch (protocol) {
      case TreeishProtocols.Commit:
        {
          if (!request.match(/^[a-f0-9]{40}$/)) throw new Error(`Invalid commit hash`);
          return querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify({ ...extra,
            commit: request
          });
        }

      case TreeishProtocols.Head:
        {
          const head = refs.get(`refs/heads/${request}`);
          if (typeof head === `undefined`) throw new Error(`Unknown head ("${request}")`);
          return querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify({ ...extra,
            commit: head
          });
        }

      case TreeishProtocols.Tag:
        {
          const tag = refs.get(`refs/tags/${request}`);
          if (typeof tag === `undefined`) throw new Error(`Unknown tag ("${request}")`);
          return querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify({ ...extra,
            commit: tag
          });
        }

      case TreeishProtocols.Semver:
        {
          if (!semver__WEBPACK_IMPORTED_MODULE_1___default().validRange(request)) throw new Error(`Invalid range ("${request}")`);
          const semverTags = new Map([...refs.entries()].filter(([ref]) => {
            return ref.startsWith(`refs/tags/`);
          }).map(([ref, hash]) => {
            return [semver__WEBPACK_IMPORTED_MODULE_1___default().parse(ref.slice(10)), hash];
          }).filter(entry => {
            return entry[0] !== null;
          }));
          const bestVersion = semver__WEBPACK_IMPORTED_MODULE_1___default().maxSatisfying([...semverTags.keys()], request);
          if (bestVersion === null) throw new Error(`No matching range ("${request}")`);
          return querystring__WEBPACK_IMPORTED_MODULE_0___default().stringify({ ...extra,
            commit: semverTags.get(bestVersion)
          });
        }

      case null:
        {
          let result;
          if ((result = tryResolve(TreeishProtocols.Commit, request)) !== null) return result;
          if ((result = tryResolve(TreeishProtocols.Tag, request)) !== null) return result;
          if ((result = tryResolve(TreeishProtocols.Head, request)) !== null) return result;

          if (request.match(/^[a-f0-9]+$/)) {
            throw new Error(`Couldn't resolve "${request}" as either a commit, a tag, or a head - if a commit, use the 40-characters commit hash`);
          } else {
            throw new Error(`Couldn't resolve "${request}" as either a commit, a tag, or a head`);
          }
        }

      default:
        {
          throw new Error(`Invalid Git resolution protocol ("${protocol}")`);
        }
    }
  };

  const tryResolve = (protocol, request) => {
    try {
      return resolve(protocol, request);
    } catch (err) {
      return null;
    }
  };

  return `${repo}#${resolve(protocol, request)}`;
}
async function clone(url, configuration) {
  if (!configuration.get(`enableNetwork`)) throw new Error(`Network access has been disabled by configuration (${url})`);
  return await configuration.getLimit(`cloneConcurrency`)(async () => {
    const {
      repo,
      treeish: {
        protocol,
        request
      }
    } = splitRepoUrl(url);
    if (protocol !== `commit`) throw new Error(`Invalid treeish protocol when cloning`);
    const directory = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.mktempPromise();
    const execOpts = {
      cwd: directory,
      env: makeGitEnvironment(),
      strict: true
    };

    try {
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.execUtils.execvp(`git`, [`clone`, `-c core.autocrlf=false`, normalizeRepoUrl(repo, {
        git: true
      }), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.fromPortablePath(directory)], execOpts);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.execUtils.execvp(`git`, [`checkout`, `${request}`], execOpts);
    } catch (error) {
      error.message = `Repository clone failed: ${error.message}`;
      throw error;
    }

    return directory;
  });
}

/***/ }),
/* 631 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GitResolver": () => /* binding */ GitResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(230);
/* harmony import */ var _gitUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(630);




class GitResolver {
  supportsDescriptor(descriptor, opts) {
    return _gitUtils__WEBPACK_IMPORTED_MODULE_0__.isGitUrl(descriptor.range);
  }

  supportsLocator(locator, opts) {
    return _gitUtils__WEBPACK_IMPORTED_MODULE_0__.isGitUrl(locator.reference);
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const reference = await _gitUtils__WEBPACK_IMPORTED_MODULE_0__.resolveUrl(descriptor.range, opts.project.configuration);
    const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeLocator(descriptor, reference);
    return [locator];
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 632 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _GithubFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(633);

const plugin = {
  hooks: {
    async fetchHostedRepository(previous, locator, opts) {
      if (previous !== null) return previous;
      const fetcher = new _GithubFetcher__WEBPACK_IMPORTED_MODULE_0__.GithubFetcher();
      if (!fetcher.supports(locator, opts)) return null;

      try {
        return await fetcher.fetch(locator, opts);
      } catch (error) {
        return null;
      }
    }

  }
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 633 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GithubFetcher": () => /* binding */ GithubFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(209);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_plugin_git__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(628);
/* harmony import */ var _githubUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(634);




class GithubFetcher {
  supports(locator, opts) {
    if (!_githubUtils__WEBPACK_IMPORTED_MODULE_1__.isGithubUrl(locator.reference)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from GitHub`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    const sourceBuffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.httpUtils.get(this.getLocatorUrl(locator, opts), {
      configuration: opts.project.configuration
    });
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.mktempPromise(async extractPath => {
      const extractTarget = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.CwdFS(extractPath);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.tgzUtils.extractArchiveTo(sourceBuffer, extractTarget, {
        stripComponents: 1
      });
      const repoUrlParts = _yarnpkg_plugin_git__WEBPACK_IMPORTED_MODULE_0__.gitUtils.splitRepoUrl(locator.reference);
      const packagePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(extractPath, `package.tgz`);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.scriptUtils.prepareExternalProject(extractPath, packagePath, {
        configuration: opts.project.configuration,
        report: opts.report,
        workspace: repoUrlParts.extra.workspace
      });
      const packedBuffer = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.readFilePromise(packagePath);
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.tgzUtils.convertToZip(packedBuffer, {
        compressionLevel: opts.project.configuration.get(`compressionLevel`),
        prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.getIdentVendorPath(locator),
        stripComponents: 1
      });
    });
  }

  getLocatorUrl(locator, opts) {
    const {
      auth,
      username,
      reponame,
      treeish
    } = _githubUtils__WEBPACK_IMPORTED_MODULE_1__.parseGithubUrl(locator.reference);
    return `https://${auth ? `${auth}@` : ``}github.com/${username}/${reponame}/archive/${treeish}.tar.gz`;
  }

}

/***/ }),
/* 634 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isGithubUrl": () => /* binding */ isGithubUrl,
/* harmony export */   "parseGithubUrl": () => /* binding */ parseGithubUrl
/* harmony export */ });
/* unused harmony export invalidGithubUrlMessage */
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(141);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_0__);

const githubPatterns = [/^https?:\/\/(?:([^/]+?)@)?github.com\/([^/#]+)\/([^/#]+)\/tarball\/([^/#]+)(?:#(.*))?$/, /^https?:\/\/(?:([^/]+?)@)?github.com\/([^/#]+)\/([^/#]+?)(?:\.git)?(?:#(.*))?$/];
/**
 * Determines whether a given url is a valid github git url via regex
 */

function isGithubUrl(url) {
  return url ? githubPatterns.some(pattern => !!url.match(pattern)) : false;
}
/**
 * Takes a valid github repository url and parses it, returning
 * an object of type `ParsedGithubUrl`
 */

function parseGithubUrl(urlStr) {
  let match;

  for (const pattern of githubPatterns) {
    match = urlStr.match(pattern);

    if (match) {
      break;
    }
  }

  if (!match) throw new Error(invalidGithubUrlMessage(urlStr));
  let [, auth, username, reponame, treeish = `master`] = match;
  const {
    commit
  } = querystring__WEBPACK_IMPORTED_MODULE_0___default().parse(treeish);
  treeish = // New style:
  // The URLs have already been normalized by `gitUtils.resolveUrl`,
  // so it's certain in the context of the `GithubFetcher`
  // that the `commit` querystring parameter exists
  commit // Old style:
  // Shouldn't ever be needed by the GithubFetcher
  || treeish.replace(/[^:]*:/, ``);
  return {
    auth,
    username,
    reponame,
    treeish
  };
}
function invalidGithubUrlMessage(url) {
  return `Input cannot be parsed as a valid GitHub URL ('${url}').`;
}

/***/ }),
/* 635 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _TarballHttpFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(636);
/* harmony import */ var _TarballHttpResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(638);


const plugin = {
  fetchers: [_TarballHttpFetcher__WEBPACK_IMPORTED_MODULE_0__.TarballHttpFetcher],
  resolvers: [_TarballHttpResolver__WEBPACK_IMPORTED_MODULE_1__.TarballHttpResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 636 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarballHttpFetcher": () => /* binding */ TarballHttpFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(637);


class TarballHttpFetcher {
  supports(locator, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(locator.reference)) return false;
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL_REGEXP.test(locator.reference)) return true;
    return false;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    const sourceBuffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.httpUtils.get(locator.reference, {
      configuration: opts.project.configuration
    });
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.tgzUtils.convertToZip(sourceBuffer, {
      compressionLevel: opts.project.configuration.get(`compressionLevel`),
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.getIdentVendorPath(locator),
      stripComponents: 1
    });
  }

}

/***/ }),
/* 637 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TARBALL_REGEXP": () => /* binding */ TARBALL_REGEXP,
/* harmony export */   "PROTOCOL_REGEXP": () => /* binding */ PROTOCOL_REGEXP
/* harmony export */ });
const TARBALL_REGEXP = /^[^?]*\.(?:tar\.gz|tgz)(?:\?.*)?$/;
const PROTOCOL_REGEXP = /^https?:/;

/***/ }),
/* 638 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TarballHttpResolver": () => /* binding */ TarballHttpResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(637);




class TarballHttpResolver {
  supportsDescriptor(descriptor, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(descriptor.range)) return false;
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL_REGEXP.test(descriptor.range)) return true;
    return false;
  }

  supportsLocator(locator, opts) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.TARBALL_REGEXP.test(locator.reference)) return false;
    if (_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL_REGEXP.test(locator.reference)) return true;
    return false;
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.convertDescriptorToLocator(descriptor)];
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 639 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _commands_init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(640);


const plugin = {
  configuration: {
    initLicense: {
      description: `License used when creating packages via the init command`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.STRING,
      default: null
    },
    initScope: {
      description: `Scope used when creating packages via the init command`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.STRING,
      default: null
    },
    initVersion: {
      description: `Version used when creating packages via the init command`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.STRING,
      default: null
    },
    initFields: {
      description: `Additional fields to set when creating packages via the init command`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.MAP,
      valueDefinition: {
        description: ``,
        type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.ANY
      }
    },
    initEditorConfig: {
      description: `Extra rules to define in the generator editorconfig`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.MAP,
      valueDefinition: {
        description: ``,
        type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.SettingsType.ANY
      }
    }
  },
  commands: [_commands_init__WEBPACK_IMPORTED_MODULE_0__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 640 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ InitCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(112);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(641);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);







 // eslint-disable-next-line arca/no-default-export

class InitCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.usev2 = false;
    this.assumeFreshProject = false;
    this.yes = false;
    this.private = false;
    this.workspace = false;
    this.install = false;
  }

  async execute() {
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Manifest.fileName))) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`A package.json already exists in the specified directory`);
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Configuration.find(this.context.cwd, this.context.plugins);
    const install = this.install ? this.install === true ? `latest` : this.install : null;

    if (install !== null) {
      return await this.executeProxy(configuration, install);
    } else {
      return await this.executeRegular(configuration);
    }
  }

  async executeProxy(configuration, version) {
    if (configuration.get(`yarnPath`) !== null) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Cannot use the --install flag when the current directory already uses yarnPath (from ${configuration.sources.get(`yarnPath`)})`);
    if (configuration.projectCwd !== null) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Cannot use the --install flag when the current directory is already part of a project`);
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(this.context.cwd)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mkdirPromise(this.context.cwd, {
      recursive: true
    });
    const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, configuration.get(`lockfileFilename`));
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(lockfilePath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(lockfilePath, ``);
    const versionExitCode = await this.cli.run([`set`, `version`, version]);
    if (versionExitCode !== 0) return versionExitCode;
    this.context.stdout.write(`\n`);
    const args = [`--assume-fresh-project`];
    if (this.private) args.push(`-p`);
    if (this.workspace) args.push(`-w`);
    if (this.yes) args.push(`-y`);
    return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mktempPromise(async binFolder => {
      const {
        code
      } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.execUtils.pipevp(`yarn`, [`init`, ...args], {
        cwd: this.context.cwd,
        stdin: this.context.stdin,
        stdout: this.context.stdout,
        stderr: this.context.stderr,
        env: await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.scriptUtils.makeScriptEnv({
          binFolder
        })
      });
      return code;
    });
  }

  async executeRegular(configuration) {
    let existingProject = null;

    if (!this.assumeFreshProject) {
      try {
        existingProject = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.Project.find(configuration, this.context.cwd);
      } catch (_a) {
        existingProject = null;
      }
    }

    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(this.context.cwd)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mkdirPromise(this.context.cwd, {
      recursive: true
    });
    const manifest = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Manifest();
    const fields = Object.fromEntries(configuration.get(`initFields`).entries());
    manifest.load(fields);
    manifest.name = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.makeIdent(configuration.get(`initScope`), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.basename(this.context.cwd));
    manifest.version = configuration.get(`initVersion`);
    manifest.private = this.private || this.workspace;
    manifest.license = configuration.get(`initLicense`);

    if (this.workspace) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `packages`), {
        recursive: true
      });
      manifest.workspaceDefinitions = [{
        pattern: `packages/*`
      }];
    }

    const serialized = {};
    manifest.exportTo(serialized); // @ts-ignore: The Node typings forgot one field

    util__WEBPACK_IMPORTED_MODULE_3__.inspect.styles.name = `cyan`;
    this.context.stdout.write(`${(0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(serialized, {
      depth: Infinity,
      colors: true,
      compact: false
    })}\n`);
    const manifestPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Manifest.fileName);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.changeFilePromise(manifestPath, `${JSON.stringify(serialized, null, 2)}\n`);
    const readmePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `README.md`);
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(readmePath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(readmePath, `# ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.stringifyIdent(manifest.name)}\n`);

    if (!existingProject) {
      const lockfilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.Filename.lockfile);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(lockfilePath, ``);
      const gitattributesLines = [`/.yarn/** linguist-vendored`];
      const gitattributesBody = gitattributesLines.map(line => {
        return `${line}\n`;
      }).join(``);
      const gitattributesPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `.gitattributes`);
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(gitattributesPath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(gitattributesPath, gitattributesBody);
      const gitignoreLines = [`/.yarn/*`, `!/.yarn/releases`, `!/.yarn/plugins`, `!/.yarn/sdks`, ``, `# Swap the comments on the following lines if you don't wish to use zero-installs`, `# Documentation here: https://yarnpkg.com/features/zero-installs`, `!/.yarn/cache`, `#/.pnp.*`];
      const gitignoreBody = gitignoreLines.map(line => {
        return `${line}\n`;
      }).join(``);
      const gitignorePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `.gitignore`);
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(gitignorePath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(gitignorePath, gitignoreBody);
      const editorConfigProperties = {
        [`*`]: {
          endOfLine: `lf`,
          insertFinalNewline: true
        },
        [`*.{js,json,.yml}`]: {
          charset: `utf-8`,
          indentStyle: `space`,
          indentSize: 2
        }
      };
      lodash_merge__WEBPACK_IMPORTED_MODULE_2___default()(editorConfigProperties, configuration.get(`initEditorConfig`));
      let editorConfigBody = `root = true\n`;

      for (const [selector, props] of Object.entries(editorConfigProperties)) {
        editorConfigBody += `\n[${selector}]\n`;

        for (const [propName, propValue] of Object.entries(props)) {
          const snakeCaseName = propName.replace(/[A-Z]/g, $0 => `_${$0.toLowerCase()}`);
          editorConfigBody += `${snakeCaseName} = ${propValue}\n`;
        }
      }

      const editorConfigPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ppath.join(this.context.cwd, `.editorconfig`);
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.existsSync(editorConfigPath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.xfs.writeFilePromise(editorConfigPath, editorConfigBody);
      await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.execUtils.execvp(`git`, [`init`], {
        cwd: this.context.cwd
      });
    }
  }

}
InitCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `create a new package`,
  details: `
      This command will setup a new package in your local directory.

      If the \`-p,--private\` or \`-w,--workspace\` options are set, the package will be private by default.

      If the \`-w,--workspace\` option is set, the package will be configured to accept a set of workspaces in the \`packages/\` directory.

      If the \`-i,--install\` option is given a value, Yarn will first download it using \`yarn set version\` and only then forward the init call to the newly downloaded bundle. Without arguments, the downloaded bundle will be \`latest\`.

      The initial settings of the manifest can be changed by using the \`initScope\` and \`initFields\` configuration values. Additionally, Yarn will generate an EditorConfig file whose rules can be altered via \`initEditorConfig\`, and will initialize a Git repository in the current directory.
    `,
  examples: [[`Create a new package in the local directory`, `yarn init`], [`Create a new private package in the local directory`, `yarn init -p`], [`Create a new package and store the Yarn release inside`, `yarn init -i latest`], [`Create a new private package and defines it as a workspace root`, `yarn init -w`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-2`, {
  hidden: true
})], InitCommand.prototype, "usev2", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--assume-fresh-project`, {
  hidden: true
})], InitCommand.prototype, "assumeFreshProject", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-y,--yes`, {
  hidden: true
})], InitCommand.prototype, "yes", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-p,--private`)], InitCommand.prototype, "private", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-w,--workspace`)], InitCommand.prototype, "workspace", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-i,--install`, {
  tolerateBoolean: true
})], InitCommand.prototype, "install", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`init`)], InitCommand.prototype, "execute", null);

/***/ }),
/* 641 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(642),
    createAssigner = __webpack_require__(649);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 642 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(382),
    assignMergeValue = __webpack_require__(643),
    baseFor = __webpack_require__(467),
    baseMergeDeep = __webpack_require__(644),
    isObject = __webpack_require__(348),
    keysIn = __webpack_require__(409),
    safeGet = __webpack_require__(647);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 643 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(390),
    eq = __webpack_require__(361);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 644 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__(643),
    cloneBuffer = __webpack_require__(412),
    cloneTypedArray = __webpack_require__(437),
    copyArray = __webpack_require__(413),
    initCloneObject = __webpack_require__(438),
    isArguments = __webpack_require__(375),
    isArray = __webpack_require__(327),
    isArrayLikeObject = __webpack_require__(645),
    isBuffer = __webpack_require__(397),
    isFunction = __webpack_require__(347),
    isObject = __webpack_require__(348),
    isPlainObject = __webpack_require__(646),
    isTypedArray = __webpack_require__(399),
    safeGet = __webpack_require__(647),
    toPlainObject = __webpack_require__(648);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 645 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(407),
    isObjectLike = __webpack_require__(336);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 646 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(330),
    getPrototype = __webpack_require__(421),
    isObjectLike = __webpack_require__(336);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 647 */
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 648 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(393),
    keysIn = __webpack_require__(409);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 649 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(650),
    isIterateeCall = __webpack_require__(657);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 650 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(490),
    overRest = __webpack_require__(651),
    setToString = __webpack_require__(653);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 651 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(652);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 652 */
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 653 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(654),
    shortOut = __webpack_require__(656);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 654 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(655),
    defineProperty = __webpack_require__(391),
    identity = __webpack_require__(490);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 655 */
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 656 */
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 657 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(361),
    isArrayLike = __webpack_require__(407),
    isIndex = __webpack_require__(377),
    isObject = __webpack_require__(348);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 658 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _LinkFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(659);
/* harmony import */ var _LinkResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(661);
/* harmony import */ var _RawLinkFetcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(662);
/* harmony import */ var _RawLinkResolver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(663);




const plugin = {
  fetchers: [_RawLinkFetcher__WEBPACK_IMPORTED_MODULE_2__.RawLinkFetcher, _LinkFetcher__WEBPACK_IMPORTED_MODULE_0__.LinkFetcher],
  resolvers: [_RawLinkResolver__WEBPACK_IMPORTED_MODULE_3__.RawLinkResolver, _LinkResolver__WEBPACK_IMPORTED_MODULE_1__.LinkResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 659 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkFetcher": () => /* binding */ LinkFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(209);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(210);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(660);



class LinkFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL
    });
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path)) return path;
    const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
    if (parentLocalPath === null) return null;
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(parentLocalPath, path);
  }

  async fetch(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL
    }); // If the link target is an absolute path we can directly access it via its
    // location on the disk. Otherwise we must go through the package fs.

    const parentFetch = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path) ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root
    } : await opts.fetcher.fetch(parentLocator, opts); // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.

    const effectiveParentFetch = parentFetch.localPath ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root, parentFetch.localPath)
    } : parentFetch; // Discard the parent fs unless we really need it to access the files

    if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs();
    const sourceFs = effectiveParentFetch.packageFs;
    const sourcePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(effectiveParentFetch.prefixPath, path);

    if (parentFetch.localPath) {
      return {
        packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(sourcePath, {
          baseFs: sourceFs
        }),
        releaseFs: effectiveParentFetch.releaseFs,
        prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
        localPath: sourcePath
      };
    } else {
      return {
        packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.JailFS(sourcePath, {
          baseFs: sourceFs
        }),
        releaseFs: effectiveParentFetch.releaseFs,
        prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot
      };
    }
  }

}

/***/ }),
/* 660 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LINK_PROTOCOL": () => /* binding */ LINK_PROTOCOL,
/* harmony export */   "RAW_LINK_PROTOCOL": () => /* binding */ RAW_LINK_PROTOCOL
/* harmony export */ });
const LINK_PROTOCOL = `portal:`;
const RAW_LINK_PROTOCOL = `link:`;

/***/ }),
/* 661 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkResolver": () => /* binding */ LinkResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(660);





class LinkResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const path = descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL.length);
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.LINK_PROTOCOL}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path)}`)];
  }

  async resolve(locator, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const packageFetch = await opts.fetchOptions.fetcher.fetch(locator, opts.fetchOptions);
    const manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.releaseAfterUseAsync(async () => {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Manifest.find(packageFetch.prefixPath, {
        baseFs: packageFetch.packageFs
      });
    }, packageFetch.releaseFs);
    return { ...locator,
      version: manifest.version || `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.LinkType.SOFT,
      dependencies: new Map([...manifest.dependencies, ...manifest.devDependencies]),
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 662 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawLinkFetcher": () => /* binding */ RawLinkFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(209);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(210);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(660);



class RawLinkFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL
    });
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path)) return path;
    const parentLocalPath = opts.fetcher.getLocalPath(parentLocator, opts);
    if (parentLocalPath === null) return null;
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(parentLocalPath, path);
  }

  async fetch(locator, opts) {
    const {
      parentLocator,
      path
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseFileStyleRange(locator.reference, {
      protocol: _constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL
    }); // If the link target is an absolute path we can directly access it via its
    // location on the disk. Otherwise we must go through the package fs.

    const parentFetch = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(path) ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
      localPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root
    } : await opts.fetcher.fetch(parentLocator, opts); // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.

    const effectiveParentFetch = parentFetch.localPath ? {
      packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root),
      prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.root, parentFetch.localPath)
    } : parentFetch; // Discard the parent fs unless we really need it to access the files

    if (parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs();
    const sourceFs = effectiveParentFetch.packageFs;
    const sourcePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(effectiveParentFetch.prefixPath, path);

    if (parentFetch.localPath) {
      return {
        packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.CwdFS(sourcePath, {
          baseFs: sourceFs
        }),
        releaseFs: effectiveParentFetch.releaseFs,
        prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
        discardFromLookup: true,
        localPath: sourcePath
      };
    } else {
      return {
        packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.JailFS(sourcePath, {
          baseFs: sourceFs
        }),
        releaseFs: effectiveParentFetch.releaseFs,
        prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.PortablePath.dot,
        discardFromLookup: true
      };
    }
  }

}

/***/ }),
/* 663 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RawLinkResolver": () => /* binding */ RawLinkResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(660);




class RawLinkResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const path = descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL.length);
    return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_0__.RAW_LINK_PROTOCOL}${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path)}`)];
  }

  async resolve(locator, opts) {
    return { ...locator,
      version: `0.0.0`,
      languageName: opts.project.configuration.get(`defaultLanguageName`),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.LinkType.SOFT,
      dependencies: new Map(),
      peerDependencies: new Map(),
      dependenciesMeta: new Map(),
      peerDependenciesMeta: new Map(),
      bin: new Map()
    };
  }

}

/***/ }),
/* 664 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPnpPath": () => /* binding */ getPnpPath,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _NodeModulesLinker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(665);
/* harmony import */ var _PnpLooseLinker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(688);



const getPnpPath = project => _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(project.cwd, `.pnp.js`);
const plugin = {
  linkers: [_NodeModulesLinker__WEBPACK_IMPORTED_MODULE_0__.NodeModulesLinker, _PnpLooseLinker__WEBPACK_IMPORTED_MODULE_1__.PnpLooseLinker]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 665 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeModulesLinker": () => /* binding */ NodeModulesLinker
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(214);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(215);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(666);
/* harmony import */ var _yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(686);
/* harmony import */ var _yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(668);
/* harmony import */ var _zkochan_cmd_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(682);
/* harmony import */ var _zkochan_cmd_shim__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_zkochan_cmd_shim__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_6__);















const STATE_FILE_VERSION = 1;
const NODE_MODULES = `node_modules`;
const DOT_BIN = `.bin`;
const INSTALL_STATE_FILE = `.yarn-state.yml`;
class NodeModulesLinker {
  supportsPackage(pkg, opts) {
    return opts.project.configuration.get(`nodeLinker`) === `node-modules`;
  }

  async findPackageLocation(locator, opts) {
    const workspace = opts.project.tryWorkspaceByLocator(locator);
    if (workspace) return workspace.cwd;
    const installState = await findInstallState(opts.project, {
      unrollAliases: true
    });
    if (installState === null) throw new clipanion__WEBPACK_IMPORTED_MODULE_5__.UsageError(`Couldn't find the node_modules state file - running an install might help (findPackageLocation)`);
    const locatorInfo = installState.locatorMap.get(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.stringifyLocator(locator));
    if (!locatorInfo) throw new clipanion__WEBPACK_IMPORTED_MODULE_5__.UsageError(`Couldn't find ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyLocator(opts.project.configuration, locator)} in the currently installed node_modules map - running an install might help`);
    return locatorInfo.locations[0];
  }

  async findPackageLocator(location, opts) {
    const installState = await findInstallState(opts.project, {
      unrollAliases: true
    });
    if (installState === null) return null;
    const {
      locationRoot,
      segments
    } = parseLocation(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.resolve(location), {
      skipPrefix: opts.project.cwd
    });
    let locationNode = installState.locationTree.get(locationRoot);
    if (!locationNode) return null;
    let locator = locationNode.locator;

    for (const segment of segments) {
      locationNode = locationNode.children.get(segment);
      if (!locationNode) break;
      locator = locationNode.locator || locator;
    }

    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseLocator(locator);
  }

  makeInstaller(opts) {
    return new NodeModulesInstaller({ ...opts,
      skipIncompatiblePackageLinking: true
    });
  }

}

class NodeModulesInstaller extends _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_2__.AbstractPnpInstaller {
  constructor() {
    super(...arguments);
    this.manifestCache = new Map();
  }

  async getBuildScripts(locator, manifest, fetchResult) {
    return [];
  }

  async transformPackage(locator, manifest, fetchResult, dependencyMeta, flags) {
    return fetchResult.packageFs;
  }

  async finalizeInstallWithPnp(pnpSettings) {
    if (this.opts.project.configuration.get(`nodeLinker`) !== `node-modules`) return undefined;
    const defaultFsLayer = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.VirtualFS({
      baseFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.ZipOpenFS({
        libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)(),
        maxOpenFiles: 80,
        readOnlyArchives: true
      })
    });
    let preinstallState = await findInstallState(this.opts.project); // Remove build state as well, to force rebuild of all the packages

    if (preinstallState === null) {
      const bstatePath = this.opts.project.configuration.get(`bstatePath`);
      if (await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsPromise(bstatePath)) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.unlinkPromise(bstatePath);
      preinstallState = {
        locatorMap: new Map(),
        binSymlinks: new Map(),
        locationTree: new Map()
      };
    }

    const pnp = (0,_yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_3__.makeRuntimeApi)(pnpSettings, this.opts.project.cwd, defaultFsLayer);
    const nmTree = (0,_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_12__.buildNodeModulesTree)(pnp, {
      pnpifyFs: false
    });
    const locatorMap = (0,_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_12__.buildLocatorMap)(nmTree);
    await persistNodeModules(preinstallState, locatorMap, {
      baseFs: defaultFsLayer,
      project: this.opts.project,
      report: this.opts.report,
      loadManifest: this.cachedManifestLoad.bind(this)
    });
    const installStatuses = [];

    for (const [locatorKey, installRecord] of locatorMap.entries()) {
      if (isLinkLocator(locatorKey)) continue;
      const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseLocator(locatorKey);
      const pnpLocator = {
        name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.stringifyIdent(locator),
        reference: locator.reference
      };
      const pnpEntry = pnp.getPackageInformation(pnpLocator);
      if (pnpEntry === null) throw new Error(`Assertion failed: Expected the package to be registered (${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyLocator(this.opts.project.configuration, locator)})`);
      const sourceLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.toPortablePath(installRecord.locations[0]);
      const manifest = await this.cachedManifestLoad(sourceLocation);
      const buildScripts = await this.getSourceBuildScripts(sourceLocation, manifest);

      if (buildScripts.length > 0 && !this.opts.project.configuration.get(`enableScripts`)) {
        this.opts.report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.MessageName.DISABLED_BUILD_SCRIPTS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyLocator(this.opts.project.configuration, locator)} lists build scripts, but all build scripts have been disabled.`);
        buildScripts.length = 0;
      }

      if (buildScripts.length > 0 && installRecord.linkType !== _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.HARD && !this.opts.project.tryWorkspaceByLocator(locator)) {
        this.opts.report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.MessageName.SOFT_LINK_BUILD, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyLocator(this.opts.project.configuration, locator)} lists build scripts, but is referenced through a soft link. Soft links don't support build scripts, so they'll be ignored.`);
        buildScripts.length = 0;
      }

      const dependencyMeta = this.opts.project.getDependencyMeta(locator, manifest.version);

      if (buildScripts.length > 0 && dependencyMeta && dependencyMeta.built === false) {
        this.opts.report.reportInfoOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_13__.MessageName.BUILD_DISABLED, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.prettyLocator(this.opts.project.configuration, locator)} lists build scripts, but its build has been explicitly disabled through configuration.`);
        buildScripts.length = 0;
      }

      if (buildScripts.length > 0) {
        installStatuses.push({
          buildLocations: installRecord.locations,
          locatorHash: locator.locatorHash,
          buildDirective: buildScripts
        });
      }
    }

    return installStatuses;
  }

  async cachedManifestLoad(sourceLocation) {
    let manifest = this.manifestCache.get(sourceLocation);
    if (manifest) return manifest;

    try {
      manifest = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_15__.Manifest.find(sourceLocation);
    } catch (e) {
      e.message = `While loading ${sourceLocation}: ${e.message}`;
      throw e;
    }

    this.manifestCache.set(sourceLocation, manifest);
    return manifest;
  }

  async getSourceBuildScripts(packageLocation, manifest) {
    const buildScripts = [];
    const {
      scripts
    } = manifest;

    for (const scriptName of [`preinstall`, `install`, `postinstall`]) if (scripts.has(scriptName)) buildScripts.push([_yarnpkg_core__WEBPACK_IMPORTED_MODULE_16__.BuildType.SCRIPT, scriptName]); // Detect cases where a package has a binding.gyp but no install script


    const bindingFilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.resolve(packageLocation, `binding.gyp`);
    if (!scripts.has(`install`) && _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsSync(bindingFilePath)) buildScripts.push([_yarnpkg_core__WEBPACK_IMPORTED_MODULE_16__.BuildType.SHELLCODE, `node-gyp rebuild`]);
    return buildScripts;
  }

}

async function writeInstallState(project, locatorMap, binSymlinks) {
  let locatorState = ``;
  locatorState += `# Warning: This file is automatically generated. Removing it is fine, but will\n`;
  locatorState += `# cause your node_modules installation to become invalidated.\n`;
  locatorState += `\n`;
  locatorState += `__metadata:\n`;
  locatorState += `  version: ${STATE_FILE_VERSION}\n`;
  const locators = Array.from(locatorMap.keys()).sort();

  for (const locator of locators) {
    const installRecord = locatorMap.get(locator);
    locatorState += `\n`;
    locatorState += `${JSON.stringify(locator)}:\n`;
    locatorState += `  locations:\n`;
    let topLevelLocator = false;

    for (const location of installRecord.locations) {
      const internalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.contains(project.cwd, location);
      if (internalPath === null) throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
      locatorState += `    - ${JSON.stringify(internalPath)}\n`;

      if (location === project.cwd) {
        topLevelLocator = true;
      }
    }

    if (installRecord.aliases.length > 0) {
      locatorState += `  aliases:\n`;

      for (const alias of installRecord.aliases) {
        locatorState += `    - ${JSON.stringify(alias)}\n`;
      }
    }

    if (topLevelLocator && binSymlinks.size > 0) {
      locatorState += `  bin:\n`;

      for (const [location, symlinks] of binSymlinks) {
        const internalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.contains(project.cwd, location);
        if (internalPath === null) throw new Error(`Assertion failed: Expected the path to be within the project (${location})`);
        locatorState += `    ${JSON.stringify(internalPath)}:\n`;

        for (const [name, target] of symlinks) {
          const relativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, NODE_MODULES), target);
          locatorState += `      ${JSON.stringify(name)}: ${JSON.stringify(relativePath)}\n`;
        }
      }
    }
  }

  const rootPath = project.cwd;
  const installStatePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(rootPath, NODE_MODULES, INSTALL_STATE_FILE);
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.changeFilePromise(installStatePath, locatorState, {
    automaticNewlines: true
  });
}

async function findInstallState(project, {
  unrollAliases = false
} = {}) {
  const rootPath = project.cwd;
  const installStatePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(rootPath, NODE_MODULES, INSTALL_STATE_FILE);
  if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsSync(installStatePath)) return null;
  const locatorState = (0,_yarnpkg_parsers__WEBPACK_IMPORTED_MODULE_1__.parseSyml)(await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.readFilePromise(installStatePath, `utf8`)); // If we have a higher serialized version than we can handle, ignore the state alltogether

  if (locatorState.__metadata.version > STATE_FILE_VERSION) return null;
  const locatorMap = new Map();
  const binSymlinks = new Map();
  delete locatorState.__metadata;

  for (const [locatorStr, installRecord] of Object.entries(locatorState)) {
    const locations = installRecord.locations.map(location => {
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(rootPath, location);
    });
    const recordSymlinks = installRecord.bin;

    if (recordSymlinks) {
      for (const [relativeLocation, locationSymlinks] of Object.entries(recordSymlinks)) {
        const location = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(rootPath, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.toPortablePath(relativeLocation));
        const symlinks = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.miscUtils.getMapWithDefault(binSymlinks, location);

        for (const [name, target] of Object.entries(locationSymlinks)) {
          symlinks.set((0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.toFilename)(name), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.toPortablePath([location, NODE_MODULES, target].join(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.delimiter)));
        }
      }
    }

    locatorMap.set(locatorStr, {
      target: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.PortablePath.dot,
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.HARD,
      locations,
      aliases: installRecord.aliases || []
    });

    if (unrollAliases && installRecord.aliases) {
      for (const reference of installRecord.aliases) {
        const {
          scope,
          name
        } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseLocator(locatorStr);
        const alias = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.makeLocator(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.makeIdent(scope, name), reference);
        const aliasStr = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.stringifyLocator(alias);
        locatorMap.set(aliasStr, {
          target: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.PortablePath.dot,
          linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.HARD,
          locations,
          aliases: []
        });
      }
    }
  }

  return {
    locatorMap,
    binSymlinks,
    locationTree: buildLocationTree(locatorMap, {
      skipPrefix: project.cwd
    })
  };
}

const removeDir = async (dir, options) => {
  if (dir.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.sep).indexOf(NODE_MODULES) < 0) throw new Error(`Assertion failed: trying to remove dir that doesn't contain node_modules: ${dir}`);

  try {
    if (!options.innerLoop) {
      const stats = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.lstatPromise(dir);

      if (stats.isSymbolicLink()) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.unlinkPromise(dir);
        return;
      }
    }

    const entries = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.readdirPromise(dir, {
      withFileTypes: true
    });

    for (const entry of entries) {
      const targetPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(dir, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.toFilename)(entry.name));

      if (entry.isDirectory()) {
        if (entry.name !== NODE_MODULES || options && options.innerLoop) {
          await removeDir(targetPath, {
            innerLoop: true,
            contentsOnly: false
          });
        }
      } else {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.unlinkPromise(targetPath);
      }
    }

    if (!options.contentsOnly) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.rmdirPromise(dir);
    }
  } catch (e) {
    if (e.code !== `ENOENT` && e.code !== `ENOTEMPTY`) {
      throw e;
    }
  }
};

const CONCURRENT_OPERATION_LIMIT = 4;

const parseLocation = (location, {
  skipPrefix
}) => {
  const projectRelativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.contains(skipPrefix, location);
  if (projectRelativePath === null) throw new Error(`Assertion failed: Cannot process a path that isn't part of the requested prefix (${location} isn't within ${skipPrefix})`);
  const allSegments = projectRelativePath.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.sep) // Ignore empty segments (after trailing slashes)
  .filter(segment => segment !== ``);
  const nmIndex = allSegments.indexOf(NODE_MODULES); // Project path, up until the first node_modules segment

  const relativeRoot = allSegments.slice(0, nmIndex).join(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.sep);
  const locationRoot = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(skipPrefix, relativeRoot); // All segments that follow

  const segments = allSegments.slice(nmIndex);
  return {
    locationRoot,
    segments
  };
};

const buildLocationTree = (locatorMap, {
  skipPrefix
}) => {
  const locationTree = new Map();
  if (locatorMap === null) return locationTree;

  const makeNode = () => ({
    children: new Map(),
    linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.HARD
  });

  for (const [locator, info] of locatorMap.entries()) {
    if (info.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.SOFT) {
      const internalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.contains(skipPrefix, info.target);

      if (internalPath !== null) {
        const node = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.miscUtils.getFactoryWithDefault(locationTree, info.target, makeNode);
        node.locator = locator;
        node.linkType = info.linkType;
      }
    }

    for (const location of info.locations) {
      const {
        locationRoot,
        segments
      } = parseLocation(location, {
        skipPrefix
      });
      let node = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.miscUtils.getFactoryWithDefault(locationTree, locationRoot, makeNode);

      for (let idx = 0; idx < segments.length; ++idx) {
        const segment = segments[idx]; // '.' segment exists only for top-level locator, skip it

        if (segment !== `.`) {
          const nextNode = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.miscUtils.getFactoryWithDefault(node.children, segment, makeNode);
          node.children.set(segment, nextNode);
          node = nextNode;
        }

        if (idx === segments.length - 1) {
          node.locator = locator;
          node.linkType = info.linkType;
        }
      }
    }
  }

  return locationTree;
};

const symlinkPromise = async (srcPath, dstPath) => {
  let stats;

  try {
    if (process.platform === `win32`) {
      stats = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.lstatSync(srcPath);
    }
  } catch (e) {}

  if (process.platform == `win32` && (!stats || stats.isDirectory())) {
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.symlinkPromise(srcPath, dstPath, `junction`);
  } else {
    _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.symlinkPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.dirname(dstPath), srcPath), dstPath);
  }
};

const copyPromise = async (dstDir, srcDir, {
  baseFs,
  innerLoop
}) => {
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(dstDir, {
    recursive: true
  });
  const entries = await baseFs.readdirPromise(srcDir, {
    withFileTypes: true
  });

  const copy = async (dstPath, srcPath, srcType) => {
    if (srcType.isFile()) {
      const stat = await baseFs.lstatPromise(srcPath);
      await baseFs.copyFilePromise(srcPath, dstPath);
      const mode = stat.mode & 0o777; // An optimization - files will have rw-r-r permissions (0o644) by default, we can skip chmod for them

      if (mode !== 0o644) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.chmodPromise(dstPath, mode);
      }
    } else if (srcType.isSymbolicLink()) {
      const target = await baseFs.readlinkPromise(srcPath);
      await symlinkPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.dirname(dstPath), target), dstPath);
    } else {
      throw new Error(`Unsupported file type (file: ${srcPath}, mode: 0o${await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.statSync(srcPath).mode.toString(8).padStart(6, `0`)})`);
    }
  };

  for (const entry of entries) {
    const srcPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(srcDir, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.toFilename)(entry.name));
    const dstPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(dstDir, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.toFilename)(entry.name));

    if (entry.isDirectory()) {
      if (entry.name !== NODE_MODULES || innerLoop) {
        await copyPromise(dstPath, srcPath, {
          baseFs,
          innerLoop: true
        });
      }
    } else {
      await copy(dstPath, srcPath, entry);
    }
  }
};
/**
 * This function removes node_modules roots that do not exist on the filesystem from the location tree.
 *
 * This is needed to transparently support workflows on CI systems. When
 * user caches only top-level node_modules and forgets to cache node_modules
 * from deeper workspaces. By removing non-existent node_modules roots
 * we make our location tree to represent the real tree on the file system.
 *
 * Please note, that this function doesn't help with any other inconsistency
 * on a deeper level inside node_modules tree, it helps only when some node_modules roots
 * do not exist at all
 *
 * @param locationTree location tree
 *
 * @returns location tree with non-existent node_modules roots stripped
 */


function refineNodeModulesRoots(locationTree, binSymlinks) {
  const refinedLocationTree = new Map([...locationTree]);
  const refinedBinSymlinks = new Map([...binSymlinks]);

  for (const [workspaceRoot, node] of locationTree) {
    const nodeModulesRoot = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(workspaceRoot, NODE_MODULES);

    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsSync(nodeModulesRoot)) {
      node.children.delete(NODE_MODULES); // O(m^2) complexity algorithm, but on a very few values, so not worth the trouble to optimize it

      for (const location of refinedBinSymlinks.keys()) {
        if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.contains(nodeModulesRoot, location) !== null) {
          refinedBinSymlinks.delete(location);
        }
      }
    }
  }

  return {
    locationTree: refinedLocationTree,
    binSymlinks: refinedBinSymlinks
  };
}

function isLinkLocator(locatorKey) {
  let descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseDescriptor(locatorKey);
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.isVirtualDescriptor(descriptor)) descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.devirtualizeDescriptor(descriptor);
  return descriptor.range.startsWith(`link:`);
}

async function createBinSymlinkMap(installState, locationTree, projectRoot, {
  loadManifest
}) {
  const locatorScriptMap = new Map();

  for (const [locatorKey, {
    locations
  }] of installState) {
    const manifest = isLinkLocator(locatorKey) ? null : await loadManifest(locations[0]);
    const bin = new Map();

    if (manifest) {
      for (const [name, value] of manifest.bin) {
        const target = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(locations[0], value);

        if (value !== `` && _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.existsSync(target)) {
          bin.set(name, value);
        }
      }
    }

    locatorScriptMap.set(locatorKey, bin);
  }

  const binSymlinks = new Map();

  const getBinSymlinks = (location, parentLocatorLocation, node) => {
    const symlinks = new Map();
    const internalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.contains(projectRoot, location);

    if (node.locator && internalPath !== null) {
      const binScripts = locatorScriptMap.get(node.locator);

      for (const [filename, scriptPath] of binScripts) {
        const symlinkTarget = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.toPortablePath(scriptPath));
        symlinks.set((0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.toFilename)(filename), symlinkTarget);
      }

      for (const [childLocation, childNode] of node.children) {
        const absChildLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, childLocation);
        const childSymlinks = getBinSymlinks(absChildLocation, absChildLocation, childNode);

        if (childSymlinks.size > 0) {
          binSymlinks.set(location, new Map([...(binSymlinks.get(location) || new Map()), ...childSymlinks]));
        }
      }
    } else {
      for (const [childLocation, childNode] of node.children) {
        const childSymlinks = getBinSymlinks(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, childLocation), parentLocatorLocation, childNode);

        for (const [name, symlinkTarget] of childSymlinks) {
          symlinks.set(name, symlinkTarget);
        }
      }
    }

    return symlinks;
  };

  for (const [location, node] of locationTree) {
    const symlinks = getBinSymlinks(location, location, node);

    if (symlinks.size > 0) {
      binSymlinks.set(location, new Map([...(binSymlinks.get(location) || new Map()), ...symlinks]));
    }
  }

  return binSymlinks;
}

const areRealLocatorsEqual = (locatorKey1, locatorKey2) => {
  if (!locatorKey1 || !locatorKey2) return locatorKey1 === locatorKey2;
  let locator1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseLocator(locatorKey1);
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.isVirtualLocator(locator1)) locator1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.devirtualizeLocator(locator1);
  let locator2 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.parseLocator(locatorKey2);
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.isVirtualLocator(locator2)) locator2 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.devirtualizeLocator(locator2);
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.structUtils.areLocatorsEqual(locator1, locator2);
};

async function persistNodeModules(preinstallState, installState, {
  baseFs,
  project,
  report,
  loadManifest
}) {
  const rootNmDirPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(project.cwd, NODE_MODULES);
  const {
    locationTree: prevLocationTree,
    binSymlinks: prevBinSymlinks
  } = refineNodeModulesRoots(preinstallState.locationTree, preinstallState.binSymlinks);
  const locationTree = buildLocationTree(installState, {
    skipPrefix: project.cwd
  });
  const addQueue = [];

  const addModule = async ({
    srcDir,
    dstDir,
    linkType
  }) => {
    const promise = (async () => {
      try {
        if (linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.SOFT) {
          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.dirname(dstDir), {
            recursive: true
          });
          await symlinkPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.resolve(srcDir), dstDir);
        } else {
          await copyPromise(dstDir, srcDir, {
            baseFs
          });
        }
      } catch (e) {
        e.message = `While persisting ${srcDir} -> ${dstDir} ${e.message}`;
        throw e;
      } finally {
        progress.tick();
      }
    })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));

    addQueue.push(promise);

    if (addQueue.length > CONCURRENT_OPERATION_LIMIT) {
      await Promise.race(addQueue);
    }
  };

  const cloneModule = async (srcDir, dstDir, options) => {
    const promise = (async () => {
      const cloneDir = async (srcDir, dstDir, options) => {
        try {
          if (!options || !options.innerLoop) await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(dstDir, {
            recursive: true
          });
          const entries = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.readdirPromise(srcDir, {
            withFileTypes: true
          });

          for (const entry of entries) {
            if ((!options || !options.innerLoop) && entry.name === DOT_BIN) continue;
            const src = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(srcDir, entry.name);
            const dst = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(dstDir, entry.name);

            if (entry.isDirectory()) {
              if (entry.name !== NODE_MODULES || options && options.innerLoop) {
                await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(dst, {
                  recursive: true
                });
                await cloneDir(src, dst, {
                  innerLoop: true
                });
              }
            } else {
              await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.copyFilePromise(src, dst, (fs__WEBPACK_IMPORTED_MODULE_6___default().constants.COPYFILE_FICLONE));
            }
          }
        } catch (e) {
          if (!options || !options.innerLoop) e.message = `While cloning ${srcDir} -> ${dstDir} ${e.message}`;
          throw e;
        } finally {
          if (!options || !options.innerLoop) {
            progress.tick();
          }
        }
      };

      await cloneDir(srcDir, dstDir, options);
    })().then(() => addQueue.splice(addQueue.indexOf(promise), 1));

    addQueue.push(promise);

    if (addQueue.length > CONCURRENT_OPERATION_LIMIT) {
      await Promise.race(addQueue);
    }
  };

  const removeOutdatedDirs = async (location, prevNode, node) => {
    if (!node) {
      if (prevNode.children.has(NODE_MODULES)) await removeDir(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, NODE_MODULES), {
        contentsOnly: false
      });
      await removeDir(location, {
        contentsOnly: location === rootNmDirPath
      });
    } else {
      for (const [segment, prevChildNode] of prevNode.children) {
        const childNode = node.children.get(segment);
        await removeOutdatedDirs(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, segment), prevChildNode, childNode);
      }
    }
  }; // Find locations that existed previously, but no longer exist


  for (const [location, prevNode] of prevLocationTree) {
    const node = locationTree.get(location);

    for (const [segment, prevChildNode] of prevNode.children) {
      // '.' segment exists only for top-level locator, skip it
      if (segment === `.`) continue;
      const childNode = node ? node.children.get(segment) : node;
      await removeOutdatedDirs(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, segment), prevChildNode, childNode);
    }
  }

  const cleanNewDirs = async (location, node, prevNode) => {
    if (!prevNode) {
      // We want to clean only contents of top-level node_modules dir, since we need these dirs to be present
      if (node.children.has(NODE_MODULES)) await removeDir(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, NODE_MODULES), {
        contentsOnly: true
      }); // 1. If old directory is a symlink removeDir will remove it, regardless contentsOnly value
      // 2. If old and new directories are hardlinks - we pass contentsOnly: true
      // so that removeDir cleared only contents
      // 3. If new directory is a symlink - we pass contentsOnly: false
      // so that removeDir removed the whole directory

      await removeDir(location, {
        contentsOnly: node.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.HARD
      });
    } else {
      if (!areRealLocatorsEqual(node.locator, prevNode.locator)) await removeDir(location, {
        contentsOnly: node.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.HARD
      });

      for (const [segment, childNode] of node.children) {
        const prevChildNode = prevNode.children.get(segment);
        await cleanNewDirs(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, segment), childNode, prevChildNode);
      }
    }
  }; // Find new locations that are being added/changed and need to be cleaned up first


  for (const [location, node] of locationTree) {
    const prevNode = prevLocationTree.get(location);

    for (const [segment, childNode] of node.children) {
      // '.' segment exists only for top-level locator, skip it
      if (segment === `.`) continue;
      const prevChildNode = prevNode ? prevNode.children.get(segment) : prevNode;
      await cleanNewDirs(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, segment), childNode, prevChildNode);
    }
  } // Update changed locations


  const addList = [];

  for (const [prevLocator, {
    locations
  }] of preinstallState.locatorMap.entries()) {
    for (const location of locations) {
      const {
        locationRoot,
        segments
      } = parseLocation(location, {
        skipPrefix: project.cwd
      });
      let node = locationTree.get(locationRoot);
      let curLocation = locationRoot;

      if (node) {
        for (const segment of segments) {
          curLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(curLocation, segment);
          node = node.children.get(segment);

          if (!node) {
            break;
          }
        }

        if (node && !areRealLocatorsEqual(node.locator, prevLocator)) {
          const info = installState.get(node.locator);
          const srcDir = info.target;
          const dstDir = curLocation;
          const linkType = info.linkType;

          if (srcDir !== dstDir) {
            addList.push({
              srcDir,
              dstDir,
              linkType
            });
          }
        }
      }
    }
  } // Add new locations


  for (const [locator, {
    locations
  }] of installState.entries()) {
    for (const location of locations) {
      const {
        locationRoot,
        segments
      } = parseLocation(location, {
        skipPrefix: project.cwd
      });
      let prevTreeNode = prevLocationTree.get(locationRoot);
      let node = locationTree.get(locationRoot);
      let curLocation = locationRoot;
      const info = installState.get(locator);
      const srcDir = info.target;
      const dstDir = location;
      if (srcDir === dstDir) continue;
      const linkType = info.linkType;

      for (const segment of segments) node = node.children.get(segment);

      if (!prevTreeNode) {
        addList.push({
          srcDir,
          dstDir,
          linkType
        });
      } else {
        for (const segment of segments) {
          curLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(curLocation, segment);
          prevTreeNode = prevTreeNode.children.get(segment);

          if (!prevTreeNode) {
            addList.push({
              srcDir,
              dstDir,
              linkType
            });
            break;
          }
        }
      }
    }
  }

  const progress = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_17__.Report.progressViaCounter(addList.length);
  const reportedProgress = report.reportProgress(progress);

  try {
    const persistedLocations = new Map(); // For the first pass we'll only want to install a single copy for each
    // source directory. We'll later use the resulting install directories for
    // the other instances of the same package (this will avoid us having to
    // crawl the zip archives for each package).

    for (const entry of addList) {
      if (entry.linkType === _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.SOFT || !persistedLocations.has(entry.srcDir)) {
        persistedLocations.set(entry.srcDir, entry.dstDir);
        await addModule({ ...entry
        });
      }
    }

    await Promise.all(addQueue);
    addQueue.length = 0; // Second pass: clone module duplicates

    for (const entry of addList) {
      const persistedDir = persistedLocations.get(entry.srcDir);

      if (entry.linkType !== _yarnpkg_core__WEBPACK_IMPORTED_MODULE_14__.LinkType.SOFT && entry.dstDir !== persistedDir) {
        await cloneModule(persistedDir, entry.dstDir);
      }
    }

    await Promise.all(addQueue);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(rootNmDirPath, {
      recursive: true
    });
    const binSymlinks = await createBinSymlinkMap(installState, locationTree, project.cwd, {
      loadManifest
    });
    await persistBinSymlinks(prevBinSymlinks, binSymlinks);
    await writeInstallState(project, installState, binSymlinks);
  } finally {
    reportedProgress.stop();
  }
}

async function persistBinSymlinks(previousBinSymlinks, binSymlinks) {
  // Delete outdated .bin folders
  for (const location of previousBinSymlinks.keys()) {
    if (!binSymlinks.has(location)) {
      const binDir = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, NODE_MODULES, DOT_BIN);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.removePromise(binDir);
    }
  }

  for (const [location, symlinks] of binSymlinks) {
    const binDir = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(location, NODE_MODULES, DOT_BIN);
    const prevSymlinks = previousBinSymlinks.get(location) || new Map();
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.mkdirPromise(binDir, {
      recursive: true
    });

    for (const name of prevSymlinks.keys()) {
      if (!symlinks.has(name)) {
        // Remove outdated symlinks
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.removePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(binDir, name));

        if (process.platform === `win32`) {
          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.removePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(binDir, (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.toFilename)(`${name}.cmd`)));
        }
      }
    }

    for (const [name, target] of symlinks) {
      const prevTarget = prevSymlinks.get(name);
      const symlinkPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.ppath.join(binDir, name); // Skip unchanged .bin symlinks

      if (prevTarget === target) continue;

      if (process.platform === `win32`) {
        await _zkochan_cmd_shim__WEBPACK_IMPORTED_MODULE_4___default()(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.fromPortablePath(target), _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.npath.fromPortablePath(symlinkPath), {
          createPwshFile: false
        });
      } else {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.removePromise(symlinkPath);
        await symlinkPromise(target, symlinkPath);
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_11__.xfs.chmodPromise(target, 0o755);
      }
    }
  }
}

/***/ }),
/* 666 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pnpUtils": () => /* reexport module object */ _pnpUtils__WEBPACK_IMPORTED_MODULE_3__,
/* harmony export */   "getPnpPath": () => /* binding */ getPnpPath,
/* harmony export */   "quotePathIfNeeded": () => /* binding */ quotePathIfNeeded,
/* harmony export */   "AbstractPnpInstaller": () => /* reexport safe */ _AbstractPnpInstaller__WEBPACK_IMPORTED_MODULE_7__.AbstractPnpInstaller,
/* harmony export */   "PnpInstaller": () => /* reexport safe */ _PnpLinker__WEBPACK_IMPORTED_MODULE_1__.PnpInstaller,
/* harmony export */   "PnpLinker": () => /* reexport safe */ _PnpLinker__WEBPACK_IMPORTED_MODULE_1__.PnpLinker,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(206);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _PnpLinker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(667);
/* harmony import */ var _commands_unplug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(681);
/* harmony import */ var _pnpUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(680);
/* harmony import */ var _AbstractPnpInstaller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(679);







const getPnpPath = project => {
  let mainFilename;
  let otherFilename;

  if (project.topLevelWorkspace.manifest.type === `module`) {
    mainFilename = `.pnp.cjs`;
    otherFilename = `.pnp.js`;
  } else {
    mainFilename = `.pnp.js`;
    otherFilename = `.pnp.cjs`;
  }

  return {
    main: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(project.cwd, mainFilename),
    other: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(project.cwd, otherFilename)
  };
};
const quotePathIfNeeded = path => {
  return /\s/.test(path) ? JSON.stringify(path) : path;
};

async function setupScriptEnvironment(project, env, makePathWrapper) {
  const pnpPath = getPnpPath(project).main;
  const pnpRequire = `--require ${quotePathIfNeeded(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.npath.fromPortablePath(pnpPath))}`;
  if (pnpPath.includes(` `) && semver__WEBPACK_IMPORTED_MODULE_0___default().lt(process.versions.node, `12.0.0`)) throw new Error(`Expected the build location to not include spaces when using Node < 12.0.0 (${process.versions.node})`);

  if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.existsSync(pnpPath)) {
    let nodeOptions = env.NODE_OPTIONS || ``;
    const pnpRegularExpression = /\s*--require\s+\S*\.pnp\.c?js\s*/g;
    nodeOptions = nodeOptions.replace(pnpRegularExpression, ` `).trim();
    nodeOptions = nodeOptions ? `${pnpRequire} ${nodeOptions}` : pnpRequire;
    env.NODE_OPTIONS = nodeOptions;
  }
}

async function populateYarnPaths(project, definePath) {
  definePath(getPnpPath(project).main);
  definePath(getPnpPath(project).other);
  definePath(project.configuration.get(`pnpDataPath`));
  definePath(project.configuration.get(`pnpUnpluggedFolder`));
}

const plugin = {
  hooks: {
    populateYarnPaths,
    setupScriptEnvironment
  },
  configuration: {
    nodeLinker: {
      description: `The linker used for installing Node packages, one of: "pnp", "node-modules"`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.SettingsType.STRING,
      default: `pnp`
    },
    pnpMode: {
      description: `If 'strict', generates standard PnP maps. If 'loose', merges them with the n_m resolution.`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.SettingsType.STRING,
      default: `strict`
    },
    pnpShebang: {
      description: `String to prepend to the generated PnP script`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.SettingsType.STRING,
      default: `#!/usr/bin/env node`
    },
    pnpIgnorePatterns: {
      description: `Array of glob patterns; files matching them will use the classic resolution`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.SettingsType.STRING,
      default: [],
      isArray: true
    },
    pnpEnableInlining: {
      description: `If true, the PnP data will be inlined along with the generated loader`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.SettingsType.BOOLEAN,
      default: true
    },
    pnpFallbackMode: {
      description: `If true, the generated PnP loader will follow the top-level fallback rule`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.SettingsType.STRING,
      default: `dependencies-only`
    },
    pnpUnpluggedFolder: {
      description: `Folder where the unplugged packages must be stored`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.SettingsType.ABSOLUTE_PATH,
      default: `./.yarn/unplugged`
    },
    pnpDataPath: {
      description: `Path of the file where the PnP data (used by the loader) must be written`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.SettingsType.ABSOLUTE_PATH,
      default: `./.pnp.data.json`
    }
  },
  linkers: [_PnpLinker__WEBPACK_IMPORTED_MODULE_1__.PnpLinker],
  commands: [_commands_unplug__WEBPACK_IMPORTED_MODULE_2__.default]
};

 // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 667 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpLinker": () => /* binding */ PnpLinker,
/* harmony export */   "PnpInstaller": () => /* binding */ PnpInstaller
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(237);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(209);
/* harmony import */ var _yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(668);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _AbstractPnpInstaller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(679);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(666);
/* harmony import */ var _pnpUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(680);









const FORCED_UNPLUG_PACKAGES = new Set([// Some packages do weird stuff and MUST be unplugged. I don't like them.
_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.makeIdent(null, `nan`).identHash, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.makeIdent(null, `node-gyp`).identHash, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.makeIdent(null, `node-pre-gyp`).identHash, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.makeIdent(null, `node-addon-api`).identHash, // Those ones contain native builds (*.node), and Node loads them through dlopen
_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.makeIdent(null, `fsevents`).identHash]);
const FORCED_UNPLUG_FILETYPES = new Set([// Windows can't execute exe files inside zip archives
`.exe`, // The c/c++ compiler can't read files from zip archives
`.h`, `.hh`, `.hpp`, `.c`, `.cc`, `.cpp`, // The java runtime can't read files from zip archives
`.java`, `.jar`, // Node opens these through dlopen
`.node`]);
class PnpLinker {
  constructor() {
    this.mode = `strict`;
  }

  supportsPackage(pkg, opts) {
    if (opts.project.configuration.get(`nodeLinker`) !== `pnp`) return false;
    if (opts.project.configuration.get(`pnpMode`) !== this.mode) return false;
    return true;
  }

  async findPackageLocation(locator, opts) {
    const pnpPath = (0,_index__WEBPACK_IMPORTED_MODULE_3__.getPnpPath)(opts.project).main;
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(pnpPath)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The project in ${opts.project.cwd}/package.json doesn't seem to have been installed - running an install there might help`);
    const pnpFile = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.miscUtils.dynamicRequireNoCache(pnpPath);
    const packageLocator = {
      name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.requirableIdent(locator),
      reference: locator.reference
    };
    const packageInformation = pnpFile.getPackageInformation(packageLocator);
    if (!packageInformation) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Couldn't find ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyLocator(opts.project.configuration, locator)} in the currently installed PnP map - running an install might help`);
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(packageInformation.packageLocation);
  }

  async findPackageLocator(location, opts) {
    const pnpPath = (0,_index__WEBPACK_IMPORTED_MODULE_3__.getPnpPath)(opts.project).main;
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(pnpPath)) return null;
    const physicalPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(pnpPath);
    const pnpFile = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.miscUtils.dynamicRequire(physicalPath);
    delete __webpack_require__.c[physicalPath];
    const locator = pnpFile.findPackageLocator(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.fromPortablePath(location));
    if (!locator) return null;
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.makeLocator(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.parseIdent(locator.name), locator.reference);
  }

  makeInstaller(opts) {
    return new PnpInstaller(opts);
  }

}
class PnpInstaller extends _AbstractPnpInstaller__WEBPACK_IMPORTED_MODULE_2__.AbstractPnpInstaller {
  constructor() {
    super(...arguments);
    this.mode = `strict`;
    this.unpluggedPaths = new Set();
  }

  async getBuildScripts(locator, manifest, fetchResult) {
    if (manifest === null) return [];
    const buildScripts = [];

    for (const scriptName of [`preinstall`, `install`, `postinstall`]) if (manifest.scripts.has(scriptName)) buildScripts.push([_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.BuildType.SCRIPT, scriptName]); // Detect cases where a package has a binding.gyp but no install script


    const bindingFilePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(fetchResult.prefixPath, `binding.gyp`);
    if (!manifest.scripts.has(`install`) && fetchResult.packageFs.existsSync(bindingFilePath)) buildScripts.push([_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.BuildType.SHELLCODE, `node-gyp rebuild`]);
    return buildScripts;
  }

  async transformPackage(locator, manifest, fetchResult, dependencyMeta, {
    hasBuildScripts
  }) {
    if (this.isUnplugged(locator, manifest, fetchResult, dependencyMeta, {
      hasBuildScripts
    })) {
      return this.unplugPackage(locator, fetchResult.packageFs);
    } else {
      return fetchResult.packageFs;
    }
  }

  async finalizeInstallWithPnp(pnpSettings) {
    if (this.opts.project.configuration.get(`pnpMode`) !== this.mode) return;
    const pnpPath = (0,_index__WEBPACK_IMPORTED_MODULE_3__.getPnpPath)(this.opts.project);
    const pnpDataPath = this.opts.project.configuration.get(`pnpDataPath`);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpPath.other);

    if (this.opts.project.configuration.get(`nodeLinker`) !== `pnp`) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpPath.main);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpDataPath);
      return;
    }

    const nodeModules = await this.locateNodeModules();

    if (nodeModules.length > 0) {
      this.opts.report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.MessageName.DANGEROUS_NODE_MODULES, `One or more node_modules have been detected and will be removed. This operation may take some time.`);

      for (const nodeModulesPath of nodeModules) {
        await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(nodeModulesPath);
      }
    }

    if (this.opts.project.configuration.get(`pnpEnableInlining`)) {
      const loaderFile = (0,_yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_0__.generateInlinedScript)(pnpSettings);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.changeFilePromise(pnpPath.main, loaderFile, {
        automaticNewlines: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.chmodPromise(pnpPath.main, 0o755);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpDataPath);
    } else {
      const dataLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.dirname(pnpPath.main), pnpDataPath);
      const {
        dataFile,
        loaderFile
      } = (0,_yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_0__.generateSplitScript)({ ...pnpSettings,
        dataLocation
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.changeFilePromise(pnpPath.main, loaderFile, {
        automaticNewlines: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.chmodPromise(pnpPath.main, 0o755);
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.changeFilePromise(pnpDataPath, dataFile, {
        automaticNewlines: true
      });
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.chmodPromise(pnpDataPath, 0o644);
    }

    const pnpUnpluggedFolder = this.opts.project.configuration.get(`pnpUnpluggedFolder`);

    if (this.unpluggedPaths.size === 0) {
      await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(pnpUnpluggedFolder);
    } else {
      for (const entry of await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.readdirPromise(pnpUnpluggedFolder)) {
        const unpluggedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(pnpUnpluggedFolder, entry);

        if (!this.unpluggedPaths.has(unpluggedPath)) {
          await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.removePromise(unpluggedPath);
        }
      }
    }
  }

  async locateNodeModules() {
    const nodeModules = [];

    for (const workspace of this.opts.project.workspaces) {
      const nodeModulesPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(workspace.cwd, `node_modules`);
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.existsSync(nodeModulesPath)) continue;
      const directoryListing = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.readdirPromise(nodeModulesPath, {
        withFileTypes: true
      });
      const nonCacheEntries = directoryListing.filter(entry => {
        return !entry.isDirectory() || entry.name === `.bin` || !entry.name.startsWith(`.`);
      });

      if (nonCacheEntries.length === directoryListing.length) {
        nodeModules.push(nodeModulesPath);
      } else {
        for (const entry of nonCacheEntries) {
          nodeModules.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(nodeModulesPath, entry.name));
        }
      }
    }

    return nodeModules;
  }

  async unplugPackage(locator, packageFs) {
    const unplugPath = _pnpUtils__WEBPACK_IMPORTED_MODULE_4__.getUnpluggedPath(locator, {
      configuration: this.opts.project.configuration
    });
    this.unpluggedPaths.add(unplugPath);
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.mkdirPromise(unplugPath, {
      recursive: true
    });
    await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.xfs.copyPromise(unplugPath, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.dot, {
      baseFs: packageFs,
      overwrite: false
    });
    return new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_10__.CwdFS(unplugPath);
  }

  isUnplugged(ident, manifest, fetchResult, dependencyMeta, {
    hasBuildScripts
  }) {
    if (typeof dependencyMeta.unplugged !== `undefined`) return dependencyMeta.unplugged;
    if (FORCED_UNPLUG_PACKAGES.has(ident.identHash)) return true;
    if (manifest !== null && manifest.preferUnplugged !== null) return manifest.preferUnplugged;
    if (hasBuildScripts || fetchResult.packageFs.getExtractHint({
      relevantExtensions: FORCED_UNPLUG_FILETYPES
    })) return true;
    return false;
  }

}

/***/ }),
/* 668 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateInlinedScript": () => /* reexport safe */ _generatePnpScript__WEBPACK_IMPORTED_MODULE_1__.generateInlinedScript,
/* harmony export */   "generateSplitScript": () => /* reexport safe */ _generatePnpScript__WEBPACK_IMPORTED_MODULE_1__.generateSplitScript,
/* harmony export */   "makeRuntimeApi": () => /* reexport safe */ _makeRuntimeApi__WEBPACK_IMPORTED_MODULE_3__.makeRuntimeApi
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(669);
/* harmony import */ var _generatePnpScript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(670);
/* harmony import */ var _hydratePnpApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(674);
/* harmony import */ var _makeRuntimeApi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(678);





/***/ }),
/* 669 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export LinkType */
// Note: most of those types are useless for most users. Just check the
// PnpSettings and PnpApi types at the end and you'll be fine.
//
// Apart from that, note that the "Data"-suffixed types are the ones stored
// within the state files (hence why they only use JSON datatypes).
var LinkType;

(function (LinkType) {
  LinkType["HARD"] = "HARD";
  LinkType["SOFT"] = "SOFT";
})(LinkType || (LinkType = {}));

/***/ }),
/* 670 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateInlinedScript": () => /* binding */ generateInlinedScript,
/* harmony export */   "generateSplitScript": () => /* binding */ generateSplitScript
/* harmony export */ });
/* harmony import */ var _generatePrettyJson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(671);
/* harmony import */ var _generateSerializedState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(672);
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(673);
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_hook__WEBPACK_IMPORTED_MODULE_2__);

 // @ts-ignore



function generateLoader(shebang, loader) {
  return [shebang ? `${shebang}\n` : ``, `/* eslint-disable */\n\n`, `try {\n`, `  Object.freeze({}).detectStrictMode = true;\n`, `} catch (error) {\n`, `  throw new Error(\`The whole PnP file got strict-mode-ified, which is known to break (Emscripten libraries aren't strict mode). This usually happens when the file goes through Babel.\`);\n`, `}\n`, `\n`, `var __non_webpack_module__ = module;\n`, `\n`, `function $$SETUP_STATE(hydrateRuntimeState, basePath) {\n`, loader.replace(/^/gm, `  `), `}\n`, `\n`, _hook__WEBPACK_IMPORTED_MODULE_2___default()()].join(``);
}

function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}

function generateInlinedSetup(data) {
  return [`return hydrateRuntimeState(${(0,_generatePrettyJson__WEBPACK_IMPORTED_MODULE_0__.generatePrettyJson)(data)}, {basePath: basePath || __dirname});\n`].join(``);
}

function generateSplitSetup(dataLocation) {
  return [`var path = require('path');\n`, `var dataLocation = path.resolve(__dirname, ${JSON.stringify(dataLocation)});\n`, `return hydrateRuntimeState(require(dataLocation), {basePath: basePath || path.dirname(dataLocation)});\n`].join(``);
}

function generateInlinedScript(settings) {
  const data = (0,_generateSerializedState__WEBPACK_IMPORTED_MODULE_1__.generateSerializedState)(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = (0,_generateSerializedState__WEBPACK_IMPORTED_MODULE_1__.generateSerializedState)(settings);
  const setup = generateSplitSetup(settings.dataLocation);
  const loaderFile = generateLoader(settings.shebang, setup);
  return {
    dataFile: generateJsonString(data),
    loaderFile
  };
}

/***/ }),
/* 671 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generatePrettyJson": () => /* binding */ generatePrettyJson
/* harmony export */ });
var PrettyJsonState;

(function (PrettyJsonState) {
  PrettyJsonState["DEFAULT"] = "DEFAULT";
  PrettyJsonState["TOP_LEVEL"] = "TOP_LEVEL";
  PrettyJsonState["FALLBACK_EXCLUSION_LIST"] = "FALLBACK_EXCLUSION_LIST";
  PrettyJsonState["FALLBACK_EXCLUSION_ENTRIES"] = "FALLBACK_EXCLUSION_ENTRIES";
  PrettyJsonState["FALLBACK_EXCLUSION_DATA"] = "FALLBACK_EXCLUSION_DATA";
  PrettyJsonState["PACKAGE_REGISTRY_DATA"] = "PACKAGE_REGISTRY_DATA";
  PrettyJsonState["PACKAGE_REGISTRY_ENTRIES"] = "PACKAGE_REGISTRY_ENTRIES";
  PrettyJsonState["PACKAGE_STORE_DATA"] = "PACKAGE_STORE_DATA";
  PrettyJsonState["PACKAGE_STORE_ENTRIES"] = "PACKAGE_STORE_ENTRIES";
  PrettyJsonState["PACKAGE_INFORMATION_DATA"] = "PACKAGE_INFORMATION_DATA";
  PrettyJsonState["PACKAGE_DEPENDENCIES"] = "PACKAGE_DEPENDENCIES";
  PrettyJsonState["PACKAGE_DEPENDENCY"] = "PACKAGE_DEPENDENCY";
})(PrettyJsonState || (PrettyJsonState = {}));

const prettyJsonMachine = {
  [PrettyJsonState.DEFAULT]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // {
  //   "fallbackExclusionList": ...
  // }
  [PrettyJsonState.TOP_LEVEL]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: PrettyJsonState.FALLBACK_EXCLUSION_LIST,
      [`packageRegistryData`]: PrettyJsonState.PACKAGE_REGISTRY_DATA,
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "fallbackExclusionList": [
  //   ...
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_LIST]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES
    }
  },
  // "fallbackExclusionList": [
  //   [...]
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_DATA
    }
  },
  // "fallbackExclusionList": [
  //   [..., [...]]
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_DATA]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "packageRegistryData": [
  //   ...
  // ]
  [PrettyJsonState.PACKAGE_REGISTRY_DATA]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_REGISTRY_ENTRIES
    }
  },
  // "packageRegistryData": [
  //   [...]
  // ]
  [PrettyJsonState.PACKAGE_REGISTRY_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_STORE_DATA
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     ...
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_STORE_DATA]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_STORE_ENTRIES
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [...]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_STORE_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_INFORMATION_DATA
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       ...
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_INFORMATION_DATA]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: PrettyJsonState.PACKAGE_DEPENDENCIES,
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       "packagePeers": [
  //         ...
  //       ]
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_DEPENDENCIES]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_DEPENDENCY
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       "packageDependencies": [
  //         [...]
  //       ]
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_DEPENDENCY]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  }
};

function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;

  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);

    if (t + 1 < T) {
      result += `, `;
    }
  }

  result += `]`;
  return result;
}

function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[\n`;

  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T) result += `,`;
    result += `\n`;
  }

  result += indent;
  result += `]`;
  return result;
}

function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;

  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`) continue;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);

    if (t + 1 < T) {
      result += `, `;
    }
  }

  result += `}`;
  return result;
}

function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{\n`;

  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`) continue;
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    if (t + 1 < T) result += `,`;
    result += `\n`;
  }

  result += indent;
  result += `}`;
  return result;
}

function generateNext(key, data, state, indent) {
  const {
    next
  } = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}

function generate(data, state, indent) {
  const {
    collapsed
  } = prettyJsonMachine[state];

  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }

  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }

  return JSON.stringify(data);
}

function generatePrettyJson(data) {
  return generate(data, PrettyJsonState.TOP_LEVEL, ``);
}

/***/ }),
/* 672 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateSerializedState": () => /* binding */ generateSerializedState
/* harmony export */ });
/* unused harmony export sortMap */
// Keep this function is sync with its implementation in:
// @yarnpkg/core/sources/miscUtils.ts
function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers)) mappers = [mappers];
  const stringified = [];

  for (const mapper of mappers) stringified.push(asArray.map(value => mapper(value)));

  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? +1 : 0;

      if (comparison !== 0) {
        return comparison;
      }
    }

    return 0;
  });
  return indices.map(index => {
    return asArray[index];
  });
}

function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [({
    name,
    reference
  }) => name, ({
    name,
    reference
  }) => reference]);

  for (const {
    name,
    reference
  } of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`) fallbackExclusionList.set(name, references = new Set());
    references.add(reference);
  }

  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}

function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}

function generatePackageRegistryData(settings) {
  const packageRegistryData = [];

  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName]) => packageName === null ? `0` : `1${packageName}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);

    for (const [packageReference, {
      packageLocation,
      packageDependencies,
      packagePeers,
      linkType,
      discardFromLookup
    }] of sortMap(packageStore, ([packageReference]) => packageReference === null ? `0` : `1${packageReference}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName)) normalizedDependencies.push([packageName, packageReference]);

      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName]) => dependencyName)) normalizedDependencies.push([dependencyName, dependencyReference]);

      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : undefined;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : undefined;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }

  return packageRegistryData;
}

function generateLocationBlacklistData(settings) {
  return sortMap(settings.blacklistedLocations || [], location => location);
}

function generateSerializedState(settings) {
  return {
    __info: [`This file is automatically generated. Do not touch it, or risk`, `your modifications being lost. We also recommend you not to read`, `it either without using the @yarnpkg/pnp package, as the data layout`, `is entirely unspecified and WILL change from a version to another.`],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    locationBlacklistData: generateLocationBlacklistData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}

/***/ }),
/* 673 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let hook;

module.exports = () => {
  if (typeof hook === `undefined`)
    hook = __webpack_require__(116).brotliDecompressSync(Buffer.from('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', 'base64')).toString();

  return hook;
};


/***/ }),
/* 674 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony exports hydratePnpFile, hydratePnpSource */
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(113);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _loader_hydrateRuntimeState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(675);
/* harmony import */ var _loader_makeApi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(676);





const readFileP = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)(fs__WEBPACK_IMPORTED_MODULE_0__.readFile); // Note that using those functions is typically NOT needed! The PnP API is
// designed to be consumed directly from within Node - meaning that depending
// on your situation you probably should use one of those two alternatives
// instead:
//
//   - If your script is executing within a PnP environment, you'll be able to
//     simply `require("pnpapi")` in order to get a reference to the running
//     API. You can also simply check whether you're actually running within a
//     PnP environment by checking `process.versions.pnp`.
//
//   - Or if you're not running within a PnP environment, or wish to interact
//     with a different one than the current one, then you can directly require
//     its `.pnp.js` file.
//
// The function exported in this file only work when the PnP data are kept
// outside of the loader (pnpEnableInlining = false in Yarn), and their only
// real use case is to access the PnP API without running the risk of executing
// third-party Javascript code.

async function hydratePnpFile(location, {
  fakeFs,
  pnpapiResolution
}) {
  const source = await readFileP(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: dirname(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, {
  basePath,
  fakeFs,
  pnpapiResolution
}) {
  const data = JSON.parse(source);
  const runtimeState = hydrateRuntimeState(data, {
    basePath
  });
  return makeApi(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}

/***/ }),
/* 675 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hydrateRuntimeState": () => /* binding */ hydrateRuntimeState
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);

function hydrateRuntimeState(data, {
  basePath
}) {
  const portablePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(basePath);
  const absolutePortablePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      return [packageReference, {
        // We use ppath.join instead of ppath.resolve because:
        // 1) packageInformationData.packageLocation is a relative path when part of the SerializedState
        // 2) ppath.join preserves trailing slashes
        packageLocation: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.join(absolutePortablePath, packageInformationData.packageLocation),
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup: packageInformationData.discardFromLookup || false
      }];
    }))];
  }));
  const packageLocatorsByLocations = new Map();
  const packageLocationLengths = new Set();

  for (const [packageName, storeData] of data.packageRegistryData) {
    for (const [packageReference, packageInformationData] of storeData) {
      if (packageName === null !== (packageReference === null)) throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      if (packageInformationData.discardFromLookup) continue; // @ts-ignore: TypeScript isn't smart enough to understand the type assertion

      const packageLocator = {
        name: packageName,
        reference: packageReference
      };
      packageLocatorsByLocations.set(packageInformationData.packageLocation, packageLocator);
      packageLocationLengths.add(packageInformationData.packageLocation.length);
    }
  }

  for (const location of data.locationBlacklistData) packageLocatorsByLocations.set(location, null);

  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocationLengths: [...packageLocationLengths].sort((a, b) => b - a),
    packageLocatorsByLocations,
    packageRegistry
  };
}

/***/ }),
/* 676 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeApi": () => /* binding */ makeApi
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(214);
/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(219);
/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(module__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _internalTools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(677);




function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL); // @ts-ignore

  const builtinModules = new Set(module__WEBPACK_IMPORTED_MODULE_0__.Module.builtinModules || Object.keys(process.binding(`natives`))); // Splits a require request into its components, or return null if the request is a file path

  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/; // Matches if the path starts with a valid path qualifier (./, ../, /)
  // eslint-disable-next-line no-unused-vars

  const isStrictRegExp = /^\.{0,2}\//; // Matches if the path must point to a directory (ie ends with /)

  const isDirRegExp = /\/$/; // We only instantiate one of those so that we can use strict-equal comparisons

  const topLevelLocator = {
    name: null,
    reference: null
  }; // Used for compatibility purposes - cf setupCompatibilityLayer

  const fallbackLocators = []; // To avoid emitting the same warning multiple times

  const emittedWarnings = new Set();
  if (runtimeState.enableTopLevelFallback === true) fallbackLocators.push(topLevelLocator);

  if (opts.compatibilityMode !== false) {
    // ESLint currently doesn't have any portable way for shared configs to
    // specify their own plugins that should be used (cf issue #10125). This
    // will likely get fixed at some point but it'll take time, so in the
    // meantime we'll just add additional fallback entries for common shared
    // configs.
    // Similarly, Gatsby generates files within the `public` folder located
    // within the project, but doesn't pre-resolve the `require` calls to use
    // its own dependencies. Meaning that when PnP see a file from the `public`
    // folder making a require, it thinks that your project forgot to list one
    // of your dependencies.
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);

      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({
              name,
              reference
            });
          }
        }
      }
    }
  }
  /**
   * The setup code will be injected here. The tables listed below are guaranteed to be filled after the call to
   * the $$DYNAMICALLY_GENERATED_CODE function.
   */


  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations,
    packageLocationLengths
  } = runtimeState;
  /**
   * Allows to print useful logs just be setting a value in the environment
   */

  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }

  function maybeLog(name, fn) {
    if (opts.allowDebug === false) return fn;

    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);

          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            console.trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            console.trace(logEntry);
            throw error;
          }
        };
      }
    }

    return fn;
  }
  /**
   * Returns information about a package in a safe way (will throw if they cannot be retrieved)
   */


  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);

    if (!packageInformation) {
      throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.INTERNAL, `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`);
    }

    return packageInformation;
  }
  /**
   * Returns whether the specified locator is a dependency tree root (in which case it's part of the project) or not
   */


  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null) return true;

    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots) if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference) return true;

    return false;
  }
  /**
   * Implements the node resolution for folder access and extension selection
   */


  function applyNodeExtensionResolution(unqualifiedPath, candidates, {
    extensions
  }) {
    let stat;

    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {} // If the file exists and is a file, we can stop right there


    if (stat && !stat.isDirectory()) return opts.fakeFs.realpathSync(unqualifiedPath); // If the file is a directory, we must check if it contains a package.json with a "main" entry

    if (stat && stat.isDirectory()) {
      let pkgJson;

      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(unqualifiedPath, `package.json`), `utf8`));
      } catch (error) {}

      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main) nextUnqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(unqualifiedPath, pkgJson.main); // If the "main" field changed the path, we start again from this new location

      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, {
          extensions
        });

        if (resolution !== null) {
          return resolution;
        }
      }
    } // Otherwise we check if we find a file that match one of the supported extensions


    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);

      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    } // Otherwise, we check if the path is a folder - in such a case, we try to use its index


    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.format({
          dir: unqualifiedPath,
          name: `index`,
          ext: extensions[i]
        });
        candidates.push(candidateFile);

        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    } // Otherwise there's nothing else we can do :(


    return null;
  }
  /**
   * This function creates fake modules that can be used with the _resolveFilename function.
   * Ideally it would be nice to be able to avoid this, since it causes useless allocations
   * and cannot be cached efficiently (we recompute the nodeModulePaths every time).
   *
   * Fortunately, this should only affect the fallback, and there hopefully shouldn't have a
   * lot of them.
   */


  function makeFakeModule(path) {
    // @ts-ignore
    const fakeModule = new module__WEBPACK_IMPORTED_MODULE_0__.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = module__WEBPACK_IMPORTED_MODULE_0__.Module._nodeModulePaths(path);
    return fakeModule;
  }
  /**
   * Normalize path to posix format.
   */


  function normalizePath(p) {
    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(p);
  }
  /**
   * Forward the resolution to the next resolver (usually the native one)
   */


  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`)) issuer = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(issuer, `internal.js`); // Since we would need to create a fake module anyway (to call _resolveLookupPath that
    // would give us the paths to give to _resolveFilename), we can as well not use
    // the {paths} option at all, since it internally makes _resolveFilename create another
    // fake module anyway.

    return module__WEBPACK_IMPORTED_MODULE_0__.Module._resolveFilename(request, makeFakeModule(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(issuer)), false, {
      plugnplay: false
    });
  }
  /**
   *
   */


  function isPathIgnored(path) {
    if (ignorePattern === null) return false;
    const subPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.contains(runtimeState.basePath, path);
    if (subPath === null) return false;

    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * This key indicates which version of the standard is implemented by this resolver. The `std` key is the
   * Plug'n'Play standard, and any other key are third-party extensions. Third-party extensions are not allowed
   * to override the standard, and can only offer new methods.
   *
   * If a new version of the Plug'n'Play standard is released and some extensions conflict with newly added
   * functions, they'll just have to fix the conflicts and bump their own version number.
   */


  const VERSIONS = {
    std: 3,
    resolveVirtual: 1
  };
  /**
   * We export a special symbol for easy access to the top level locator.
   */

  const topLevel = topLevelLocator;
  /**
   * Gets the package information for a given locator. Returns null if they cannot be retrieved.
   */

  function getPackageInformation({
    name,
    reference
  }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore) return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation) return null;
    return packageInformation;
  }
  /**
   * Find all packages that depend on the specified one.
   *
   * Note: This is a private function; we expect consumers to implement it
   * themselves. We keep it that way because this implementation isn't
   * optimized at all, since we only need it when printing errors.
   */


  function findPackageDependents({
    name,
    reference
  }) {
    const dependents = [];

    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null) continue;

      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null) continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference) continue; // Don't forget that all packages depend on themselves

        if (dependentName === name && dependentReference === reference) continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }

    return dependents;
  }
  /**
   * Find all packages that broke the peer dependency on X, starting from Y.
   *
   * Note: This is a private function; we expect consumers to implement it
   * themselves. We keep it that way because this implementation isn't
   * optimized at all, since we only need it when printing errors.
   */


  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = new Map();
    const alreadyVisited = new Set();

    const traversal = currentPackage => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier)) return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);

      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);

        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`) brokenPackages.set(dependent.name, brokenSet = new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };

    traversal(initialPackage);
    const brokenList = [];

    for (const name of [...brokenPackages.keys()].sort()) for (const reference of [...brokenPackages.get(name)].sort()) brokenList.push({
      name,
      reference
    });

    return brokenList;
  }
  /**
   * Finds the package locator that owns the specified path. If none is found, returns null instead.
   */


  function findPackageLocator(location) {
    let relativeLocation = normalizePath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.relative(runtimeState.basePath, location));
    if (!relativeLocation.match(isStrictRegExp)) relativeLocation = `./${relativeLocation}`;
    if (location.match(isDirRegExp) && !relativeLocation.endsWith(`/`)) relativeLocation = `${relativeLocation}/`;
    let from = 0; // If someone wants to use a binary search to go from O(n) to O(log n), be my guest

    while (from < packageLocationLengths.length && packageLocationLengths[from] > relativeLocation.length) from += 1;

    for (let t = from; t < packageLocationLengths.length; ++t) {
      const locator = packageLocatorsByLocations.get(relativeLocation.substr(0, packageLocationLengths[t]));
      if (typeof locator === `undefined`) continue; // Ensures that the returned locator isn't a blacklisted one.
      //
      // Blacklisted packages are packages that cannot be used because their dependencies cannot be deduced. This only
      // happens with peer dependencies, which effectively have different sets of dependencies depending on their
      // parents.
      //
      // In order to deambiguate those different sets of dependencies, the Yarn implementation of PnP will generate a
      // symlink for each combination of <package name>/<package version>/<dependent package> it will find, and will
      // blacklist the target of those symlinks. By doing this, we ensure that files loaded through a specific path
      // will always have the same set of dependencies, provided the symlinks are correctly preserved.
      //
      // Unfortunately, some tools do not preserve them, and when it happens PnP isn't able anymore to deduce the set of
      // dependencies based on the path of the file that makes the require calls. But since we've blacklisted those
      // paths, we're able to print a more helpful error message that points out that a third-party package is doing
      // something incompatible!

      if (locator === null) {
        const locationForDisplay = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(location);
        throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.BLACKLISTED, `A forbidden path has been used in the package resolution process - this is usually caused by one of your tools calling 'fs.realpath' on the return value of 'require.resolve'. Since we need to use symlinks to simultaneously provide valid filesystem paths and disambiguate peer dependencies, they must be passed untransformed to 'require'.\n\nForbidden path: ${locationForDisplay}`, {
          location: locationForDisplay
        });
      }

      return locator;
    }

    return null;
  }
  /**
   * Transforms a request (what's typically passed as argument to the require function) into an unqualified path.
   * This path is called "unqualified" because it only changes the package name to the package location on the disk,
   * which means that the end result still cannot be directly accessed (for example, it doesn't try to resolve the
   * file extension, or to resolve directories to their "index.js" content). Use the "resolveUnqualified" function
   * to convert them to fully-qualified paths, or just use "resolveRequest" that do both operations in one go.
   *
   * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be
   * treated as a folder (ie. "/tmp/foo/" rather than "/tmp/foo" if "foo" is a directory). Otherwise relative
   * imports won't be computed correctly (they'll get resolved relative to "/tmp/" instead of "/tmp/foo/").
   */


  function resolveToUnqualified(request, issuer, {
    considerBuiltins = true
  } = {}) {
    // The 'pnpapi' request is reserved and will always return the path to the PnP file, from everywhere
    if (request === `pnpapi`) return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(opts.pnpapiResolution); // Bailout if the request is a native module

    if (considerBuiltins && builtinModules.has(request)) return null;
    const requestForDisplay = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(request);
    const issuerForDisplay = issuer && (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(issuer); // We allow disabling the pnp resolution for some subpaths.
    // This is because some projects, often legacy, contain multiple
    // levels of dependencies (ie. a yarn.lock inside a subfolder of
    // a yarn.lock). This is typically solved using workspaces, but
    // not all of them have been converted already.

    if (issuer && isPathIgnored(issuer)) {
      // Absolute paths that seem to belong to a PnP tree are still
      // handled by our runtime even if the issuer isn't. This is
      // because the native Node resolution uses a special version
      // of the `stat` syscall which would otherwise bypass the
      // filesystem layer we require to access the files.
      if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);

        if (result === false) {
          throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)\n\nRequire request: "${requestForDisplay}"\nRequired by: ${issuerForDisplay}\n`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        }

        return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(result);
      }
    }

    let unqualifiedPath; // If the request is a relative or absolute path, we just return it normalized

    const dependencyNameMatch = request.match(pathRegExp);

    if (!dependencyNameMatch) {
      if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.isAbsolute(request)) {
        unqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(request);
      } else {
        if (!issuer) {
          throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        } // We use ppath.join instead of ppath.resolve because:
        // 1) The request is a relative path in this branch
        // 2) ppath.join preserves trailing slashes


        const absoluteIssuer = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.resolve(issuer);

        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(absoluteIssuer), request));
        }
      } // No need to use the return value; we just want to check the blacklist status


      findPackageLocator(unqualifiedPath);
    } // Things are more hairy if it's a package require - we then need to figure out which package is needed, and in
    // particular the exact version for the given location on the dependency tree
    else {
        if (!issuer) {
          throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        }

        const [, dependencyName, subPath] = dependencyNameMatch;
        const issuerLocator = findPackageLocator(issuer); // If the issuer file doesn't seem to be owned by a package managed through pnp, then we resort to using the next
        // resolution algorithm in the chain, usually the native Node resolution one

        if (!issuerLocator) {
          const result = callNativeResolution(request, issuer);

          if (result === false) {
            throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).\n\nRequire path: "${requestForDisplay}"\nRequired by: ${issuerForDisplay}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay
            });
          }

          return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(result);
        }

        const issuerInformation = getPackageInformationSafe(issuerLocator); // We obtain the dependency reference in regard to the package that request it

        let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
        let fallbackReference = null; // If we can't find it, we check if we can potentially load it from the packages that have been defined as potential fallbacks.
        // It's a bit of a hack, but it improves compatibility with the existing Node ecosystem. Hopefully we should eventually be able
        // to kill this logic and become stricter once pnp gets enough traction and the affected packages fix themselves.

        if (dependencyReference == null) {
          if (issuerLocator.name !== null) {
            // To allow programs to become gradually stricter, starting from the v2 we enforce that workspaces cannot depend on fallbacks.
            // This works by having a list containing all their locators, and checking when a fallback is required whether it's one of them.
            const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
            const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);

            if (canUseFallbacks) {
              for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
                const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
                const reference = fallbackInformation.packageDependencies.get(dependencyName);
                if (reference == null) continue;
                if (alwaysWarnOnFallback) fallbackReference = reference;else dependencyReference = reference;
                break;
              }

              if (runtimeState.enableTopLevelFallback) {
                if (dependencyReference == null && fallbackReference === null) {
                  const reference = runtimeState.fallbackPool.get(dependencyName);

                  if (reference != null) {
                    fallbackReference = reference;
                  }
                }
              }
            }
          }
        } // If we can't find the path, and if the package making the request is the top-level, we can offer nicer error messages


        let error = null;

        if (dependencyReference === null) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.MISSING_PEER_DEPENDENCY, `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerForDisplay}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              dependencyName
            });
          } else {
            const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);

            if (brokenAncestors.every(ancestor => isDependencyTreeRoot(ancestor))) {
              error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n${brokenAncestors.map(ancestorLocator => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}\n`).join(``)}\n`, {
                request: requestForDisplay,
                issuer: issuerForDisplay,
                issuerLocator: Object.assign({}, issuerLocator),
                dependencyName,
                brokenAncestors
              });
            } else {
              error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n${brokenAncestors.map(ancestorLocator => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}\n`).join(``)}\n`, {
                request: requestForDisplay,
                issuer: issuerForDisplay,
                issuerLocator: Object.assign({}, issuerLocator),
                dependencyName,
                brokenAncestors
              });
            }
          }
        } else if (dependencyReference === undefined) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerForDisplay}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              dependencyName
            });
          } else {
            error = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName} (via "${requestForDisplay}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              issuerLocator: Object.assign({}, issuerLocator),
              dependencyName
            });
          }
        }

        if (dependencyReference == null) {
          if (fallbackReference === null || error === null) throw error || new Error(`Assertion failed: Expected an error to have been set`);
          dependencyReference = fallbackReference;
          const message = error.message.replace(/\n.*/g, ``);
          error.message = message;

          if (!emittedWarnings.has(message)) {
            emittedWarnings.add(message);
            process.emitWarning(error);
          }
        } // We need to check that the package exists on the filesystem, because it might not have been installed


        const dependencyLocator = Array.isArray(dependencyReference) ? {
          name: dependencyReference[0],
          reference: dependencyReference[1]
        } : {
          name: dependencyName,
          reference: dependencyReference
        };
        const dependencyInformation = getPackageInformationSafe(dependencyLocator);

        if (!dependencyInformation.packageLocation) {
          throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.MISSING_DEPENDENCY, `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.\n\nRequired package: ${dependencyLocator.name}@${dependencyLocator.reference} (via "${requestForDisplay}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n`, {
            request: requestForDisplay,
            issuer: issuerForDisplay,
            dependencyLocator: Object.assign({}, dependencyLocator)
          });
        } // Now that we know which package we should resolve to, we only have to find out the file location
        // packageLocation is always absolute as it's returned by getPackageInformationSafe


        const dependencyLocation = dependencyInformation.packageLocation;

        if (subPath) {
          // We use ppath.join instead of ppath.resolve because:
          // 1) subPath is always a relative path
          // 2) ppath.join preserves trailing slashes
          unqualifiedPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.join(dependencyLocation, subPath);
        } else {
          unqualifiedPath = dependencyLocation;
        }
      }

    return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(unqualifiedPath);
  }
  /**
   * Transforms an unqualified path into a qualified path by using the Node resolution algorithm (which automatically
   * appends ".js" / ".json", and transforms directory accesses into "index.js").
   */


  function resolveUnqualified(unqualifiedPath, {
    extensions = Object.keys(module__WEBPACK_IMPORTED_MODULE_0__.Module._extensions)
  } = {}) {
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, {
      extensions
    });

    if (qualifiedPath) {
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(qualifiedPath);
    } else {
      const unqualifiedPathForDisplay = (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(unqualifiedPath);
      throw (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.makeError)(_internalTools__WEBPACK_IMPORTED_MODULE_1__.ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Qualified path resolution failed - none of the candidates can be found on the disk.\n\nSource path: ${unqualifiedPathForDisplay}\n${candidates.map(candidate => `Rejected candidate: ${(0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(candidate)}\n`).join(``)}`, {
        unqualifiedPath: unqualifiedPathForDisplay
      });
    }
  }
  /**
   * Transforms a request into a fully qualified path.
   *
   * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be
   * treated as a folder (ie. "/tmp/foo/" rather than "/tmp/foo" if "foo" is a directory). Otherwise relative
   * imports won't be computed correctly (they'll get resolved relative to "/tmp/" instead of "/tmp/foo/").
   */


  function resolveRequest(request, issuer, {
    considerBuiltins,
    extensions
  } = {}) {
    const unqualifiedPath = resolveToUnqualified(request, issuer, {
      considerBuiltins
    });
    if (unqualifiedPath === null) return null;

    try {
      return resolveUnqualified(unqualifiedPath, {
        extensions
      });
    } catch (resolutionError) {
      if (resolutionError.pnpCode === `QUALIFIED_PATH_RESOLUTION_FAILED`) Object.assign(resolutionError.data, {
        request: (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(request),
        issuer: issuer && (0,_internalTools__WEBPACK_IMPORTED_MODULE_1__.getPathForDisplay)(issuer)
      });
      throw resolutionError;
    }
  }

  function resolveVirtual(request) {
    const normalized = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.normalize(request);
    const resolved = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }

  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return {
          name: referencish[0],
          reference: referencish[1]
        };
      } else {
        return {
          name,
          reference: referencish
        };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },
    getPackageInformation: locator => {
      const info = getPackageInformation(locator);
      if (info === null) return null;
      const packageLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(info.packageLocation);
      const nativeInfo = { ...info,
        packageLocation
      };
      return nativeInfo;
    },
    findPackageLocator: path => {
      return findPackageLocator(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts) => {
      const portableIssuer = issuer !== null ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(request), portableIssuer, opts);
      if (resolution === null) return null;
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts) => {
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(resolveUnqualified(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(unqualifiedPath), opts));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts) => {
      const portableIssuer = issuer !== null ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(request), portableIssuer, opts);
      if (resolution === null) return null;
      return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, path => {
      const result = resolveVirtual(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.toPortablePath(path));

      if (result !== null) {
        return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}

/***/ }),
/* 677 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorCode": () => /* binding */ ErrorCode,
/* harmony export */   "makeError": () => /* binding */ makeError,
/* harmony export */   "getPathForDisplay": () => /* binding */ getPathForDisplay
/* harmony export */ });
/* unused harmony export getIssuerModule */
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);

var ErrorCode;

(function (ErrorCode) {
  ErrorCode["API_ERROR"] = "API_ERROR";
  ErrorCode["BLACKLISTED"] = "BLACKLISTED";
  ErrorCode["BUILTIN_NODE_RESOLUTION_FAILED"] = "BUILTIN_NODE_RESOLUTION_FAILED";
  ErrorCode["MISSING_DEPENDENCY"] = "MISSING_DEPENDENCY";
  ErrorCode["MISSING_PEER_DEPENDENCY"] = "MISSING_PEER_DEPENDENCY";
  ErrorCode["QUALIFIED_PATH_RESOLUTION_FAILED"] = "QUALIFIED_PATH_RESOLUTION_FAILED";
  ErrorCode["INTERNAL"] = "INTERNAL";
  ErrorCode["UNDECLARED_DEPENDENCY"] = "UNDECLARED_DEPENDENCY";
  ErrorCode["UNSUPPORTED"] = "UNSUPPORTED";
})(ErrorCode || (ErrorCode = {})); // Some errors are exposed as MODULE_NOT_FOUND for compatibility with packages
// that expect this umbrella error when the resolution fails


const MODULE_NOT_FOUND_ERRORS = new Set([ErrorCode.BLACKLISTED, ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, ErrorCode.MISSING_DEPENDENCY, ErrorCode.MISSING_PEER_DEPENDENCY, ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, ErrorCode.UNDECLARED_DEPENDENCY]);
/**
 * Simple helper function that assign an error code to an error, so that it can more easily be caught and used
 * by third-parties.
 */

function makeError(pnpCode, message, data = {}) {
  const code = MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: { ...propertySpec,
      value: code
    },
    pnpCode: { ...propertySpec,
      value: pnpCode
    },
    data: { ...propertySpec,
      value: data
    }
  });
}
/**
 * Returns the module that should be used to resolve require calls. It's usually the direct parent, except if we're
 * inside an eval expression.
 */

function getIssuerModule(parent) {
  let issuer = parent;

  while (issuer && (issuer.id === `[eval]` || issuer.id === `<repl>` || !issuer.filename)) issuer = issuer.parent;

  return issuer || null;
}
function getPathForDisplay(p) {
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.normalize(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.fromPortablePath(p));
}

/***/ }),
/* 678 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeRuntimeApi": () => /* binding */ makeRuntimeApi
/* harmony export */ });
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _generateSerializedState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(672);
/* harmony import */ var _loader_hydrateRuntimeState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(675);
/* harmony import */ var _loader_makeApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(676);




const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = (0,_generateSerializedState__WEBPACK_IMPORTED_MODULE_0__.generateSerializedState)(settings);
  const state = (0,_loader_hydrateRuntimeState__WEBPACK_IMPORTED_MODULE_1__.hydrateRuntimeState)(data, {
    basePath
  });
  const pnpapiResolution = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.join(basePath, `.pnp.js`);
  return (0,_loader_makeApi__WEBPACK_IMPORTED_MODULE_2__.makeApi)(state, {
    fakeFs,
    pnpapiResolution
  });
};

/***/ }),
/* 679 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractPnpInstaller": () => /* binding */ AbstractPnpInstaller
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);



class AbstractPnpInstaller {
  constructor(opts) {
    this.opts = opts;
    this.packageRegistry = new Map();
    this.blacklistedPaths = new Set();
    this.opts = opts;
  }

  checkAndReportManifestIncompatibility(manifest, pkg) {
    if (manifest && !manifest.isCompatibleWithOS(process.platform)) {
      this.opts.report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.MessageName.INCOMPATIBLE_OS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(this.opts.project.configuration, pkg)} The platform ${process.platform} is incompatible with this module, ${this.opts.skipIncompatiblePackageLinking ? `linking` : `building`} skipped.`);
      return false;
    }

    if (manifest && !manifest.isCompatibleWithCPU(process.arch)) {
      this.opts.report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.MessageName.INCOMPATIBLE_CPU, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(this.opts.project.configuration, pkg)} The CPU architecture ${process.arch} is incompatible with this module, ${this.opts.skipIncompatiblePackageLinking ? `linking` : `building`} skipped.`);
      return false;
    }

    return true;
  }

  async installPackage(pkg, fetchResult) {
    const key1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.requirableIdent(pkg);
    const key2 = pkg.reference;
    const hasVirtualInstances = pkg.peerDependencies.size > 0 && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.isVirtualLocator(pkg) && !this.opts.project.tryWorkspaceByLocator(pkg);
    const manifest = !hasVirtualInstances || this.opts.skipIncompatiblePackageLinking ? await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.Manifest.tryFind(fetchResult.prefixPath, {
      baseFs: fetchResult.packageFs
    }) : null;
    const isManifestCompatible = this.checkAndReportManifestIncompatibility(manifest, pkg);
    if (this.opts.skipIncompatiblePackageLinking && !isManifestCompatible) return {
      packageLocation: null,
      buildDirective: null
    };
    const buildScripts = !hasVirtualInstances ? await this.getBuildScripts(pkg, manifest, fetchResult) : [];
    const dependencyMeta = this.opts.project.getDependencyMeta(pkg, pkg.version);

    if (buildScripts.length > 0 && !this.opts.project.configuration.get(`enableScripts`) && !dependencyMeta.built) {
      this.opts.report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.MessageName.DISABLED_BUILD_SCRIPTS, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(this.opts.project.configuration, pkg)} lists build scripts, but all build scripts have been disabled.`);
      buildScripts.length = 0;
    }

    if (buildScripts.length > 0 && pkg.linkType !== _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.LinkType.HARD && !this.opts.project.tryWorkspaceByLocator(pkg)) {
      this.opts.report.reportWarningOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.MessageName.SOFT_LINK_BUILD, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(this.opts.project.configuration, pkg)} lists build scripts, but is referenced through a soft link. Soft links don't support build scripts, so they'll be ignored.`);
      buildScripts.length = 0;
    }

    if (buildScripts.length > 0 && dependencyMeta && dependencyMeta.built === false) {
      this.opts.report.reportInfoOnce(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_0__.MessageName.BUILD_DISABLED, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(this.opts.project.configuration, pkg)} lists build scripts, but its build has been explicitly disabled through configuration.`);
      buildScripts.length = 0;
    }

    const packageFs = !hasVirtualInstances && pkg.linkType !== _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.LinkType.SOFT ? await this.transformPackage(pkg, manifest, fetchResult, dependencyMeta, {
      hasBuildScripts: buildScripts.length > 0
    }) : fetchResult.packageFs;
    if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.isAbsolute(fetchResult.prefixPath)) throw new Error(`Assertion failed: Expected the prefix path (${fetchResult.prefixPath}) to be relative to the parent`);
    const packageRawLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(packageFs.getRealPath(), fetchResult.prefixPath);
    const packageLocation = this.normalizeDirectoryPath(packageRawLocation);
    const packageDependencies = new Map();
    const packagePeers = new Set(); // Only virtual packages should have effective peer dependencies, but the
    // workspaces are a special case because the original packages are kept in
    // the dependency tree even after being virtualized; so in their case we
    // just ignore their declared peer dependencies.

    if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.isVirtualLocator(pkg)) {
      for (const descriptor of pkg.peerDependencies.values()) {
        packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.requirableIdent(descriptor), null);
        packagePeers.add(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.stringifyIdent(descriptor));
      }
    }

    _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.getMapWithDefault(this.packageRegistry, key1).set(key2, {
      packageLocation,
      packageDependencies,
      packagePeers,
      linkType: pkg.linkType,
      discardFromLookup: fetchResult.discardFromLookup || false
    });
    if (hasVirtualInstances) this.blacklistedPaths.add(packageLocation);
    return {
      packageLocation: packageRawLocation,
      buildDirective: buildScripts.length > 0 && isManifestCompatible ? buildScripts : null
    };
  }

  async attachInternalDependencies(locator, dependencies) {
    const packageInformation = this.getPackageInformation(locator);

    for (const [descriptor, locator] of dependencies) {
      const target = !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.areIdentsEqual(descriptor, locator) ? [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.requirableIdent(locator), locator.reference] : locator.reference;
      packageInformation.packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.requirableIdent(descriptor), target);
    }
  }

  async attachExternalDependents(locator, dependentPaths) {
    for (const dependentPath of dependentPaths) {
      const packageInformation = this.getDiskInformation(dependentPath);
      packageInformation.packageDependencies.set(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.requirableIdent(locator), locator.reference);
    }
  }

  async finalizeInstall() {
    this.trimBlacklistedPackages();
    this.packageRegistry.set(null, new Map([[null, this.getPackageInformation(this.opts.project.topLevelWorkspace.anchoredLocator)]]));
    const pnpFallbackMode = this.opts.project.configuration.get(`pnpFallbackMode`);
    const blacklistedLocations = this.blacklistedPaths;
    const dependencyTreeRoots = this.opts.project.workspaces.map(({
      anchoredLocator
    }) => ({
      name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.requirableIdent(anchoredLocator),
      reference: anchoredLocator.reference
    }));
    const enableTopLevelFallback = pnpFallbackMode !== `none`;
    const fallbackExclusionList = [];
    const fallbackPool = new Map();
    const ignorePattern = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.buildIgnorePattern([`.yarn/sdks/**`, ...this.opts.project.configuration.get(`pnpIgnorePatterns`)]);
    const packageRegistry = this.packageRegistry;
    const shebang = this.opts.project.configuration.get(`pnpShebang`);
    if (pnpFallbackMode === `dependencies-only`) for (const pkg of this.opts.project.storedPackages.values()) if (this.opts.project.tryWorkspaceByLocator(pkg)) fallbackExclusionList.push({
      name: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.requirableIdent(pkg),
      reference: pkg.reference
    });
    return await this.finalizeInstallWithPnp({
      blacklistedLocations,
      dependencyTreeRoots,
      enableTopLevelFallback,
      fallbackExclusionList,
      fallbackPool,
      ignorePattern,
      packageRegistry,
      shebang
    });
  }

  getPackageInformation(locator) {
    const key1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.requirableIdent(locator);
    const key2 = locator.reference;
    const packageInformationStore = this.packageRegistry.get(key1);
    if (!packageInformationStore) throw new Error(`Assertion failed: The package information store should have been available (for ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyIdent(this.opts.project.configuration, locator)})`);
    const packageInformation = packageInformationStore.get(key2);
    if (!packageInformation) throw new Error(`Assertion failed: The package information should have been available (for ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.prettyLocator(this.opts.project.configuration, locator)})`);
    return packageInformation;
  }

  getDiskInformation(path) {
    const packageStore = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.getMapWithDefault(this.packageRegistry, `@@disk`);
    const normalizedPath = this.normalizeDirectoryPath(path);
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.getFactoryWithDefault(packageStore, normalizedPath, () => ({
      packageLocation: normalizedPath,
      packageDependencies: new Map(),
      packagePeers: new Set(),
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.LinkType.SOFT,
      discardFromLookup: false
    }));
  }

  trimBlacklistedPackages() {
    for (const packageStore of this.packageRegistry.values()) {
      for (const [key2, packageInformation] of packageStore) {
        if (packageInformation.packageLocation && this.blacklistedPaths.has(packageInformation.packageLocation)) {
          packageStore.delete(key2);
        }
      }
    }
  }

  normalizeDirectoryPath(folder) {
    let relativeFolder = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.relative(this.opts.project.cwd, folder);
    if (!relativeFolder.match(/^\.{0,2}\//)) // Don't use ppath.join here, it ignores the `.`
      relativeFolder = `./${relativeFolder}`;
    return relativeFolder.replace(/\/?$/, `/`);
  }

}

/***/ }),
/* 680 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getUnpluggedPath": () => /* binding */ getUnpluggedPath
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);


function getUnpluggedPath(locator, {
  configuration
}) {
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.resolve(configuration.get(`pnpUnpluggedFolder`), _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.slugifyLocator(locator));
}

/***/ }),
/* 681 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ UnplugCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(217);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(122);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _pnpUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(680);







 // eslint-disable-next-line arca/no-default-export

class UnplugCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.patterns = [];
    this.all = false;
    this.recursive = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    if (configuration.get(`nodeLinker`) !== `pnp`) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`This command can only be used if the \`nodeLinker\` option is set to \`pnp\``);
    await project.restoreInstallState();
    const unreferencedPatterns = new Set(this.patterns);
    const matchers = this.patterns.map(pattern => {
      const patternDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.parseDescriptor(pattern);
      const pseudoDescriptor = patternDescriptor.range !== `unknown` ? patternDescriptor : _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.makeDescriptor(patternDescriptor, `*`);
      if (!semver__WEBPACK_IMPORTED_MODULE_3___default().validRange(pseudoDescriptor.range)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The range of the descriptor patterns must be a valid semver range (${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.prettyDescriptor(configuration, pseudoDescriptor)})`);
      return pkg => {
        const stringifiedIdent = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.stringifyIdent(pkg);
        if (!micromatch__WEBPACK_IMPORTED_MODULE_2___default().isMatch(stringifiedIdent, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.stringifyIdent(pseudoDescriptor))) return false;
        if (pkg.version && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.semverUtils.satisfiesWithPrereleases(pkg.version, pseudoDescriptor.range)) return false;
        unreferencedPatterns.delete(pattern);
        return true;
      };
    });

    const getAllMatchingPackages = () => {
      const selection = [];

      for (const pkg of project.storedPackages.values()) if (!project.tryWorkspaceByLocator(pkg) && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.isVirtualLocator(pkg) && matchers.some(matcher => matcher(pkg))) selection.push(pkg);

      return selection;
    };

    const getSelectedPackages = roots => {
      const seen = new Set();
      const selection = [];

      const traverse = (pkg, depth) => {
        if (seen.has(pkg.locatorHash)) return;
        seen.add(pkg.locatorHash);
        if (!project.tryWorkspaceByLocator(pkg) && !_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.isVirtualLocator(pkg) && matchers.some(matcher => matcher(pkg))) selection.push(pkg); // Don't recurse unless requested

        if (depth > 0 && !this.recursive) return;

        for (const dependency of pkg.dependencies.values()) {
          const resolution = project.storedResolutions.get(dependency.descriptorHash);
          if (!resolution) throw new Error(`Assertion failed: The resolution should have been registered`);
          const nextPkg = project.storedPackages.get(resolution);
          if (!nextPkg) throw new Error(`Assertion failed: The package should have been registered`);
          traverse(nextPkg, depth + 1);
        }
      };

      for (const workspace of roots) {
        const pkg = project.storedPackages.get(workspace.anchoredLocator.locatorHash);
        if (!pkg) throw new Error(`Assertion failed: The package should have been registered`);
        traverse(pkg, 0);
      }

      return selection;
    };

    let selection; // We can shortcut the execution if we want all the dependencies and
    // transitive dependencies of all the branches: it means we want everything!

    if (this.all && this.recursive) selection = getAllMatchingPackages();else if (this.all) selection = getSelectedPackages(project.workspaces);else selection = getSelectedPackages([workspace]);
    const projectOrWorkspaces = this.recursive ? `the project` : `any workspace`;
    if (unreferencedPatterns.size > 1) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Patterns ${[...unreferencedPatterns].join(`, `)} don't match any packages referenced by ${projectOrWorkspaces}`);
    if (unreferencedPatterns.size > 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Pattern ${[...unreferencedPatterns][0]} doesn't match any packages referenced by ${projectOrWorkspaces}`);
    selection = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.miscUtils.sortMap(selection, pkg => {
      return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.stringifyLocator(pkg);
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.StreamReport.start({
      configuration,
      stdout: this.context.stdout,
      json: this.json
    }, async report => {
      var _a;

      for (const pkg of selection) {
        const version = (_a = pkg.version) !== null && _a !== void 0 ? _a : `unknown`;
        const dependencyMeta = project.topLevelWorkspace.manifest.ensureDependencyMeta(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.makeDescriptor(pkg, version));
        dependencyMeta.unplugged = true;
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.UNNAMED, `Will unpack ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.prettyLocator(configuration, pkg)} to ${configuration.format(_pnpUtils__WEBPACK_IMPORTED_MODULE_4__.getUnpluggedPath(pkg, {
          configuration
        }), _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.FormatType.PATH)}`);
        report.reportJson({
          locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.stringifyLocator(pkg),
          version
        });
      }

      await project.topLevelWorkspace.persistManifest();
      report.reportSeparator();
      await project.install({
        cache,
        report
      });
    });
    return report.exitCode();
  }

}
UnplugCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `force the unpacking of a list of packages`,
  details: `
      This command will add the selectors matching the specified patterns to the list of packages that must be unplugged when installed.

      A package being unplugged means that instead of being referenced directly through its archive, it will be unpacked at install time in the directory configured via \`pnpUnpluggedFolder\`. Note that unpacking packages this way is generally not recommended because it'll make it harder to store your packages within the repository. However, it's a good approach to quickly and safely debug some packages, and can even sometimes be required depending on the context (for example when the package contains shellscripts).

      Running the command will set a persistent flag inside your top-level \`package.json\`, in the \`dependenciesMeta\` field. As such, to undo its effects, you'll need to revert the changes made to the manifest and run \`yarn install\` to apply the modification.

      By default, only direct dependencies from the current workspace are affected. If \`-A,--all\` is set, direct dependencies from the entire project are affected. Using the \`-R,--recursive\` flag will affect transitive dependencies as well as direct ones.

      This command accepts glob patterns inside the scope and name components (not the range). Make sure to escape the patterns to prevent your own shell from trying to expand them.
    `,
  examples: [[`Unplug the lodash dependency from the active workspace`, `yarn unplug lodash`], [`Unplug all instances of lodash referenced by any workspace`, `yarn unplug lodash -A`], [`Unplug all instances of lodash referenced by the active workspace and its dependencies`, `yarn unplug lodash -R`], [`Unplug all instances of lodash, anywhere`, `yarn unplug lodash -AR`], [`Unplug one specific version of lodash`, `yarn unplug lodash@1.2.3`], [`Unplug all packages with the \`@babel\` scope`, `yarn unplug '@babel/*'`], [`Unplug all packages (only for testing, not recommended)`, `yarn unplug -R '*'`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Rest()], UnplugCommand.prototype, "patterns", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-A,--all`)], UnplugCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-R,--recursive`)], UnplugCommand.prototype, "recursive", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], UnplugCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`unplug`)], UnplugCommand.prototype, "execute", null);

/***/ }),
/* 682 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

cmdShim.ifExists = cmdShimIfExists;
const util_1 = __webpack_require__(115);
const makeDir = __webpack_require__(683);
const path = __webpack_require__(113);
const isWindows = __webpack_require__(685);
const shebangExpr = /^#!\s*(?:\/usr\/bin\/env)?\s*([^ \t]+)(.*)$/;
const DEFAULT_OPTIONS = {
    // Create PowerShell file by default if the option hasn't been specified
    createPwshFile: true,
    createCmdFile: isWindows(),
    fs: __webpack_require__(6)
};
/**
 * Map from extensions of files that this module is frequently used for to their runtime.
 * @type {Map<string, string>}
 */
const extensionToProgramMap = new Map([
    ['.js', 'node'],
    ['.cmd', 'cmd'],
    ['.bat', 'cmd'],
    ['.ps1', 'pwsh'],
    ['.sh', 'sh']
]);
function ingestOptions(opts) {
    const opts_ = { ...DEFAULT_OPTIONS, ...opts };
    const fs = opts_.fs;
    opts_.fs_ = {
        chmod: fs.chmod ? util_1.promisify(fs.chmod) : (async () => { }),
        stat: util_1.promisify(fs.stat),
        unlink: util_1.promisify(fs.unlink),
        readFile: util_1.promisify(fs.readFile),
        writeFile: util_1.promisify(fs.writeFile)
    };
    return opts_;
}
/**
 * Try to create shims.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 * @throws If `src` is missing.
 */
async function cmdShim(src, to, opts) {
    const opts_ = ingestOptions(opts);
    await opts_.fs_.stat(src);
    await cmdShim_(src, to, opts_);
}
/**
 * Try to create shims.
 *
 * Does nothing if `src` doesn't exist.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 */
function cmdShimIfExists(src, to, opts) {
    return cmdShim(src, to, opts).catch(() => { });
}
/**
 * Try to unlink, but ignore errors.
 * Any problems will surface later.
 *
 * @param path File to be removed.
 */
function rm(path, opts) {
    return opts.fs_.unlink(path).catch(() => { });
}
/**
 * Try to create shims **even if `src` is missing**.
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims.
 * Don't add an extension if you will create multiple types of shims.
 * @param opts Options.
 */
async function cmdShim_(src, to, opts) {
    const srcRuntimeInfo = await searchScriptRuntime(src, opts);
    // Always tries to create all types of shims by calling `writeAllShims` as of now.
    // Append your code here to change the behavior in response to `srcRuntimeInfo`.
    // Create 3 shims for (Ba)sh in Cygwin / MSYS, no extension) & CMD (.cmd) & PowerShell (.ps1)
    await writeShimsPreCommon(to, opts);
    return writeAllShims(src, to, srcRuntimeInfo, opts);
}
/**
 * Do processes before **all** shims are created.
 * This must be called **only once** for one call of `cmdShim(IfExists)`.
 *
 * @param target Path of shims that are going to be created.
 */
function writeShimsPreCommon(target, opts) {
    return makeDir(path.dirname(target), { fs: opts.fs });
}
/**
 * Write all types (sh & cmd & pwsh) of shims to files.
 * Extensions (`.cmd` and `.ps1`) are appended to cmd and pwsh shims.
 *
 *
 * @param src Path to program (executable or script).
 * @param to Path to shims **without extensions**.
 * Extensions are added for CMD and PowerShell shims.
 * @param srcRuntimeInfo Return value of `await searchScriptRuntime(src)`.
 * @param opts Options.
 */
function writeAllShims(src, to, srcRuntimeInfo, opts) {
    const opts_ = ingestOptions(opts);
    const generatorAndExts = [{ generator: generateShShim, extension: '' }];
    if (opts_.createCmdFile) {
        generatorAndExts.push({ generator: generateCmdShim, extension: '.cmd' });
    }
    if (opts_.createPwshFile) {
        generatorAndExts.push({ generator: generatePwshShim, extension: '.ps1' });
    }
    return Promise.all(generatorAndExts.map((generatorAndExt) => writeShim(src, to + generatorAndExt.extension, srcRuntimeInfo, generatorAndExt.generator, opts_)));
}
/**
 * Do processes before writing shim.
 *
 * @param target Path to shim that is going to be created.
 */
function writeShimPre(target, opts) {
    return rm(target, opts);
}
/**
 * Do processes after writing the shim.
 *
 * @param target Path to just created shim.
 */
function writeShimPost(target, opts) {
    // Only chmoding shims as of now.
    // Some other processes may be appended.
    return chmodShim(target, opts);
}
/**
 * Look into runtime (e.g. `node` & `sh` & `pwsh`) and its arguments
 * of the target program (script or executable).
 *
 * @param target Path to the executable or script.
 * @return Promise of infomation of runtime of `target`.
 */
async function searchScriptRuntime(target, opts) {
    const data = await opts.fs_.readFile(target, 'utf8');
    // First, check if the bin is a #! of some sort.
    const firstLine = data.trim().split(/\r*\n/)[0];
    const shebang = firstLine.match(shebangExpr);
    if (!shebang) {
        // If not, infer script type from its extension.
        // If the inference fails, it's something that'll be compiled, or some other
        // sort of script, and just call it directly.
        const targetExtension = path.extname(target).toLowerCase();
        return {
            // undefined if extension is unknown but it's converted to null.
            program: extensionToProgramMap.get(targetExtension) || null,
            additionalArgs: ''
        };
    }
    return {
        program: shebang[1],
        additionalArgs: shebang[2]
    };
}
/**
 * Write shim to the file system while executing the pre- and post-processes
 * defined in `WriteShimPre` and `WriteShimPost`.
 *
 * @param src Path to the executable or script.
 * @param to Path to the (sh) shim(s) that is going to be created.
 * @param srcRuntimeInfo Result of `await searchScriptRuntime(src)`.
 * @param generateShimScript Generator of shim script.
 * @param opts Other options.
 */
async function writeShim(src, to, srcRuntimeInfo, generateShimScript, opts) {
    const defaultArgs = opts.preserveSymlinks ? '--preserve-symlinks' : '';
    // `Array.prototype.filter` removes ''.
    // ['--foo', '--bar'].join(' ') and [].join(' ') returns '--foo --bar' and '' respectively.
    const args = [srcRuntimeInfo.additionalArgs, defaultArgs].filter(arg => arg).join(' ');
    opts = Object.assign({}, opts, {
        prog: srcRuntimeInfo.program,
        args: args
    });
    await writeShimPre(to, opts);
    await opts.fs_.writeFile(to, generateShimScript(src, to, opts), 'utf8');
    return writeShimPost(to, opts);
}
/**
 * Generate the content of a shim for CMD.
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.cmd` (or `.bat`).
 * @param opts Options.
 * @return The content of shim.
 */
function generateCmdShim(src, to, opts) {
    // `shTarget` is not used to generate the content.
    const shTarget = path.relative(path.dirname(to), src);
    let target = shTarget.split('/').join('\\');
    const quotedPathToTarget = path.isAbsolute(target) ? `"${target}"` : `"%~dp0\\${target}"`;
    let longProg;
    let prog = opts.prog;
    let args = opts.args || '';
    const nodePath = normalizePathEnvVar(opts.nodePath).win32;
    if (!prog) {
        prog = quotedPathToTarget;
        args = '';
        target = '';
    }
    else {
        longProg = `"%~dp0\\${prog}.exe"`;
        target = quotedPathToTarget;
    }
    let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : '';
    // @IF EXIST "%~dp0\node.exe" (
    //   "%~dp0\node.exe" "%~dp0\.\node_modules\npm\bin\npm-cli.js" %*
    // ) ELSE (
    //   SETLOCAL
    //   SET PATHEXT=%PATHEXT:;.JS;=;%
    //   node "%~dp0\.\node_modules\npm\bin\npm-cli.js" %*
    // )
    let cmd = nodePath ? `@SET NODE_PATH=${nodePath}\r\n` : '';
    if (longProg) {
        cmd += `@IF EXIST ${longProg} (\r\n` +
            `  ${longProg} ${args} ${target} ${progArgs}%*\r\n` +
            ') ELSE (\r\n' +
            '  @SETLOCAL\r\n' +
            '  @SET PATHEXT=%PATHEXT:;.JS;=;%\r\n' +
            `  ${prog} ${args} ${target} ${progArgs}%*\r\n` +
            ')';
    }
    else {
        cmd += `@${prog} ${args} ${target} ${progArgs}%*\r\n`;
    }
    return cmd;
}
/**
 * Generate the content of a shim for (Ba)sh in, for example, Cygwin and MSYS(2).
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.sh` or to contain no extension.
 * @param opts Options.
 * @return The content of shim.
 */
function generateShShim(src, to, opts) {
    let shTarget = path.relative(path.dirname(to), src);
    let shProg = opts.prog && opts.prog.split('\\').join('/');
    let shLongProg;
    shTarget = shTarget.split('\\').join('/');
    const quotedPathToTarget = path.isAbsolute(shTarget) ? `"${shTarget}"` : `"$basedir/${shTarget}"`;
    let args = opts.args || '';
    const shNodePath = normalizePathEnvVar(opts.nodePath).posix;
    if (!shProg) {
        shProg = quotedPathToTarget;
        args = '';
        shTarget = '';
    }
    else {
        shLongProg = `"$basedir/${opts.prog}"`;
        shTarget = quotedPathToTarget;
    }
    let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : '';
    // #!/bin/sh
    // basedir=`dirname "$0"`
    //
    // case `uname` in
    //     *CYGWIN*) basedir=`cygpath -w "$basedir"`;;
    // esac
    //
    // export NODE_PATH="<nodepath>"
    //
    // if [ -x "$basedir/node.exe" ]; then
    //   exec "$basedir/node.exe" "$basedir/node_modules/npm/bin/npm-cli.js" "$@"
    // else
    //   exec node "$basedir/node_modules/npm/bin/npm-cli.js" "$@"
    // fi
    let sh = '#!/bin/sh\n';
    sh = sh +
        "basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\")\n" +
        '\n' +
        'case `uname` in\n' +
        '    *CYGWIN*) basedir=`cygpath -w "$basedir"`;;\n' +
        'esac\n' +
        '\n';
    const env = opts.nodePath ? `export NODE_PATH="${shNodePath}"\n` : '';
    if (shLongProg) {
        sh += env +
            `if [ -x ${shLongProg} ]; then\n` +
            `  exec ${shLongProg} ${args} ${shTarget} ${progArgs}"$@"\n` +
            'else \n' +
            `  exec ${shProg} ${args} ${shTarget} ${progArgs}"$@"\n` +
            'fi\n';
    }
    else {
        sh += `${env}${shProg} ${args} ${shTarget} ${progArgs}"$@"\n` +
            'exit $?\n';
    }
    return sh;
}
/**
 * Generate the content of a shim for PowerShell.
 *
 * @param src Path to the executable or script.
 * @param to Path to the shim to be created.
 * It is highly recommended to end with `.ps1`.
 * @param opts Options.
 * @return The content of shim.
 */
function generatePwshShim(src, to, opts) {
    let shTarget = path.relative(path.dirname(to), src);
    const shProg = opts.prog && opts.prog.split('\\').join('/');
    let pwshProg = shProg && `"${shProg}$exe"`;
    let pwshLongProg;
    shTarget = shTarget.split('\\').join('/');
    const quotedPathToTarget = path.isAbsolute(shTarget) ? `"${shTarget}"` : `"$basedir/${shTarget}"`;
    let args = opts.args || '';
    let normalizedPathEnvVar = normalizePathEnvVar(opts.nodePath);
    const nodePath = normalizedPathEnvVar.win32;
    const shNodePath = normalizedPathEnvVar.posix;
    if (!pwshProg) {
        pwshProg = quotedPathToTarget;
        args = '';
        shTarget = '';
    }
    else {
        pwshLongProg = `"$basedir/${opts.prog}$exe"`;
        shTarget = quotedPathToTarget;
    }
    let progArgs = opts.progArgs ? `${opts.progArgs.join(` `)} ` : '';
    // #!/usr/bin/env pwsh
    // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent
    //
    // $ret=0
    // $exe = ""
    // if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {
    //   # Fix case when both the Windows and Linux builds of Node
    //   # are installed in the same directory
    //   $exe = ".exe"
    // }
    // if (Test-Path "$basedir/node") {
    //   # Support pipeline input
    //   if ($MyInvocation.ExpectingInput) {
    //     $input | & "$basedir/node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
    //   } else {
    //     & "$basedir/node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
    //   }
    //   $ret=$LASTEXITCODE
    // } else {
    //   # Support pipeline input
    //   if ($MyInvocation.ExpectingInput) {
    //     $input | & "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
    //   } else {
    //     & "node$exe" "$basedir/node_modules/npm/bin/npm-cli.js" $args
    //   }
    //   $ret=$LASTEXITCODE
    // }
    // exit $ret
    let pwsh = '#!/usr/bin/env pwsh\n' +
        '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n' +
        '\n' +
        '$exe=""\n' +
        (opts.nodePath ? '$env_node_path=$env:NODE_PATH\n' +
            `$env:NODE_PATH="${nodePath}"\n` : '') +
        'if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {\n' +
        '  # Fix case when both the Windows and Linux builds of Node\n' +
        '  # are installed in the same directory\n' +
        '  $exe=".exe"\n' +
        '}';
    if (opts.nodePath) {
        pwsh = pwsh +
            ' else {\n' +
            `  $env:NODE_PATH="${shNodePath}"\n` +
            '}';
    }
    pwsh += '\n';
    if (pwshLongProg) {
        pwsh = pwsh +
            '$ret=0\n' +
            `if (Test-Path ${pwshLongProg}) {\n` +
            '  # Support pipeline input\n' +
            '  if ($MyInvocation.ExpectingInput) {\n' +
            `    $input | & ${pwshLongProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '  } else {\n' +
            `    & ${pwshLongProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '  }\n' +
            '  $ret=$LASTEXITCODE\n' +
            '} else {\n' +
            '  # Support pipeline input\n' +
            '  if ($MyInvocation.ExpectingInput) {\n' +
            `    $input | & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '  } else {\n' +
            `    & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '  }\n' +
            '  $ret=$LASTEXITCODE\n' +
            '}\n' +
            (opts.nodePath ? '$env:NODE_PATH=$env_node_path\n' : '') +
            'exit $ret\n';
    }
    else {
        pwsh = pwsh +
            '# Support pipeline input\n' +
            'if ($MyInvocation.ExpectingInput) {\n' +
            `  $input | & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '} else {\n' +
            `  & ${pwshProg} ${args} ${shTarget} ${progArgs}$args\n` +
            '}\n' +
            (opts.nodePath ? '$env:NODE_PATH=$env_node_path\n' : '') +
            'exit $LASTEXITCODE\n';
    }
    return pwsh;
}
/**
 * Chmod just created shim and make it executable
 *
 * @param to Path to shim.
 */
function chmodShim(to, opts) {
    return opts.fs_.chmod(to, 0o755);
}
function normalizePathEnvVar(nodePath) {
    if (!nodePath) {
        return {
            win32: '',
            posix: ''
        };
    }
    let split = (typeof nodePath === 'string' ? nodePath.split(path.delimiter) : Array.from(nodePath));
    let result = {};
    for (let i = 0; i < split.length; i++) {
        const win32 = split[i].split('/').join('\\');
        const posix = isWindows() ? split[i].split('\\').join('/').replace(/^([^:\\/]*):/, (_, $1) => `/mnt/${$1.toLowerCase()}`) : split[i];
        result.win32 = result.win32 ? `${result.win32};${win32}` : win32;
        result.posix = result.posix ? `${result.posix}:${posix}` : posix;
        result[i] = { win32, posix };
    }
    return result;
}
module.exports = cmdShim;
//# sourceMappingURL=index.js.map

/***/ }),
/* 683 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(6);
const path = __webpack_require__(113);
const {promisify} = __webpack_require__(115);
const semver = __webpack_require__(684);

const useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0');

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const checkPath = pth => {
	if (process.platform === 'win32') {
		const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''));

		if (pathHasInvalidWinCharacters) {
			const error = new Error(`Path contains invalid characters: ${pth}`);
			error.code = 'EINVAL';
			throw error;
		}
	}
};

const processOptions = options => {
	// https://github.com/sindresorhus/make-dir/issues/18
	const defaults = {
		mode: 0o777,
		fs
	};

	return {
		...defaults,
		...options
	};
};

const permissionError = pth => {
	// This replicates the exception of `fs.mkdir` with native the
	// `recusive` option when run on an invalid drive under Windows.
	const error = new Error(`operation not permitted, mkdir '${pth}'`);
	error.code = 'EPERM';
	error.errno = -4048;
	error.path = pth;
	error.syscall = 'mkdir';
	return error;
};

const makeDir = async (input, options) => {
	checkPath(input);
	options = processOptions(options);

	const mkdir = promisify(options.fs.mkdir);
	const stat = promisify(options.fs.stat);

	if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
		const pth = path.resolve(input);

		await mkdir(pth, {
			mode: options.mode,
			recursive: true
		});

		return pth;
	}

	const make = async pth => {
		try {
			await mkdir(pth, options.mode);

			return pth;
		} catch (error) {
			if (error.code === 'EPERM') {
				throw error;
			}

			if (error.code === 'ENOENT') {
				if (path.dirname(pth) === pth) {
					throw permissionError(pth);
				}

				if (error.message.includes('null bytes')) {
					throw error;
				}

				await make(path.dirname(pth));

				return make(pth);
			}

			try {
				const stats = await stat(pth);
				if (!stats.isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch (_) {
				throw error;
			}

			return pth;
		}
	};

	return make(path.resolve(input));
};

module.exports = makeDir;

module.exports.sync = (input, options) => {
	checkPath(input);
	options = processOptions(options);

	if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
		const pth = path.resolve(input);

		fs.mkdirSync(pth, {
			mode: options.mode,
			recursive: true
		});

		return pth;
	}

	const make = pth => {
		try {
			options.fs.mkdirSync(pth, options.mode);
		} catch (error) {
			if (error.code === 'EPERM') {
				throw error;
			}

			if (error.code === 'ENOENT') {
				if (path.dirname(pth) === pth) {
					throw permissionError(pth);
				}

				if (error.message.includes('null bytes')) {
					throw error;
				}

				make(path.dirname(pth));
				return make(pth);
			}

			try {
				if (!options.fs.statSync(pth).isDirectory()) {
					throw new Error('The path is not a directory');
				}
			} catch (_) {
				throw error;
			}
		}

		return pth;
	};

	return make(path.resolve(input));
};


/***/ }),
/* 684 */
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var t = exports.tokens = {}
var R = 0

function tok (n) {
  t[n] = R++
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

tok('NUMERICIDENTIFIER')
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
tok('NUMERICIDENTIFIERLOOSE')
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER')
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION')
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')'

tok('MAINVERSIONLOOSE')
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER')
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +
                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'

tok('PRERELEASEIDENTIFIERLOOSE')
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE')
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'

tok('PRERELEASELOOSE')
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER')
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD')
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] +
             '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL')
tok('FULLPLAIN')
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +
                  src[t.PRERELEASE] + '?' +
                  src[t.BUILD] + '?'

src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
tok('LOOSEPLAIN')
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] +
                  src[t.PRERELEASELOOSE] + '?' +
                  src[t.BUILD] + '?'

tok('LOOSE')
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'

tok('GTLT')
src[t.GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
tok('XRANGEIDENTIFIERLOOSE')
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
tok('XRANGEIDENTIFIER')
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*'

tok('XRANGEPLAIN')
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[t.PRERELEASE] + ')?' +
                   src[t.BUILD] + '?' +
                   ')?)?'

tok('XRANGEPLAINLOOSE')
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +
                        src[t.BUILD] + '?' +
                        ')?)?'

tok('XRANGE')
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$'
tok('XRANGELOOSE')
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
tok('COERCE')
src[t.COERCE] = '(^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'
tok('COERCERTL')
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')

// Tilde ranges.
// Meaning is "reasonably at or greater than"
tok('LONETILDE')
src[t.LONETILDE] = '(?:~>?)'

tok('TILDETRIM')
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+'
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

tok('TILDE')
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'
tok('TILDELOOSE')
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
tok('LONECARET')
src[t.LONECARET] = '(?:\\^)'

tok('CARETTRIM')
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+'
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')
var caretTrimReplace = '$1^'

tok('CARET')
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'
tok('CARETLOOSE')
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
tok('COMPARATORLOOSE')
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'
tok('COMPARATOR')
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
tok('COMPARATORTRIM')
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] +
                      '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
tok('HYPHENRANGE')
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s*$'

tok('HYPHENRANGELOOSE')
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
tok('STAR')
src[t.STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  var i = 0
  do {
    var a = this.build[i]
    var b = other.build[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.compareBuild = compareBuild
function compareBuild (a, b, loose) {
  var versionA = new SemVer(a, loose)
  var versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1] !== undefined ? m[1] : ''
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY || version === ANY) {
    return true
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    if (this.value === '') {
      return true
    }
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true
    }
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[t.COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[t.CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return (
      isSatisfiable(thisComparators, options) &&
      range.set.some(function (rangeComparators) {
        return (
          isSatisfiable(rangeComparators, options) &&
          thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        )
      })
    )
  })
}

// take a set of comparators and determine whether there
// exists a version which can satisfy it
function isSatisfiable (comparators, options) {
  var result = true
  var remainingComparators = comparators.slice()
  var testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr +
        ' <' + M + '.' + (+m + 1) + '.0' + pr
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version, options) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  var match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next
    while ((next = re[t.COERCERTL].exec(version)) &&
      (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
          next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(match[2] +
    '.' + (match[3] || '0') +
    '.' + (match[4] || '0'), options)
}


/***/ }),
/* 685 */
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * is-windows <https://github.com/jonschlinkert/is-windows>
 *
 * Copyright  2015-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

(function(factory) {
  if (exports && typeof exports === 'object' && "object" !== 'undefined') {
    module.exports = factory();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function() {
  'use strict';
  return function isWindows() {
    return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));
  };
});


/***/ }),
/* 686 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildNodeModulesTree": () => /* binding */ buildNodeModulesTree,
/* harmony export */   "buildLocatorMap": () => /* binding */ buildLocatorMap
/* harmony export */ });
/* unused harmony exports LinkType, getArchivePath */
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);
/* harmony import */ var _hoist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(687);


 // Babel doesn't support const enums, thats why we use non-const enum for LinkType in @yarnpkg/pnp
// But because of this TypeScript requires @yarnpkg/pnp during runtime
// To prevent this we redeclare LinkType enum here, to not depend on @yarnpkg/pnp during runtime

var LinkType;

(function (LinkType) {
  LinkType["HARD"] = "HARD";
  LinkType["SOFT"] = "SOFT";
})(LinkType || (LinkType = {}));
/** node_modules path segment */


const NODE_MODULES = `node_modules`;
/**
 * Returns path to archive, if package location is inside the archive.
 *
 * @param packagePath package location
 *
 * @returns path to archive is location is insde the archive or null otherwise
 */

const getArchivePath = packagePath => packagePath.indexOf(`.zip/${NODE_MODULES}/`) >= 0 ? npath.toPortablePath(packagePath.split(`/${NODE_MODULES}/`)[0]) : null;
/**
 * Retrieve full package list and build hoisted `node_modules` directories
 * representation in-memory.
 *
 * @param pnp PnP API
 *
 * @returns hoisted `node_modules` directories representation in-memory
 */

const buildNodeModulesTree = (pnp, options) => {
  const packageTree = buildPackageTree(pnp, options);
  const hoistedTree = (0,_hoist__WEBPACK_IMPORTED_MODULE_0__.hoist)(packageTree);
  return populateNodeModulesTree(pnp, hoistedTree, options);
};

const stringifyLocator = locator => `${locator.name}@${locator.reference}`;

const buildLocatorMap = nodeModulesTree => {
  const map = new Map();

  for (const [location, val] of nodeModulesTree.entries()) {
    if (!val.dirList) {
      let entry = map.get(val.locator);

      if (!entry) {
        entry = {
          target: val.target,
          linkType: val.linkType,
          locations: [],
          aliases: val.aliases
        };
        map.set(val.locator, entry);
      }

      entry.locations.push(location);
    }
  }

  for (const val of map.values()) {
    // Sort locations by depth first and then alphabetically for determinism
    val.locations = val.locations.sort((loc1, loc2) => {
      const len1 = loc1.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.delimiter).length;
      const len2 = loc2.split(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.delimiter).length;
      return len1 !== len2 ? len2 - len1 : loc2.localeCompare(loc1);
    });
  }

  return map;
};

function isPortalLocator(locatorKey) {
  let descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseDescriptor(locatorKey);
  if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.isVirtualDescriptor(descriptor)) descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.devirtualizeDescriptor(descriptor);
  return descriptor.range.startsWith(`portal:`);
}
/**
 * Traverses PnP tree and produces input for the `RawHoister`
 *
 * @param pnp PnP API
 *
 * @returns package tree, packages info and locators
 */


const buildPackageTree = (pnp, options) => {
  const pnpRoots = pnp.getDependencyTreeRoots();
  const topPkg = pnp.getPackageInformation(pnp.topLevel);
  if (topPkg === null) throw new Error(`Assertion failed: Expected the top-level package to have been registered`);
  const topLocator = pnp.findPackageLocator(topPkg.packageLocation);
  if (topLocator === null) throw new Error(`Assertion failed: Expected the top-level package to have a physical locator`);

  for (const locator of pnpRoots) {
    if (locator.name !== topLocator.name || locator.reference !== topLocator.reference) {
      topPkg.packageDependencies.set(`${locator.name}$wsroot$`, locator.reference);
    }
  }

  const packageTree = {
    name: topLocator.name,
    identName: topLocator.name,
    reference: topLocator.reference,
    peerNames: topPkg.packagePeers,
    dependencies: new Set()
  };
  const nodes = new Map();

  const getNodeKey = (name, locator) => `${stringifyLocator(locator)}:${name}`;

  const addPackageToTree = (name, pkg, locator, parent, parentPkg) => {
    const nodeKey = getNodeKey(name, locator);
    let node = nodes.get(nodeKey);
    const isSeen = !!node;

    if (!isSeen && locator.name === topLocator.name && locator.reference === topLocator.reference) {
      node = packageTree;
      nodes.set(nodeKey, packageTree);
    }

    if (!node) {
      node = {
        name,
        identName: locator.name,
        reference: locator.reference,
        dependencies: new Set(),
        peerNames: pkg.packagePeers
      };
      nodes.set(nodeKey, node);
    }

    parent.dependencies.add(node); // If we link dependencies to file system we must not try to install children dependencies inside portal folders

    const shouldAddChildrenDependencies = options.pnpifyFs || !isPortalLocator(nodeKey);

    if (!isSeen && shouldAddChildrenDependencies) {
      for (const [name, referencish] of pkg.packageDependencies) {
        if (referencish !== null && !node.peerNames.has(name)) {
          const depLocator = pnp.getLocator(name, referencish);
          const pkgLocator = pnp.getLocator(name.replace(`$wsroot$`, ``), referencish);
          const depPkg = pnp.getPackageInformation(pkgLocator);
          if (depPkg === null) throw new Error(`Assertion failed: Expected the package to have been registered`); // Skip package self-references

          if (depLocator.name === locator.name && depLocator.reference === locator.reference) continue;
          addPackageToTree(name, depPkg, depLocator, node, pkg);
        }
      }
    }
  };

  addPackageToTree(topLocator.name, topPkg, topLocator, packageTree, topPkg);
  return packageTree;
};

function getTargetLocatorPath(locator, pnp, options) {
  const pkgLocator = pnp.getLocator(locator.name.replace(`$wsroot$`, ``), locator.reference);
  const info = pnp.getPackageInformation(pkgLocator);
  if (info === null) throw new Error(`Assertion failed: Expected the package to be registered`);
  let linkType;
  let target;

  if (options.pnpifyFs) {
    // In case of pnpifyFs we represent modules as symlinks to archives in NodeModulesFS
    // `/home/user/project/foo` is a symlink to `/home/user/project/.yarn/.cache/foo.zip/node_modules/foo`
    // To make this fs layout work with legacy tools we make
    // `/home/user/project/.yarn/.cache/foo.zip/node_modules/foo/node_modules` (which normally does not exist inside archive) a symlink to:
    // `/home/user/project/node_modules/foo/node_modules`, so that the tools were able to access it
    target = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(info.packageLocation);
    linkType = LinkType.SOFT;
  } else {
    const truePath = pnp.resolveVirtual && locator.reference && locator.reference.startsWith(`virtual:`) ? pnp.resolveVirtual(info.packageLocation) : info.packageLocation;
    target = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(truePath || info.packageLocation);
    linkType = info.linkType;
  }

  return {
    linkType,
    target
  };
}
/**
 * Converts hoisted tree to node modules map
 *
 * @param pnp PnP API
 * @param hoistedTree hoisted package tree from `RawHoister`
 * @param locators locators
 * @param packages package weights
 *
 * @returns node modules map
 */


const populateNodeModulesTree = (pnp, hoistedTree, options) => {
  const tree = new Map();

  const makeLeafNode = (locator, aliases) => {
    const {
      linkType,
      target
    } = getTargetLocatorPath(locator, pnp, options);
    return {
      locator: stringifyLocator(locator),
      target,
      linkType,
      aliases
    };
  };

  const getPackageName = identName => {
    const [nameOrScope, name] = identName.split(`/`);
    return name ? {
      scope: (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.toFilename)(nameOrScope),
      name: (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.toFilename)(name)
    } : {
      scope: null,
      name: (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.toFilename)(nameOrScope)
    };
  };

  const seenNodes = new Set();

  const buildTree = (pkg, locationPrefix) => {
    if (seenNodes.has(pkg)) return;
    seenNodes.add(pkg);

    for (const dep of pkg.dependencies) {
      // We do not want self-references in node_modules, since they confuse existing tools
      if (dep === pkg) continue;
      const references = Array.from(dep.references).sort();
      const locator = {
        name: dep.identName,
        reference: references[0]
      };
      const {
        name,
        scope
      } = getPackageName(dep.name);
      const packageNameParts = scope ? [scope, name] : [name];
      const nodeModulesDirPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.join(locationPrefix, NODE_MODULES);
      const nodeModulesLocation = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.join(nodeModulesDirPath, ...packageNameParts);
      const leafNode = makeLeafNode(locator, references.slice(1));

      if (!dep.name.endsWith(`$wsroot$`)) {
        const prevNode = tree.get(nodeModulesLocation);

        if (prevNode) {
          if (prevNode.dirList) {
            throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge dir node with leaf node`);
          } else {
            const locator1 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseLocator(prevNode.locator);
            const locator2 = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseLocator(leafNode.locator);
            if (prevNode.linkType !== leafNode.linkType) throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different link types`);else if (locator1.identHash !== locator2.identHash) throw new Error(`Assertion failed: ${nodeModulesLocation} cannot merge nodes with different idents ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.stringifyLocator(locator1)} and ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.stringifyLocator(locator2)}`);
            leafNode.aliases = [...leafNode.aliases, ...prevNode.aliases, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseLocator(prevNode.locator).reference];
          }
        }

        tree.set(nodeModulesLocation, leafNode);
        const segments = nodeModulesLocation.split(`/`);
        const nodeModulesIdx = segments.indexOf(NODE_MODULES);
        let segCount = segments.length - 1;

        while (nodeModulesIdx >= 0 && segCount > nodeModulesIdx) {
          const dirPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.npath.toPortablePath(segments.slice(0, segCount).join(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.ppath.sep));
          const targetDir = (0,_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_1__.toFilename)(segments[segCount]);
          const subdirs = tree.get(dirPath);

          if (!subdirs) {
            tree.set(dirPath, {
              dirList: new Set([targetDir])
            });
          } else if (subdirs.dirList) {
            if (subdirs.dirList.has(targetDir)) {
              break;
            } else {
              subdirs.dirList.add(targetDir);
            }
          }

          segCount--;
        }
      }

      buildTree(dep, leafNode.linkType === LinkType.SOFT ? leafNode.target : nodeModulesLocation);
    }
  };

  const rootNode = makeLeafNode({
    name: hoistedTree.name,
    reference: Array.from(hoistedTree.references)[0]
  }, []);
  const rootPath = rootNode.target;
  tree.set(rootPath, rootNode);
  buildTree(hoistedTree, rootPath);
  return tree;
};
/**
 * Benchmarks raw hoisting performance.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param packageTree package tree
 * @param packages package info
 *
 * @returns average raw hoisting time
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


const benchmarkRawHoisting = packageTree => {
  const iterCount = 10;
  const startTime = Date.now();

  for (let iter = 0; iter < iterCount; iter++) hoist(packageTree);

  const endTime = Date.now();
  return (endTime - startTime) / iterCount;
};
/**
 * Benchmarks node_modules tree building.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param packageTree package tree
 * @param packages package info
 *
 * @returns average raw hoisting time
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


const benchmarkBuildTree = (pnp, options) => {
  const iterCount = 100;
  const startTime = Date.now();

  for (let iter = 0; iter < iterCount; iter++) {
    const packageTree = buildPackageTree(pnp, options);
    const hoistedTree = hoist(packageTree);
    populateNodeModulesTree(pnp, hoistedTree, options);
  }

  const endTime = Date.now();
  return (endTime - startTime) / iterCount;
};
/**
 * Pretty-prints node_modules tree.
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param tree node_modules tree
 * @param rootPath top-level project root folder
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


const dumpNodeModulesTree = (tree, rootPath) => {
  const sortedTree = new Map();
  const keys = Array.from(tree.keys()).sort();

  for (const key of keys) {
    const val = tree.get(key);
    sortedTree.set(key, val.dirList ? {
      dirList: new Set(Array.from(val.dirList).sort())
    } : val);
  }

  const seenPaths = new Set();

  const dumpTree = (nodePath, prefix = ``, dirPrefix = ``) => {
    const node = sortedTree.get(nodePath);
    if (!node) return ``;
    seenPaths.add(nodePath);
    let str = ``;

    if (node.dirList) {
      const dirs = Array.from(node.dirList);

      for (let idx = 0; idx < dirs.length; idx++) {
        const dir = dirs[idx];
        str += `${prefix}${idx < dirs.length - 1 ? `` : ``}${dirPrefix}${dir}\n`;
        str += dumpTree(ppath.join(nodePath, dir), `${prefix}${idx < dirs.length - 1 ? ` ` : `  `}`);
      }
    } else {
      const {
        target,
        linkType
      } = node;
      str += dumpTree(ppath.join(nodePath, NODE_MODULES), `${prefix} `, `${NODE_MODULES}/`);
      str += `${prefix}${linkType === LinkType.SOFT ? `s>` : `>`}${target}\n`;
    }

    return str;
  };

  let str = dumpTree(ppath.join(rootPath, NODE_MODULES));

  for (const key of sortedTree.keys()) {
    if (!seenPaths.has(key)) {
      str += `${key.replace(rootPath, ``)}\n${dumpTree(key)}`;
    }
  }

  return str;
};
/**
 * Pretty-prints dependency tree in the `yarn why`-like format
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param pkg node_modules tree
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars


const dumpDepTree = tree => {
  const dumpLocator = locator => {
    if (locator.reference === `workspace:.`) {
      return `.`;
    } else if (!locator.reference) {
      return `${locator.name}@${locator.reference}`;
    } else {
      const version = (locator.reference.indexOf(`#`) > 0 ? locator.reference.split(`#`)[1] : locator.reference).replace(`npm:`, ``);

      if (locator.reference.startsWith(`virtual`)) {
        return `v:${locator.name}@${version}`;
      } else {
        return `${locator.name}@${version}`;
      }
    }
  };

  const dumpPackage = (pkg, parents, prefix = ``) => {
    if (parents.includes(pkg)) return ``;
    const dependencies = Array.from(pkg.dependencies);
    let str = ``;

    for (let idx = 0; idx < dependencies.length; idx++) {
      const dep = dependencies[idx];
      str += `${prefix}${idx < dependencies.length - 1 ? `` : ``}${(parents.includes(dep) ? `>` : ``) + dumpLocator({
        name: dep.name,
        reference: Array.from(dep.references)[0]
      })}\n`;
      str += dumpPackage(dep, [...parents, dep], `${prefix}${idx < dependencies.length - 1 ? ` ` : `  `}`);
    }

    return str;
  };

  return dumpPackage(tree, []);
};

/***/ }),
/* 687 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hoist": () => /* binding */ hoist
/* harmony export */ });
const makeLocator = (name, reference) => `${name}@${reference}`;

const makeIdent = (name, reference) => {
  const hashIdx = reference.indexOf(`#`); // Strip virtual reference part, we don't need it for hoisting purposes

  const realReference = hashIdx >= 0 ? reference.substring(hashIdx + 1) : reference;
  return makeLocator(name, realReference);
};
/**
 * Hoists package tree.
 *
 * The root node of a tree must has id: '.'.
 * This function does not mutate its arguments, it hoists and returns tree copy.
 *
 * @param tree package tree (cycles in the tree are allowed)
 *
 * @returns hoisted tree copy
 */


const hoist = (tree, opts = {}) => {
  const debugLevel = opts.debugLevel || Number(process.env.NM_DEBUG_LEVEL || -1);
  const check = opts.check || debugLevel >= 9;
  const options = {
    check,
    debugLevel
  };
  if (options.debugLevel >= 0) console.time(`hoist`);
  const treeCopy = cloneTree(tree);
  hoistTo(treeCopy, treeCopy, new Set([treeCopy.locator]), options);
  if (options.debugLevel >= 0) console.timeEnd(`hoist`);

  if (options.debugLevel >= 1) {
    const checkLog = selfCheck(treeCopy);

    if (checkLog) {
      throw new Error(`${checkLog}, after hoisting finished:\n${dumpDepTree(treeCopy)}`);
    }
  }

  if (options.debugLevel >= 2) console.log(dumpDepTree(treeCopy));
  return shrinkTree(treeCopy);
};

const getHoistedDependencies = rootNode => {
  const hoistedDependencies = new Map();
  const seenNodes = new Set();

  const addHoistedDependencies = node => {
    if (seenNodes.has(node)) return;
    seenNodes.add(node);

    for (const dep of node.hoistedDependencies.values()) if (!rootNode.dependencies.has(dep.name)) hoistedDependencies.set(dep.name, dep);

    for (const dep of node.dependencies.values()) {
      if (!node.peerNames.has(dep.name)) {
        addHoistedDependencies(dep);
      }
    }
  };

  addHoistedDependencies(rootNode);
  return hoistedDependencies;
};
/**
 * This method clones the node and returns cloned node copy, if the node was not previously decoupled.
 *
 * The node is considered decoupled if there is no multiple parents to any node
 * on the path from the dependency graph root up to this node. This means that there are no other
 * nodes in dependency graph that somehow transitively use this node and hence node can be hoisted without
 * side effects.
 *
 * The process of node decoupling is done by going from root node of the graph up to the node in concern
 * and decoupling each node on this graph path.
 *
 * @param node original node
 *
 * @returns decoupled node
 */


const decoupleGraphNode = (parent, node) => {
  if (node.decoupled) return node;
  const {
    name,
    references,
    ident,
    locator,
    dependencies,
    originalDependencies,
    hoistedDependencies,
    peerNames,
    reasons
  } = node; // To perform node hoisting from parent node we must clone parent nodes up to the root node,
  // because some other package in the tree might depend on the parent package where hoisting
  // cannot be performed

  const clone = {
    name,
    references: new Set(references),
    ident,
    locator,
    dependencies: new Map(dependencies),
    originalDependencies: new Map(originalDependencies),
    hoistedDependencies: new Map(hoistedDependencies),
    peerNames: new Set(peerNames),
    reasons: new Map(reasons),
    decoupled: true
  };
  const selfDep = clone.dependencies.get(name);
  if (selfDep && selfDep.ident == clone.ident) // Update self-reference
    clone.dependencies.set(name, clone);
  parent.dependencies.set(clone.name, clone);
  return clone;
};
/**
 * Builds a map of most popular packages that might be hoisted to the root node.
 *
 * The values in the map are idents sorted by popularity from most popular to less popular.
 * If the root node has already some version of a package, the value array will contain only
 * one element, since it is not possible for other versions of a package to be hoisted.
 *
 * @param rootNode root node
 * @param popularityMap popularity map
 */


const getHoistIdentMap = (rootNode, popularityMap) => {
  const identMap = new Map([[rootNode.name, [rootNode.ident]]]);

  for (const dep of rootNode.dependencies.values()) {
    if (!rootNode.peerNames.has(dep.name)) {
      identMap.set(dep.name, [dep.ident]);
    }
  }

  const keyList = Array.from(popularityMap.keys());
  keyList.sort((key1, key2) => popularityMap.get(key2).size - popularityMap.get(key1).size);

  for (const key of keyList) {
    const name = key.substring(0, key.indexOf(`@`, 1));
    const ident = key.substring(name.length + 1);

    if (!rootNode.peerNames.has(name)) {
      let idents = identMap.get(name);

      if (!idents) {
        idents = [];
        identMap.set(name, idents);
      }

      if (idents.indexOf(ident) < 0) {
        idents.push(ident);
      }
    }
  }

  return identMap;
};
/**
 * Performs hoisting all the dependencies down the tree to the root node.
 *
 * The algorithm used here reduces dependency graph by deduplicating
 * instances of the packages while keeping:
 * 1. Regular dependency promise: the package should require the exact version of the dependency
 * that was declared in its `package.json`
 * 2. Peer dependency promise: the package and its direct parent package
 * must use the same instance of the peer dependency
 *
 * The regular and peer dependency promises are kept while performing transform
 * on tree branches of packages at a time:
 * `root package` -> `parent package 1` ... `parent package n` -> `dependency`
 * We check wether we can hoist `dependency` to `root package`, this boils down basically
 * to checking:
 * 1. Wether `root package` does not depend on other version of `dependency`
 * 2. Wether all the peer dependencies of a `dependency` had already been hoisted from all `parent packages`
 *
 * If many versions of the `dependency` can be hoisted to the `root package` we choose the most used
 * `dependency` version in the project among them.
 *
 * This function mutates the tree.
 *
 * @param tree package dependencies graph
 * @param rootNode root node to hoist to
 * @param rootNodePath root node path in the tree
 * @param options hoisting options
 */


const hoistTo = (tree, rootNode, rootNodePath, options, seenNodes = new Set()) => {
  if (seenNodes.has(rootNode)) return;
  seenNodes.add(rootNode);
  const popularityMap = buildPopularityMap(rootNode);
  const hoistIdentMap = getHoistIdentMap(rootNode, popularityMap);
  const hoistIdents = new Set(Array.from(hoistIdentMap.values()).map(x => x[0]));
  const hoistedDependencies = rootNode === tree ? new Map() : getHoistedDependencies(rootNode);
  let wasStateChanged;

  do {
    hoistGraph(tree, rootNode, rootNodePath, hoistedDependencies, hoistIdents, hoistIdentMap, options);
    wasStateChanged = false;

    for (const [name, idents] of hoistIdentMap) {
      if (idents.length > 1 && !rootNode.dependencies.has(name)) {
        hoistIdents.delete(idents[0]);
        idents.shift();
        hoistIdents.add(idents[0]);
        wasStateChanged = true;
      }
    }
  } while (wasStateChanged);

  for (const dependency of rootNode.dependencies.values()) {
    if (!rootNode.peerNames.has(dependency.name) && !rootNodePath.has(dependency.locator)) {
      rootNodePath.add(dependency.locator);
      hoistTo(tree, dependency, rootNodePath, options);
      rootNodePath.delete(dependency.locator);
    }
  }
};
/**
 * Gets regular node dependencies only and sorts them in the order so that
 * peer dependencies come before the dependency that rely on them.
 *
 * @param node graph node
 * @returns sorted regular dependencies
 */


const getSortedReglarDependencies = node => {
  const dependencies = new Set();

  const addDep = (dep, seenDeps = new Set()) => {
    if (seenDeps.has(dep)) return;
    seenDeps.add(dep);

    for (const peerName of dep.peerNames) {
      if (!node.peerNames.has(peerName)) {
        const peerDep = node.dependencies.get(peerName);

        if (peerDep && !dependencies.has(peerDep)) {
          addDep(peerDep, seenDeps);
        }
      }
    }

    dependencies.add(dep);
  };

  for (const dep of node.dependencies.values()) {
    if (!node.peerNames.has(dep.name)) {
      addDep(dep);
    }
  }

  return dependencies;
};
/**
 * Performs actual graph transformation, by hoisting packages to the root node.
 *
 * @param tree dependency tree
 * @param rootNode root package node
 * @param rootNodePath root node path in the tree
 * @param hoistedDependencies map of dependencies that were hoisted to parent nodes
 * @param hoistIdents idents that should be attempted to be hoisted to the root node
 */


const hoistGraph = (tree, rootNode, rootNodePath, hoistedDependencies, hoistIdents, hoistIdentMap, options) => {
  const seenNodes = new Set();

  const hoistNode = (nodePath, locatorPath, node, newNodes) => {
    if (seenNodes.has(node)) return;
    let reasonRoot;
    let reason;
    if (options.debugLevel >= 2) reasonRoot = `${Array.from(rootNodePath).map(x => prettyPrintLocator(x)).join(``)}`;
    let isHoistable = hoistIdents.has(node.ident);
    if (options.debugLevel >= 2 && !isHoistable) reason = `- filled by: ${prettyPrintLocator(hoistIdentMap.get(node.name)[0])} at ${reasonRoot}`;

    if (isHoistable) {
      let arePeerDepsSatisfied = true;
      const checkList = new Set(node.peerNames);

      for (let idx = nodePath.length - 1; idx >= 1; idx--) {
        const parent = nodePath[idx];

        for (const name of checkList) {
          if (parent.peerNames.has(name) && parent.originalDependencies.has(name)) continue;
          const parentDepNode = parent.dependencies.get(name);

          if (parentDepNode) {
            if (options.debugLevel >= 2) reason = `- peer dependency ${prettyPrintLocator(parentDepNode.locator)} from parent ${prettyPrintLocator(parent.locator)} was not hoisted to ${reasonRoot}`;
            arePeerDepsSatisfied = false;
            break;
          }

          checkList.delete(name);
        }

        if (!arePeerDepsSatisfied) {
          break;
        }
      }

      isHoistable = arePeerDepsSatisfied;
    }

    if (isHoistable) {
      let isNameAvailable = false;
      const hoistedDep = hoistedDependencies.get(node.name);
      isNameAvailable = !hoistedDep || hoistedDep.ident === node.ident;
      if (options.debugLevel >= 2 && !isNameAvailable) reason = `- filled by: ${prettyPrintLocator(hoistedDep.locator)} at ${reasonRoot}`;

      if (isNameAvailable) {
        for (let idx = 1; idx < nodePath.length - 1; idx++) {
          const parent = nodePath[idx];
          const parentDep = parent.dependencies.get(node.name);

          if (parentDep && parentDep.ident !== node.ident) {
            isNameAvailable = false;
            if (options.debugLevel >= 2) reason = `- filled by: ${prettyPrintLocator(parentDep.locator)} at ${prettyPrintLocator(parent.locator)}`;
            break;
          }
        }
      }

      isHoistable = isNameAvailable;
    }

    if (isHoistable) {
      const parentNode = nodePath[nodePath.length - 1];
      parentNode.dependencies.delete(node.name);
      parentNode.hoistedDependencies.set(node.name, node);
      parentNode.reasons.delete(node.name);
      const hoistedNode = rootNode.dependencies.get(node.name); // Add hoisted node to root node, in case it is not already there

      if (!hoistedNode) {
        // Avoid adding other version of root node to itself
        if (rootNode.ident !== node.ident) {
          rootNode.dependencies.set(node.name, node);
          newNodes.add(node);
        }
      } else {
        for (const reference of node.references) {
          hoistedNode.references.add(reference);
        }
      }

      if (options.check) {
        const checkLog = selfCheck(tree);

        if (checkLog) {
          throw new Error(`${checkLog}, after hoisting ${[rootNode, ...nodePath, node].map(x => prettyPrintLocator(x.locator)).join(``)}:\n${dumpDepTree(tree)}`);
        }
      }
    } else if (options.debugLevel >= 2) {
      const parent = nodePath[nodePath.length - 1];
      parent.reasons.set(node.name, reason);
    }

    if (!isHoistable && locatorPath.indexOf(node.locator) < 0) {
      const decoupledNode = decoupleGraphNode(nodePath[nodePath.length - 1], node);
      seenNodes.add(decoupledNode);

      for (const dep of getSortedReglarDependencies(node)) hoistNode([...nodePath, decoupledNode], [...locatorPath, node.locator], dep, newNodes);

      seenNodes.delete(decoupledNode);
    }
  };

  let newNodes;
  let nextNewNodes = new Set(rootNode.dependencies.values());

  do {
    newNodes = nextNewNodes;
    nextNewNodes = new Set();

    for (const dep of newNodes) {
      if (rootNode.peerNames.has(dep.name) || dep.locator === rootNode.locator) continue;
      const decoupledDep = decoupleGraphNode(rootNode, dep);
      seenNodes.add(decoupledDep);

      for (const subDep of getSortedReglarDependencies(dep)) {
        if (subDep.locator !== dep.locator) {
          hoistNode([rootNode, decoupledDep], [rootNode.locator, dep.locator], subDep, nextNewNodes);
        }
      }

      seenNodes.delete(decoupledDep);
    }
  } while (nextNewNodes.size > 0);
};

const selfCheck = tree => {
  const log = [];
  const seenNodes = new Set();
  const parents = new Set();

  const checkNode = (node, parentDeps) => {
    if (seenNodes.has(node)) return;
    seenNodes.add(node);
    if (parents.has(node)) return;
    const dependencies = new Map(parentDeps);

    for (const dep of node.dependencies.values()) if (!node.peerNames.has(dep.name)) dependencies.set(dep.name, dep);

    for (const origDep of node.originalDependencies.values()) {
      const dep = dependencies.get(origDep.name);

      const prettyPrintTreePath = () => `${Array.from(parents).concat([node]).map(x => prettyPrintLocator(x.locator)).join(``)}`;

      if (node.peerNames.has(origDep.name)) {
        const parentDep = parentDeps.get(origDep.name);

        if (parentDep !== dep) {
          log.push(`${prettyPrintTreePath()} - broken peer promise: expected ${dep.locator} but found ${parentDep ? parentDep.locator : parentDep}`);
        }
      } else {
        if (!dep) {
          log.push(`${prettyPrintTreePath()} - broken require promise: no required dependency ${origDep.locator} found`);
        } else if (dep.ident !== origDep.ident) {
          log.push(`${prettyPrintTreePath()} - broken require promise for ${origDep.name}: expected ${origDep.ident}, but found: ${dep.ident}`);
        }
      }
    }

    parents.add(node);

    for (const dep of node.dependencies.values()) {
      if (!node.peerNames.has(dep.name)) {
        checkNode(dep, dependencies);
      }
    }

    parents.delete(node);
  };

  checkNode(tree, tree.dependencies);
  return log.join(`\n`);
};
/**
 * Creates a clone of package tree with extra fields used for hoisting purposes.
 *
 * @param tree package tree clone
 */


const cloneTree = tree => {
  const {
    identName,
    name,
    reference,
    peerNames
  } = tree;
  const treeCopy = {
    name,
    references: new Set([reference]),
    locator: makeLocator(identName, reference),
    ident: makeIdent(identName, reference),
    dependencies: new Map(),
    originalDependencies: new Map(),
    hoistedDependencies: new Map(),
    peerNames: new Set(peerNames),
    reasons: new Map(),
    decoupled: true
  };
  const seenNodes = new Map([[tree, treeCopy]]);

  const addNode = (node, parentNode) => {
    // Skip self-references
    let workNode = seenNodes.get(node);
    const isSeen = !!workNode;

    if (!workNode) {
      const {
        name,
        identName,
        reference,
        peerNames
      } = node;
      workNode = {
        name,
        references: new Set([reference]),
        locator: makeLocator(identName, reference),
        ident: makeIdent(identName, reference),
        dependencies: new Map(),
        originalDependencies: new Map(),
        hoistedDependencies: new Map(),
        peerNames: new Set(peerNames),
        reasons: new Map(),
        decoupled: true
      };
      seenNodes.set(node, workNode);
    }

    parentNode.dependencies.set(node.name, workNode);
    parentNode.originalDependencies.set(node.name, workNode);

    if (!isSeen) {
      for (const dep of node.dependencies) {
        addNode(dep, workNode);
      }
    } else {
      const seenCoupledNodes = new Set();

      const markNodeCoupled = node => {
        if (seenCoupledNodes.has(node)) return;
        seenCoupledNodes.add(node);
        node.decoupled = false;

        for (const dep of node.dependencies.values()) {
          if (!node.peerNames.has(dep.name)) {
            markNodeCoupled(dep);
          }
        }
      };

      markNodeCoupled(workNode);
    }
  };

  for (const dep of tree.dependencies) addNode(dep, treeCopy);

  return treeCopy;
};

const getIdentName = locator => locator.substring(0, locator.indexOf(`@`, 1));
/**
 * Creates a clone of hoisted package tree with extra fields removed
 *
 * @param tree stripped down hoisted package tree clone
 */


const shrinkTree = tree => {
  const treeCopy = {
    name: tree.name,
    identName: getIdentName(tree.locator),
    references: new Set(tree.references),
    dependencies: new Set()
  };
  const seenNodes = new Set([tree]);

  const addNode = (node, parentWorkNode, parentNode) => {
    const isSeen = seenNodes.has(node);
    let resultNode;

    if (parentWorkNode === node) {
      resultNode = parentNode;
    } else {
      const {
        name,
        references,
        locator
      } = node;
      resultNode = {
        name,
        identName: getIdentName(locator),
        references,
        dependencies: new Set()
      };
    }

    parentNode.dependencies.add(resultNode);

    if (!isSeen) {
      seenNodes.add(node);

      for (const dep of node.dependencies.values()) {
        if (!node.peerNames.has(dep.name)) {
          addNode(dep, node, resultNode);
        }
      }

      seenNodes.delete(node);
    }
  };

  for (const dep of tree.dependencies.values()) addNode(dep, tree, treeCopy);

  return treeCopy;
};
/**
 * Builds mapping, where key is an alias + dependent package ident and the value is the list of
 * parent package idents who depend on this package.
 *
 * @param rootNode package tree root node
 *
 * @returns popularity map
 */


const buildPopularityMap = rootNode => {
  const popularityMap = new Map();
  const seenNodes = new Set([rootNode]);

  const getPopularityKey = node => `${node.name}@${node.ident}`;

  const addParent = (parentNode, node) => {
    const isSeen = !!seenNodes.has(node);
    const key = getPopularityKey(node);
    let parents = popularityMap.get(key);

    if (!parents) {
      parents = new Set();
      popularityMap.set(key, parents);
    }

    parents.add(parentNode.ident);

    if (!isSeen) {
      seenNodes.add(node);

      for (const dep of node.dependencies.values()) {
        if (!node.peerNames.has(dep.name)) {
          addParent(node, dep);
        }
      }
    }
  };

  for (const dep of rootNode.dependencies.values()) if (!rootNode.peerNames.has(dep.name)) addParent(rootNode, dep);

  return popularityMap;
};

const prettyPrintLocator = locator => {
  const idx = locator.indexOf(`@`, 1);
  const name = locator.substring(0, idx);
  const reference = locator.substring(idx + 1);

  if (reference === `workspace:.`) {
    return `.`;
  } else if (!reference) {
    return `${name}`;
  } else {
    const version = (reference.indexOf(`#`) > 0 ? reference.split(`#`)[1] : reference).replace(`npm:`, ``);

    if (reference.startsWith(`virtual`)) {
      return `v:${name}@${version}`;
    } else {
      return `${name}@${version}`;
    }
  }
};

const MAX_NODES_TO_DUMP = 50000;
/**
 * Pretty-prints dependency tree in the `yarn why`-like format
 *
 * The function is used for troubleshooting purposes only.
 *
 * @param pkg node_modules tree
 *
 * @returns sorted node_modules tree
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars

const dumpDepTree = tree => {
  let nodeCount = 0;

  const dumpPackage = (pkg, parents, prefix = ``) => {
    if (nodeCount > MAX_NODES_TO_DUMP || parents.has(pkg)) return ``;
    nodeCount++;
    const dependencies = Array.from(pkg.dependencies.values());
    let str = ``;
    parents.add(pkg);

    for (let idx = 0; idx < dependencies.length; idx++) {
      const dep = dependencies[idx];

      if (!pkg.peerNames.has(dep.name)) {
        const reason = pkg.reasons.get(dep.name);
        const identName = getIdentName(dep.locator);
        str += `${prefix}${idx < dependencies.length - 1 ? `` : ``}${(parents.has(dep) ? `>` : ``) + (identName !== dep.name ? `a:${dep.name}:` : ``) + prettyPrintLocator(dep.locator) + (reason ? ` ${reason}` : ``)}\n`;
        str += dumpPackage(dep, parents, `${prefix}${idx < dependencies.length - 1 ? ` ` : `  `}`);
      }
    }

    parents.delete(pkg);
    return str;
  };

  const treeDump = dumpPackage(tree, new Set());
  return treeDump + (nodeCount > MAX_NODES_TO_DUMP ? `\nTree is too large, part of the tree has been dunped\n` : ``);
};

/***/ }),
/* 688 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PnpLooseLinker": () => /* binding */ PnpLooseLinker
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(214);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(215);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(666);
/* harmony import */ var _yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(686);
/* harmony import */ var _yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(668);






class PnpLooseLinker extends _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_1__.PnpLinker {
  constructor() {
    super(...arguments);
    this.mode = `loose`;
  }

  makeInstaller(opts) {
    return new PnpLooseInstaller(opts);
  }

}

class PnpLooseInstaller extends _yarnpkg_plugin_pnp__WEBPACK_IMPORTED_MODULE_1__.PnpInstaller {
  constructor() {
    super(...arguments);
    this.mode = `loose`;
  }

  async finalizeInstallWithPnp(pnpSettings) {
    if (this.opts.project.configuration.get(`pnpMode`) !== this.mode) return undefined;
    const defaultFsLayer = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.VirtualFS({
      baseFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ZipOpenFS({
        libzip: await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)(),
        maxOpenFiles: 80,
        readOnlyArchives: true
      })
    });
    const pnp = (0,_yarnpkg_pnp__WEBPACK_IMPORTED_MODULE_2__.makeRuntimeApi)(pnpSettings, this.opts.project.cwd, defaultFsLayer);
    const nmTree = (0,_yarnpkg_pnpify__WEBPACK_IMPORTED_MODULE_5__.buildNodeModulesTree)(pnp, {
      pnpifyFs: false
    });
    const fallbackPool = new Map();
    pnpSettings.fallbackPool = fallbackPool;

    const registerFallback = (name, entry) => {
      const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.parseLocator(entry.locator);
      const identStr = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.stringifyIdent(locator);

      if (identStr === name) {
        fallbackPool.set(name, locator.reference);
      } else {
        fallbackPool.set(name, [identStr, locator.reference]);
      }
    };

    const root = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(this.opts.project.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.Filename.nodeModules);
    const entry = nmTree.get(root);
    if (typeof entry === `undefined`) throw new Error(`Assertion failed: Expected a root junction point`);
    if (`target` in entry) throw new Error(`Assertion failed: Expected the root junction point to be a directory`);

    for (const childName of entry.dirList) {
      const childP = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(root, childName);
      const child = nmTree.get(childP);
      if (typeof child === `undefined`) throw new Error(`Assertion failed: Expected the child to have been registered`);

      if (`target` in child) {
        registerFallback(childName, child);
      } else {
        for (const subChildName of child.dirList) {
          const subChildP = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(childP, subChildName);
          const subChild = nmTree.get(subChildP);
          if (typeof subChild === `undefined`) throw new Error(`Assertion failed: Expected the subchild to have been registered`);

          if (`target` in subChild) {
            registerFallback(`${childName}/${subChildName}`, subChild);
          } else {
            throw new Error(`Assertion failed: Expected the leaf junction to be a package`);
          }
        }
      }
    }

    return super.finalizeInstallWithPnp(pnpSettings);
  }

}

/***/ }),
/* 689 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "npmConfigUtils": () => /* reexport module object */ _npmConfigUtils__WEBPACK_IMPORTED_MODULE_5__,
/* harmony export */   "npmHttpUtils": () => /* reexport module object */ _npmHttpUtils__WEBPACK_IMPORTED_MODULE_6__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);
/* harmony import */ var _NpmHttpFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(690);
/* harmony import */ var _NpmRemapResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(694);
/* harmony import */ var _NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(695);
/* harmony import */ var _NpmSemverResolver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(696);
/* harmony import */ var _NpmTagResolver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(697);
/* harmony import */ var _npmConfigUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(693);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(692);










const authSettings = {
  npmAlwaysAuth: {
    description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.BOOLEAN,
    default: false
  },
  npmAuthIdent: {
    description: `Authentication identity for the npm registry (_auth in npm and yarn v1)`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.SECRET,
    default: null
  },
  npmAuthToken: {
    description: `Authentication token for the npm registry (_authToken in npm and yarn v1)`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.SECRET,
    default: null
  }
};
const registrySettings = {
  npmPublishRegistry: {
    description: `Registry to push packages to`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.STRING,
    default: null
  },
  npmRegistryServer: {
    description: `URL of the selected npm registry (note: npm enterprise isn't supported)`,
    type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.STRING,
    default: `https://registry.yarnpkg.com`
  }
};
const plugin = {
  configuration: { ...authSettings,
    ...registrySettings,
    npmScopes: {
      description: `Settings per package scope`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.MAP,
      valueDefinition: {
        description: ``,
        type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.SHAPE,
        properties: { ...authSettings,
          ...registrySettings
        }
      }
    },
    npmRegistries: {
      description: `Settings per registry`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.MAP,
      normalizeKeys: _npmConfigUtils__WEBPACK_IMPORTED_MODULE_5__.normalizeRegistry,
      valueDefinition: {
        description: ``,
        type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.SettingsType.SHAPE,
        properties: { ...authSettings
        }
      }
    }
  },
  fetchers: [_NpmHttpFetcher__WEBPACK_IMPORTED_MODULE_0__.NpmHttpFetcher, _NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_2__.NpmSemverFetcher],
  resolvers: [_NpmRemapResolver__WEBPACK_IMPORTED_MODULE_1__.NpmRemapResolver, _NpmSemverResolver__WEBPACK_IMPORTED_MODULE_3__.NpmSemverResolver, _NpmTagResolver__WEBPACK_IMPORTED_MODULE_4__.NpmTagResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 690 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmHttpFetcher": () => /* binding */ NpmHttpFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(232);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(691);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(692);




class NpmHttpFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL)) return false;
    const {
      selector,
      params
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.structUtils.parseRange(locator.reference);
    if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(selector)) return false;
    if (params === null || typeof params.__archiveUrl !== `string`) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote server`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.structUtils.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    const {
      params
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.structUtils.parseRange(locator.reference);
    if (params === null || typeof params.__archiveUrl !== `string`) throw new Error(`Assertion failed: The archiveUrl querystring parameter should have been available`);
    const sourceBuffer = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__.get(params.__archiveUrl, {
      configuration: opts.project.configuration,
      ident: locator
    });
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.tgzUtils.convertToZip(sourceBuffer, {
      compressionLevel: opts.project.configuration.get(`compressionLevel`),
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.structUtils.getIdentVendorPath(locator),
      stripComponents: 1
    });
  }

}

/***/ }),
/* 691 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PROTOCOL": () => /* binding */ PROTOCOL
/* harmony export */ });
const PROTOCOL = `npm:`;

/***/ }),
/* 692 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AuthType": () => /* binding */ AuthType,
/* harmony export */   "getIdentUrl": () => /* binding */ getIdentUrl,
/* harmony export */   "get": () => /* binding */ get,
/* harmony export */   "put": () => /* binding */ put
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(217);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(534);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(enquirer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _npmConfigUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(693);




var AuthType;

(function (AuthType) {
  AuthType[AuthType["NO_AUTH"] = 0] = "NO_AUTH";
  AuthType[AuthType["BEST_EFFORT"] = 1] = "BEST_EFFORT";
  AuthType[AuthType["CONFIGURATION"] = 2] = "CONFIGURATION";
  AuthType[AuthType["ALWAYS_AUTH"] = 3] = "ALWAYS_AUTH";
})(AuthType || (AuthType = {}));

function getIdentUrl(ident) {
  if (ident.scope) {
    return `/@${ident.scope}%2f${ident.name}`;
  } else {
    return `/${ident.name}`;
  }
}
async function get(path, {
  configuration,
  headers,
  ident,
  authType,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_1__.getScopeRegistry(ident.scope, {
    configuration
  });
  if (ident && ident.scope && typeof authType === `undefined`) authType = AuthType.BEST_EFFORT;
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };
  let url;

  try {
    url = new URL(path);
  } catch (e) {
    url = new URL(registry + path);
  }

  try {
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.httpUtils.get(url.href, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    if (error.name === `HTTPError` && (error.response.statusCode === 401 || error.response.statusCode === 403)) {
      throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.MessageName.AUTHENTICATION_INVALID, `Invalid authentication (as ${await whoami(registry, headers, {
        configuration
      })})`);
    } else {
      throw error;
    }
  }
}
async function put(path, body, {
  attemptedAs,
  configuration,
  headers,
  ident,
  authType = AuthType.ALWAYS_AUTH,
  registry,
  ...rest
}) {
  if (ident && typeof registry === `undefined`) registry = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_1__.getScopeRegistry(ident.scope, {
    configuration
  });
  if (typeof registry !== `string`) throw new Error(`Assertion failed: The registry should be a string`);
  const auth = getAuthenticationHeader(registry, {
    authType,
    configuration,
    ident
  });
  if (auth) headers = { ...headers,
    authorization: auth
  };

  try {
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.httpUtils.put(registry + path, body, {
      configuration,
      headers,
      ...rest
    });
  } catch (error) {
    if (!isOtpError(error)) {
      if (error.name === `HTTPError` && (error.response.statusCode === 401 || error.response.statusCode === 403)) {
        throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.MessageName.AUTHENTICATION_INVALID, `Invalid authentication (${typeof attemptedAs !== `string` ? `as ${await whoami(registry, headers, {
          configuration
        })}` : `attempted as ${attemptedAs}`})`);
      } else {
        throw error;
      }
    }

    const otp = await askForOtp();
    const headersWithOtp = { ...headers,
      ...getOtpHeaders(otp)
    }; // Retrying request with OTP

    try {
      return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.httpUtils.put(`${registry}${path}`, body, {
        configuration,
        headers: headersWithOtp,
        ...rest
      });
    } catch (error) {
      if (error.name === `HTTPError` && (error.response.statusCode === 401 || error.response.statusCode === 403)) {
        throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.MessageName.AUTHENTICATION_INVALID, `Invalid authentication (${typeof attemptedAs !== `string` ? `as ${await whoami(registry, headersWithOtp, {
          configuration
        })}` : `attempted as ${attemptedAs}`})`);
      } else {
        throw error;
      }
    }
  }
}

function getAuthenticationHeader(registry, {
  authType = AuthType.CONFIGURATION,
  configuration,
  ident
}) {
  const effectiveConfiguration = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_1__.getAuthConfiguration(registry, {
    configuration,
    ident
  });
  const mustAuthenticate = shouldAuthenticate(effectiveConfiguration, authType);
  if (!mustAuthenticate) return null;
  if (effectiveConfiguration.get(`npmAuthToken`)) return `Bearer ${effectiveConfiguration.get(`npmAuthToken`)}`;
  if (effectiveConfiguration.get(`npmAuthIdent`)) return `Basic ${effectiveConfiguration.get(`npmAuthIdent`)}`;

  if (mustAuthenticate && authType !== AuthType.BEST_EFFORT) {
    throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.MessageName.AUTHENTICATION_NOT_FOUND, `No authentication configured for request`);
  } else {
    return null;
  }
}

function shouldAuthenticate(authConfiguration, authType) {
  switch (authType) {
    case AuthType.CONFIGURATION:
      return authConfiguration.get(`npmAlwaysAuth`);

    case AuthType.BEST_EFFORT:
    case AuthType.ALWAYS_AUTH:
      return true;

    case AuthType.NO_AUTH:
      return false;

    default:
      throw new Error(`Unreachable`);
  }
}

async function whoami(registry, headers, {
  configuration
}) {
  if (typeof headers === `undefined` || typeof headers.authorization === `undefined`) return `an anonymous user`;

  try {
    const response = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.httpUtils.get(new URL(`${registry}/-/whoami`).href, {
      configuration,
      headers
    });
    return response.username;
  } catch (_a) {
    return `an unknown user`;
  }
}

async function askForOtp() {
  if (process.env.TEST_ENV) return process.env.TEST_NPM_2FA_TOKEN || ``;
  const {
    otp
  } = await (0,enquirer__WEBPACK_IMPORTED_MODULE_0__.prompt)({
    type: `password`,
    name: `otp`,
    message: `One-time password:`,
    required: true,
    onCancel: () => process.exit(130)
  });
  return otp;
}

function isOtpError(error) {
  if (error.name !== `HTTPError`) return false;

  try {
    const authMethods = error.response.headers[`www-authenticate`].split(/,\s*/).map(s => s.toLowerCase());
    return authMethods.includes(`otp`);
  } catch (e) {
    return false;
  }
}

function getOtpHeaders(otp) {
  return {
    [`npm-otp`]: otp
  };
}

/***/ }),
/* 693 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RegistryType": () => /* binding */ RegistryType,
/* harmony export */   "normalizeRegistry": () => /* binding */ normalizeRegistry,
/* harmony export */   "getPublishRegistry": () => /* binding */ getPublishRegistry,
/* harmony export */   "getScopeRegistry": () => /* binding */ getScopeRegistry,
/* harmony export */   "getDefaultRegistry": () => /* binding */ getDefaultRegistry,
/* harmony export */   "getRegistryConfiguration": () => /* binding */ getRegistryConfiguration,
/* harmony export */   "getScopeConfiguration": () => /* binding */ getScopeConfiguration,
/* harmony export */   "getAuthConfiguration": () => /* binding */ getAuthConfiguration
/* harmony export */ });
var RegistryType;

(function (RegistryType) {
  RegistryType["FETCH_REGISTRY"] = "npmRegistryServer";
  RegistryType["PUBLISH_REGISTRY"] = "npmPublishRegistry";
})(RegistryType || (RegistryType = {}));

function normalizeRegistry(registry) {
  return registry.replace(/\/$/, ``);
}
function getPublishRegistry(manifest, {
  configuration
}) {
  if (manifest.publishConfig && manifest.publishConfig.registry) return normalizeRegistry(manifest.publishConfig.registry);
  if (manifest.name) return getScopeRegistry(manifest.name.scope, {
    configuration,
    type: RegistryType.PUBLISH_REGISTRY
  });
  return getDefaultRegistry({
    configuration,
    type: RegistryType.PUBLISH_REGISTRY
  });
}
function getScopeRegistry(scope, {
  configuration,
  type = RegistryType.FETCH_REGISTRY
}) {
  const scopeConfiguration = getScopeConfiguration(scope, {
    configuration
  });
  if (scopeConfiguration === null) return getDefaultRegistry({
    configuration,
    type
  });
  const scopeRegistry = scopeConfiguration.get(type);
  if (scopeRegistry === null) return getDefaultRegistry({
    configuration,
    type
  });
  return normalizeRegistry(scopeRegistry);
}
function getDefaultRegistry({
  configuration,
  type = RegistryType.FETCH_REGISTRY
}) {
  const defaultRegistry = configuration.get(type);
  if (defaultRegistry !== null) return normalizeRegistry(defaultRegistry);
  return normalizeRegistry(configuration.get(RegistryType.FETCH_REGISTRY));
}
function getRegistryConfiguration(registry, {
  configuration
}) {
  const registryConfigurations = configuration.get(`npmRegistries`);
  const exactEntry = registryConfigurations.get(registry);
  if (typeof exactEntry !== `undefined`) return exactEntry;
  const noProtocolEntry = registryConfigurations.get(registry.replace(/^[a-z]+:/, ``));
  if (typeof noProtocolEntry !== `undefined`) return noProtocolEntry;
  return null;
}
function getScopeConfiguration(scope, {
  configuration
}) {
  if (scope === null) return null;
  const scopeConfigurations = configuration.get(`npmScopes`);
  const scopeConfiguration = scopeConfigurations.get(scope);
  if (!scopeConfiguration) return null;
  return scopeConfiguration;
}
function getAuthConfiguration(registry, {
  configuration,
  ident
}) {
  const scopeConfiguration = ident && getScopeConfiguration(ident.scope, {
    configuration
  });
  if ((scopeConfiguration === null || scopeConfiguration === void 0 ? void 0 : scopeConfiguration.get(`npmAuthIdent`)) || (scopeConfiguration === null || scopeConfiguration === void 0 ? void 0 : scopeConfiguration.get(`npmAuthToken`))) return scopeConfiguration;
  const registryConfiguration = getRegistryConfiguration(registry, {
    configuration
  });
  return registryConfiguration || configuration;
}

/***/ }),
/* 694 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmRemapResolver": () => /* binding */ NpmRemapResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(691);


class NpmRemapResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL)) return false;
    if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.tryParseDescriptor(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length), true)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    return false;
  }

  shouldPersistResolution(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    const nextDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseDescriptor(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length), true);
    return opts.resolver.getResolutionDependencies(nextDescriptor, opts);
  }

  async getCandidates(descriptor, dependencies, opts) {
    const nextDescriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.parseDescriptor(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_0__.PROTOCOL.length), true);
    return await opts.resolver.getCandidates(nextDescriptor, dependencies, opts);
  }

  resolve(locator, opts) {
    // Once transformed into locators, the descriptors are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

}

/***/ }),
/* 695 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmSemverFetcher": () => /* binding */ NpmSemverFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(217);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(281);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(691);
/* harmony import */ var _npmConfigUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(693);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(692);







class NpmSemverFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL)) return false;
    const url = new url__WEBPACK_IMPORTED_MODULE_1__.URL(locator.reference);
    if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(url.pathname)) return false;
    if (url.searchParams.has(`__archiveUrl`)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the remote registry`),
      loader: () => this.fetchFromNetwork(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.getIdentVendorPath(locator),
      checksum
    };
  }

  async fetchFromNetwork(locator, opts) {
    let sourceBuffer;

    try {
      sourceBuffer = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_4__.get(NpmSemverFetcher.getLocatorUrl(locator), {
        configuration: opts.project.configuration,
        ident: locator
      });
    } catch (error) {
      // The npm registry doesn't always support %2f when fetching the package tarballs 
      // OK: https://registry.yarnpkg.com/@emotion%2fbabel-preset-css-prop/-/babel-preset-css-prop-10.0.7.tgz
      // KO: https://registry.yarnpkg.com/@xtuc%2fieee754/-/ieee754-1.2.0.tgz
      sourceBuffer = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_4__.get(NpmSemverFetcher.getLocatorUrl(locator).replace(/%2f/g, `/`), {
        configuration: opts.project.configuration,
        ident: locator
      });
    }

    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.tgzUtils.convertToZip(sourceBuffer, {
      compressionLevel: opts.project.configuration.get(`compressionLevel`),
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.structUtils.getIdentVendorPath(locator),
      stripComponents: 1
    });
  }

  static isConventionalTarballUrl(locator, url, {
    configuration
  }) {
    let registry = _npmConfigUtils__WEBPACK_IMPORTED_MODULE_3__.getScopeRegistry(locator.scope, {
      configuration
    });
    const path = NpmSemverFetcher.getLocatorUrl(locator); // From time to time the npm registry returns http urls instead of https 

    url = url.replace(/^https?:(\/\/(?:[^/]+\.)?npmjs.org(?:$|\/))/, `https:$1`); // The yarnpkg and npmjs registries are interchangeable for that matter, so we uniformize them

    registry = registry.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
    url = url.replace(/^https:\/\/registry\.npmjs\.org($|\/)/, `https://registry.yarnpkg.com$1`);
    if (url === registry + path) return true;
    if (url === registry + path.replace(/%2f/g, `/`)) return true;
    return false;
  }

  static getLocatorUrl(locator) {
    const version = semver__WEBPACK_IMPORTED_MODULE_0___default().clean(locator.reference.slice(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL.length));
    if (version === null) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
    return `${_npmHttpUtils__WEBPACK_IMPORTED_MODULE_4__.getIdentUrl(locator)}/-/${locator.name}-${version}.tgz`;
  }

}

/***/ }),
/* 696 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmSemverResolver": () => /* binding */ NpmSemverResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(230);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(223);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(232);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(695);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(691);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(692);







const NODE_GYP_IDENT = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.makeIdent(null, `node-gyp`);
const NODE_GYP_MATCH = /\b(node-gyp|prebuild-install)\b/;
class NpmSemverResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL)) return false;
    if (!semver__WEBPACK_IMPORTED_MODULE_0___default().validRange(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL.length))) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL)) return false;
    const {
      selector
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.parseRange(locator.reference);
    if (!semver__WEBPACK_IMPORTED_MODULE_0___default().valid(selector)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return true;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const range = descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL.length);
    const registryData = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__.get(_npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__.getIdentUrl(descriptor), {
      configuration: opts.project.configuration,
      ident: descriptor,
      json: true
    });
    const versions = Object.keys(registryData.versions);
    const candidates = versions.filter(version => semver__WEBPACK_IMPORTED_MODULE_0___default().satisfies(version, range));
    candidates.sort((a, b) => {
      return -semver__WEBPACK_IMPORTED_MODULE_0___default().compare(a, b);
    });
    return candidates.map(version => {
      const versionLocator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_2__.PROTOCOL}${version}`);
      const archiveUrl = registryData.versions[version].dist.tarball;

      if (_NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_1__.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {
        configuration: opts.project.configuration
      })) {
        return versionLocator;
      } else {
        return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.bindLocator(versionLocator, {
          __archiveUrl: archiveUrl
        });
      }
    });
  }

  async resolve(locator, opts) {
    const {
      selector
    } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.parseRange(locator.reference);
    const version = semver__WEBPACK_IMPORTED_MODULE_0___default().clean(selector);
    if (version === null) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
    const registryData = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__.get(_npmHttpUtils__WEBPACK_IMPORTED_MODULE_3__.getIdentUrl(locator), {
      configuration: opts.project.configuration,
      ident: locator,
      json: true
    });
    if (!Object.prototype.hasOwnProperty.call(registryData, `versions`)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
    if (!Object.prototype.hasOwnProperty.call(registryData.versions, version)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.REMOTE_NOT_FOUND, `Registry failed to return reference "${version}"`);
    const manifest = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Manifest();
    manifest.load(registryData.versions[version]); // Manually add node-gyp dependency if there is a script using it and not already set
    // This is because the npm registry will automatically add a `node-gyp rebuild` install script
    // in the metadata if there is not already an install script and a binding.gyp file exists.
    // Also, node-gyp is not always set as a dependency in packages, so it will also be added if used in scripts.

    if (!manifest.dependencies.has(NODE_GYP_IDENT.identHash) && !manifest.peerDependencies.has(NODE_GYP_IDENT.identHash)) {
      for (const value of manifest.scripts.values()) {
        if (value.match(NODE_GYP_MATCH)) {
          manifest.dependencies.set(NODE_GYP_IDENT.identHash, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.makeDescriptor(NODE_GYP_IDENT, `latest`));
          opts.report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.NODE_GYP_INJECTED, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.prettyLocator(opts.project.configuration, locator)}: Implicit dependencies on node-gyp are discouraged`);
          break;
        }
      }
    } // Show deprecation warnings


    if (typeof manifest.raw.deprecated === `string`) opts.report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.DEPRECATED_PACKAGE, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.structUtils.prettyLocator(opts.project.configuration, locator)} is deprecated: ${manifest.raw.deprecated}`);
    return { ...locator,
      version,
      languageName: `node`,
      linkType: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.LinkType.HARD,
      dependencies: manifest.dependencies,
      peerDependencies: manifest.peerDependencies,
      dependenciesMeta: manifest.dependenciesMeta,
      peerDependenciesMeta: manifest.peerDependenciesMeta,
      bin: manifest.bin
    };
  }

}

/***/ }),
/* 697 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NpmTagResolver": () => /* binding */ NpmTagResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(224);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var _NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(695);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(691);
/* harmony import */ var _npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(692);





class NpmTagResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL)) return false;
    if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.TAG_REGEXP.test(descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL.length))) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    // Once transformed into locators, the tags are resolved by the NpmSemverResolver
    return false;
  }

  shouldPersistResolution(locator, opts) {
    // Once transformed into locators, the tags are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    return descriptor;
  }

  getResolutionDependencies(descriptor, opts) {
    return [];
  }

  async getCandidates(descriptor, dependencies, opts) {
    const tag = descriptor.range.slice(_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL.length);
    const registryData = await _npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__.get(_npmHttpUtils__WEBPACK_IMPORTED_MODULE_2__.getIdentUrl(descriptor), {
      configuration: opts.project.configuration,
      ident: descriptor,
      json: true
    });
    if (!Object.prototype.hasOwnProperty.call(registryData, `dist-tags`)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.REMOTE_INVALID, `Registry returned invalid data - missing "dist-tags" field`);
    const distTags = registryData[`dist-tags`];
    if (!Object.prototype.hasOwnProperty.call(distTags, tag)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.REMOTE_NOT_FOUND, `Registry failed to return tag "${tag}"`);
    const version = distTags[tag];
    const versionLocator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.makeLocator(descriptor, `${_constants__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL}${version}`);
    const archiveUrl = registryData.versions[version].dist.tarball;

    if (_NpmSemverFetcher__WEBPACK_IMPORTED_MODULE_0__.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, {
      configuration: opts.project.configuration
    })) {
      return [versionLocator];
    } else {
      return [_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.bindLocator(versionLocator, {
        __archiveUrl: archiveUrl
      })];
    }
  }

  async resolve(locator, opts) {
    // Once transformed into locators (through getCandidates), the tags are resolved by the NpmSemverResolver
    throw new Error(`Unreachable`);
  }

}

/***/ }),
/* 698 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);
/* harmony import */ var _commands_npm_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(699);
/* harmony import */ var _commands_npm_login__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(700);
/* harmony import */ var _commands_npm_logout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(701);
/* harmony import */ var _commands_npm_publish__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(702);
/* harmony import */ var _commands_npm_whoami__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(708);






const plugin = {
  configuration: {
    npmPublishAccess: {
      description: `Default access of the published packages`,
      type: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.SettingsType.STRING,
      default: null
    }
  },
  commands: [_commands_npm_info__WEBPACK_IMPORTED_MODULE_0__.default, _commands_npm_login__WEBPACK_IMPORTED_MODULE_1__.default, _commands_npm_logout__WEBPACK_IMPORTED_MODULE_2__.default, _commands_npm_publish__WEBPACK_IMPORTED_MODULE_3__.default, _commands_npm_whoami__WEBPACK_IMPORTED_MODULE_4__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 699 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ InfoCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(689);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(113);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(67);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(115);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);








 // eslint-disable-next-line arca/no-default-export

class InfoCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Project.find(configuration, this.context.cwd);
    const fields = typeof this.fields !== `undefined` ? new Set([`name`, ...this.fields.split(/\s*,\s*/)]) : null;
    const infos = [];
    let leadWithSeparator = false;
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      includeFooter: false,
      json: this.json,
      stdout: this.context.stdout
    }, async report => {
      for (const identStr of this.packages) {
        let descriptor;

        if (identStr === `.`) {
          const workspace = project.topLevelWorkspace;
          if (!workspace.manifest.name) throw new clipanion__WEBPACK_IMPORTED_MODULE_2__.UsageError(`Missing 'name' field in ${path__WEBPACK_IMPORTED_MODULE_3___default().join(workspace.cwd, `package.json`)}`);
          descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.structUtils.makeDescriptor(workspace.manifest.name, `unknown`);
        } else {
          descriptor = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.structUtils.parseDescriptor(identStr);
        }

        const identUrl = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(descriptor);
        let result;

        try {
          // The information from `registry.npmjs.org/<package>`
          result = clean(await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.get(identUrl, {
            configuration,
            ident: descriptor,
            json: true
          }));
        } catch (err) {
          if (err.name !== `HTTPError`) {
            throw err;
          } else if (err.response.statusCode === 404) {
            throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.EXCEPTION, `Package not found`);
          } else {
            throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.EXCEPTION, err.toString());
          }
        }

        const versions = Object.keys(result.versions).sort((semver__WEBPACK_IMPORTED_MODULE_4___default().compareLoose));
        const fallbackVersion = result[`dist-tags`].latest || versions[versions.length - 1]; // The latest version that satisfies `descriptor.range` (if it is a valid range), else `fallbackVersion`

        let version = fallbackVersion;

        if (semver__WEBPACK_IMPORTED_MODULE_4___default().validRange(descriptor.range)) {
          const maxSatisfyingVersion = semver__WEBPACK_IMPORTED_MODULE_4___default().maxSatisfying(versions, descriptor.range);

          if (maxSatisfyingVersion !== null) {
            version = maxSatisfyingVersion;
          } else {
            report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.UNNAMED, `Unmet range ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.structUtils.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
            leadWithSeparator = true;
          }
        } else if (descriptor.range !== `unknown`) {
          report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.UNNAMED, `Invalid range ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.structUtils.prettyRange(configuration, descriptor.range)}; falling back to the latest version`);
          leadWithSeparator = true;
        }

        const release = result.versions[version];
        /**
         * The merging of
         * @see `result` - The information from `registry.npmjs.org/<package>`
         * @see `release` - The release corresponding to `version`
         * @see `version` - The latest version that satisfies `descriptor.range` (if it is a valid range), else `fallbackVersion`
         * @see `versions` - All version tags of a package, sorted in ascending order
         */

        const packageInformation = { ...result,
          ...release,
          version,
          versions
        };
        let serialized;

        if (fields !== null) {
          serialized = {};

          for (const field of fields) {
            // @ts-ignore
            const value = packageInformation[field];

            if (typeof value !== `undefined`) {
              serialized[field] = value;
            } else {
              report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.MessageName.EXCEPTION, `The '${field}' field doesn't exist inside ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.structUtils.prettyIdent(configuration, descriptor)}'s informations`);
              leadWithSeparator = true;
              continue;
            }
          }
        } else {
          // Remove long fields
          if (!this.json) {
            delete packageInformation.dist;
            delete packageInformation.readme;
            delete packageInformation.users;
          }

          serialized = packageInformation;
        }

        report.reportJson(serialized);

        if (!this.json) {
          infos.push(serialized);
        }
      }
    }); // @ts-ignore: The Node typings forgot one field

    util__WEBPACK_IMPORTED_MODULE_5__.inspect.styles.name = `cyan`;

    for (const serialized of infos) {
      if (serialized !== infos[0] || leadWithSeparator) this.context.stdout.write(`\n`);
      this.context.stdout.write(`${(0,util__WEBPACK_IMPORTED_MODULE_5__.inspect)(serialized, {
        depth: Infinity,
        colors: true,
        compact: false
      })}\n`);
    }

    return report.exitCode();
  }

}
InfoCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  description: `show information about a package`,
  details: `
      This command will fetch information about a package from the npm registry, and prints it in a tree format.

      The package does not have to be installed locally, but needs to have been published (in particular, local changes will be ignored even for workspaces).

      Append \`@<range>\` to the package argument to provide information specific to the latest version that satisfies the range. If the range is invalid or if there is no version satisfying the range, the command will print a warning and fall back to the latest version.

      If the \`-f,--fields\` option is set, it's a comma-separated list of fields which will be used to only display part of the package informations.

      By default, this command won't return the \`dist\`, \`readme\`, and \`users\` fields, since they are often very long. To explicitly request those fields, explicitly list them with the \`--fields\` flag or request the output in JSON mode.

      If the \`--json\` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).
    `,
  examples: [[`Show all available information about react (except the \`dist\`, \`readme\`, and \`users\` fields)`, `yarn npm info react`], [`Show all available information about react as valid JSON (including the \`dist\`, \`readme\`, and \`users\` fields)`, `yarn npm info react --json`], [`Show all available information about react 16.12.0`, `yarn npm info react@16.12.0`], [`Show the description of react`, `yarn npm info react --fields description`], [`Show all available versions of react`, `yarn npm info react --fields versions`], [`Show the readme of react`, `yarn npm info react --fields readme`], [`Show a few fields of react`, `yarn npm info react --fields homepage,repository`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Rest()], InfoCommand.prototype, "packages", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`-f,--fields`)], InfoCommand.prototype, "fields", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--json`)], InfoCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `info`)], InfoCommand.prototype, "execute", null); // Remove hidden properties recursively


function clean(value) {
  if (Array.isArray(value)) {
    const result = [];

    for (let item of value) {
      item = clean(item);

      if (item) {
        result.push(item);
      }
    }

    return result;
  } else if (typeof value === `object` && value !== null) {
    const result = {};

    for (const key of Object.keys(value)) {
      if (key.startsWith(`_`)) continue;
      const item = clean(value[key]);

      if (item) {
        result[key] = item;
      }
    }

    return result;
  } else if (value) {
    return value;
  } else {
    return null;
  }
}

/***/ }),
/* 700 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmLoginCommand,
/* harmony export */   "getRegistry": () => /* binding */ getRegistry
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(689);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(534);
/* harmony import */ var enquirer__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(enquirer__WEBPACK_IMPORTED_MODULE_3__);






 // eslint-disable-next-line arca/no-default-export

class NpmLoginCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.publish = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.find(this.context.cwd, this.context.plugins);
    const registry = await getRegistry({
      configuration,
      cwd: this.context.cwd,
      publish: this.publish,
      scope: this.scope
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const credentials = await getCredentials({
        registry,
        report,
        stdin: this.context.stdin,
        stdout: this.context.stdout
      });
      const url = `/-/user/org.couchdb.user:${encodeURIComponent(credentials.name)}`;
      const response = await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.put(url, credentials, {
        attemptedAs: credentials.name,
        configuration,
        registry,
        json: true,
        authType: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.AuthType.NO_AUTH
      });
      await setAuthToken(registry, response.token, {
        configuration,
        scope: this.scope
      });
      return report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `Successfully logged in`);
    });
    return report.exitCode();
  }

}
NpmLoginCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `store new login info to access the npm registry`,
  details: `
      This command will ask you for your username, password, and 2FA One-Time-Password (when it applies). It will then modify your local configuration (in your home folder, never in the project itself) to reference the new tokens thus generated.

      Adding the \`-s,--scope\` flag will cause the authentication to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the authentication to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).
    `,
  examples: [[`Login to the default registry`, `yarn npm login`], [`Login to the registry linked to the @my-scope registry`, `yarn npm login --scope my-scope`], [`Login to the publish registry for the current package`, `yarn npm login --publish`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`-s,--scope`)], NpmLoginCommand.prototype, "scope", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--publish`)], NpmLoginCommand.prototype, "publish", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_7__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `login`)], NpmLoginCommand.prototype, "execute", null);

async function getRegistry({
  scope,
  publish,
  configuration,
  cwd
}) {
  if (scope && publish) return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getScopeRegistry(scope, {
    configuration,
    type: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.RegistryType.PUBLISH_REGISTRY
  });
  if (scope) return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getScopeRegistry(scope, {
    configuration
  });
  if (publish) return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry((await (0,_yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.openWorkspace)(configuration, cwd)).manifest, {
    configuration
  });
  return _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getDefaultRegistry({
    configuration
  });
}

async function setAuthToken(registry, npmAuthToken, {
  configuration,
  scope
}) {
  if (scope) {
    return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.updateHomeConfiguration({
      npmScopes: (scopes = {}) => ({ ...scopes,
        [scope]: { ...scopes[scope],
          npmAuthToken
        }
      })
    });
  }

  return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Configuration.updateHomeConfiguration({
    npmRegistries: (registries = {}) => ({ ...registries,
      [registry]: { ...registries[registry],
        npmAuthToken
      }
    })
  });
}

async function getCredentials({
  registry,
  report,
  stdin,
  stdout
}) {
  if (process.env.TEST_ENV) {
    return {
      name: process.env.TEST_NPM_USER || ``,
      password: process.env.TEST_NPM_PASSWORD || ``
    };
  }

  report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `Logging in to ${registry}`);
  let isToken = false;

  if (registry.match(/^https:\/\/npm\.pkg\.github\.com(\/|$)/)) {
    report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.MessageName.UNNAMED, `You seem to be using the GitHub Package Registry. Tokens must be generated with the 'repo', 'write:packages', and 'read:packages' permissions.`);
    isToken = true;
  }

  report.reportSeparator();
  const {
    username,
    password
  } = await (0,enquirer__WEBPACK_IMPORTED_MODULE_3__.prompt)([{
    type: `input`,
    name: `username`,
    message: `Username:`,
    required: true,
    onCancel: () => process.exit(130),
    stdin,
    stdout
  }, {
    type: `password`,
    name: `password`,
    message: isToken ? `Token:` : `Password:`,
    required: true,
    onCancel: () => process.exit(130),
    stdin,
    stdout
  }]);
  report.reportSeparator();
  return {
    name: username,
    password
  };
}

/***/ }),
/* 701 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmLogoutCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(700);





 // eslint-disable-next-line arca/no-default-export

class NpmLogoutCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.publish = false;
    this.all = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const registry = this.all ? null : await (0,_login__WEBPACK_IMPORTED_MODULE_2__.getRegistry)({
      configuration,
      cwd: this.context.cwd,
      publish: this.publish,
      scope: this.scope
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      await logout(registry);
      return report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.UNNAMED, `Successfully logged out of ${registry === null ? `all registries` : registry}`);
    });
    return report.exitCode();
  }

}
NpmLogoutCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  category: `Npm-related commands`,
  description: `logout of the npm registry`,
  details: `
      This command will log you out by modifying your local configuration (in your home folder, never in the project itself) to delete all credentials linked to a registry.

      Adding the \`-s,--scope\` flag will cause the deletion to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the deletion to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).

      Adding the \`-A,--all\` flag will cause the deletion to be done against all registries.
    `,
  examples: [[`Logout of the default registry`, `yarn npm logout`], [`Logout of the registry linked to the @my-scope registry`, `yarn npm logout --scope my-scope`], [`Logout of the publish registry for the current package`, `yarn npm logout --publish`], [`Logout of the publish registry for the current package linked to the @my-scope registry`, `yarn npm logout --publish --scope my-scope`], [`Logout of all registries`, `yarn npm logout --all`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-s,--scope`)], NpmLogoutCommand.prototype, "scope", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--publish`)], NpmLogoutCommand.prototype, "publish", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-A,--all`)], NpmLogoutCommand.prototype, "all", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`npm`, `logout`)], NpmLogoutCommand.prototype, "execute", null);

async function logout(registry) {
  return await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.updateHomeConfiguration({
    npmRegistries: (registries = {}) => registry === null ? undefined : { ...registries,
      [registry]: undefined
    }
  });
}

/***/ }),
/* 702 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmPublishCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(689);
/* harmony import */ var _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(703);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(143);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ssri__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(706);








 // eslint-disable-next-line arca/no-default-export

class NpmPublishCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.tag = `latest`;
    this.tolerateRepublish = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    if (workspace.manifest.private) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Private workspaces cannot be published`);
    if (workspace.manifest.name === null || workspace.manifest.version === null) throw new clipanion__WEBPACK_IMPORTED_MODULE_3__.UsageError(`Workspaces must have valid names and versions to be published on an external registry`);
    await project.restoreInstallState(); // We store it so that TS knows that it's non-null

    const ident = workspace.manifest.name;
    const version = workspace.manifest.version;
    const registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry(workspace.manifest, {
      configuration
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      // Not an error if --tolerate-republish is set
      if (this.tolerateRepublish) {
        try {
          const registryData = await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.get(_yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(ident), {
            configuration,
            registry,
            ident,
            json: true
          });
          if (!Object.prototype.hasOwnProperty.call(registryData, `versions`)) throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);

          if (Object.prototype.hasOwnProperty.call(registryData.versions, version)) {
            report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.UNNAMED, `Registry already knows about version ${version}; skipping.`);
            return;
          }
        } catch (error) {
          if (error.name !== `HTTPError`) {
            throw error;
          } else if (error.response.statusCode !== 404) {
            throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_9__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.NETWORK_ERROR, `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`);
          }
        }
      }

      await _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__.packUtils.prepareForPack(workspace, {
        report
      }, async () => {
        const files = await _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__.packUtils.genPackList(workspace);

        for (const file of files) report.reportInfo(null, file);

        const pack = await _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__.packUtils.genPackStream(workspace, files);
        const buffer = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.miscUtils.bufferStream(pack);
        const body = await makePublishBody(workspace, buffer, {
          access: this.access,
          tag: this.tag,
          registry
        });

        try {
          await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.put(_yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.getIdentUrl(ident), body, {
            configuration,
            registry,
            ident,
            json: true
          });
        } catch (error) {
          if (error.name !== `HTTPError`) {
            throw error;
          } else {
            const message = error.response.body && error.response.body.error ? error.response.body.error : `The remote server answered with HTTP ${error.response.statusCode} ${error.response.statusMessage}`;
            report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.NETWORK_ERROR, message);
          }
        }
      });

      if (!report.hasErrors()) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.UNNAMED, `Package archive published`);
      }
    });
    return report.exitCode();
  }

}
NpmPublishCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Usage({
  category: `Npm-related commands`,
  description: `publish the active workspace to the npm registry`,
  details: `
      This command will pack the active workspace into a fresh archive and upload it to the npm registry.

      The package will by default be attached to the \`latest\` tag on the registry, but this behavior can be overriden by using the \`--tag\` option.

      Note that for legacy reasons scoped packages are by default published with an access set to \`restricted\` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the \`--access public\` flag. This behavior can be enabled by default through the \`npmPublishAccess\` settings.
    `,
  examples: [[`Publish the active workspace`, `yarn npm publish`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.String(`--access`)], NpmPublishCommand.prototype, "access", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.String(`--tag`)], NpmPublishCommand.prototype, "tag", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Boolean(`--tolerate-republish`)], NpmPublishCommand.prototype, "tolerateRepublish", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_12__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_3__.Command.Path(`npm`, `publish`)], NpmPublishCommand.prototype, "execute", null);

async function makePublishBody(workspace, buffer, {
  access,
  tag,
  registry
}) {
  const configuration = workspace.project.configuration;
  const ident = workspace.manifest.name;
  const version = workspace.manifest.version;
  const name = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_11__.structUtils.stringifyIdent(ident);
  const shasum = (0,crypto__WEBPACK_IMPORTED_MODULE_4__.createHash)(`sha1`).update(buffer).digest(`hex`);
  const integrity = ssri__WEBPACK_IMPORTED_MODULE_5__.fromData(buffer).toString();

  if (typeof access === `undefined`) {
    if (workspace.manifest.publishConfig && typeof workspace.manifest.publishConfig.access === `string`) {
      access = workspace.manifest.publishConfig.access;
    } else if (configuration.get(`npmPublishAccess`) !== null) {
      access = configuration.get(`npmPublishAccess`);
    } else if (ident.scope) {
      access = `restricted`;
    } else {
      access = `public`;
    }
  }

  const raw = await _yarnpkg_plugin_pack__WEBPACK_IMPORTED_MODULE_2__.packUtils.genPackageManifest(workspace); // This matches Lerna's logic:
  // https://github.com/evocateur/libnpmpublish/blob/latest/publish.js#L142
  // While the npm registry ignores the provided tarball URL, it's used by
  // other registries such as verdaccio.

  const tarballName = `${name}-${version}.tgz`;
  const tarballURL = new URL(`${name}/-/${tarballName}`, registry);
  return {
    _id: name,
    _attachments: {
      [tarballName]: {
        [`content_type`]: `application/octet-stream`,
        data: buffer.toString(`base64`),
        length: buffer.length
      }
    },
    name,
    access,
    [`dist-tags`]: {
      [tag]: version
    },
    versions: {
      [version]: { ...raw,
        _id: `${name}@${version}`,
        name,
        version,
        dist: {
          shasum,
          integrity,
          // the npm registry requires a tarball path, but it seems useless 
          tarball: tarballURL.toString()
        }
      }
    }
  };
}

/***/ }),
/* 703 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "packUtils": () => /* reexport module object */ _packUtils__WEBPACK_IMPORTED_MODULE_1__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(217);
/* harmony import */ var _commands_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(704);
/* harmony import */ var _packUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(705);





const DEPENDENCY_TYPES = [`dependencies`, `devDependencies`, `peerDependencies`];
const WORKSPACE_PROTOCOL = `workspace:`;

const beforeWorkspacePacking = (workspace, rawManifest) => {
  if (rawManifest.publishConfig) {
    if (rawManifest.publishConfig.main) rawManifest.main = rawManifest.publishConfig.main;
    if (rawManifest.publishConfig.browser) rawManifest.browser = rawManifest.publishConfig.browser;
    if (rawManifest.publishConfig.module) rawManifest.module = rawManifest.publishConfig.module;
    if (rawManifest.publishConfig.browser) rawManifest.browser = rawManifest.publishConfig.browser;

    if (rawManifest.publishConfig.bin) {
      rawManifest.bin = rawManifest.publishConfig.bin;
    }
  }

  const project = workspace.project;

  for (const dependencyType of DEPENDENCY_TYPES) {
    for (const descriptor of workspace.manifest.getForScope(dependencyType).values()) {
      const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);
      const range = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseRange(descriptor.range);
      if (range.protocol !== WORKSPACE_PROTOCOL) continue;

      if (matchingWorkspace === null) {
        if (project.tryWorkspaceByIdent(descriptor) === null) {
          throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.MessageName.WORKSPACE_NOT_FOUND, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.prettyDescriptor(project.configuration, descriptor)}: No local workspace found for this range`);
        }
      } else {
        let versionToWrite; // For workspace:path/to/workspace and workspace:* we look up the workspace version

        if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.areDescriptorsEqual(descriptor, matchingWorkspace.anchoredDescriptor) || range.selector === `*`) versionToWrite = matchingWorkspace.manifest.version;else // for workspace:version we simply strip the protocol
          versionToWrite = range.selector;
        rawManifest[dependencyType][_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.stringifyIdent(descriptor)] = versionToWrite;
      }
    }
  }
};

const plugin = {
  hooks: {
    beforeWorkspacePacking
  },
  commands: [_commands_pack__WEBPACK_IMPORTED_MODULE_0__.default]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 704 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PackCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(250);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(206);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _packUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(705);





 // eslint-disable-next-line arca/no-default-export

class PackCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.installIfNeeded = false;
    this.dryRun = false;
    this.json = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);

    if (await _packUtils__WEBPACK_IMPORTED_MODULE_2__.hasPackScripts(workspace)) {
      if (this.installIfNeeded) {
        await project.install({
          cache: await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration),
          report: new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.ThrowReport()
        });
      } else {
        await project.restoreInstallState();
      }
    }

    const target = typeof this.out !== `undefined` ? _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(this.context.cwd, interpolateOutputName(this.out, {
      workspace
    })) : _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(workspace.cwd, `package.tgz`);
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.StreamReport.start({
      configuration,
      stdout: this.context.stdout,
      json: this.json
    }, async report => {
      await _packUtils__WEBPACK_IMPORTED_MODULE_2__.prepareForPack(workspace, {
        report
      }, async () => {
        report.reportJson({
          base: workspace.cwd
        });
        const files = await _packUtils__WEBPACK_IMPORTED_MODULE_2__.genPackList(workspace);

        for (const file of files) {
          report.reportInfo(null, file);
          report.reportJson({
            location: file
          });
        }

        if (!this.dryRun) {
          const pack = await _packUtils__WEBPACK_IMPORTED_MODULE_2__.genPackStream(workspace, files);
          const write = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.xfs.createWriteStream(target);
          pack.pipe(write);
          await new Promise(resolve => {
            write.on(`finish`, resolve);
          });
        }
      });

      if (!this.dryRun) {
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_10__.MessageName.UNNAMED, `Package archive generated in ${configuration.format(target, `magenta`)}`);
        report.reportJson({
          output: target
        });
      }
    });
    return report.exitCode();
  }

}
PackCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `generate a tarball from the active workspace`,
  details: `
      This command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (\`package.tgz\`).

      If the \`--install-if-needed\` flag is set Yarn will run a preliminary \`yarn install\` if the package contains build scripts.

      If the \`-n,--dry-run\` flag is set the command will just print the file paths without actually generating the package archive.

      If the \`--json\` flag is set the output will follow a JSON-stream output also known as NDJSON (https://github.com/ndjson/ndjson-spec).

      If the \`-o,---out\` is set the archive will be created at the specified path. The \`%s\` and \`%v\` variables can be used within the path and will be respectively replaced by the package name and version.
    `,
  examples: [[`Create an archive from the active workspace`, `yarn pack`], [`List the files that would be made part of the workspace's archive`, `yarn pack --dry-run`], [`Name and output the archive in a dedicated folder`, `yarn pack --out /artifacts/%s-%v.tgz`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--install-if-needed`)], PackCommand.prototype, "installIfNeeded", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`-n,--dry-run`)], PackCommand.prototype, "dryRun", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Boolean(`--json`)], PackCommand.prototype, "json", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`--filename`, {
  hidden: false
}), clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String(`-o,--out`)], PackCommand.prototype, "out", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_11__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`pack`)], PackCommand.prototype, "execute", null);

function interpolateOutputName(name, {
  workspace
}) {
  const interpolated = name.replace(`%s`, prettyWorkspaceIdent(workspace)).replace(`%v`, prettyWorkspaceVersion(workspace));
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.npath.toPortablePath(interpolated);
}

function prettyWorkspaceIdent(workspace) {
  if (workspace.manifest.name !== null) {
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_12__.structUtils.slugifyIdent(workspace.manifest.name);
  } else {
    return `package`;
  }
}

function prettyWorkspaceVersion(workspace) {
  if (workspace.manifest.version !== null) {
    return workspace.manifest.version;
  } else {
    return `unknown`;
  }
}

/***/ }),
/* 705 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasPackScripts": () => /* binding */ hasPackScripts,
/* harmony export */   "prepareForPack": () => /* binding */ prepareForPack,
/* harmony export */   "genPackStream": () => /* binding */ genPackStream,
/* harmony export */   "genPackageManifest": () => /* binding */ genPackageManifest,
/* harmony export */   "genPackList": () => /* binding */ genPackList
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(226);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(210);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(122);
/* harmony import */ var micromatch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(micromatch__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var tar_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(283);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(116);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_3__);






const NEVER_IGNORE = [`/package.json`, `/readme`, `/readme.*`, `/license`, `/license.*`, `/licence`, `/licence.*`, `/changelog`, `/changelog.*`];
const ALWAYS_IGNORE = [`/package.tgz`, `.github`, `.git`, `.hg`, `node_modules`, `.npmignore`, `.gitignore`, `.#*`, `.DS_Store`];
async function hasPackScripts(workspace) {
  if (await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.hasWorkspaceScript(workspace, `prepack`)) return true;
  if (await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.hasWorkspaceScript(workspace, `postpack`)) return true;
  return false;
}
async function prepareForPack(workspace, {
  report
}, cb) {
  const stdin = null;
  const stdout = new stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough();
  const stderr = new stream__WEBPACK_IMPORTED_MODULE_1__.PassThrough();

  if (await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.hasWorkspaceScript(workspace, `prepack`)) {
    report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.LIFECYCLE_SCRIPT, `Calling the "prepack" lifecycle script`);
    const exitCode = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.executeWorkspaceScript(workspace, `prepack`, [], {
      stdin,
      stdout,
      stderr
    });

    if (exitCode !== 0) {
      throw new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.ReportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.LIFECYCLE_SCRIPT, `Prepack script failed; run "yarn prepack" to investigate`);
    }
  }

  try {
    await cb();
  } finally {
    if (await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.hasWorkspaceScript(workspace, `postpack`)) {
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.LIFECYCLE_SCRIPT, `Calling the "postpack" lifecycle script`);
      const exitCode = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.scriptUtils.executeWorkspaceScript(workspace, `postpack`, [], {
        stdin,
        stdout,
        stderr
      });

      if (exitCode !== 0) {
        report.reportWarning(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.LIFECYCLE_SCRIPT, `Postpack script failed; run "yarn postpack" to investigate`);
      }
    }
  }
}
async function genPackStream(workspace, files) {
  var _a, _b;

  if (typeof files === `undefined`) files = await genPackList(workspace);
  const executableFiles = new Set();

  for (const value of (_b = (_a = workspace.manifest.publishConfig) === null || _a === void 0 ? void 0 : _a.executableFiles) !== null && _b !== void 0 ? _b : new Set()) executableFiles.add(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.normalize(value));

  for (const value of workspace.manifest.bin.values()) executableFiles.add(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.normalize(value));

  const pack = tar_stream__WEBPACK_IMPORTED_MODULE_2__.pack();
  process.nextTick(async () => {
    for (const fileRequest of files) {
      const file = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.normalize(fileRequest);
      const source = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(workspace.cwd, file);
      const dest = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(`package`, file);
      const stat = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.lstatPromise(source);
      const opts = {
        name: dest,
        mtime: new Date(315532800)
      };
      const mode = executableFiles.has(file) ? 0o755 : 0o644;
      let resolveFn;
      let rejectFn;
      const awaitTarget = new Promise((resolve, reject) => {
        resolveFn = resolve;
        rejectFn = reject;
      });

      const cb = error => {
        if (error) {
          rejectFn(error);
        } else {
          resolveFn();
        }
      };

      if (stat.isFile()) {
        let content; // The root package.json supports replacement fields in publishConfig

        if (file === `package.json`) content = Buffer.from(JSON.stringify(await genPackageManifest(workspace), null, 2));else content = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.readFilePromise(source);
        pack.entry({ ...opts,
          mode,
          type: `file`
        }, content, cb);
      } else if (stat.isSymbolicLink()) {
        pack.entry({ ...opts,
          mode,
          type: `symlink`,
          linkname: await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_8__.xfs.readlinkPromise(source)
        }, cb);
      }

      await awaitTarget;
    }

    pack.finalize();
  });
  const tgz = (0,zlib__WEBPACK_IMPORTED_MODULE_3__.createGzip)();
  pack.pipe(tgz);
  return tgz;
}
async function genPackageManifest(workspace) {
  const data = JSON.parse(JSON.stringify(workspace.manifest.raw));
  await workspace.project.configuration.triggerHook(hooks => hooks.beforeWorkspacePacking, workspace, data);
  return data;
}
async function genPackList(workspace) {
  var _a, _b, _c, _d, _e, _f, _g, _h;

  const project = workspace.project;
  const configuration = project.configuration;
  const globalList = {
    accept: [],
    reject: []
  };

  for (const pattern of ALWAYS_IGNORE) globalList.reject.push(pattern);

  for (const pattern of NEVER_IGNORE) globalList.accept.push(pattern);

  globalList.reject.push(configuration.get(`rcFilename`));

  const maybeRejectPath = path => {
    if (path === null || !path.startsWith(`${workspace.cwd}/`)) return;
    const workspaceRelativePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(workspace.cwd, path);
    const workspaceAbsolutePath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, workspaceRelativePath);
    globalList.reject.push(workspaceAbsolutePath);
  };

  maybeRejectPath(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(project.cwd, configuration.get(`lockfileFilename`)));
  maybeRejectPath(configuration.get(`bstatePath`));
  maybeRejectPath(configuration.get(`cacheFolder`));
  maybeRejectPath(configuration.get(`globalFolder`));
  maybeRejectPath(configuration.get(`installStatePath`));
  maybeRejectPath(configuration.get(`virtualFolder`));
  maybeRejectPath(configuration.get(`yarnPath`));
  await configuration.triggerHook(hooks => {
    return hooks.populateYarnPaths;
  }, project, path => {
    maybeRejectPath(path);
  }); // All child workspaces are ignored

  for (const otherWorkspace of project.workspaces) {
    const rel = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(workspace.cwd, otherWorkspace.cwd);

    if (rel !== `` && !rel.match(/^(\.\.)?\//)) {
      globalList.reject.push(`/${rel}`);
    }
  }

  const ignoreList = {
    accept: [],
    reject: []
  };
  const main = (_b = (_a = workspace.manifest.publishConfig) === null || _a === void 0 ? void 0 : _a.main) !== null && _b !== void 0 ? _b : workspace.manifest.main;
  const module = (_d = (_c = workspace.manifest.publishConfig) === null || _c === void 0 ? void 0 : _c.module) !== null && _d !== void 0 ? _d : workspace.manifest.module;
  const browser = (_f = (_e = workspace.manifest.publishConfig) === null || _e === void 0 ? void 0 : _e.browser) !== null && _f !== void 0 ? _f : workspace.manifest.browser;
  const bins = (_h = (_g = workspace.manifest.publishConfig) === null || _g === void 0 ? void 0 : _g.bin) !== null && _h !== void 0 ? _h : workspace.manifest.bin;
  if (main != null) ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, main));
  if (module != null) ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, module));
  if (browser != null) ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, browser));

  for (const path of bins.values()) ignoreList.accept.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, path));

  const hasExplicitFileList = workspace.manifest.files !== null;

  if (hasExplicitFileList) {
    ignoreList.reject.push(`/*`);

    for (const pattern of workspace.manifest.files) {
      addIgnorePattern(ignoreList.accept, pattern, {
        cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root
      });
    }
  }

  return await walk(workspace.cwd, {
    hasExplicitFileList,
    globalList,
    ignoreList
  });
}

async function walk(initialCwd, {
  hasExplicitFileList,
  globalList,
  ignoreList
}) {
  const list = [];
  const cwdFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.JailFS(initialCwd);
  const cwdList = [[_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, [ignoreList]]];

  while (cwdList.length > 0) {
    const [cwd, ignoreLists] = cwdList.pop();
    const stat = await cwdFs.lstatPromise(cwd);
    if (isIgnored(cwd, {
      globalList,
      ignoreLists: stat.isDirectory() ? null : ignoreLists
    })) continue;

    if (stat.isDirectory()) {
      const entries = await cwdFs.readdirPromise(cwd);
      let hasGitIgnore = false;
      let hasNpmIgnore = false;

      if (!hasExplicitFileList || cwd !== _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root) {
        for (const entry of entries) {
          hasGitIgnore = hasGitIgnore || entry === `.gitignore`;
          hasNpmIgnore = hasNpmIgnore || entry === `.npmignore`;
        }
      }

      const localIgnoreList = hasNpmIgnore ? await loadIgnoreList(cwdFs, cwd, `.npmignore`) : hasGitIgnore ? await loadIgnoreList(cwdFs, cwd, `.gitignore`) : null;
      let nextIgnoreLists = localIgnoreList !== null ? [localIgnoreList].concat(ignoreLists) : ignoreLists;
      if (isIgnored(cwd, {
        globalList,
        ignoreLists
      })) nextIgnoreLists = [...ignoreLists, {
        accept: [],
        reject: [`**/*`]
      }];

      for (const entry of entries) {
        cwdList.push([_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(cwd, entry), nextIgnoreLists]);
      }
    } else {
      list.push(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.PortablePath.root, cwd));
    }
  }

  return list.sort();
}

async function loadIgnoreList(fs, cwd, filename) {
  const ignoreList = {
    accept: [],
    reject: []
  };
  const data = await fs.readFilePromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.join(cwd, filename), `utf8`);

  for (const pattern of data.split(/\n/g)) addIgnorePattern(ignoreList.reject, pattern, {
    cwd
  });

  return ignoreList;
}

function normalizePattern(pattern, {
  cwd
}) {
  const negated = pattern[0] === `!`;
  if (negated) pattern = pattern.slice(1);
  if (pattern.match(/\.{0,1}\//)) pattern = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.ppath.resolve(cwd, pattern);
  if (negated) pattern = `!${pattern}`;
  return pattern;
}

function addIgnorePattern(target, pattern, {
  cwd
}) {
  const trimed = pattern.trim();
  if (trimed === `` || trimed[0] === `#`) return;
  target.push(normalizePattern(trimed, {
    cwd
  }));
}

function isIgnored(cwd, {
  globalList,
  ignoreLists
}) {
  if (isMatch(cwd, globalList.accept)) return false;
  if (isMatch(cwd, globalList.reject)) return true;

  if (ignoreLists !== null) {
    for (const ignoreList of ignoreLists) {
      if (isMatch(cwd, ignoreList.accept)) return false;

      if (isMatch(cwd, ignoreList.reject)) {
        return true;
      }
    }
  }

  return false;
}

function isMatch(path, patterns) {
  let inclusives = patterns;
  const exclusives = [];

  for (let t = 0; t < patterns.length; ++t) {
    if (patterns[t][0] !== `!`) {
      if (inclusives !== patterns) {
        inclusives.push(patterns[t]);
      }
    } else {
      if (inclusives === patterns) inclusives = patterns.slice(0, t);
      exclusives.push(patterns[t].slice(1));
    }
  }

  if (isMatchBasename(path, exclusives)) return false;
  if (isMatchBasename(path, inclusives)) return true;
  return false;
}

function isMatchBasename(path, patterns) {
  let paths = patterns;
  const basenames = [];

  for (let t = 0; t < patterns.length; ++t) {
    if (patterns[t].includes(`/`)) {
      if (paths !== patterns) {
        paths.push(patterns[t]);
      }
    } else {
      if (paths === patterns) paths = patterns.slice(0, t);
      basenames.push(patterns[t]);
    }
  }

  if (micromatch__WEBPACK_IMPORTED_MODULE_0___default().isMatch(path, paths, {
    dot: true,
    nocase: true
  })) return true;
  if (micromatch__WEBPACK_IMPORTED_MODULE_0___default().isMatch(path, basenames, {
    dot: true,
    basename: true,
    nocase: true
  })) return true;
  return false;
}

/***/ }),
/* 706 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


const crypto = __webpack_require__(143)
const figgyPudding = __webpack_require__(707)
const Transform = __webpack_require__(110).Transform

const SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']

const BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i
const SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/
const STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)*$/
const VCHAR_REGEX = /^[\x21-\x7E]+$/

const SsriOpts = figgyPudding({
  algorithms: {default: ['sha512']},
  error: {default: false},
  integrity: {},
  options: {default: []},
  pickAlgorithm: {default: () => getPrioritizedHash},
  Promise: {default: () => Promise},
  sep: {default: ' '},
  single: {default: false},
  size: {},
  strict: {default: false}
})

class Hash {
  get isHash () { return true }
  constructor (hash, opts) {
    opts = SsriOpts(opts)
    const strict = !!opts.strict
    this.source = hash.trim()
    // 3.1. Integrity metadata (called "Hash" by ssri)
    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description
    const match = this.source.match(
      strict
      ? STRICT_SRI_REGEX
      : SRI_REGEX
    )
    if (!match) { return }
    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }
    this.algorithm = match[1]
    this.digest = match[2]

    const rawOpts = match[3]
    this.options = rawOpts ? rawOpts.slice(1).split('?') : []
  }
  hexDigest () {
    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')
  }
  toJSON () {
    return this.toString()
  }
  toString (opts) {
    opts = SsriOpts(opts)
    if (opts.strict) {
      // Strict mode enforces the standard as close to the foot of the
      // letter as it can.
      if (!(
        // The spec has very restricted productions for algorithms.
        // https://www.w3.org/TR/CSP2/#source-list-syntax
        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&
        // Usually, if someone insists on using a "different" base64, we
        // leave it as-is, since there's multiple standards, and the
        // specified is not a URL-safe variant.
        // https://www.w3.org/TR/CSP2/#base64_value
        this.digest.match(BASE64_REGEX) &&
        // Option syntax is strictly visual chars.
        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression
        // https://tools.ietf.org/html/rfc5234#appendix-B.1
        (this.options || []).every(opt => opt.match(VCHAR_REGEX))
      )) {
        return ''
      }
    }
    const options = this.options && this.options.length
    ? `?${this.options.join('?')}`
    : ''
    return `${this.algorithm}-${this.digest}${options}`
  }
}

class Integrity {
  get isIntegrity () { return true }
  toJSON () {
    return this.toString()
  }
  toString (opts) {
    opts = SsriOpts(opts)
    let sep = opts.sep || ' '
    if (opts.strict) {
      // Entries must be separated by whitespace, according to spec.
      sep = sep.replace(/\S+/g, ' ')
    }
    return Object.keys(this).map(k => {
      return this[k].map(hash => {
        return Hash.prototype.toString.call(hash, opts)
      }).filter(x => x.length).join(sep)
    }).filter(x => x.length).join(sep)
  }
  concat (integrity, opts) {
    opts = SsriOpts(opts)
    const other = typeof integrity === 'string'
    ? integrity
    : stringify(integrity, opts)
    return parse(`${this.toString(opts)} ${other}`, opts)
  }
  hexDigest () {
    return parse(this, {single: true}).hexDigest()
  }
  match (integrity, opts) {
    opts = SsriOpts(opts)
    const other = parse(integrity, opts)
    const algo = other.pickAlgorithm(opts)
    return (
      this[algo] &&
      other[algo] &&
      this[algo].find(hash =>
        other[algo].find(otherhash =>
          hash.digest === otherhash.digest
        )
      )
    ) || false
  }
  pickAlgorithm (opts) {
    opts = SsriOpts(opts)
    const pickAlgorithm = opts.pickAlgorithm
    const keys = Object.keys(this)
    if (!keys.length) {
      throw new Error(`No algorithms available for ${
        JSON.stringify(this.toString())
      }`)
    }
    return keys.reduce((acc, algo) => {
      return pickAlgorithm(acc, algo) || acc
    })
  }
}

__webpack_unused_export__ = parse
function parse (sri, opts) {
  opts = SsriOpts(opts)
  if (typeof sri === 'string') {
    return _parse(sri, opts)
  } else if (sri.algorithm && sri.digest) {
    const fullSri = new Integrity()
    fullSri[sri.algorithm] = [sri]
    return _parse(stringify(fullSri, opts), opts)
  } else {
    return _parse(stringify(sri, opts), opts)
  }
}

function _parse (integrity, opts) {
  // 3.4.3. Parse metadata
  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
  if (opts.single) {
    return new Hash(integrity, opts)
  }
  return integrity.trim().split(/\s+/).reduce((acc, string) => {
    const hash = new Hash(string, opts)
    if (hash.algorithm && hash.digest) {
      const algo = hash.algorithm
      if (!acc[algo]) { acc[algo] = [] }
      acc[algo].push(hash)
    }
    return acc
  }, new Integrity())
}

__webpack_unused_export__ = stringify
function stringify (obj, opts) {
  opts = SsriOpts(opts)
  if (obj.algorithm && obj.digest) {
    return Hash.prototype.toString.call(obj, opts)
  } else if (typeof obj === 'string') {
    return stringify(parse(obj, opts), opts)
  } else {
    return Integrity.prototype.toString.call(obj, opts)
  }
}

__webpack_unused_export__ = fromHex
function fromHex (hexDigest, algorithm, opts) {
  opts = SsriOpts(opts)
  const optString = opts.options && opts.options.length
  ? `?${opts.options.join('?')}`
  : ''
  return parse(
    `${algorithm}-${
      Buffer.from(hexDigest, 'hex').toString('base64')
    }${optString}`, opts
  )
}

module.exports.fromData = fromData
function fromData (data, opts) {
  opts = SsriOpts(opts)
  const algorithms = opts.algorithms
  const optString = opts.options && opts.options.length
  ? `?${opts.options.join('?')}`
  : ''
  return algorithms.reduce((acc, algo) => {
    const digest = crypto.createHash(algo).update(data).digest('base64')
    const hash = new Hash(
      `${algo}-${digest}${optString}`,
       opts
    )
    if (hash.algorithm && hash.digest) {
      const algo = hash.algorithm
      if (!acc[algo]) { acc[algo] = [] }
      acc[algo].push(hash)
    }
    return acc
  }, new Integrity())
}

__webpack_unused_export__ = fromStream
function fromStream (stream, opts) {
  opts = SsriOpts(opts)
  const P = opts.Promise || Promise
  const istream = integrityStream(opts)
  return new P((resolve, reject) => {
    stream.pipe(istream)
    stream.on('error', reject)
    istream.on('error', reject)
    let sri
    istream.on('integrity', s => { sri = s })
    istream.on('end', () => resolve(sri))
    istream.on('data', () => {})
  })
}

__webpack_unused_export__ = checkData
function checkData (data, sri, opts) {
  opts = SsriOpts(opts)
  sri = parse(sri, opts)
  if (!Object.keys(sri).length) {
    if (opts.error) {
      throw Object.assign(
        new Error('No valid integrity hashes to check against'), {
          code: 'EINTEGRITY'
        }
      )
    } else {
      return false
    }
  }
  const algorithm = sri.pickAlgorithm(opts)
  const digest = crypto.createHash(algorithm).update(data).digest('base64')
  const newSri = parse({algorithm, digest})
  const match = newSri.match(sri, opts)
  if (match || !opts.error) {
    return match
  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {
    const err = new Error(`data size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${data.length}`)
    err.code = 'EBADSIZE'
    err.found = data.length
    err.expected = opts.size
    err.sri = sri
    throw err
  } else {
    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)
    err.code = 'EINTEGRITY'
    err.found = newSri
    err.expected = sri
    err.algorithm = algorithm
    err.sri = sri
    throw err
  }
}

__webpack_unused_export__ = checkStream
function checkStream (stream, sri, opts) {
  opts = SsriOpts(opts)
  const P = opts.Promise || Promise
  const checker = integrityStream(opts.concat({
    integrity: sri
  }))
  return new P((resolve, reject) => {
    stream.pipe(checker)
    stream.on('error', reject)
    checker.on('error', reject)
    let sri
    checker.on('verified', s => { sri = s })
    checker.on('end', () => resolve(sri))
    checker.on('data', () => {})
  })
}

__webpack_unused_export__ = integrityStream
function integrityStream (opts) {
  opts = SsriOpts(opts)
  // For verification
  const sri = opts.integrity && parse(opts.integrity, opts)
  const goodSri = sri && Object.keys(sri).length
  const algorithm = goodSri && sri.pickAlgorithm(opts)
  const digests = goodSri && sri[algorithm]
  // Calculating stream
  const algorithms = Array.from(
    new Set(opts.algorithms.concat(algorithm ? [algorithm] : []))
  )
  const hashes = algorithms.map(crypto.createHash)
  let streamSize = 0
  const stream = new Transform({
    transform (chunk, enc, cb) {
      streamSize += chunk.length
      hashes.forEach(h => h.update(chunk, enc))
      cb(null, chunk, enc)
    }
  }).on('end', () => {
    const optString = (opts.options && opts.options.length)
    ? `?${opts.options.join('?')}`
    : ''
    const newSri = parse(hashes.map((h, i) => {
      return `${algorithms[i]}-${h.digest('base64')}${optString}`
    }).join(' '), opts)
    // Integrity verification mode
    const match = goodSri && newSri.match(sri, opts)
    if (typeof opts.size === 'number' && streamSize !== opts.size) {
      const err = new Error(`stream size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${streamSize}`)
      err.code = 'EBADSIZE'
      err.found = streamSize
      err.expected = opts.size
      err.sri = sri
      stream.emit('error', err)
    } else if (opts.integrity && !match) {
      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)
      err.code = 'EINTEGRITY'
      err.found = newSri
      err.expected = digests
      err.algorithm = algorithm
      err.sri = sri
      stream.emit('error', err)
    } else {
      stream.emit('size', streamSize)
      stream.emit('integrity', newSri)
      match && stream.emit('verified', match)
    }
  })
  return stream
}

__webpack_unused_export__ = createIntegrity
function createIntegrity (opts) {
  opts = SsriOpts(opts)
  const algorithms = opts.algorithms
  const optString = opts.options.length
  ? `?${opts.options.join('?')}`
  : ''

  const hashes = algorithms.map(crypto.createHash)

  return {
    update: function (chunk, enc) {
      hashes.forEach(h => h.update(chunk, enc))
      return this
    },
    digest: function (enc) {
      const integrity = algorithms.reduce((acc, algo) => {
        const digest = hashes.shift().digest('base64')
        const hash = new Hash(
          `${algo}-${digest}${optString}`,
          opts
        )
        if (hash.algorithm && hash.digest) {
          const algo = hash.algorithm
          if (!acc[algo]) { acc[algo] = [] }
          acc[algo].push(hash)
        }
        return acc
      }, new Integrity())

      return integrity
    }
  }
}

const NODE_HASHES = new Set(crypto.getHashes())

// This is a Best Effort at a reasonable priority for hash algos
const DEFAULT_PRIORITY = [
  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',
  // TODO - it's unclear _which_ of these Node will actually use as its name
  //        for the algorithm, so we guesswork it based on the OpenSSL names.
  'sha3',
  'sha3-256', 'sha3-384', 'sha3-512',
  'sha3_256', 'sha3_384', 'sha3_512'
].filter(algo => NODE_HASHES.has(algo))

function getPrioritizedHash (algo1, algo2) {
  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())
  ? algo1
  : algo2
}


/***/ }),
/* 707 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


class FiggyPudding {
  constructor (specs, opts, providers) {
    this.__specs = specs || {}
    Object.keys(this.__specs).forEach(alias => {
      if (typeof this.__specs[alias] === 'string') {
        const key = this.__specs[alias]
        const realSpec = this.__specs[key]
        if (realSpec) {
          const aliasArr = realSpec.aliases || []
          aliasArr.push(alias, key)
          realSpec.aliases = [...(new Set(aliasArr))]
          this.__specs[alias] = realSpec
        } else {
          throw new Error(`Alias refers to invalid key: ${key} -> ${alias}`)
        }
      }
    })
    this.__opts = opts || {}
    this.__providers = reverse((providers).filter(
      x => x != null && typeof x === 'object'
    ))
    this.__isFiggyPudding = true
  }
  get (key) {
    return pudGet(this, key, true)
  }
  get [Symbol.toStringTag] () { return 'FiggyPudding' }
  forEach (fn, thisArg = this) {
    for (let [key, value] of this.entries()) {
      fn.call(thisArg, value, key, this)
    }
  }
  toJSON () {
    const obj = {}
    this.forEach((val, key) => {
      obj[key] = val
    })
    return obj
  }
  * entries (_matcher) {
    for (let key of Object.keys(this.__specs)) {
      yield [key, this.get(key)]
    }
    const matcher = _matcher || this.__opts.other
    if (matcher) {
      const seen = new Set()
      for (let p of this.__providers) {
        const iter = p.entries ? p.entries(matcher) : entries(p)
        for (let [key, val] of iter) {
          if (matcher(key) && !seen.has(key)) {
            seen.add(key)
            yield [key, val]
          }
        }
      }
    }
  }
  * [Symbol.iterator] () {
    for (let [key, value] of this.entries()) {
      yield [key, value]
    }
  }
  * keys () {
    for (let [key] of this.entries()) {
      yield key
    }
  }
  * values () {
    for (let [, value] of this.entries()) {
      yield value
    }
  }
  concat (...moreConfig) {
    return new Proxy(new FiggyPudding(
      this.__specs,
      this.__opts,
      reverse(this.__providers).concat(moreConfig)
    ), proxyHandler)
  }
}
try {
  const util = __webpack_require__(115)
  FiggyPudding.prototype[util.inspect.custom] = function (depth, opts) {
    return (
      this[Symbol.toStringTag] + ' '
    ) + util.inspect(this.toJSON(), opts)
  }
} catch (e) {}

function BadKeyError (key) {
  throw Object.assign(new Error(
    `invalid config key requested: ${key}`
  ), {code: 'EBADKEY'})
}

function pudGet (pud, key, validate) {
  let spec = pud.__specs[key]
  if (validate && !spec && (!pud.__opts.other || !pud.__opts.other(key))) {
    BadKeyError(key)
  } else {
    if (!spec) { spec = {} }
    let ret
    for (let p of pud.__providers) {
      ret = tryGet(key, p)
      if (ret === undefined && spec.aliases && spec.aliases.length) {
        for (let alias of spec.aliases) {
          if (alias === key) { continue }
          ret = tryGet(alias, p)
          if (ret !== undefined) {
            break
          }
        }
      }
      if (ret !== undefined) {
        break
      }
    }
    if (ret === undefined && spec.default !== undefined) {
      if (typeof spec.default === 'function') {
        return spec.default(pud)
      } else {
        return spec.default
      }
    } else {
      return ret
    }
  }
}

function tryGet (key, p) {
  let ret
  if (p.__isFiggyPudding) {
    ret = pudGet(p, key, false)
  } else if (typeof p.get === 'function') {
    ret = p.get(key)
  } else {
    ret = p[key]
  }
  return ret
}

const proxyHandler = {
  has (obj, prop) {
    return prop in obj.__specs && pudGet(obj, prop, false) !== undefined
  },
  ownKeys (obj) {
    return Object.keys(obj.__specs)
  },
  get (obj, prop) {
    if (
      typeof prop === 'symbol' ||
      prop.slice(0, 2) === '__' ||
      prop in FiggyPudding.prototype
    ) {
      return obj[prop]
    }
    return obj.get(prop)
  },
  set (obj, prop, value) {
    if (
      typeof prop === 'symbol' ||
      prop.slice(0, 2) === '__'
    ) {
      obj[prop] = value
      return true
    } else {
      throw new Error('figgyPudding options cannot be modified. Use .concat() instead.')
    }
  },
  deleteProperty () {
    throw new Error('figgyPudding options cannot be deleted. Use .concat() and shadow them instead.')
  }
}

module.exports = figgyPudding
function figgyPudding (specs, opts) {
  function factory (...providers) {
    return new Proxy(new FiggyPudding(
      specs,
      opts,
      providers
    ), proxyHandler)
  }
  return factory
}

function reverse (arr) {
  const ret = []
  arr.forEach(x => ret.unshift(x))
  return ret
}

function entries (obj) {
  return Object.keys(obj).map(k => [k, obj[k]])
}


/***/ }),
/* 708 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ NpmWhoamiCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(689);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);





 // eslint-disable-next-line arca/no-default-export

class NpmWhoamiCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  constructor() {
    super(...arguments);
    this.publish = false;
  }

  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    let registry;
    if (this.scope && this.publish) registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getScopeRegistry(this.scope, {
      configuration,
      type: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.RegistryType.PUBLISH_REGISTRY
    });else if (this.scope) registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getScopeRegistry(this.scope, {
      configuration
    });else if (this.publish) registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getPublishRegistry((await (0,_yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.openWorkspace)(configuration, this.context.cwd)).manifest, {
      configuration
    });else registry = _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmConfigUtils.getDefaultRegistry({
      configuration
    });
    const report = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      try {
        const response = await _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.get(`/-/whoami`, {
          configuration,
          registry,
          authType: _yarnpkg_plugin_npm__WEBPACK_IMPORTED_MODULE_1__.npmHttpUtils.AuthType.ALWAYS_AUTH,
          json: true
        });
        report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.UNNAMED, response.username);
      } catch (err) {
        if (err.name !== `HTTPError`) {
          throw err;
        } else if (err.response.statusCode === 401 || err.response.statusCode === 403) {
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.AUTHENTICATION_INVALID, `Authentication failed - your credentials may have expired`);
        } else {
          report.reportError(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.MessageName.AUTHENTICATION_INVALID, err.toString());
        }
      }
    });
    return report.exitCode();
  }

}
NpmWhoamiCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Usage({
  category: `Npm-related commands`,
  description: `display the name of the authenticated user`,
  details: `
      Print the username associated with the current authentication settings to the standard output.

      When using \`-s,--scope\`, the username printed will be the one that matches the authentication settings of the registry associated with the given scope (those settings can be overriden using the \`npmRegistries\` map, and the registry associated with the scope is configured via the \`npmScopes\` map).

      When using \`--publish\`, the registry we'll select will by default be the one used when publishing packages (\`publishConfig.registry\` or \`npmPublishRegistry\` if available, otherwise we'll fallback to the regular \`npmRegistryServer\`).
    `,
  examples: [[`Print username for the default registry`, `yarn npm whoami`], [`Print username for the registry on a given scope`, `yarn npm whoami --scope company`]]
});

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.String(`-s,--scope`)], NpmWhoamiCommand.prototype, "scope", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Boolean(`--publish`)], NpmWhoamiCommand.prototype, "publish", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_2__.Command.Path(`npm`, `whoami`)], NpmWhoamiCommand.prototype, "execute", null);

/***/ }),
/* 709 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "patchUtils": () => /* reexport module object */ _patchUtils__WEBPACK_IMPORTED_MODULE_4__,
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _PatchFetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(710);
/* harmony import */ var _PatchResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(714);
/* harmony import */ var _commands_patchCommit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(715);
/* harmony import */ var _commands_patch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(716);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(711);






const plugin = {
  commands: [_commands_patchCommit__WEBPACK_IMPORTED_MODULE_2__.default, _commands_patch__WEBPACK_IMPORTED_MODULE_3__.default],
  fetchers: [_PatchFetcher__WEBPACK_IMPORTED_MODULE_0__.PatchFetcher],
  resolvers: [_PatchResolver__WEBPACK_IMPORTED_MODULE_1__.PatchResolver]
}; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);

/***/ }),
/* 710 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PatchFetcher": () => /* binding */ PatchFetcher
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(206);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(114);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(209);
/* harmony import */ var _yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(711);




class PatchFetcher {
  supports(locator, opts) {
    if (!locator.reference.startsWith(`patch:`)) return false;
    return true;
  }

  getLocalPath(locator, opts) {
    return null;
  }

  async fetch(locator, opts) {
    const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
    const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
      onHit: () => opts.report.reportCacheHit(locator),
      onMiss: () => opts.report.reportCacheMiss(locator, `${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
      loader: () => this.patchPackage(locator, opts),
      skipIntegrityCheck: opts.skipIntegrityCheck
    });
    return {
      packageFs,
      releaseFs,
      prefixPath: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.getIdentVendorPath(locator),
      localPath: this.getLocalPath(locator, opts),
      checksum
    };
  }

  async patchPackage(locator, opts) {
    const {
      parentLocator,
      sourceLocator,
      sourceVersion,
      patchPaths
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_1__.parseLocator(locator);
    const patchFiles = await _patchUtils__WEBPACK_IMPORTED_MODULE_1__.loadPatchFiles(parentLocator, patchPaths, opts);
    const tmpDir = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.xfs.mktempPromise();
    const tmpFile = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.join(tmpDir, `patched.zip`);
    const sourceFetch = await opts.fetcher.fetch(sourceLocator, opts);
    const prefixPath = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.getIdentVendorPath(locator);
    const libzip = await (0,_yarnpkg_libzip__WEBPACK_IMPORTED_MODULE_0__.getLibzipPromise)();
    const copiedPackage = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ZipFS(tmpFile, {
      libzip,
      create: true,
      level: opts.project.configuration.get(`compressionLevel`)
    });
    await copiedPackage.mkdirpPromise(prefixPath);
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.miscUtils.releaseAfterUseAsync(async () => {
      await copiedPackage.copyPromise(prefixPath, sourceFetch.prefixPath, {
        baseFs: sourceFetch.packageFs,
        stableSort: true
      });
    }, sourceFetch.releaseFs);
    copiedPackage.saveAndClose();
    const patchedPackage = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.ZipFS(tmpFile, {
      libzip,
      level: opts.project.configuration.get(`compressionLevel`)
    });
    const patchFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.PortablePath.root, prefixPath), {
      baseFs: patchedPackage
    });

    for (const patchFile of patchFiles) {
      if (patchFile !== null) {
        await _patchUtils__WEBPACK_IMPORTED_MODULE_1__.applyPatchFile(_patchUtils__WEBPACK_IMPORTED_MODULE_1__.parsePatchFile(patchFile), {
          baseFs: patchFs,
          version: sourceVersion
        });
      }
    }

    return patchedPackage;
  }

}

/***/ }),
/* 711 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPatchFile": () => /* reexport safe */ _tools_apply__WEBPACK_IMPORTED_MODULE_0__.applyPatchFile,
/* harmony export */   "parsePatchFile": () => /* reexport safe */ _tools_parse__WEBPACK_IMPORTED_MODULE_1__.parsePatchFile,
/* harmony export */   "parseDescriptor": () => /* binding */ parseDescriptor,
/* harmony export */   "parseLocator": () => /* binding */ parseLocator,
/* harmony export */   "makeDescriptor": () => /* binding */ makeDescriptor,
/* harmony export */   "makeLocator": () => /* binding */ makeLocator,
/* harmony export */   "isParentRequired": () => /* binding */ isParentRequired,
/* harmony export */   "loadPatchFiles": () => /* binding */ loadPatchFiles,
/* harmony export */   "extractPackageToDisk": () => /* binding */ extractPackageToDisk,
/* harmony export */   "diffFolders": () => /* binding */ diffFolders
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(250);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(209);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(206);
/* harmony import */ var _tools_apply__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(712);
/* harmony import */ var _tools_parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(713);




const BUILTIN_REGEXP = /^builtin<([^>]+)>$/;

function parseSpec(spec, sourceParser) {
  const {
    source,
    selector,
    params
  } = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseRange(spec);
  if (source === null) throw new Error(`Patch locators must explicitly define their source`);
  const patchPaths = selector ? selector.split(/&/).map(path => _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(path)) : [];
  const parentLocator = params && typeof params.locator === `string` ? _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseLocator(params.locator) : null;
  const sourceVersion = params && typeof params.version === `string` ? params.version : null;
  const sourceItem = sourceParser(source);
  return {
    parentLocator,
    sourceItem,
    patchPaths,
    sourceVersion
  };
}

function parseDescriptor(descriptor) {
  const {
    sourceItem,
    ...rest
  } = parseSpec(descriptor.range, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseDescriptor);
  return { ...rest,
    sourceDescriptor: sourceItem
  };
}
function parseLocator(locator) {
  const {
    sourceItem,
    ...rest
  } = parseSpec(locator.reference, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.parseLocator);
  return { ...rest,
    sourceLocator: sourceItem
  };
}

function makeSpec({
  parentLocator,
  sourceItem,
  patchPaths,
  sourceVersion,
  patchHash
}, sourceStringifier) {
  const parentLocatorSpread = parentLocator !== null ? {
    locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.stringifyLocator(parentLocator)
  } : {};
  const sourceVersionSpread = typeof sourceVersion !== `undefined` ? {
    version: sourceVersion
  } : {};
  const patchHashSpread = typeof patchHash !== `undefined` ? {
    hash: patchHash
  } : {};
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.makeRange({
    protocol: `patch:`,
    source: sourceStringifier(sourceItem),
    selector: patchPaths.join(`&`),
    params: { ...sourceVersionSpread,
      ...patchHashSpread,
      ...parentLocatorSpread
    }
  });
}

function makeDescriptor(ident, {
  parentLocator,
  sourceDescriptor,
  patchPaths
}) {
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.makeLocator(ident, makeSpec({
    parentLocator,
    sourceItem: sourceDescriptor,
    patchPaths
  }, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.stringifyDescriptor));
}
function makeLocator(ident, {
  parentLocator,
  sourcePackage,
  patchPaths,
  patchHash
}) {
  return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.makeLocator(ident, makeSpec({
    parentLocator,
    sourceItem: sourcePackage,
    sourceVersion: sourcePackage.version,
    patchPaths,
    patchHash
  }, _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.stringifyLocator));
}

function visitPatchPath({
  onAbsolute,
  onRelative,
  onBuiltin
}, patchPath) {
  const builtinMatch = patchPath.match(BUILTIN_REGEXP);
  if (builtinMatch !== null) return onBuiltin(builtinMatch[1]);

  if (_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.isAbsolute(patchPath)) {
    return onAbsolute(patchPath);
  } else {
    return onRelative(patchPath);
  }
}

function isParentRequired(patchPath) {
  return visitPatchPath({
    onAbsolute: () => false,
    onRelative: () => true,
    onBuiltin: () => false
  }, patchPath);
}
async function loadPatchFiles(parentLocator, patchPaths, opts) {
  // When the patch files use absolute paths we can directly access them via
  // their location on the disk. Otherwise we must go through the package fs.
  const parentFetch = parentLocator !== null ? await opts.fetcher.fetch(parentLocator, opts) : null; // If the package fs publicized its "original location" (for example like
  // in the case of "file:" packages), we use it to derive the real location.

  const effectiveParentFetch = parentFetch && parentFetch.localPath ? {
    packageFs: new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_4__.CwdFS(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.PortablePath.root),
    prefixPath: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.PortablePath.root, parentFetch.localPath)
  } : parentFetch; // Discard the parent fs unless we really need it to access the files

  if (parentFetch && parentFetch !== effectiveParentFetch && parentFetch.releaseFs) parentFetch.releaseFs(); // First we obtain the specification for all the patches that we'll have to
  // apply to the original package.

  const patchFiles = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.miscUtils.releaseAfterUseAsync(async () => {
    return await Promise.all(patchPaths.map(async patchPath => visitPatchPath({
      onAbsolute: async () => {
        return await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.readFilePromise(patchPath, `utf8`);
      },
      onRelative: async () => {
        if (parentFetch === null) throw new Error(`Assertion failed: The parent locator should have been fetched`);
        return await parentFetch.packageFs.readFilePromise(patchPath, `utf8`);
      },
      onBuiltin: async name => {
        return await opts.project.configuration.firstHook(hooks => {
          return hooks.getBuiltinPatch;
        }, opts.project, name);
      }
    }, patchPath)));
  }); // Normalizes the line endings to prevent mismatches when cloning a
  // repository on Windows systems (the default settings for Git are to
  // convert newlines back and forth, which would mess with the checksum)

  return patchFiles.map(definition => {
    if (typeof definition === `string`) {
      return definition.replace(/\r\n?/g, `\n`);
    } else {
      return definition;
    }
  });
}
async function extractPackageToDisk(locator, {
  cache,
  project
}) {
  const checksums = project.storedChecksums;
  const report = new _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.ThrowReport();
  const fetcher = project.configuration.makeFetcher();
  const fetchResult = await fetcher.fetch(locator, {
    cache,
    project,
    fetcher,
    checksums,
    report
  });
  const temp = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.mktempPromise();
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.copyPromise(temp, fetchResult.prefixPath, {
    baseFs: fetchResult.packageFs
  });
  await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.writeJsonPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.ppath.join(temp, `.yarn-patch.json`), {
    locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.structUtils.stringifyLocator(locator)
  });
  _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_5__.xfs.detachTemp(temp);
  return temp;
}
async function diffFolders(folderA, folderB) {
  const folderAN = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(folderA).replace(/\\/g, `/`);
  const folderBN = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.fromPortablePath(folderB).replace(/\\/g, `/`);
  const {
    stdout
  } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.execUtils.execvp(`git`, [`diff`, `--src-prefix=a/`, `--dst-prefix=b/`, `--ignore-cr-at-eol`, `--full-index`, `--no-index`, folderAN, folderBN], {
    cwd: _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_3__.npath.toPortablePath(process.cwd())
  });
  const normalizePath = folderAN.startsWith(`/`) ? p => p.slice(1) : p => p;
  return stdout.replace(new RegExp(`(a|b)(${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.miscUtils.escapeRegExp(`/${normalizePath(folderAN)}/`)})`, `g`), `$1/`).replace(new RegExp(`(a|b)${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.miscUtils.escapeRegExp(`/${normalizePath(folderBN)}/`)}`, `g`), `$1/`).replace(new RegExp(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.miscUtils.escapeRegExp(`${folderAN}/`), `g`), ``).replace(new RegExp(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_2__.miscUtils.escapeRegExp(`${folderBN}/`), `g`), ``);
}

/***/ }),
/* 712 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPatchFile": () => /* binding */ applyPatchFile
/* harmony export */ });
/* unused harmony export applyPatch */
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);


const DEFAULT_TIME = 315532800;

async function preserveTime(baseFs, p, cb) {
  const stat = await baseFs.lstatPromise(p);
  const result = await cb();
  if (typeof result !== `undefined`) p = result;

  if (baseFs.lutimesPromise) {
    await baseFs.lutimesPromise(p, stat.atime, stat.mtime);
  } else if (!stat.isSymbolicLink()) {
    await baseFs.utimesPromise(p, stat.atime, stat.mtime);
  } else {
    throw new Error(`Cannot preserve the time values of a symlink`);
  }
}

async function applyPatchFile(effects, {
  baseFs = new _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.NodeFS(),
  dryRun = false,
  version = null
} = {}) {
  for (const eff of effects) {
    if (eff.semverExclusivity !== null && version !== null) if (!_yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.semverUtils.satisfiesWithPrereleases(version, eff.semverExclusivity)) continue;

    switch (eff.type) {
      case `file deletion`:
        {
          if (dryRun) {
            if (!baseFs.existsSync(eff.path)) {
              throw new Error(`Trying to delete file that doesn't exist: ${eff.path}`);
            }
          } else {
            await preserveTime(baseFs, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(eff.path), async () => {
              await baseFs.unlinkPromise(eff.path);
            });
          }
        }
        break;

      case `rename`:
        {
          if (dryRun) {
            if (!baseFs.existsSync(eff.fromPath)) {
              throw new Error(`Trying to move file that doesn't exist: ${eff.fromPath}`);
            }
          } else {
            await preserveTime(baseFs, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(eff.fromPath), async () => {
              await preserveTime(baseFs, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(eff.toPath), async () => {
                await preserveTime(baseFs, eff.fromPath, async () => {
                  await baseFs.movePromise(eff.fromPath, eff.toPath);
                  return eff.toPath;
                });
              });
            });
          }
        }
        break;

      case `file creation`:
        {
          if (dryRun) {
            if (baseFs.existsSync(eff.path)) {
              throw new Error(`Trying to create file that already exists: ${eff.path}`);
            }
          } else {
            const fileContents = eff.hunk ? eff.hunk.parts[0].lines.join(`\n`) + (eff.hunk.parts[0].noNewlineAtEndOfFile ? `` : `\n`) : ``; // Todo: the parent of the first directory thus created will still see its mtime changed

            await baseFs.mkdirpPromise(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_2__.ppath.dirname(eff.path), {
              chmod: 0o755,
              utimes: [DEFAULT_TIME, DEFAULT_TIME]
            });
            await baseFs.writeFilePromise(eff.path, fileContents, {
              mode: eff.mode
            });
            await baseFs.utimesPromise(eff.path, DEFAULT_TIME, DEFAULT_TIME);
          }
        }
        break;

      case `patch`:
        {
          await preserveTime(baseFs, eff.path, async () => {
            await applyPatch(eff, {
              baseFs,
              dryRun
            });
          });
        }
        break;

      case `mode change`:
        {
          const currentStat = await baseFs.statPromise(eff.path);
          const currentMode = currentStat.mode;
          if (isExecutable(eff.newMode) !== isExecutable(currentMode)) continue;
          await preserveTime(baseFs, eff.path, async () => {
            await baseFs.chmodPromise(eff.path, eff.newMode);
          });
        }
        break;

      default:
        {
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.assertNever(eff);
        }
        break;
    }
  }
}

function isExecutable(fileMode) {
  return (fileMode & 0o100) > 0;
}

function trimRight(s) {
  return s.replace(/\s+$/, ``);
}

function linesAreEqual(a, b) {
  return trimRight(a) === trimRight(b);
}
/**
 * How does noNewLineAtEndOfFile work?
 *
 * if you remove the newline from a file that had one without editing other bits:
 *
 *    it creates an insertion/removal pair where the insertion has \ No new line at end of file
 *
 * if you edit a file that didn't have a new line and don't add one:
 *
 *    both insertion and deletion have \ No new line at end of file
 *
 * if you edit a file that didn't have a new line and add one:
 *
 *    deletion has \ No new line at end of file
 *    but not insertion
 *
 * if you edit a file that had a new line and leave it in:
 *
 *    neither insetion nor deletion have the annoation
 *
 */


async function applyPatch({
  hunks,
  path
}, {
  baseFs,
  dryRun = false
}) {
  const mode = await baseFs.statSync(path).mode;
  const fileContents = await baseFs.readFileSync(path, `utf8`);
  const fileLines = fileContents.split(/\n/);
  const result = [];
  let fixupOffset = 0;
  let maxFrozenLine = 0;

  for (const hunk of hunks) {
    const firstGuess = Math.max(maxFrozenLine, hunk.header.patched.start + fixupOffset);
    const maxPrefixFuzz = Math.max(0, firstGuess - maxFrozenLine);
    const maxSuffixFuzz = Math.max(0, fileLines.length - firstGuess - hunk.header.original.length);
    const maxFuzz = Math.max(maxPrefixFuzz, maxSuffixFuzz);
    let offset = 0;
    let location = 0;
    let modifications = null;

    while (offset <= maxFuzz) {
      if (offset <= maxPrefixFuzz) {
        location = firstGuess - offset;
        modifications = evaluateHunk(hunk, fileLines, location);

        if (modifications !== null) {
          offset = -offset;
          break;
        }
      }

      if (offset <= maxSuffixFuzz) {
        location = firstGuess + offset;
        modifications = evaluateHunk(hunk, fileLines, location);

        if (modifications !== null) {
          break;
        }
      }

      offset += 1;
    }

    if (modifications === null) throw new Error(`Cannot apply hunk #${hunks.indexOf(hunk) + 1}`);
    result.push(modifications);
    fixupOffset += offset;
    maxFrozenLine = location + hunk.header.original.length;
  }

  if (dryRun) return;
  let diffOffset = 0;

  for (const modifications of result) {
    for (const modification of modifications) {
      switch (modification.type) {
        case `splice`:
          {
            const firstLine = modification.index + diffOffset;
            fileLines.splice(firstLine, modification.numToDelete, ...modification.linesToInsert);
            diffOffset += modification.linesToInsert.length - modification.numToDelete;
          }
          break;

        case `pop`:
          {
            fileLines.pop();
          }
          break;

        case `push`:
          {
            fileLines.push(modification.line);
          }
          break;

        default:
          {
            _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.assertNever(modification);
          }
          break;
      }
    }
  }

  await baseFs.writeFilePromise(path, fileLines.join(`\n`), {
    mode
  });
}

function evaluateHunk(hunk, fileLines, offset) {
  const result = [];

  for (const part of hunk.parts) {
    switch (part.type) {
      case `deletion`:
      case `context`:
        {
          for (const line of part.lines) {
            const originalLine = fileLines[offset];
            if (originalLine == null || !linesAreEqual(originalLine, line)) return null;
            offset += 1;
          }

          if (part.type === `deletion`) {
            result.push({
              type: `splice`,
              index: offset - part.lines.length,
              numToDelete: part.lines.length,
              linesToInsert: []
            });

            if (part.noNewlineAtEndOfFile) {
              result.push({
                type: `push`,
                line: ``
              });
            }
          }
        }
        break;

      case `insertion`:
        {
          result.push({
            type: `splice`,
            index: offset,
            numToDelete: 0,
            linesToInsert: part.lines
          });

          if (part.noNewlineAtEndOfFile) {
            result.push({
              type: `pop`
            });
          }
        }
        break;

      default:
        {
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.assertNever(part.type);
        }
        break;
    }
  }

  return result;
}

/***/ }),
/* 713 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parsePatchFile": () => /* binding */ parsePatchFile
/* harmony export */ });
/* unused harmony exports getPath, parseHunkHeaderLine, NON_EXECUTABLE_FILE_MODE, EXECUTABLE_FILE_MODE, interpretParsedPatchFile, verifyHunkIntegrity */
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);


const HEADER_REGEXP = /^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@.*/;
function getPath(p) {
  return _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.relative(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.ppath.resolve(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.PortablePath.root, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_0__.npath.toPortablePath(p)));
}
function parseHunkHeaderLine(headerLine) {
  const match = headerLine.trim().match(HEADER_REGEXP);
  if (!match) throw new Error(`Bad header line: '${headerLine}'`);
  return {
    original: {
      start: Math.max(Number(match[1]), 1),
      length: Number(match[3] || 1)
    },
    patched: {
      start: Math.max(Number(match[4]), 1),
      length: Number(match[6] || 1)
    }
  };
}
const NON_EXECUTABLE_FILE_MODE = 0o644;
const EXECUTABLE_FILE_MODE = 0o755;

const emptyFilePatch = () => ({
  semverExclusivity: null,
  diffLineFromPath: null,
  diffLineToPath: null,
  oldMode: null,
  newMode: null,
  deletedFileMode: null,
  newFileMode: null,
  renameFrom: null,
  renameTo: null,
  beforeHash: null,
  afterHash: null,
  fromPath: null,
  toPath: null,
  hunks: null
});

const emptyHunk = headerLine => ({
  header: parseHunkHeaderLine(headerLine),
  parts: []
});

const hunkLinetypes = {
  [`@`]: `header`,
  [`-`]: `deletion`,
  [`+`]: `insertion`,
  [` `]: `context`,
  [`\\`]: `pragma`,
  // Treat blank lines as context
  undefined: `context`
};

function parsePatchLines(lines) {
  const result = [];
  let currentFilePatch = emptyFilePatch();
  let state = `parsing header`;
  let currentHunk = null;
  let currentHunkMutationPart = null;

  function commitHunk() {
    if (currentHunk) {
      if (currentHunkMutationPart) {
        currentHunk.parts.push(currentHunkMutationPart);
        currentHunkMutationPart = null;
      }

      currentFilePatch.hunks.push(currentHunk);
      currentHunk = null;
    }
  }

  function commitFilePatch() {
    commitHunk();
    result.push(currentFilePatch);
    currentFilePatch = emptyFilePatch();
  }

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (state === `parsing header`) {
      if (line.startsWith(`@@`)) {
        state = `parsing hunks`;
        currentFilePatch.hunks = [];
        i -= 1;
      } else if (line.startsWith(`diff --git `)) {
        if (currentFilePatch && currentFilePatch.diffLineFromPath) commitFilePatch();
        const match = line.match(/^diff --git a\/(.*?) b\/(.*?)\s*$/);
        if (!match) throw new Error(`Bad diff line: ${line}`);
        currentFilePatch.diffLineFromPath = match[1];
        currentFilePatch.diffLineToPath = match[2];
      } else if (line.startsWith(`old mode `)) {
        currentFilePatch.oldMode = line.slice(`old mode `.length).trim();
      } else if (line.startsWith(`new mode `)) {
        currentFilePatch.newMode = line.slice(`new mode `.length).trim();
      } else if (line.startsWith(`deleted file mode `)) {
        currentFilePatch.deletedFileMode = line.slice(`deleted file mode `.length).trim();
      } else if (line.startsWith(`new file mode `)) {
        currentFilePatch.newFileMode = line.slice(`new file mode `.length).trim();
      } else if (line.startsWith(`rename from `)) {
        currentFilePatch.renameFrom = line.slice(`rename from `.length).trim();
      } else if (line.startsWith(`rename to `)) {
        currentFilePatch.renameTo = line.slice(`rename to `.length).trim();
      } else if (line.startsWith(`index `)) {
        const match = line.match(/(\w+)\.\.(\w+)/);
        if (!match) continue;
        currentFilePatch.beforeHash = match[1];
        currentFilePatch.afterHash = match[2];
      } else if (line.startsWith(`semver exclusivity `)) {
        currentFilePatch.semverExclusivity = line.slice(`semver exclusivity `.length).trim();
      } else if (line.startsWith(`--- `)) {
        currentFilePatch.fromPath = line.slice(`--- a/`.length).trim();
      } else if (line.startsWith(`+++ `)) {
        currentFilePatch.toPath = line.slice(`+++ b/`.length).trim();
      }
    } else {
      // parsing hunks
      const lineType = hunkLinetypes[line[0]] || null;

      switch (lineType) {
        case `header`:
          {
            commitHunk();
            currentHunk = emptyHunk(line);
          }
          break;

        case null:
          {
            // unrecognized, bail out
            state = `parsing header`;
            commitFilePatch();
            i -= 1;
          }
          break;

        case `pragma`:
          {
            if (!line.startsWith(`\\ No newline at end of file`)) throw new Error(`Unrecognized pragma in patch file: ${line}`);
            if (!currentHunkMutationPart) throw new Error(`Bad parser state: No newline at EOF pragma encountered without context`);
            currentHunkMutationPart.noNewlineAtEndOfFile = true;
          }
          break;

        case `insertion`:
        case `deletion`:
        case `context`:
          {
            if (!currentHunk) throw new Error(`Bad parser state: Hunk lines encountered before hunk header`);

            if (currentHunkMutationPart && currentHunkMutationPart.type !== lineType) {
              currentHunk.parts.push(currentHunkMutationPart);
              currentHunkMutationPart = null;
            }

            if (!currentHunkMutationPart) {
              currentHunkMutationPart = {
                type: lineType,
                lines: [],
                noNewlineAtEndOfFile: false
              };
            }

            currentHunkMutationPart.lines.push(line.slice(1));
          }
          break;

        default:
          {
            _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.assertNever(lineType);
          }
          break;
      }
    }
  }

  commitFilePatch();

  for (const {
    hunks
  } of result) if (hunks) for (const hunk of hunks) verifyHunkIntegrity(hunk);

  return result;
}

function interpretParsedPatchFile(files) {
  const result = [];

  for (const file of files) {
    const {
      semverExclusivity,
      diffLineFromPath,
      diffLineToPath,
      oldMode,
      newMode,
      deletedFileMode,
      newFileMode,
      renameFrom,
      renameTo,
      beforeHash,
      afterHash,
      fromPath,
      toPath,
      hunks
    } = file;
    const type = renameFrom ? `rename` : deletedFileMode ? `file deletion` : newFileMode ? `file creation` : hunks && hunks.length > 0 ? `patch` : `mode change`;
    let destinationFilePath = null;

    switch (type) {
      case `rename`:
        {
          if (!renameFrom || !renameTo) throw new Error(`Bad parser state: rename from & to not given`);
          result.push({
            type: `rename`,
            semverExclusivity,
            fromPath: getPath(renameFrom),
            toPath: getPath(renameTo)
          });
          destinationFilePath = renameTo;
        }
        break;

      case `file deletion`:
        {
          const path = diffLineFromPath || fromPath;
          if (!path) throw new Error(`Bad parse state: no path given for file deletion`);
          result.push({
            type: `file deletion`,
            semverExclusivity,
            hunk: hunks && hunks[0] || null,
            path: getPath(path),
            mode: parseFileMode(deletedFileMode),
            hash: beforeHash
          });
        }
        break;

      case `file creation`:
        {
          const path = diffLineToPath || toPath;
          if (!path) throw new Error(`Bad parse state: no path given for file creation`);
          result.push({
            type: `file creation`,
            semverExclusivity,
            hunk: hunks && hunks[0] || null,
            path: getPath(path),
            mode: parseFileMode(newFileMode),
            hash: afterHash
          });
        }
        break;

      case `patch`:
      case `mode change`:
        {
          destinationFilePath = toPath || diffLineToPath;
        }
        break;

      default:
        {
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.assertNever(type);
        }
        break;
    }

    if (destinationFilePath && oldMode && newMode && oldMode !== newMode) {
      result.push({
        type: `mode change`,
        semverExclusivity,
        path: getPath(destinationFilePath),
        oldMode: parseFileMode(oldMode),
        newMode: parseFileMode(newMode)
      });
    }

    if (destinationFilePath && hunks && hunks.length) {
      result.push({
        type: `patch`,
        semverExclusivity,
        path: getPath(destinationFilePath),
        hunks,
        beforeHash,
        afterHash
      });
    }
  }

  return result;
}

function parseFileMode(mode) {
  const parsedMode = parseInt(mode, 8) & 0o777;
  if (parsedMode !== NON_EXECUTABLE_FILE_MODE && parsedMode !== EXECUTABLE_FILE_MODE) throw new Error(`Unexpected file mode string: ${mode}`);
  return parsedMode;
}

function parsePatchFile(file) {
  const lines = file.split(/\n/g);
  if (lines[lines.length - 1] === ``) lines.pop();
  return interpretParsedPatchFile(parsePatchLines(lines));
}
function verifyHunkIntegrity(hunk) {
  // verify hunk integrity
  let originalLength = 0;
  let patchedLength = 0;

  for (const {
    type,
    lines
  } of hunk.parts) {
    switch (type) {
      case `context`:
        {
          patchedLength += lines.length;
          originalLength += lines.length;
        }
        break;

      case `deletion`:
        {
          originalLength += lines.length;
        }
        break;

      case `insertion`:
        {
          patchedLength += lines.length;
        }
        break;

      default:
        {
          _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.miscUtils.assertNever(type);
        }
        break;
    }
  }

  if (originalLength !== hunk.header.original.length || patchedLength !== hunk.header.patched.length) {
    const format = n => n < 0 ? n : `+${n}`;

    throw new Error(`hunk header integrity check failed (expected @@ ${format(hunk.header.original.length)} ${format(hunk.header.patched.length)} @@, got @@ ${format(originalLength)} ${format(patchedLength)} @@)`);
  }
}

/***/ }),
/* 714 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PatchResolver": () => /* binding */ PatchResolver
/* harmony export */ });
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(711);


 // We use this to for the patches to be regenerated without bumping the whole
// cache, like when the libzip had incorrect mtime in some cases

const CACHE_VERSION = 2;
class PatchResolver {
  supportsDescriptor(descriptor, opts) {
    if (!descriptor.range.startsWith(`patch:`)) return false;
    return true;
  }

  supportsLocator(locator, opts) {
    if (!locator.reference.startsWith(`patch:`)) return false;
    return true;
  }

  shouldPersistResolution(locator, opts) {
    return false;
  }

  bindDescriptor(descriptor, fromLocator, opts) {
    // If the patch is statically defined (ie absolute or a builtin), then we
    // don't need to bind the descriptor to its parent
    const {
      patchPaths
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_0__.parseDescriptor(descriptor);
    if (patchPaths.every(patchPath => !_patchUtils__WEBPACK_IMPORTED_MODULE_0__.isParentRequired(patchPath))) return descriptor;
    return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.bindDescriptor(descriptor, {
      locator: _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.structUtils.stringifyLocator(fromLocator)
    });
  }

  getResolutionDependencies(descriptor, opts) {
    const {
      sourceDescriptor
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_0__.parseDescriptor(descriptor);
    return [sourceDescriptor];
  }

  async getCandidates(descriptor, dependencies, opts) {
    if (!opts.fetchOptions) throw new Error(`Assertion failed: This resolver cannot be used unless a fetcher is configured`);
    const {
      parentLocator,
      sourceDescriptor,
      patchPaths
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_0__.parseDescriptor(descriptor);
    const patchFiles = await _patchUtils__WEBPACK_IMPORTED_MODULE_0__.loadPatchFiles(parentLocator, patchPaths, opts.fetchOptions);
    const sourcePackage = dependencies.get(sourceDescriptor.descriptorHash);
    if (typeof sourcePackage === `undefined`) throw new Error(`Assertion failed: The dependency should have been resolved`);
    const patchHash = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_1__.hashUtils.makeHash(`${CACHE_VERSION}`, ...patchFiles).slice(0, 6);
    return [_patchUtils__WEBPACK_IMPORTED_MODULE_0__.makeLocator(descriptor, {
      parentLocator,
      sourcePackage,
      patchPaths,
      patchHash
    })];
  }

  async resolve(locator, opts) {
    const {
      sourceLocator
    } = _patchUtils__WEBPACK_IMPORTED_MODULE_0__.parseLocator(locator);
    const sourcePkg = await opts.resolver.resolve(sourceLocator, opts);
    return { ...sourcePkg,
      ...locator
    };
  }

}

/***/ }),
/* 715 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PatchCommitCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(112);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(206);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(711);





 // eslint-disable-next-line arca/no-default-export

class PatchCommitCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState();
    const folderPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.resolve(this.context.cwd, _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.npath.toPortablePath(this.patchFolder));
    const metaPath = _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_6__.ppath.join(folderPath, `.yarn-patch.json`);
    if (!_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.existsSync(metaPath)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`The argument folder didn't get created by 'yarn patch'`);
    const meta = await _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_7__.xfs.readJsonPromise(metaPath);
    const locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.structUtils.parseLocator(meta.locator, true);
    if (!project.storedPackages.has(locator.locatorHash)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No package found in the project for the given locator`);
    const originalPath = await _patchUtils__WEBPACK_IMPORTED_MODULE_2__.extractPackageToDisk(locator, {
      cache,
      project
    });
    this.context.stdout.write(await _patchUtils__WEBPACK_IMPORTED_MODULE_2__.diffFolders(originalPath, folderPath));
  }

}
PatchCommitCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `
      This will turn the folder passed in parameter into a patchfile suitable for consumption with the \`patch:\` protocol.

      Only folders generated through \`yarn patch\` are accepted as valid input for \`yarn patch-commit\`.
    `
});

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PatchCommitCommand.prototype, "patchFolder", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_9__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`patch-commit`)], PatchCommitCommand.prototype, "execute", null);

/***/ }),
/* 716 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ PatchCommand
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(10);
/* harmony import */ var _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(314);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(242);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(233);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(232);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(239);
/* harmony import */ var _yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(217);
/* harmony import */ var _yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(112);
/* harmony import */ var clipanion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _patchUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(711);





 // eslint-disable-next-line arca/no-default-export

class PatchCommand extends _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.BaseCommand {
  async execute() {
    const configuration = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_3__.Configuration.find(this.context.cwd, this.context.plugins);
    const {
      project,
      workspace
    } = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_4__.Project.find(configuration, this.context.cwd);
    const cache = await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_5__.Cache.find(configuration);
    if (!workspace) throw new _yarnpkg_cli__WEBPACK_IMPORTED_MODULE_0__.WorkspaceRequiredError(project.cwd, this.context.cwd);
    await project.restoreInstallState();
    let locator = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.parseLocator(this.package);

    if (locator.reference === `unknown`) {
      const candidateLocators = _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.miscUtils.mapAndFilter([...project.storedPackages.values()], pkg => {
        if (pkg.identHash !== locator.identHash) return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.miscUtils.mapAndFilter.skip;
        if (_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.isVirtualLocator(pkg)) return _yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.miscUtils.mapAndFilter.skip;
        return pkg;
      });
      if (candidateLocators.length === 0) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No package found in the project for the given locator`);
      if (candidateLocators.length > 1) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`Multiple candidate packages found; explicitly choose one of them (use \`yarn why <package>\` to get more information as to who depends on them):\n${candidateLocators.map(locator => `\n- ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.prettyLocator(configuration, locator)}`).join(``)}`);
      locator = candidateLocators[0];
    }

    if (!project.storedPackages.has(locator.locatorHash)) throw new clipanion__WEBPACK_IMPORTED_MODULE_1__.UsageError(`No package found in the project for the given locator`);
    await _yarnpkg_core__WEBPACK_IMPORTED_MODULE_7__.StreamReport.start({
      configuration,
      stdout: this.context.stdout
    }, async report => {
      const temp = await _patchUtils__WEBPACK_IMPORTED_MODULE_2__.extractPackageToDisk(locator, {
        cache,
        project
      });
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Package ${_yarnpkg_core__WEBPACK_IMPORTED_MODULE_6__.structUtils.prettyLocator(configuration, locator)} got extracted with success!`);
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `You can now edit the following folder: ${configuration.format(_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.npath.fromPortablePath(temp), `magenta`)}`);
      report.reportInfo(_yarnpkg_core__WEBPACK_IMPORTED_MODULE_8__.MessageName.UNNAMED, `Once you are done run ${configuration.format(`yarn patch-commit ${_yarnpkg_fslib__WEBPACK_IMPORTED_MODULE_9__.npath.fromPortablePath(temp)}`, `cyan`)} and Yarn will store a patchfile based on your changes.`);
    });
  }

}
PatchCommand.usage = clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Usage({
  description: `
      This command will cause a package to be extracted in a temporary directory (under a folder named "patch-workdir"). This folder will be editable at will; running \`yarn patch\` inside it will then cause Yarn to generate a patchfile and register it into your top-level manifest (cf the \`patch:\` protocol).
    `
});

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.String()], PatchCommand.prototype, "package", void 0);

(0,tslib__WEBPACK_IMPORTED_MODULE_10__.__decorate)([clipanion__WEBPACK_IMPORTED_MODULE_1__.Command.Path(`patch`)], PatchCommand.prototype, "execute", null);

/***/ }),
/* 717 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const url_1 = __webpack_require__(281);
const create_1 = __webpack_require__(718);
const defaults = {
    options: {
        method: 'GET',
        retry: {
            limit: 2,
            methods: [
                'GET',
                'PUT',
                'HEAD',
                'DELETE',
                'OPTIONS',
                'TRACE'
            ],
            statusCodes: [
                408,
                413,
                429,
                500,
                502,
                503,
                504,
                521,
                522,
                524
            ],
            errorCodes: [
                'ETIMEDOUT',
                'ECONNRESET',
                'EADDRINUSE',
                'ECONNREFUSED',
                'EPIPE',
                'ENOTFOUND',
                'ENETUNREACH',
                'EAI_AGAIN'
            ],
            maxRetryAfter: undefined,
            calculateDelay: ({ computedValue }) => computedValue
        },
        timeout: {},
        headers: {
            'user-agent': 'got (https://github.com/sindresorhus/got)'
        },
        hooks: {
            init: [],
            beforeRequest: [],
            beforeRedirect: [],
            beforeRetry: [],
            beforeError: [],
            afterResponse: []
        },
        cache: undefined,
        dnsCache: undefined,
        decompress: true,
        throwHttpErrors: true,
        followRedirect: true,
        isStream: false,
        responseType: 'text',
        resolveBodyOnly: false,
        maxRedirects: 10,
        prefixUrl: '',
        methodRewriting: true,
        ignoreInvalidCookies: false,
        context: {},
        // TODO: Set this to `true` when Got 12 gets released
        http2: false,
        allowGetBody: false,
        rejectUnauthorized: true,
        pagination: {
            transform: (response) => {
                if (response.request.options.responseType === 'json') {
                    return response.body;
                }
                return JSON.parse(response.body);
            },
            paginate: response => {
                if (!Reflect.has(response.headers, 'link')) {
                    return false;
                }
                const items = response.headers.link.split(',');
                let next;
                for (const item of items) {
                    const parsed = item.split(';');
                    if (parsed[1].includes('next')) {
                        next = parsed[0].trimStart().trim();
                        next = next.slice(1, -1);
                        break;
                    }
                }
                if (next) {
                    const options = {
                        url: new url_1.URL(next)
                    };
                    return options;
                }
                return false;
            },
            filter: () => true,
            shouldContinue: () => true,
            countLimit: Infinity,
            requestLimit: 10000,
            stackAllItems: true
        }
    },
    handlers: [create_1.defaultHandler],
    mutableDefaults: false
};
const got = create_1.default(defaults);
exports.default = got;
// For CommonJS default export support
module.exports = got;
module.exports.default = got;
__export(__webpack_require__(718));
__export(__webpack_require__(721));


/***/ }),
/* 718 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const p_cancelable_1 = __webpack_require__(719);
const is_1 = __webpack_require__(720);
const as_promise_1 = __webpack_require__(721);
const create_rejection_1 = __webpack_require__(769);
const core_1 = __webpack_require__(729);
const deep_freeze_1 = __webpack_require__(770);
const errors = {
    RequestError: as_promise_1.RequestError,
    CacheError: as_promise_1.CacheError,
    ReadError: as_promise_1.ReadError,
    HTTPError: as_promise_1.HTTPError,
    MaxRedirectsError: as_promise_1.MaxRedirectsError,
    TimeoutError: as_promise_1.TimeoutError,
    ParseError: as_promise_1.ParseError,
    CancelError: p_cancelable_1.CancelError,
    UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
    UploadError: as_promise_1.UploadError
};
const { normalizeArguments, mergeOptions } = as_promise_1.PromisableRequest;
const getPromiseOrStream = (options) => options.isStream ? new core_1.default(options.url, options) : as_promise_1.default(options);
const isGotInstance = (value) => ('defaults' in value && 'options' in value.defaults);
const aliases = [
    'get',
    'post',
    'put',
    'patch',
    'head',
    'delete'
];
exports.defaultHandler = (options, next) => next(options);
const callInitHooks = (hooks, options) => {
    if (hooks) {
        for (const hook of hooks) {
            hook(options);
        }
    }
};
const create = (defaults) => {
    // Proxy properties from next handlers
    defaults._rawHandlers = defaults.handlers;
    defaults.handlers = defaults.handlers.map(fn => ((options, next) => {
        // This will be assigned by assigning result
        let root;
        const result = fn(options, newOptions => {
            root = next(newOptions);
            return root;
        });
        if (result !== root && !options.isStream && root) {
            const typedResult = result;
            const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;
            Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));
            Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));
            // These should point to the new promise
            // eslint-disable-next-line promise/prefer-await-to-then
            typedResult.then = promiseThen;
            typedResult.catch = promiseCatch;
            typedResult.finally = promiseFianlly;
        }
        return result;
    }));
    const got = ((url, options) => {
        var _a, _b;
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
            return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);
        };
        if (is_1.default.plainObject(url)) {
            options = {
                ...url,
                ...options
            };
            url = undefined;
        }
        try {
            // Call `init` hooks
            let initHookError;
            try {
                callInitHooks(defaults.options.hooks.init, options);
                callInitHooks((_a = options === null || options === void 0 ? void 0 : options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);
            }
            catch (error) {
                initHookError = error;
            }
            // Normalize options & call handlers
            const normalizedOptions = normalizeArguments(url, options, defaults.options);
            normalizedOptions[core_1.kIsNormalizedAlready] = true;
            if (initHookError) {
                throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
            }
            return iterateHandlers(normalizedOptions);
        }
        catch (error) {
            if (options === null || options === void 0 ? void 0 : options.isStream) {
                throw error;
            }
            else {
                return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options === null || options === void 0 ? void 0 : options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
            }
        }
    });
    got.extend = (...instancesOrOptions) => {
        const optionsArray = [defaults.options];
        let handlers = [...defaults._rawHandlers];
        let isMutableDefaults;
        for (const value of instancesOrOptions) {
            if (isGotInstance(value)) {
                optionsArray.push(value.defaults.options);
                handlers.push(...value.defaults._rawHandlers);
                isMutableDefaults = value.defaults.mutableDefaults;
            }
            else {
                optionsArray.push(value);
                if ('handlers' in value) {
                    handlers.push(...value.handlers);
                }
                isMutableDefaults = value.mutableDefaults;
            }
        }
        handlers = handlers.filter(handler => handler !== exports.defaultHandler);
        if (handlers.length === 0) {
            handlers.push(exports.defaultHandler);
        }
        return create({
            options: mergeOptions(...optionsArray),
            handlers,
            mutableDefaults: Boolean(isMutableDefaults)
        });
    };
    got.paginate = (async function* (url, options) {
        let normalizedOptions = normalizeArguments(url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const pagination = normalizedOptions.pagination;
        if (!is_1.default.object(pagination)) {
            throw new TypeError('`options.pagination` must be implemented');
        }
        const all = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
            // TODO: Throw when result is not an instance of Response
            // eslint-disable-next-line no-await-in-loop
            const result = (await got('', normalizedOptions));
            // eslint-disable-next-line no-await-in-loop
            const parsed = await pagination.transform(result);
            const current = [];
            for (const item of parsed) {
                if (pagination.filter(item, all, current)) {
                    if (!pagination.shouldContinue(item, all, current)) {
                        return;
                    }
                    yield item;
                    if (pagination.stackAllItems) {
                        all.push(item);
                    }
                    current.push(item);
                    if (--countLimit <= 0) {
                        return;
                    }
                }
            }
            const optionsToMerge = pagination.paginate(result, all, current);
            if (optionsToMerge === false) {
                return;
            }
            if (optionsToMerge === result.request.options) {
                normalizedOptions = result.request.options;
            }
            else if (optionsToMerge !== undefined) {
                normalizedOptions = normalizeArguments(undefined, optionsToMerge, normalizedOptions);
            }
            numberOfRequests++;
        }
    });
    got.paginate.all = (async (url, options) => {
        const results = [];
        for await (const item of got.paginate(url, options)) {
            results.push(item);
        }
        return results;
    });
    got.stream = ((url, options) => got(url, { ...options, isStream: true }));
    for (const method of aliases) {
        got[method] = ((url, options) => got(url, { ...options, method }));
        got.stream[method] = ((url, options) => {
            return got(url, { ...options, method, isStream: true });
        });
    }
    Object.assign(got, { ...errors, mergeOptions });
    Object.defineProperty(got, 'defaults', {
        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),
        writable: defaults.mutableDefaults,
        configurable: defaults.mutableDefaults,
        enumerable: true
    });
    return got;
};
exports.default = create;


/***/ }),
/* 719 */
/***/ ((module) => {

"use strict";


class CancelError extends Error {
	constructor(reason) {
		super(reason || 'Promise was canceled');
		this.name = 'CancelError';
	}

	get isCanceled() {
		return true;
	}
}

class PCancelable {
	static fn(userFn) {
		return (...arguments_) => {
			return new PCancelable((resolve, reject, onCancel) => {
				arguments_.push(onCancel);
				// eslint-disable-next-line promise/prefer-await-to-then
				userFn(...arguments_).then(resolve, reject);
			});
		};
	}

	constructor(executor) {
		this._cancelHandlers = [];
		this._isPending = true;
		this._isCanceled = false;
		this._rejectOnCancel = true;

		this._promise = new Promise((resolve, reject) => {
			this._reject = reject;

			const onResolve = value => {
				this._isPending = false;
				resolve(value);
			};

			const onReject = error => {
				this._isPending = false;
				reject(error);
			};

			const onCancel = handler => {
				if (!this._isPending) {
					throw new Error('The `onCancel` handler was attached after the promise settled.');
				}

				this._cancelHandlers.push(handler);
			};

			Object.defineProperties(onCancel, {
				shouldReject: {
					get: () => this._rejectOnCancel,
					set: boolean => {
						this._rejectOnCancel = boolean;
					}
				}
			});

			return executor(onResolve, onReject, onCancel);
		});
	}

	then(onFulfilled, onRejected) {
		// eslint-disable-next-line promise/prefer-await-to-then
		return this._promise.then(onFulfilled, onRejected);
	}

	catch(onRejected) {
		return this._promise.catch(onRejected);
	}

	finally(onFinally) {
		return this._promise.finally(onFinally);
	}

	cancel(reason) {
		if (!this._isPending || this._isCanceled) {
			return;
		}

		if (this._cancelHandlers.length > 0) {
			try {
				for (const handler of this._cancelHandlers) {
					handler();
				}
			} catch (error) {
				this._reject(error);
			}
		}

		this._isCanceled = true;
		if (this._rejectOnCancel) {
			this._reject(new CancelError(reason));
		}
	}

	get isCanceled() {
		return this._isCanceled;
	}
}

Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

module.exports = PCancelable;
module.exports.CancelError = CancelError;


/***/ }),
/* 720 */
/***/ ((module, exports) => {

"use strict";

/// <reference lib="es2018"/>
/// <reference lib="dom"/>
/// <reference types="node"/>
Object.defineProperty(exports, "__esModule", ({ value: true }));
const { toString } = Object.prototype;
const isOfType = (type) => (value) => typeof value === type;
const getObjectType = (value) => {
    const objectName = toString.call(value).slice(8, -1);
    if (objectName) {
        return objectName;
    }
    return undefined;
};
const isObjectOfType = (type) => (value) => getObjectType(value) === type;
function is(value) {
    switch (value) {
        case null:
            return "null" /* null */;
        case true:
        case false:
            return "boolean" /* boolean */;
        default:
    }
    switch (typeof value) {
        case 'undefined':
            return "undefined" /* undefined */;
        case 'string':
            return "string" /* string */;
        case 'number':
            return "number" /* number */;
        case 'bigint':
            return "bigint" /* bigint */;
        case 'symbol':
            return "symbol" /* symbol */;
        default:
    }
    if (is.function_(value)) {
        return "Function" /* Function */;
    }
    if (is.observable(value)) {
        return "Observable" /* Observable */;
    }
    if (is.array(value)) {
        return "Array" /* Array */;
    }
    if (is.buffer(value)) {
        return "Buffer" /* Buffer */;
    }
    const tagType = getObjectType(value);
    if (tagType) {
        return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError('Please don\'t use object wrappers for primitive types');
    }
    return "Object" /* Object */;
}
is.undefined = isOfType('undefined');
is.string = isOfType('string');
const isNumberType = isOfType('number');
is.number = (value) => isNumberType(value) && !is.nan(value);
is.bigint = isOfType('bigint');
// eslint-disable-next-line @typescript-eslint/ban-types
is.function_ = isOfType('function');
is.null_ = (value) => value === null;
is.class_ = (value) => is.function_(value) && value.toString().startsWith('class ');
is.boolean = (value) => value === true || value === false;
is.symbol = isOfType('symbol');
is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = Array.isArray;
is.buffer = (value) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false; };
is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
is.object = (value) => !is.null_(value) && (typeof value === 'object' || is.function_(value));
is.iterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]); };
is.asyncIterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]); };
is.generator = (value) => is.iterable(value) && is.function_(value.next) && is.function_(value.throw);
is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value) => isObjectOfType("Promise" /* Promise */)(value);
const hasPromiseAPI = (value) => {
    var _a, _b;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) &&
        is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
};
is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
is.generatorFunction = isObjectOfType("GeneratorFunction" /* GeneratorFunction */);
is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction" /* AsyncGeneratorFunction */;
is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction" /* AsyncFunction */;
// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty('prototype');
is.regExp = isObjectOfType("RegExp" /* RegExp */);
is.date = isObjectOfType("Date" /* Date */);
is.error = isObjectOfType("Error" /* Error */);
is.map = (value) => isObjectOfType("Map" /* Map */)(value);
is.set = (value) => isObjectOfType("Set" /* Set */)(value);
is.weakMap = (value) => isObjectOfType("WeakMap" /* WeakMap */)(value);
is.weakSet = (value) => isObjectOfType("WeakSet" /* WeakSet */)(value);
is.int8Array = isObjectOfType("Int8Array" /* Int8Array */);
is.uint8Array = isObjectOfType("Uint8Array" /* Uint8Array */);
is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray" /* Uint8ClampedArray */);
is.int16Array = isObjectOfType("Int16Array" /* Int16Array */);
is.uint16Array = isObjectOfType("Uint16Array" /* Uint16Array */);
is.int32Array = isObjectOfType("Int32Array" /* Int32Array */);
is.uint32Array = isObjectOfType("Uint32Array" /* Uint32Array */);
is.float32Array = isObjectOfType("Float32Array" /* Float32Array */);
is.float64Array = isObjectOfType("Float64Array" /* Float64Array */);
is.bigInt64Array = isObjectOfType("BigInt64Array" /* BigInt64Array */);
is.bigUint64Array = isObjectOfType("BigUint64Array" /* BigUint64Array */);
is.arrayBuffer = isObjectOfType("ArrayBuffer" /* ArrayBuffer */);
is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer" /* SharedArrayBuffer */);
is.dataView = isObjectOfType("DataView" /* DataView */);
is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value) => isObjectOfType("URL" /* URL */)(value);
is.urlString = (value) => {
    if (!is.string(value)) {
        return false;
    }
    try {
        new URL(value); // eslint-disable-line no-new
        return true;
    }
    catch (_a) {
        return false;
    }
};
// TODO: Use the `not` operator with a type guard here when it's available.
// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
is.truthy = (value) => Boolean(value);
// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
is.falsy = (value) => !value;
is.nan = (value) => Number.isNaN(value);
const primitiveTypeOfTypes = new Set([
    'undefined',
    'string',
    'number',
    'bigint',
    'boolean',
    'symbol'
]);
is.primitive = (value) => is.null_(value) || primitiveTypeOfTypes.has(typeof value);
is.integer = (value) => Number.isInteger(value);
is.safeInteger = (value) => Number.isSafeInteger(value);
is.plainObject = (value) => {
    // From: https://github.com/sindresorhus/is-plain-obj/blob/master/index.js
    if (getObjectType(value) !== "Object" /* Object */) {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
};
const typedArrayTypes = new Set([
    "Int8Array" /* Int8Array */,
    "Uint8Array" /* Uint8Array */,
    "Uint8ClampedArray" /* Uint8ClampedArray */,
    "Int16Array" /* Int16Array */,
    "Uint16Array" /* Uint16Array */,
    "Int32Array" /* Int32Array */,
    "Uint32Array" /* Uint32Array */,
    "Float32Array" /* Float32Array */,
    "Float64Array" /* Float64Array */,
    "BigInt64Array" /* BigInt64Array */,
    "BigUint64Array" /* BigUint64Array */
]);
is.typedArray = (value) => {
    const objectType = getObjectType(value);
    if (objectType === undefined) {
        return false;
    }
    return typedArrayTypes.has(objectType);
};
const isValidLength = (value) => is.safeInteger(value) && value >= 0;
is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.inRange = (value, range) => {
    if (is.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
const NODE_TYPE_ELEMENT = 1;
const DOM_PROPERTIES_TO_CHECK = [
    'innerHTML',
    'ownerDocument',
    'style',
    'attributes',
    'nodeValue'
];
is.domElement = (value) => is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) &&
    !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every(property => property in value);
is.observable = (value) => {
    var _a, _b, _c, _d;
    if (!value) {
        return false;
    }
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
        return true;
    }
    if (value === ((_d = (_c = value)['@@observable']) === null || _d === void 0 ? void 0 : _d.call(_c))) {
        return true;
    }
    return false;
};
is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value) => value === Infinity || value === -Infinity;
const isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value) => is.array(value) && value.length === 0;
is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
is.emptyString = (value) => is.string(value) && value.length === 0;
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyString = (value) => is.string(value) && value.length > 0;
const isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
// - https://github.com/Microsoft/TypeScript/pull/29317
is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value) => is.set(value) && value.size === 0;
is.nonEmptySet = (value) => is.set(value) && value.size > 0;
is.emptyMap = (value) => is.map(value) && value.size === 0;
is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
const predicateOnArray = (method, predicate, values) => {
    if (!is.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
        throw new TypeError('Invalid number of values');
    }
    return method.call(values, predicate);
};
is.any = (predicate, ...values) => {
    const predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some(singlePredicate => predicateOnArray(Array.prototype.some, singlePredicate, values));
};
is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
const assertType = (condition, description, value) => {
    if (!condition) {
        throw new TypeError(`Expected value which is \`${description}\`, received value of type \`${is(value)}\`.`);
    }
};
exports.assert = {
    // Unknowns.
    undefined: (value) => assertType(is.undefined(value), "undefined" /* undefined */, value),
    string: (value) => assertType(is.string(value), "string" /* string */, value),
    number: (value) => assertType(is.number(value), "number" /* number */, value),
    bigint: (value) => assertType(is.bigint(value), "bigint" /* bigint */, value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: (value) => assertType(is.function_(value), "Function" /* Function */, value),
    null_: (value) => assertType(is.null_(value), "null" /* null */, value),
    class_: (value) => assertType(is.class_(value), "Class" /* class_ */, value),
    boolean: (value) => assertType(is.boolean(value), "boolean" /* boolean */, value),
    symbol: (value) => assertType(is.symbol(value), "symbol" /* symbol */, value),
    numericString: (value) => assertType(is.numericString(value), "string with a number" /* numericString */, value),
    array: (value) => assertType(is.array(value), "Array" /* Array */, value),
    buffer: (value) => assertType(is.buffer(value), "Buffer" /* Buffer */, value),
    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined" /* nullOrUndefined */, value),
    object: (value) => assertType(is.object(value), "Object" /* Object */, value),
    iterable: (value) => assertType(is.iterable(value), "Iterable" /* iterable */, value),
    asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable" /* asyncIterable */, value),
    generator: (value) => assertType(is.generator(value), "Generator" /* Generator */, value),
    asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator" /* AsyncGenerator */, value),
    nativePromise: (value) => assertType(is.nativePromise(value), "native Promise" /* nativePromise */, value),
    promise: (value) => assertType(is.promise(value), "Promise" /* Promise */, value),
    generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction" /* GeneratorFunction */, value),
    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction" /* AsyncGeneratorFunction */, value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction" /* AsyncFunction */, value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: (value) => assertType(is.boundFunction(value), "Function" /* Function */, value),
    regExp: (value) => assertType(is.regExp(value), "RegExp" /* RegExp */, value),
    date: (value) => assertType(is.date(value), "Date" /* Date */, value),
    error: (value) => assertType(is.error(value), "Error" /* Error */, value),
    map: (value) => assertType(is.map(value), "Map" /* Map */, value),
    set: (value) => assertType(is.set(value), "Set" /* Set */, value),
    weakMap: (value) => assertType(is.weakMap(value), "WeakMap" /* WeakMap */, value),
    weakSet: (value) => assertType(is.weakSet(value), "WeakSet" /* WeakSet */, value),
    int8Array: (value) => assertType(is.int8Array(value), "Int8Array" /* Int8Array */, value),
    uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array" /* Uint8Array */, value),
    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray" /* Uint8ClampedArray */, value),
    int16Array: (value) => assertType(is.int16Array(value), "Int16Array" /* Int16Array */, value),
    uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array" /* Uint16Array */, value),
    int32Array: (value) => assertType(is.int32Array(value), "Int32Array" /* Int32Array */, value),
    uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array" /* Uint32Array */, value),
    float32Array: (value) => assertType(is.float32Array(value), "Float32Array" /* Float32Array */, value),
    float64Array: (value) => assertType(is.float64Array(value), "Float64Array" /* Float64Array */, value),
    bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array" /* BigInt64Array */, value),
    bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array" /* BigUint64Array */, value),
    arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer" /* ArrayBuffer */, value),
    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer" /* SharedArrayBuffer */, value),
    dataView: (value) => assertType(is.dataView(value), "DataView" /* DataView */, value),
    urlInstance: (value) => assertType(is.urlInstance(value), "URL" /* URL */, value),
    urlString: (value) => assertType(is.urlString(value), "string with a URL" /* urlString */, value),
    truthy: (value) => assertType(is.truthy(value), "truthy" /* truthy */, value),
    falsy: (value) => assertType(is.falsy(value), "falsy" /* falsy */, value),
    nan: (value) => assertType(is.nan(value), "NaN" /* nan */, value),
    primitive: (value) => assertType(is.primitive(value), "primitive" /* primitive */, value),
    integer: (value) => assertType(is.integer(value), "integer" /* integer */, value),
    safeInteger: (value) => assertType(is.safeInteger(value), "integer" /* safeInteger */, value),
    plainObject: (value) => assertType(is.plainObject(value), "plain object" /* plainObject */, value),
    typedArray: (value) => assertType(is.typedArray(value), "TypedArray" /* typedArray */, value),
    arrayLike: (value) => assertType(is.arrayLike(value), "array-like" /* arrayLike */, value),
    domElement: (value) => assertType(is.domElement(value), "Element" /* domElement */, value),
    observable: (value) => assertType(is.observable(value), "Observable" /* Observable */, value),
    nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream" /* nodeStream */, value),
    infinite: (value) => assertType(is.infinite(value), "infinite number" /* infinite */, value),
    emptyArray: (value) => assertType(is.emptyArray(value), "empty array" /* emptyArray */, value),
    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array" /* nonEmptyArray */, value),
    emptyString: (value) => assertType(is.emptyString(value), "empty string" /* emptyString */, value),
    nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string" /* nonEmptyString */, value),
    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace" /* emptyStringOrWhitespace */, value),
    emptyObject: (value) => assertType(is.emptyObject(value), "empty object" /* emptyObject */, value),
    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object" /* nonEmptyObject */, value),
    emptySet: (value) => assertType(is.emptySet(value), "empty set" /* emptySet */, value),
    nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set" /* nonEmptySet */, value),
    emptyMap: (value) => assertType(is.emptyMap(value), "empty map" /* emptyMap */, value),
    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map" /* nonEmptyMap */, value),
    // Numbers.
    evenInteger: (value) => assertType(is.evenInteger(value), "even integer" /* evenInteger */, value),
    oddInteger: (value) => assertType(is.oddInteger(value), "odd integer" /* oddInteger */, value),
    // Two arguments.
    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T" /* directInstanceOf */, instance),
    inRange: (value, range) => assertType(is.inRange(value, range), "in range" /* inRange */, value),
    // Variadic functions.
    any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value" /* any */, values),
    all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values" /* all */, values)
};
// Some few keywords are reserved, but we'll populate them for Node.js users
// See https://github.com/Microsoft/TypeScript/issues/2536
Object.defineProperties(is, {
    class: {
        value: is.class_
    },
    function: {
        value: is.function_
    },
    null: {
        value: is.null_
    }
});
Object.defineProperties(exports.assert, {
    class: {
        value: exports.assert.class_
    },
    function: {
        value: exports.assert.function_
    },
    null: {
        value: exports.assert.null_
    }
});
exports.default = is;
// For CommonJS default export support
module.exports = is;
module.exports.default = is;
module.exports.assert = exports.assert;


/***/ }),
/* 721 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(170);
const getStream = __webpack_require__(722);
const PCancelable = __webpack_require__(719);
const calculate_retry_delay_1 = __webpack_require__(727);
const types_1 = __webpack_require__(728);
const core_1 = __webpack_require__(768);
exports.PromisableRequest = core_1.default;
const proxy_events_1 = __webpack_require__(762);
const proxiedRequestEvents = [
    'request',
    'response',
    'redirect',
    'uploadProgress',
    'downloadProgress'
];
function asPromise(options) {
    let retryCount = 0;
    let globalRequest;
    let globalResponse;
    const emitter = new events_1.EventEmitter();
    const promise = new PCancelable((resolve, _reject, onCancel) => {
        const makeRequest = () => {
            // Support retries
            // `options.throwHttpErrors` needs to be always true,
            // so the HTTP errors are caught and the request is retried.
            // The error is **eventually** thrown if the user value is true.
            const { throwHttpErrors } = options;
            if (!throwHttpErrors) {
                options.throwHttpErrors = true;
            }
            // Note from @szmarczak: I think we should use `request.options` instead of the local options
            const request = new core_1.default(options.url, options);
            request._noPipe = true;
            onCancel(() => request.destroy());
            const reject = async (error) => {
                try {
                    for (const hook of options.hooks.beforeError) {
                        // eslint-disable-next-line no-await-in-loop
                        error = await hook(error);
                    }
                }
                catch (error_) {
                    _reject(new types_1.RequestError(error_.message, error_, request));
                    return;
                }
                _reject(error);
            };
            globalRequest = request;
            request.once('response', async (response) => {
                response.retryCount = retryCount;
                if (response.request.aborted) {
                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error
                    return;
                }
                const isOk = () => {
                    const { statusCode } = response;
                    const limitStatusCode = options.followRedirect ? 299 : 399;
                    return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;
                };
                // Download body
                let rawBody;
                try {
                    rawBody = await getStream.buffer(request);
                    response.rawBody = rawBody;
                }
                catch (_) {
                    // The same error is caught below.
                    // See request.once('error')
                    return;
                }
                // Parse body
                try {
                    response.body = core_1.parseBody(response, options.responseType, options.encoding);
                }
                catch (error) {
                    // Fallback to `utf8`
                    response.body = rawBody.toString();
                    if (isOk()) {
                        // TODO: Call `request._beforeError`, see https://github.com/nodejs/node/issues/32995
                        reject(error);
                        return;
                    }
                }
                try {
                    for (const [index, hook] of options.hooks.afterResponse.entries()) {
                        // @ts-ignore TS doesn't notice that CancelableRequest is a Promise
                        // eslint-disable-next-line no-await-in-loop
                        response = await hook(response, async (updatedOptions) => {
                            const typedOptions = core_1.default.normalizeArguments(undefined, {
                                ...updatedOptions,
                                retry: {
                                    calculateDelay: () => 0
                                },
                                throwHttpErrors: false,
                                resolveBodyOnly: false
                            }, options);
                            // Remove any further hooks for that request, because we'll call them anyway.
                            // The loop continues. We don't want duplicates (asPromise recursion).
                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);
                            for (const hook of typedOptions.hooks.beforeRetry) {
                                // eslint-disable-next-line no-await-in-loop
                                await hook(typedOptions);
                            }
                            const promise = asPromise(typedOptions);
                            onCancel(() => {
                                promise.catch(() => { });
                                promise.cancel();
                            });
                            return promise;
                        });
                    }
                }
                catch (error) {
                    // TODO: Call `request._beforeError`, see https://github.com/nodejs/node/issues/32995
                    reject(new types_1.RequestError(error.message, error, request));
                    return;
                }
                if (throwHttpErrors && !isOk()) {
                    reject(new types_1.HTTPError(response));
                    return;
                }
                globalResponse = response;
                resolve(options.resolveBodyOnly ? response.body : response);
            });
            request.once('error', (error) => {
                if (promise.isCanceled) {
                    return;
                }
                if (!request.options) {
                    reject(error);
                    return;
                }
                let backoff;
                retryCount++;
                try {
                    backoff = options.retry.calculateDelay({
                        attemptCount: retryCount,
                        retryOptions: options.retry,
                        error,
                        computedValue: calculate_retry_delay_1.default({
                            attemptCount: retryCount,
                            retryOptions: options.retry,
                            error,
                            computedValue: 0
                        })
                    });
                }
                catch (error_) {
                    // Don't emit the `response` event
                    request.destroy();
                    reject(new types_1.RequestError(error_.message, error, request));
                    return;
                }
                if (backoff) {
                    // Don't emit the `response` event
                    request.destroy();
                    const retry = async () => {
                        options.throwHttpErrors = throwHttpErrors;
                        try {
                            for (const hook of options.hooks.beforeRetry) {
                                // eslint-disable-next-line no-await-in-loop
                                await hook(options, error, retryCount);
                            }
                        }
                        catch (error_) {
                            // Don't emit the `response` event
                            request.destroy();
                            reject(new types_1.RequestError(error_.message, error, request));
                            return;
                        }
                        makeRequest();
                    };
                    setTimeout(retry, backoff);
                    return;
                }
                // The retry has not been made
                retryCount--;
                if (error instanceof types_1.HTTPError) {
                    // It will be handled by the `response` event
                    return;
                }
                // Don't emit the `response` event
                request.destroy();
                reject(error);
            });
            proxy_events_1.default(request, emitter, proxiedRequestEvents);
        };
        makeRequest();
    });
    promise.on = (event, fn) => {
        emitter.on(event, fn);
        return promise;
    };
    const shortcut = (responseType) => {
        const newPromise = (async () => {
            // Wait until downloading has ended
            await promise;
            return core_1.parseBody(globalResponse, responseType, options.encoding);
        })();
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
    };
    promise.json = () => {
        if (!globalRequest.writableFinished && options.headers.accept === undefined) {
            options.headers.accept = 'application/json';
        }
        return shortcut('json');
    };
    promise.buffer = () => shortcut('buffer');
    promise.text = () => shortcut('text');
    return promise;
}
exports.default = asPromise;
__export(__webpack_require__(728));


/***/ }),
/* 722 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const pump = __webpack_require__(723);
const bufferStream = __webpack_require__(726);

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream(inputStream, options) {
	if (!inputStream) {
		return Promise.reject(new Error('Expected a stream'));
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;

	let stream;
	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			if (error) { // A null check
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		stream = pump(inputStream, bufferStream(options), error => {
			if (error) {
				rejectPromise(error);
				return;
			}

			resolve();
		});

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

module.exports = getStream;
// TODO: Remove this for the next major release
module.exports.default = getStream;
module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
module.exports.MaxBufferError = MaxBufferError;


/***/ }),
/* 723 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(724)
var eos = __webpack_require__(725)
var fs = __webpack_require__(6) // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),
/* 724 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(312)
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}


/***/ }),
/* 725 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(724);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback();
	};

	var onend = function() {
		readable = false;
		if (!writable) callback();
	};

	var onexit = function(exitCode) {
		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', callback);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', callback);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

/***/ }),
/* 726 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __webpack_require__(110);

module.exports = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};


/***/ }),
/* 727 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __webpack_require__(728);
const retryAfterStatusCodes = new Set([413, 429, 503]);
const isErrorWithResponse = (error) => (error instanceof types_1.HTTPError || error instanceof types_1.ParseError || error instanceof types_1.MaxRedirectsError);
const calculateRetryDelay = ({ attemptCount, retryOptions, error }) => {
    if (attemptCount > retryOptions.limit) {
        return 0;
    }
    const hasMethod = retryOptions.methods.includes(error.options.method);
    const hasErrorCode = retryOptions.errorCodes.includes(error.code);
    const hasStatusCode = isErrorWithResponse(error) && retryOptions.statusCodes.includes(error.response.statusCode);
    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {
        return 0;
    }
    if (isErrorWithResponse(error)) {
        const { response } = error;
        if (response && 'retry-after' in response.headers && retryAfterStatusCodes.has(response.statusCode)) {
            let after = Number(response.headers['retry-after']);
            if (Number.isNaN(after)) {
                after = Date.parse(response.headers['retry-after']) - Date.now();
            }
            else {
                after *= 1000;
            }
            if (retryOptions.maxRetryAfter === undefined || after > retryOptions.maxRetryAfter) {
                return 0;
            }
            return after;
        }
        if (response.statusCode === 413) {
            return 0;
        }
    }
    const noise = Math.random() * 100;
    return ((2 ** (attemptCount - 1)) * 1000) + noise;
};
exports.default = calculateRetryDelay;


/***/ }),
/* 728 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const p_cancelable_1 = __webpack_require__(719);
exports.CancelError = p_cancelable_1.CancelError;
const core_1 = __webpack_require__(729);
exports.RequestError = 
// Errors to be exported
core_1.RequestError;
exports.MaxRedirectsError = core_1.MaxRedirectsError;
exports.CacheError = core_1.CacheError;
exports.UploadError = core_1.UploadError;
exports.TimeoutError = core_1.TimeoutError;
exports.HTTPError = core_1.HTTPError;
exports.ReadError = core_1.ReadError;
exports.UnsupportedProtocolError = core_1.UnsupportedProtocolError;
class ParseError extends core_1.RequestError {
    constructor(error, response) {
        const { options } = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
        this.name = 'ParseError';
        Object.defineProperty(this, 'response', {
            enumerable: false,
            value: response
        });
    }
}
exports.ParseError = ParseError;


/***/ }),
/* 729 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(115);
const stream_1 = __webpack_require__(110);
const fs_1 = __webpack_require__(6);
const url_1 = __webpack_require__(281);
const http = __webpack_require__(275);
const http_1 = __webpack_require__(275);
const https = __webpack_require__(274);
const http_timer_1 = __webpack_require__(730);
const decompressResponse = __webpack_require__(732);
const cacheable_lookup_1 = __webpack_require__(734);
const CacheableRequest = __webpack_require__(737);
// @ts-ignore Missing types
const http2wrapper = __webpack_require__(747);
const lowercaseKeys = __webpack_require__(741);
const getStream = __webpack_require__(722);
const is_1 = __webpack_require__(720);
const get_body_size_1 = __webpack_require__(760);
const is_form_data_1 = __webpack_require__(761);
const proxy_events_1 = __webpack_require__(762);
const timed_out_1 = __webpack_require__(763);
const url_to_options_1 = __webpack_require__(765);
const options_to_url_1 = __webpack_require__(766);
const weakable_map_1 = __webpack_require__(767);
const kRequest = Symbol('request');
const kResponse = Symbol('response');
const kResponseSize = Symbol('responseSize');
const kDownloadedSize = Symbol('downloadedSize');
const kBodySize = Symbol('bodySize');
const kUploadedSize = Symbol('uploadedSize');
const kServerResponsesPiped = Symbol('serverResponsesPiped');
const kUnproxyEvents = Symbol('unproxyEvents');
const kIsFromCache = Symbol('isFromCache');
const kCancelTimeouts = Symbol('cancelTimeouts');
const kStartedReading = Symbol('startedReading');
const kStopReading = Symbol('stopReading');
const kTriggerRead = Symbol('triggerRead');
const kBody = Symbol('body');
const kJobs = Symbol('jobs');
const kOriginalResponse = Symbol('originalResponse');
exports.kIsNormalizedAlready = Symbol('isNormalizedAlready');
const supportsBrotli = is_1.default.string(process.versions.brotli);
exports.withoutBody = new Set(['GET', 'HEAD']);
exports.knownHookEvents = ['init', 'beforeRequest', 'beforeRedirect', 'beforeError'];
function validateSearchParameters(searchParameters) {
    // eslint-disable-next-line guard-for-in
    for (const key in searchParameters) {
        const value = searchParameters[key];
        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value)) {
            throw new TypeError(`The \`searchParams\` value '${String(value)}' must be a string, number, boolean or null`);
        }
    }
}
function isClientRequest(clientRequest) {
    return is_1.default.object(clientRequest) && !('statusCode' in clientRequest);
}
const cacheableStore = new weakable_map_1.default();
const waitForOpenFile = async (file) => new Promise((resolve, reject) => {
    const onError = (error) => {
        reject(error);
    };
    file.once('error', onError);
    file.once('open', () => {
        file.off('error', onError);
        resolve();
    });
});
const redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
const nonEnumerableProperties = [
    'context',
    'body',
    'json',
    'form'
];
const setNonEnumerableProperties = (sources, to) => {
    // Non enumerable properties shall not be merged
    const properties = {};
    for (const source of sources) {
        if (!source) {
            continue;
        }
        for (const name of nonEnumerableProperties) {
            if (!(name in source)) {
                continue;
            }
            properties[name] = {
                writable: true,
                configurable: true,
                enumerable: false,
                // @ts-ignore TS doesn't see the check above
                value: source[name]
            };
        }
    }
    Object.defineProperties(to, properties);
};
class RequestError extends Error {
    constructor(message, error, self) {
        var _a;
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = 'RequestError';
        this.code = error.code;
        if (self instanceof Request) {
            Object.defineProperty(this, 'request', {
                enumerable: false,
                value: self
            });
            Object.defineProperty(this, 'response', {
                enumerable: false,
                value: self[kResponse]
            });
            Object.defineProperty(this, 'options', {
                // This fails because of TS 3.7.2 useDefineForClassFields
                // Ref: https://github.com/microsoft/TypeScript/issues/34972
                enumerable: false,
                value: self.options
            });
        }
        else {
            Object.defineProperty(this, 'options', {
                // This fails because of TS 3.7.2 useDefineForClassFields
                // Ref: https://github.com/microsoft/TypeScript/issues/34972
                enumerable: false,
                value: self
            });
        }
        this.timings = (_a = this.request) === null || _a === void 0 ? void 0 : _a.timings;
        // Recover the original stacktrace
        if (!is_1.default.undefined(error.stack)) {
            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
            const thisStackTrace = this.stack.slice(indexOfMessage).split('\n').reverse();
            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\n').reverse();
            // Remove duplicated traces
            while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
                thisStackTrace.shift();
            }
            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\n')}${errorStackTrace.reverse().join('\n')}`;
        }
    }
}
exports.RequestError = RequestError;
class MaxRedirectsError extends RequestError {
    constructor(request) {
        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
        this.name = 'MaxRedirectsError';
    }
}
exports.MaxRedirectsError = MaxRedirectsError;
class HTTPError extends RequestError {
    constructor(response) {
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = 'HTTPError';
    }
}
exports.HTTPError = HTTPError;
class CacheError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'CacheError';
    }
}
exports.CacheError = CacheError;
class UploadError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'UploadError';
    }
}
exports.UploadError = UploadError;
class TimeoutError extends RequestError {
    constructor(error, timings, request) {
        super(error.message, error, request);
        this.name = 'TimeoutError';
        this.event = error.event;
        this.timings = timings;
    }
}
exports.TimeoutError = TimeoutError;
class ReadError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'ReadError';
    }
}
exports.ReadError = ReadError;
class UnsupportedProtocolError extends RequestError {
    constructor(options) {
        super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
        this.name = 'UnsupportedProtocolError';
    }
}
exports.UnsupportedProtocolError = UnsupportedProtocolError;
const proxiedRequestEvents = [
    'socket',
    'connect',
    'continue',
    'information',
    'upgrade',
    'timeout'
];
class Request extends stream_1.Duplex {
    constructor(url, options = {}, defaults) {
        super({
            // It needs to be zero because we're just proxying the data to another stream
            highWaterMark: 0
        });
        this[kDownloadedSize] = 0;
        this[kUploadedSize] = 0;
        this.requestInitialized = false;
        this[kServerResponsesPiped] = new Set();
        this.redirects = [];
        this[kStopReading] = false;
        this[kTriggerRead] = false;
        this[kJobs] = [];
        // TODO: Remove this when targeting Node.js >= 12
        this._progressCallbacks = [];
        const unlockWrite = () => this._unlockWrite();
        const lockWrite = () => this._lockWrite();
        this.on('pipe', (source) => {
            source.prependListener('data', unlockWrite);
            source.on('data', lockWrite);
            source.prependListener('end', unlockWrite);
            source.on('end', lockWrite);
        });
        this.on('unpipe', (source) => {
            source.off('data', unlockWrite);
            source.off('data', lockWrite);
            source.off('end', unlockWrite);
            source.off('end', lockWrite);
        });
        this.on('pipe', source => {
            if (source instanceof http_1.IncomingMessage) {
                this.options.headers = {
                    ...source.headers,
                    ...this.options.headers
                };
            }
        });
        const { json, body, form } = options;
        if (json || body || form) {
            this._lockWrite();
        }
        (async (nonNormalizedOptions) => {
            var _a;
            try {
                if (nonNormalizedOptions.body instanceof fs_1.ReadStream) {
                    await waitForOpenFile(nonNormalizedOptions.body);
                }
                if (exports.kIsNormalizedAlready in nonNormalizedOptions) {
                    this.options = nonNormalizedOptions;
                }
                else {
                    // @ts-ignore Common TypeScript bug saying that `this.constructor` is not accessible
                    this.options = this.constructor.normalizeArguments(url, nonNormalizedOptions, defaults);
                }
                const { url: normalizedURL } = this.options;
                if (!normalizedURL) {
                    throw new TypeError('Missing `url` property');
                }
                this.requestUrl = normalizedURL.toString();
                decodeURI(this.requestUrl);
                await this._finalizeBody();
                await this._makeRequest();
                if (this.destroyed) {
                    (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();
                    return;
                }
                // Queued writes etc.
                for (const job of this[kJobs]) {
                    job();
                }
                this.requestInitialized = true;
            }
            catch (error) {
                if (error instanceof RequestError) {
                    this._beforeError(error);
                    return;
                }
                // This is a workaround for https://github.com/nodejs/node/issues/33335
                if (!this.destroyed) {
                    this.destroy(error);
                }
            }
        })(options);
    }
    static normalizeArguments(url, options, defaults) {
        var _a, _b, _c, _d;
        const rawOptions = options;
        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {
            options = { ...defaults, ...url, ...options };
        }
        else {
            if (url && options && options.url) {
                throw new TypeError('The `url` option is mutually exclusive with the `input` argument');
            }
            options = { ...defaults, ...options };
            if (url) {
                options.url = url;
            }
            if (is_1.default.urlInstance(options.url)) {
                options.url = new url_1.URL(options.url.toString());
            }
        }
        // TODO: Deprecate URL options in Got 12.
        // Support extend-specific options
        if (options.cache === false) {
            options.cache = undefined;
        }
        if (options.dnsCache === false) {
            options.dnsCache = undefined;
        }
        // Nice type assertions
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);
        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);
        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);
        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);
        // `options.method`
        if (is_1.default.string(options.method)) {
            options.method = options.method.toUpperCase();
        }
        else {
            options.method = 'GET';
        }
        // `options.headers`
        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {
            options.headers = { ...options.headers };
        }
        else {
            options.headers = lowercaseKeys({ ...(defaults === null || defaults === void 0 ? void 0 : defaults.headers), ...options.headers });
        }
        // Disallow legacy `url.Url`
        if ('slashes' in options) {
            throw new TypeError('The legacy `url.Url` has been deprecated. Use `URL` instead.');
        }
        // `options.auth`
        if ('auth' in options) {
            throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');
        }
        // `options.searchParams`
        if ('searchParams' in options) {
            if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {
                if (!is_1.default.string(options.searchParams) && !(options.searchParams instanceof url_1.URLSearchParams)) {
                    validateSearchParameters(options.searchParams);
                }
                const searchParameters = new url_1.URLSearchParams(options.searchParams);
                // `normalizeArguments()` is also used to merge options
                (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
                    // Only use default if one isn't already defined
                    if (!searchParameters.has(key)) {
                        searchParameters.append(key, value);
                    }
                });
                options.searchParams = searchParameters;
            }
        }
        // `options.username` & `options.password`
        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : '';
        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : '';
        // `options.prefixUrl` & `options.url`
        if (options.prefixUrl) {
            options.prefixUrl = options.prefixUrl.toString();
            if (options.prefixUrl !== '' && !options.prefixUrl.endsWith('/')) {
                options.prefixUrl += '/';
            }
        }
        else {
            options.prefixUrl = '';
        }
        if (is_1.default.string(options.url)) {
            if (options.url.startsWith('/')) {
                throw new Error('`input` must not start with a slash when using `prefixUrl`');
            }
            options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
        }
        else if ((is_1.default.undefined(options.url) && options.prefixUrl !== '') || options.protocol) {
            options.url = options_to_url_1.default(options.prefixUrl, options);
        }
        if (options.url) {
            // Make it possible to change `options.prefixUrl`
            let { prefixUrl } = options;
            Object.defineProperty(options, 'prefixUrl', {
                set: (value) => {
                    const url = options.url;
                    if (!url.href.startsWith(value)) {
                        throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url.href}`);
                    }
                    options.url = new url_1.URL(value + url.href.slice(prefixUrl.length));
                    prefixUrl = value;
                },
                get: () => prefixUrl
            });
            // Support UNIX sockets
            let { protocol } = options.url;
            if (protocol === 'unix:') {
                protocol = 'http:';
                options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);
            }
            // Set search params
            if (options.searchParams) {
                options.url.search = options.searchParams.toString();
            }
            // Trigger search params normalization
            if (options.url.search) {
                const triggerSearchParameters = '_GOT_INTERNAL_TRIGGER_NORMALIZATION';
                options.url.searchParams.append(triggerSearchParameters, '');
                options.url.searchParams.delete(triggerSearchParameters);
            }
            // Protocol check
            if (protocol !== 'http:' && protocol !== 'https:') {
                throw new UnsupportedProtocolError(options);
            }
            // Update `username`
            if (options.username === '') {
                options.username = options.url.username;
            }
            else {
                options.url.username = options.username;
            }
            // Update `password`
            if (options.password === '') {
                options.password = options.url.password;
            }
            else {
                options.url.password = options.password;
            }
        }
        // `options.cookieJar`
        const { cookieJar } = options;
        if (cookieJar) {
            let { setCookie, getCookieString } = cookieJar;
            is_1.assert.function_(setCookie);
            is_1.assert.function_(getCookieString);
            /* istanbul ignore next: Horrible `tough-cookie` v3 check */
            if (setCookie.length === 4 && getCookieString.length === 0) {
                setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
                getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
                options.cookieJar = {
                    setCookie,
                    getCookieString
                };
            }
        }
        // `options.cache`
        const { cache } = options;
        if (cache) {
            if (!cacheableStore.has(cache)) {
                cacheableStore.set(cache, new CacheableRequest(((requestOptions, handler) => requestOptions[kRequest](requestOptions, handler)), cache));
            }
        }
        // `options.dnsCache`
        if (options.dnsCache === true) {
            options.dnsCache = new cacheable_lookup_1.default();
        }
        else if (!is_1.default.undefined(options.dnsCache) && !(options.dnsCache instanceof cacheable_lookup_1.default)) {
            throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);
        }
        // `options.timeout`
        if (is_1.default.number(options.timeout)) {
            options.timeout = { request: options.timeout };
        }
        else if (defaults && options.timeout !== defaults.timeout) {
            options.timeout = {
                ...defaults.timeout,
                ...options.timeout
            };
        }
        else {
            options.timeout = { ...options.timeout };
        }
        // `options.context`
        if (!options.context) {
            options.context = {};
        }
        // `options.hooks`
        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);
        options.hooks = { ...options.hooks };
        for (const event of exports.knownHookEvents) {
            if (event in options.hooks) {
                if (is_1.default.array(options.hooks[event])) {
                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                    options.hooks[event] = [...options.hooks[event]];
                }
                else {
                    throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_1.default(options.hooks[event])}`);
                }
            }
            else {
                options.hooks[event] = [];
            }
        }
        if (defaults && !areHooksDefault) {
            for (const event of exports.knownHookEvents) {
                const defaultHooks = defaults.hooks[event];
                if (defaultHooks.length !== 0) {
                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                    options.hooks[event] = [
                        ...defaults.hooks[event],
                        ...options.hooks[event]
                    ];
                }
            }
        }
        // Other options
        if ('followRedirects' in options) {
            throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
        }
        if (options.agent) {
            for (const key in options.agent) {
                if (key !== 'http' && key !== 'https' && key !== 'http2') {
                    throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
                }
            }
        }
        options.maxRedirects = (_d = options.maxRedirects) !== null && _d !== void 0 ? _d : 0;
        // Set non-enumerable properties
        setNonEnumerableProperties([defaults, rawOptions], options);
        return options;
    }
    _lockWrite() {
        const onLockedWrite = () => {
            throw new TypeError('The payload has been already provided');
        };
        this.write = onLockedWrite;
        this.end = onLockedWrite;
    }
    _unlockWrite() {
        this.write = super.write;
        this.end = super.end;
    }
    async _finalizeBody() {
        const { options } = this;
        const { headers } = options;
        const isForm = !is_1.default.undefined(options.form);
        const isJSON = !is_1.default.undefined(options.json);
        const isBody = !is_1.default.undefined(options.body);
        const hasPayload = isForm || isJSON || isBody;
        const cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (hasPayload) {
            if (cannotHaveBody) {
                throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
            }
            if ([isBody, isForm, isJSON].filter(isTrue => isTrue).length > 1) {
                throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');
            }
            if (isBody &&
                !(options.body instanceof stream_1.Readable) &&
                !is_1.default.string(options.body) &&
                !is_1.default.buffer(options.body) &&
                !is_form_data_1.default(options.body)) {
                throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');
            }
            if (isForm && !is_1.default.object(options.form)) {
                throw new TypeError('The `form` option must be an Object');
            }
            {
                // Serialize body
                const noContentType = !is_1.default.string(headers['content-type']);
                if (isBody) {
                    // Special case for https://github.com/form-data/form-data
                    if (is_form_data_1.default(options.body) && noContentType) {
                        headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
                    }
                    this[kBody] = options.body;
                }
                else if (isForm) {
                    if (noContentType) {
                        headers['content-type'] = 'application/x-www-form-urlencoded';
                    }
                    this[kBody] = (new url_1.URLSearchParams(options.form)).toString();
                }
                else {
                    if (noContentType) {
                        headers['content-type'] = 'application/json';
                    }
                    this[kBody] = JSON.stringify(options.json);
                }
                const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
                // See https://tools.ietf.org/html/rfc7230#section-3.3.2
                // A user agent SHOULD send a Content-Length in a request message when
                // no Transfer-Encoding is sent and the request method defines a meaning
                // for an enclosed payload body.  For example, a Content-Length header
                // field is normally sent in a POST request even when the value is 0
                // (indicating an empty payload body).  A user agent SHOULD NOT send a
                // Content-Length header field when the request message does not contain
                // a payload body and the method semantics do not anticipate such a
                // body.
                if (is_1.default.undefined(headers['content-length']) && is_1.default.undefined(headers['transfer-encoding'])) {
                    if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {
                        headers['content-length'] = String(uploadBodySize);
                    }
                }
            }
        }
        else if (cannotHaveBody) {
            this._lockWrite();
        }
        else {
            this._unlockWrite();
        }
        this[kBodySize] = Number(headers['content-length']) || undefined;
    }
    async _onResponse(response) {
        const { options } = this;
        const { url } = options;
        this[kOriginalResponse] = response;
        if (options.decompress) {
            response = decompressResponse(response);
        }
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirects;
        typedResponse.request = this;
        typedResponse.isFromCache = response.fromCache || false;
        typedResponse.ip = this.ip;
        this[kIsFromCache] = typedResponse.isFromCache;
        this[kResponseSize] = Number(response.headers['content-length']) || undefined;
        this[kResponse] = response;
        response.once('end', () => {
            this[kResponseSize] = this[kDownloadedSize];
            this.emit('downloadProgress', this.downloadProgress);
        });
        response.once('error', (error) => {
            // Force clean-up, because some packages don't do this.
            // TODO: Fix decompress-response
            response.destroy();
            this._beforeError(new ReadError(error, this));
        });
        response.once('aborted', () => {
            if (this.aborted) {
                return;
            }
            this._beforeError(new ReadError({
                name: 'Error',
                message: 'The server aborted the pending request'
            }, this));
        });
        this.emit('downloadProgress', this.downloadProgress);
        const rawCookies = response.headers['set-cookie'];
        if (is_1.default.object(options.cookieJar) && rawCookies) {
            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
            if (options.ignoreInvalidCookies) {
                promises = promises.map(async (p) => p.catch(() => { }));
            }
            try {
                await Promise.all(promises);
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
        }
        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
            // We're being redirected, we don't care about the response.
            // It'd be besto to abort the request, but we can't because
            // we would have to sacrifice the TCP connection. We don't want that.
            response.resume();
            if (this[kRequest]) {
                this[kCancelTimeouts]();
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this[kRequest];
                this[kUnproxyEvents]();
            }
            const shouldBeGet = statusCode === 303 && options.method !== 'GET' && options.method !== 'HEAD';
            if (shouldBeGet || !options.methodRewriting) {
                // Server responded with "see other", indicating that the resource exists at another location,
                // and the client should request it from that location via GET or HEAD.
                options.method = 'GET';
                if ('body' in options) {
                    delete options.body;
                }
                if ('json' in options) {
                    delete options.json;
                }
                if ('form' in options) {
                    delete options.form;
                }
            }
            if (this.redirects.length >= options.maxRedirects) {
                this._beforeError(new MaxRedirectsError(this));
                return;
            }
            try {
                // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();
                const redirectUrl = new url_1.URL(redirectBuffer, url);
                const redirectString = redirectUrl.toString();
                decodeURI(redirectString);
                // Redirecting to a different site, clear sensitive data.
                if (redirectUrl.hostname !== url.hostname) {
                    if ('host' in options.headers) {
                        delete options.headers.host;
                    }
                    if ('cookie' in options.headers) {
                        delete options.headers.cookie;
                    }
                    if ('authorization' in options.headers) {
                        delete options.headers.authorization;
                    }
                    if (options.username || options.password) {
                        delete options.username;
                        delete options.password;
                    }
                }
                this.redirects.push(redirectString);
                options.url = redirectUrl;
                for (const hook of options.hooks.beforeRedirect) {
                    // eslint-disable-next-line no-await-in-loop
                    await hook(options, typedResponse);
                }
                this.emit('redirect', typedResponse, options);
                await this._makeRequest();
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
            return;
        }
        const limitStatusCode = options.followRedirect ? 299 : 399;
        const isOk = (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;
        if (options.throwHttpErrors && !isOk) {
            await this._beforeError(new HTTPError(typedResponse));
            if (this.destroyed) {
                return;
            }
        }
        response.on('readable', () => {
            if (this[kTriggerRead]) {
                this._read();
            }
        });
        this.on('resume', () => {
            response.resume();
        });
        this.on('pause', () => {
            response.pause();
        });
        response.once('end', () => {
            this.push(null);
        });
        this.emit('response', response);
        for (const destination of this[kServerResponsesPiped]) {
            if (destination.headersSent) {
                continue;
            }
            // eslint-disable-next-line guard-for-in
            for (const key in response.headers) {
                const isAllowed = options.decompress ? key !== 'content-encoding' : true;
                const value = response.headers[key];
                if (isAllowed) {
                    destination.setHeader(key, value);
                }
            }
            destination.statusCode = statusCode;
        }
    }
    _onRequest(request) {
        const { options } = this;
        const { timeout, url } = options;
        http_timer_1.default(request);
        this[kCancelTimeouts] = timed_out_1.default(request, timeout, url);
        const responseEventName = options.cache ? 'cacheableResponse' : 'response';
        request.once(responseEventName, (response) => {
            this._onResponse(response);
        });
        request.once('error', (error) => {
            // Force clean-up, because some packages (e.g. nock) don't do this.
            request.destroy();
            if (error instanceof timed_out_1.TimeoutError) {
                error = new TimeoutError(error, this.timings, this);
            }
            else {
                error = new RequestError(error.message, error, this);
            }
            this._beforeError(error);
        });
        this[kUnproxyEvents] = proxy_events_1.default(request, this, proxiedRequestEvents);
        this[kRequest] = request;
        this.emit('uploadProgress', this.uploadProgress);
        // Send body
        const body = this[kBody];
        const currentRequest = this.redirects.length === 0 ? this : request;
        if (is_1.default.nodeStream(body)) {
            body.pipe(currentRequest);
            body.once('error', (error) => {
                this._beforeError(new UploadError(error, this));
            });
            body.once('end', () => {
                delete options.body;
            });
        }
        else {
            this._unlockWrite();
            if (!is_1.default.undefined(body)) {
                this._writeRequest(body, null, () => { });
                currentRequest.end();
                this._lockWrite();
            }
            else if (this._cannotHaveBody || this._noPipe) {
                currentRequest.end();
                this._lockWrite();
            }
        }
        this.emit('request', request);
    }
    async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject) => {
            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
            Object.assign(options, url_to_options_1.default(url));
            // `http-cache-semantics` checks this
            delete options.url;
            // This is ugly
            const cacheRequest = cacheableStore.get(options.cache)(options, response => {
                const typedResponse = response;
                const { req } = typedResponse;
                if (req) {
                    req.emit('cacheableResponse', typedResponse);
                }
                resolve(typedResponse);
            });
            // Restore options
            options.url = url;
            cacheRequest.once('error', reject);
            cacheRequest.once('request', resolve);
        });
    }
    async _makeRequest() {
        var _a;
        const { options } = this;
        const { url, headers, request, agent, timeout } = options;
        for (const key in headers) {
            if (is_1.default.undefined(headers[key])) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete headers[key];
            }
            else if (is_1.default.null_(headers[key])) {
                throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
            }
        }
        if (options.decompress && is_1.default.undefined(headers['accept-encoding'])) {
            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';
        }
        // Set cookies
        if (options.cookieJar) {
            const cookieString = await options.cookieJar.getCookieString(options.url.toString());
            if (is_1.default.nonEmptyString(cookieString)) {
                options.headers.cookie = cookieString;
            }
        }
        for (const hook of options.hooks.beforeRequest) {
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(options);
            if (!is_1.default.undefined(result)) {
                // @ts-ignore Skip the type mismatch to support abstract responses
                options.request = () => result;
                break;
            }
        }
        if (options.dnsCache && !('lookup' in options)) {
            options.lookup = options.dnsCache.lookup;
        }
        // UNIX sockets
        if (url.hostname === 'unix') {
            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
            if (matches === null || matches === void 0 ? void 0 : matches.groups) {
                const { socketPath, path } = matches.groups;
                Object.assign(options, {
                    socketPath,
                    path,
                    host: ''
                });
            }
        }
        const isHttps = url.protocol === 'https:';
        // Fallback function
        let fallbackFn;
        if (options.http2) {
            fallbackFn = http2wrapper.auto;
        }
        else {
            fallbackFn = isHttps ? https.request : http.request;
        }
        const realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn;
        // Cache support
        const fn = options.cache ? this._createCacheableRequest : realFn;
        // Pass an agent directly when HTTP2 is disabled
        if (agent && !options.http2) {
            options.agent = agent[isHttps ? 'https' : 'http'];
        }
        // Prepare plain HTTP request options
        options[kRequest] = realFn;
        delete options.request;
        delete options.timeout;
        try {
            let requestOrResponse = await fn(url, options);
            if (is_1.default.undefined(requestOrResponse)) {
                requestOrResponse = fallbackFn(url, options);
            }
            // Restore options
            options.request = request;
            options.timeout = timeout;
            options.agent = agent;
            if (isClientRequest(requestOrResponse)) {
                this._onRequest(requestOrResponse);
                // Emit the response after the stream has been ended
            }
            else if (this.writable) {
                this.once('finish', () => {
                    this._onResponse(requestOrResponse);
                });
                this._unlockWrite();
                this.end();
                this._lockWrite();
            }
            else {
                this._onResponse(requestOrResponse);
            }
        }
        catch (error) {
            if (error instanceof CacheableRequest.CacheError) {
                throw new CacheError(error, this);
            }
            throw new RequestError(error.message, error, this);
        }
    }
    async _beforeError(error) {
        this[kStopReading] = true;
        if (!(error instanceof RequestError)) {
            error = new RequestError(error.message, error, this);
        }
        try {
            const { response } = error;
            if (response) {
                response.setEncoding(this._readableState.encoding);
                response.rawBody = await getStream.buffer(response);
                response.body = response.rawBody.toString();
            }
        }
        catch (_) { }
        try {
            for (const hook of this.options.hooks.beforeError) {
                // eslint-disable-next-line no-await-in-loop
                error = await hook(error);
            }
        }
        catch (error_) {
            error = new RequestError(error_.message, error_, this);
        }
        // This is a workaround for https://github.com/nodejs/node/issues/33335
        if (!this.destroyed) {
            this.destroy(error);
        }
    }
    _read() {
        this[kTriggerRead] = true;
        const response = this[kResponse];
        if (response && !this[kStopReading]) {
            // We cannot put this in the `if` above
            // because `.read()` also triggers the `end` event
            if (response.readableLength) {
                this[kTriggerRead] = false;
            }
            let data;
            while ((data = response.read()) !== null) {
                this[kDownloadedSize] += data.length;
                this[kStartedReading] = true;
                const progress = this.downloadProgress;
                if (progress.percent < 1) {
                    this.emit('downloadProgress', progress);
                }
                this.push(data);
            }
        }
    }
    _write(chunk, encoding, callback) {
        const write = () => {
            this._writeRequest(chunk, encoding, callback);
        };
        if (this.requestInitialized) {
            write();
        }
        else {
            this[kJobs].push(write);
        }
    }
    _writeRequest(chunk, encoding, callback) {
        this._progressCallbacks.push(() => {
            this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
            const progress = this.uploadProgress;
            if (progress.percent < 1) {
                this.emit('uploadProgress', progress);
            }
        });
        // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.
        this[kRequest].write(chunk, encoding, (error) => {
            if (!error && this._progressCallbacks.length !== 0) {
                this._progressCallbacks.shift()();
            }
            callback(error);
        });
    }
    _final(callback) {
        const endRequest = () => {
            // FIX: Node.js 10 calls the write callback AFTER the end callback!
            while (this._progressCallbacks.length !== 0) {
                this._progressCallbacks.shift()();
            }
            // We need to check if `this[kRequest]` is present,
            // because it isn't when we use cache.
            if (!(kRequest in this)) {
                callback();
                return;
            }
            this[kRequest].end((error) => {
                if (!error) {
                    this[kBodySize] = this[kUploadedSize];
                    this.emit('uploadProgress', this.uploadProgress);
                    this[kRequest].emit('upload-complete');
                }
                callback(error);
            });
        };
        if (this.requestInitialized) {
            endRequest();
        }
        else {
            this[kJobs].push(endRequest);
        }
    }
    _destroy(error, callback) {
        var _a;
        if (kRequest in this) {
            this[kCancelTimeouts]();
            // TODO: Remove the next `if` when these get fixed:
            // - https://github.com/nodejs/node/issues/32851
            if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {
                this[kRequest].destroy();
            }
        }
        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {
            error = new RequestError(error.message, error, this);
        }
        callback(error);
    }
    get ip() {
        var _a;
        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket.remoteAddress;
    }
    get aborted() {
        var _a, _b, _c;
        return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
    }
    get socket() {
        var _a;
        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket;
    }
    get downloadProgress() {
        let percent;
        if (this[kResponseSize]) {
            percent = this[kDownloadedSize] / this[kResponseSize];
        }
        else if (this[kResponseSize] === this[kDownloadedSize]) {
            percent = 1;
        }
        else {
            percent = 0;
        }
        return {
            percent,
            transferred: this[kDownloadedSize],
            total: this[kResponseSize]
        };
    }
    get uploadProgress() {
        let percent;
        if (this[kBodySize]) {
            percent = this[kUploadedSize] / this[kBodySize];
        }
        else if (this[kBodySize] === this[kUploadedSize]) {
            percent = 1;
        }
        else {
            percent = 0;
        }
        return {
            percent,
            transferred: this[kUploadedSize],
            total: this[kBodySize]
        };
    }
    get timings() {
        var _a;
        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;
    }
    get isFromCache() {
        return this[kIsFromCache];
    }
    pipe(destination, options) {
        if (this[kStartedReading]) {
            throw new Error('Failed to pipe. The response has been emitted already.');
        }
        if (destination instanceof http_1.ServerResponse) {
            this[kServerResponsesPiped].add(destination);
        }
        return super.pipe(destination, options);
    }
    unpipe(destination) {
        if (destination instanceof http_1.ServerResponse) {
            this[kServerResponsesPiped].delete(destination);
        }
        super.unpipe(destination);
        return this;
    }
}
exports.default = Request;


/***/ }),
/* 730 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const defer_to_connect_1 = __webpack_require__(731);
const nodejsMajorVersion = Number(process.versions.node.split('.')[0]);
const timer = (request) => {
    const timings = {
        start: Date.now(),
        socket: undefined,
        lookup: undefined,
        connect: undefined,
        secureConnect: undefined,
        upload: undefined,
        response: undefined,
        end: undefined,
        error: undefined,
        abort: undefined,
        phases: {
            wait: undefined,
            dns: undefined,
            tcp: undefined,
            tls: undefined,
            request: undefined,
            firstByte: undefined,
            download: undefined,
            total: undefined
        }
    };
    request.timings = timings;
    const handleError = (origin) => {
        const emit = origin.emit.bind(origin);
        origin.emit = (event, ...args) => {
            // Catches the `error` event
            if (event === 'error') {
                timings.error = Date.now();
                timings.phases.total = timings.error - timings.start;
                origin.emit = emit;
            }
            // Saves the original behavior
            return emit(event, ...args);
        };
    };
    handleError(request);
    request.prependOnceListener('abort', () => {
        timings.abort = Date.now();
        // Let the `end` response event be responsible for setting the total phase,
        // unless the Node.js major version is >= 13.
        if (!timings.response || nodejsMajorVersion >= 13) {
            timings.phases.total = Date.now() - timings.start;
        }
    });
    const onSocket = (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        const lookupListener = () => {
            timings.lookup = Date.now();
            timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener('lookup', lookupListener);
        defer_to_connect_1.default(socket, {
            connect: () => {
                timings.connect = Date.now();
                if (timings.lookup === undefined) {
                    socket.removeListener('lookup', lookupListener);
                    timings.lookup = timings.connect;
                    timings.phases.dns = timings.lookup - timings.socket;
                }
                timings.phases.tcp = timings.connect - timings.lookup;
                // This callback is called before flushing any data,
                // so we don't need to set `timings.phases.request` here.
            },
            secureConnect: () => {
                timings.secureConnect = Date.now();
                timings.phases.tls = timings.secureConnect - timings.connect;
            }
        });
    };
    if (request.socket) {
        onSocket(request.socket);
    }
    else {
        request.prependOnceListener('socket', onSocket);
    }
    const onUpload = () => {
        var _a;
        timings.upload = Date.now();
        timings.phases.request = timings.upload - (_a = timings.secureConnect, (_a !== null && _a !== void 0 ? _a : timings.connect));
    };
    const writableFinished = () => {
        if (typeof request.writableFinished === 'boolean') {
            return request.writableFinished;
        }
        // Node.js doesn't have `request.writableFinished` property
        return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);
    };
    if (writableFinished()) {
        onUpload();
    }
    else {
        request.prependOnceListener('finish', onUpload);
    }
    request.prependOnceListener('response', (response) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener('end', () => {
            timings.end = Date.now();
            timings.phases.download = timings.end - timings.response;
            timings.phases.total = timings.end - timings.start;
        });
    });
    return timings;
};
exports.default = timer;
// For CommonJS default export support
module.exports = timer;
module.exports.default = timer;


/***/ }),
/* 731 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tls_1 = __webpack_require__(279);
const deferToConnect = (socket, fn) => {
    let listeners;
    if (typeof fn === 'function') {
        const connect = fn;
        listeners = { connect };
    }
    else {
        listeners = fn;
    }
    const hasConnectListener = typeof listeners.connect === 'function';
    const hasSecureConnectListener = typeof listeners.secureConnect === 'function';
    const hasCloseListener = typeof listeners.close === 'function';
    const onConnect = () => {
        if (hasConnectListener) {
            listeners.connect();
        }
        if (socket instanceof tls_1.TLSSocket && hasSecureConnectListener) {
            if (socket.authorized) {
                listeners.secureConnect();
            }
            else if (!socket.authorizationError) {
                socket.once('secureConnect', listeners.secureConnect);
            }
        }
        if (hasCloseListener) {
            socket.once('close', listeners.close);
        }
    };
    if (socket.writable && !socket.connecting) {
        onConnect();
    }
    else if (socket.connecting) {
        socket.once('connect', onConnect);
    }
    else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
    }
};
exports.default = deferToConnect;
// For CommonJS default export support
module.exports = deferToConnect;
module.exports.default = deferToConnect;


/***/ }),
/* 732 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {
	pipeline: streamPipeline,
	PassThrough: PassThroughStream
} = __webpack_require__(110);
const zlib = __webpack_require__(116);
const mimicResponse = __webpack_require__(733);

const decompressResponse = response => {
	const contentEncoding = (response.headers['content-encoding'] || '').toLowerCase();

	if (!['gzip', 'deflate', 'br'].includes(contentEncoding)) {
		return response;
	}

	// TODO: Remove this when targeting Node.js 12.
	const isBrotli = contentEncoding === 'br';
	if (isBrotli && typeof zlib.createBrotliDecompress !== 'function') {
		return response;
	}

	const decompress = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
	const stream = new PassThroughStream();

	decompress.on('error', error => {
		// Ignore empty response
		if (error.code === 'Z_BUF_ERROR') {
			stream.end();
			return;
		}

		stream.emit('error', error);
	});

	const finalStream = streamPipeline(response, decompress, stream, () => {});

	mimicResponse(response, finalStream);

	return finalStream;
};

module.exports = decompressResponse;


/***/ }),
/* 733 */
/***/ ((module) => {

"use strict";


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProperties = [
	'aborted',
	'complete',
	'destroy',
	'headers',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'method',
	'rawHeaders',
	'rawTrailers',
	'setTimeout',
	'socket',
	'statusCode',
	'statusMessage',
	'trailers',
	'url'
];

module.exports = (fromStream, toStream) => {
	const fromProps = new Set(Object.keys(fromStream).concat(knownProperties));

	for (const prop of fromProps) {
		// Don't overwrite existing properties
		if (prop in toStream) {
			continue;
		}

		toStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];
	}
};


/***/ }),
/* 734 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {
	V4MAPPED,
	ADDRCONFIG,
	promises: {
		Resolver: AsyncResolver
	},
	lookup
} = __webpack_require__(735);
const {promisify} = __webpack_require__(115);
const os = __webpack_require__(58);
const {getResolver: getHostsResolver} = __webpack_require__(736);

const kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');
const kCacheableLookupInstance = Symbol('cacheableLookupInstance');

const verifyAgent = agent => {
	if (!(agent && typeof agent.createConnection === 'function')) {
		throw new Error('Expected an Agent instance as the first argument');
	}
};

const map4to6 = entries => {
	for (const entry of entries) {
		entry.address = `::ffff:${entry.address}`;
		entry.family = 6;
	}
};

const getIfaceInfo = () => {
	let has4 = false;
	let has6 = false;

	for (const device of Object.values(os.networkInterfaces())) {
		for (const iface of device) {
			if (iface.internal) {
				continue;
			}

			if (iface.family === 'IPv6') {
				has6 = true;
			} else {
				has4 = true;
			}

			if (has4 && has6) {
				return {has4, has6};
			}
		}
	}

	return {has4, has6};
};

const ttl = {ttl: true};

class CacheableLookup {
	constructor({
		customHostsPath,
		watchingHostsFile = false,
		cache = new Map(),
		maxTtl = Infinity,
		resolver = new AsyncResolver(),
		fallbackTtl = 1,
		errorTtl = 0.15
	} = {}) {
		this.maxTtl = maxTtl;
		this.fallbackTtl = fallbackTtl;
		this.errorTtl = errorTtl;

		this._cache = cache;
		this._resolver = resolver;

		this._lookup = promisify(lookup);

		if (this._resolver instanceof AsyncResolver) {
			this._resolve4 = this._resolver.resolve4.bind(this._resolver);
			this._resolve6 = this._resolver.resolve6.bind(this._resolver);
		} else {
			this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));
			this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));
		}

		this._iface = getIfaceInfo();
		this._hostsResolver = getHostsResolver({customHostsPath, watching: watchingHostsFile});

		this._pending = {};

		this._nextRemovalTime = false;

		this.lookup = this.lookup.bind(this);
		this.lookupAsync = this.lookupAsync.bind(this);
	}

	set servers(servers) {
		this.updateInterfaceInfo();

		this._resolver.setServers(servers);
	}

	get servers() {
		return this._resolver.getServers();
	}

	lookup(hostname, options, callback) {
		if (typeof options === 'function') {
			callback = options;
			options = {};
		} else if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		if (!callback) {
			throw new Error('Callback must be a function.');
		}

		// eslint-disable-next-line promise/prefer-await-to-then
		this.lookupAsync(hostname, options).then(result => {
			if (options.all) {
				callback(null, result);
			} else {
				callback(null, result.address, result.family, result.expires, result.ttl);
			}
		}, callback);
	}

	async lookupAsync(hostname, options = {}) {
		if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		let cached = await this.query(hostname);

		if (options.family === 6) {
			const filtered = cached.filter(entry => entry.family === 6);

			if (filtered.length === 0 && options.hints & V4MAPPED) {
				map4to6(cached);
			} else {
				cached = filtered;
			}
		} else if (options.family === 4) {
			cached = cached.filter(entry => entry.family === 4);
		}

		if (options.hints & ADDRCONFIG) {
			const {_iface} = this;
			cached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);
		}

		if (cached.length === 0) {
			const error = new Error(`ENOTFOUND ${hostname}`);
			error.code = 'ENOTFOUND';
			error.hostname = hostname;

			throw error;
		}

		if (options.all) {
			return cached;
		}

		if (cached.length === 1) {
			return cached[0];
		}

		return this._getEntry(cached, hostname);
	}

	async query(hostname) {
		let cached = await this._hostsResolver.get(hostname) || await this._cache.get(hostname);

		if (!cached) {
			const pending = this._pending[hostname];

			if (pending) {
				cached = await pending;
			} else {
				const newPromise = this.queryAndCache(hostname);
				this._pending[hostname] = newPromise;

				cached = await newPromise;
			}
		}

		cached = cached.map(entry => {
			return {...entry};
		});

		return cached;
	}

	async queryAndCache(hostname) {
		// We could make an ANY query, but DNS servers may reject that.
		const [As, AAAAs] = await Promise.all([this._resolve4(hostname, ttl).catch(() => []), this._resolve6(hostname, ttl).catch(() => [])]);

		let cacheTtl = 0;

		if (As) {
			for (const entry of As) {
				entry.family = 4;
				entry.expires = Date.now() + (entry.ttl * 1000);

				// Is the TTL the same for all entries?
				cacheTtl = Math.max(cacheTtl, entry.ttl);
			}
		}

		if (AAAAs) {
			for (const entry of AAAAs) {
				entry.family = 6;
				entry.expires = Date.now() + (entry.ttl * 1000);

				// Is the TTL the same for all entries?
				cacheTtl = Math.max(cacheTtl, entry.ttl);
			}
		}

		let entries = [...(As || []), ...(AAAAs || [])];

		if (entries.length === 0) {
			try {
				entries = await this._lookup(hostname, {
					all: true
				});

				for (const entry of entries) {
					entry.ttl = this.fallbackTtl;
					entry.expires = Date.now() + (entry.ttl * 1000);
				}

				cacheTtl = this.fallbackTtl * 1000;
			} catch (error) {
				delete this._pending[hostname];

				if (error.code === 'ENOTFOUND') {
					cacheTtl = this.errorTtl * 1000;

					entries.expires = Date.now() + cacheTtl;
					await this._cache.set(hostname, entries, cacheTtl);

					this._tick(cacheTtl);
				}

				throw error;
			}
		} else {
			cacheTtl = Math.min(this.maxTtl, cacheTtl) * 1000;
		}

		if (this.maxTtl > 0 && cacheTtl > 0) {
			entries.expires = Date.now() + cacheTtl;
			await this._cache.set(hostname, entries, cacheTtl);

			this._tick(cacheTtl);
		}

		delete this._pending[hostname];

		return entries;
	}

	// eslint-disable-next-line no-unused-vars
	_getEntry(entries, hostname) {
		return entries[0];
	}

	/* istanbul ignore next: deprecated */
	tick() {}

	_tick(ms) {
		if (!(this._cache instanceof Map) || ms === undefined) {
			return;
		}

		const nextRemovalTime = this._nextRemovalTime;

		if (!nextRemovalTime || ms < nextRemovalTime) {
			clearTimeout(this._removalTimeout);

			this._nextRemovalTime = ms;

			this._removalTimeout = setTimeout(() => {
				this._nextRemovalTime = false;

				let nextExpiry = Infinity;

				const now = Date.now();

				for (const [hostname, {expires}] of this._cache) {
					if (now >= expires) {
						this._cache.delete(hostname);
					} else if (expires < nextExpiry) {
						nextExpiry = expires;
					}
				}

				if (nextExpiry !== Infinity) {
					this._tick(nextExpiry - now);
				}
			}, ms);

			/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */
			if (this._removalTimeout.unref) {
				this._removalTimeout.unref();
			}
		}
	}

	install(agent) {
		verifyAgent(agent);

		if (kCacheableLookupCreateConnection in agent) {
			throw new Error('CacheableLookup has been already installed');
		}

		agent[kCacheableLookupCreateConnection] = agent.createConnection;
		agent[kCacheableLookupInstance] = this;

		agent.createConnection = (options, callback) => {
			if (!('lookup' in options)) {
				options.lookup = this.lookup;
			}

			return agent[kCacheableLookupCreateConnection](options, callback);
		};
	}

	uninstall(agent) {
		verifyAgent(agent);

		if (agent[kCacheableLookupCreateConnection]) {
			if (agent[kCacheableLookupInstance] !== this) {
				throw new Error('The agent is not owned by this CacheableLookup instance');
			}

			agent.createConnection = agent[kCacheableLookupCreateConnection];

			delete agent[kCacheableLookupCreateConnection];
			delete agent[kCacheableLookupInstance];
		}
	}

	updateInterfaceInfo() {
		this._iface = getIfaceInfo();
		this._cache.clear();
	}

	clear(hostname) {
		if (hostname) {
			this._cache.delete(hostname);
			return;
		}

		this._cache.clear();
	}
}

module.exports = CacheableLookup;
module.exports.default = CacheableLookup;


/***/ }),
/* 735 */
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),
/* 736 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const path = __webpack_require__(113);
const {watch} = __webpack_require__(6);
const {readFile} = __webpack_require__(6).promises;
const {isIP} = __webpack_require__(278);

const isWindows = process.platform === 'win32';
const hostsPath = isWindows ? path.join(process.env.SystemDrive, 'Windows\\System32\\drivers\\etc\\hosts') : '/etc/hosts';

const hostnameRegExp = /^(?:(?:[a-zA-Z\d]|[a-zA-Z\d][a-zA-Z\d-]*[a-zA-Z\d])\.)*(?:[A-Za-z\d]|[A-Za-z\d][A-Za-z\d-]*[A-Za-z\d])$/;
const isHostname = hostname => hostnameRegExp.test(hostname);

const fileOptions = {
	encoding: 'utf8'
};

const whitespaceRegExp = /\s+/g;

class HostsResolver {
	constructor({watching, customHostsPath = hostsPath}) {
		this._hostsPath = customHostsPath;
		this._error = null;
		this._watcher = null;
		this._watching = watching;
		this._hosts = {};

		this._init();
	}

	_init() {
		if (typeof this._hostsPath !== 'string') {
			return;
		}

		this._promise = (async () => {
			await this._update();

			this._promise = null;

			if (this._error) {
				return;
			}

			if (this._watching) {
				this._watcher = watch(this._hostsPath, {
					persistent: false
				}, eventType => {
					if (eventType === 'change') {
						this._update();
					} else {
						this._watcher.close();
					}
				});

				this._watcher.once('error', error => {
					this._error = error;
					this._hosts = {};
				});

				this._watcher.once('close', () => {
					this._init();
				});
			}
		})();
	}

	async _update() {
		try {
			let lines = await readFile(this._hostsPath, fileOptions);
			lines = lines.split('\n');

			this._hosts = {};

			for (let line of lines) {
				line = line.replace(whitespaceRegExp, ' ').trim();

				const parts = line.split(' ');

				const family = isIP(parts[0]);
				if (!family) {
					continue;
				}

				const address = parts.shift();

				for (const hostname of parts) {
					if (!isHostname(hostname)) {
						break;
					}

					if (this._hosts[hostname]) {
						let shouldAbort = false;

						for (const entry of this._hosts[hostname]) {
							if (entry.family === family) {
								shouldAbort = true;
								break;
							}
						}

						if (shouldAbort) {
							continue;
						}
					} else {
						this._hosts[hostname] = [];
						this._hosts[hostname].expires = Infinity;
					}

					this._hosts[hostname].push({
						address,
						family,
						expires: Infinity,
						ttl: Infinity
					});
				}
			}
		} catch (error) {
			this._hosts = {};
			this._error = error;
		}
	}

	async get(hostname) {
		if (this._promise) {
			await this._promise;
		}

		if (this._error) {
			throw this._error;
		}

		return this._hosts[hostname];
	}
}

const resolvers = {};

const getResolver = ({customHostsPath, watching}) => {
	if (customHostsPath !== undefined && typeof customHostsPath !== 'string') {
		customHostsPath = false;
	}

	watching = Boolean(watching);

	const id = `${customHostsPath}:${watching}`;

	let resolver = resolvers[id];

	if (resolver) {
		return resolver;
	}

	resolver = new HostsResolver({customHostsPath, watching});
	resolvers[id] = resolver;

	return resolver;
};

HostsResolver.getResolver = getResolver;

module.exports = HostsResolver;


/***/ }),
/* 737 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(170);
const urlLib = __webpack_require__(281);
const normalizeUrl = __webpack_require__(738);
const getStream = __webpack_require__(722);
const CachePolicy = __webpack_require__(739);
const Response = __webpack_require__(740);
const lowercaseKeys = __webpack_require__(741);
const cloneResponse = __webpack_require__(742);
const Keyv = __webpack_require__(744);

class CacheableRequest {
	constructor(request, cacheAdapter) {
		if (typeof request !== 'function') {
			throw new TypeError('Parameter `request` must be a function');
		}

		this.cache = new Keyv({
			uri: typeof cacheAdapter === 'string' && cacheAdapter,
			store: typeof cacheAdapter !== 'string' && cacheAdapter,
			namespace: 'cacheable-request'
		});

		return this.createCacheableRequest(request);
	}

	createCacheableRequest(request) {
		return (opts, cb) => {
			let url;
			if (typeof opts === 'string') {
				url = normalizeUrlObject(urlLib.parse(opts));
				opts = {};
			} else if (opts instanceof urlLib.URL) {
				url = normalizeUrlObject(urlLib.parse(opts.toString()));
				opts = {};
			} else {
				const [pathname, ...searchParts] = (opts.path || '').split('?');
				const search = searchParts.length > 0 ?
					`?${searchParts.join('?')}` :
					'';
				url = normalizeUrlObject({ ...opts, pathname, search });
			}

			opts = {
				headers: {},
				method: 'GET',
				cache: true,
				strictTtl: false,
				automaticFailover: false,
				...opts,
				...urlObjectToRequestOptions(url)
			};
			opts.headers = lowercaseKeys(opts.headers);

			const ee = new EventEmitter();
			const normalizedUrlString = normalizeUrl(
				urlLib.format(url),
				{
					stripWWW: false,
					removeTrailingSlash: false,
					stripAuthentication: false
				}
			);
			const key = `${opts.method}:${normalizedUrlString}`;
			let revalidate = false;
			let madeRequest = false;

			const makeRequest = opts => {
				madeRequest = true;
				let requestErrored = false;
				let requestErrorCallback;

				const requestErrorPromise = new Promise(resolve => {
					requestErrorCallback = () => {
						if (!requestErrored) {
							requestErrored = true;
							resolve();
						}
					};
				});

				const handler = response => {
					if (revalidate && !opts.forceRefresh) {
						response.status = response.statusCode;
						const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);
						if (!revalidatedPolicy.modified) {
							const headers = revalidatedPolicy.policy.responseHeaders();
							response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
							response.cachePolicy = revalidatedPolicy.policy;
							response.fromCache = true;
						}
					}

					if (!response.fromCache) {
						response.cachePolicy = new CachePolicy(opts, response, opts);
						response.fromCache = false;
					}

					let clonedResponse;
					if (opts.cache && response.cachePolicy.storable()) {
						clonedResponse = cloneResponse(response);

						(async () => {
							try {
								const bodyPromise = getStream.buffer(response);

								await Promise.race([
									requestErrorPromise,
									new Promise(resolve => response.once('end', resolve))
								]);

								if (requestErrored) {
									return;
								}

								const body = await bodyPromise;

								const value = {
									cachePolicy: response.cachePolicy.toObject(),
									url: response.url,
									statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
									body
								};

								let ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;
								if (opts.maxTtl) {
									ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;
								}

								await this.cache.set(key, value, ttl);
							} catch (error) {
								ee.emit('error', new CacheableRequest.CacheError(error));
							}
						})();
					} else if (opts.cache && revalidate) {
						(async () => {
							try {
								await this.cache.delete(key);
							} catch (error) {
								ee.emit('error', new CacheableRequest.CacheError(error));
							}
						})();
					}

					ee.emit('response', clonedResponse || response);
					if (typeof cb === 'function') {
						cb(clonedResponse || response);
					}
				};

				try {
					const req = request(opts, handler);
					req.once('error', requestErrorCallback);
					req.once('abort', requestErrorCallback);
					ee.emit('request', req);
				} catch (error) {
					ee.emit('error', new CacheableRequest.RequestError(error));
				}
			};

			(async () => {
				const get = async opts => {
					await Promise.resolve();

					const cacheEntry = opts.cache ? await this.cache.get(key) : undefined;
					if (typeof cacheEntry === 'undefined') {
						return makeRequest(opts);
					}

					const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
					if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {
						const headers = policy.responseHeaders();
						const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
						response.cachePolicy = policy;
						response.fromCache = true;

						ee.emit('response', response);
						if (typeof cb === 'function') {
							cb(response);
						}
					} else {
						revalidate = cacheEntry;
						opts.headers = policy.revalidationHeaders(opts);
						makeRequest(opts);
					}
				};

				const errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));
				this.cache.once('error', errorHandler);
				ee.on('response', () => this.cache.removeListener('error', errorHandler));

				try {
					await get(opts);
				} catch (error) {
					if (opts.automaticFailover && !madeRequest) {
						makeRequest(opts);
					}

					ee.emit('error', new CacheableRequest.CacheError(error));
				}
			})();

			return ee;
		};
	}
}

function urlObjectToRequestOptions(url) {
	const options = { ...url };
	options.path = `${url.pathname || '/'}${url.search || ''}`;
	delete options.pathname;
	delete options.search;
	return options;
}

function normalizeUrlObject(url) {
	// If url was parsed by url.parse or new URL:
	// - hostname will be set
	// - host will be hostname[:port]
	// - port will be set if it was explicit in the parsed string
	// Otherwise, url was from request options:
	// - hostname or host may be set
	// - host shall not have port encoded
	return {
		protocol: url.protocol,
		auth: url.auth,
		hostname: url.hostname || url.host || 'localhost',
		port: url.port,
		pathname: url.pathname,
		search: url.search
	};
}

CacheableRequest.RequestError = class extends Error {
	constructor(error) {
		super(error.message);
		this.name = 'RequestError';
		Object.assign(this, error);
	}
};

CacheableRequest.CacheError = class extends Error {
	constructor(error) {
		super(error.message);
		this.name = 'CacheError';
		Object.assign(this, error);
	}
};

module.exports = CacheableRequest;


/***/ }),
/* 738 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Use the `URL` global when targeting Node.js 10
const URLParser = typeof URL === 'undefined' ? __webpack_require__(281).URL : URL;

// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
const DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';
const DATA_URL_DEFAULT_CHARSET = 'us-ascii';

const testParameter = (name, filters) => {
	return filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);
};

const normalizeDataURL = (urlString, {stripHash}) => {
	const parts = urlString.match(/^data:(.*?),(.*?)(?:#(.*))?$/);

	if (!parts) {
		throw new Error(`Invalid URL: ${urlString}`);
	}

	const mediaType = parts[1].split(';');
	const body = parts[2];
	const hash = stripHash ? '' : parts[3];

	let base64 = false;

	if (mediaType[mediaType.length - 1] === 'base64') {
		mediaType.pop();
		base64 = true;
	}

	// Lowercase MIME type
	const mimeType = (mediaType.shift() || '').toLowerCase();
	const attributes = mediaType
		.map(attribute => {
			let [key, value = ''] = attribute.split('=').map(string => string.trim());

			// Lowercase `charset`
			if (key === 'charset') {
				value = value.toLowerCase();

				if (value === DATA_URL_DEFAULT_CHARSET) {
					return '';
				}
			}

			return `${key}${value ? `=${value}` : ''}`;
		})
		.filter(Boolean);

	const normalizedMediaType = [
		...attributes
	];

	if (base64) {
		normalizedMediaType.push('base64');
	}

	if (normalizedMediaType.length !== 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {
		normalizedMediaType.unshift(mimeType);
	}

	return `data:${normalizedMediaType.join(';')},${base64 ? body.trim() : body}${hash ? `#${hash}` : ''}`;
};

const normalizeUrl = (urlString, options) => {
	options = {
		defaultProtocol: 'http:',
		normalizeProtocol: true,
		forceHttp: false,
		forceHttps: false,
		stripAuthentication: true,
		stripHash: false,
		stripWWW: true,
		removeQueryParameters: [/^utm_\w+/i],
		removeTrailingSlash: true,
		removeDirectoryIndex: false,
		sortQueryParameters: true,
		...options
	};

	// TODO: Remove this at some point in the future
	if (Reflect.has(options, 'normalizeHttps')) {
		throw new Error('options.normalizeHttps is renamed to options.forceHttp');
	}

	if (Reflect.has(options, 'normalizeHttp')) {
		throw new Error('options.normalizeHttp is renamed to options.forceHttps');
	}

	if (Reflect.has(options, 'stripFragment')) {
		throw new Error('options.stripFragment is renamed to options.stripHash');
	}

	urlString = urlString.trim();

	// Data URL
	if (/^data:/i.test(urlString)) {
		return normalizeDataURL(urlString, options);
	}

	const hasRelativeProtocol = urlString.startsWith('//');
	const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);

	// Prepend protocol
	if (!isRelativeUrl) {
		urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
	}

	const urlObj = new URLParser(urlString);

	if (options.forceHttp && options.forceHttps) {
		throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
	}

	if (options.forceHttp && urlObj.protocol === 'https:') {
		urlObj.protocol = 'http:';
	}

	if (options.forceHttps && urlObj.protocol === 'http:') {
		urlObj.protocol = 'https:';
	}

	// Remove auth
	if (options.stripAuthentication) {
		urlObj.username = '';
		urlObj.password = '';
	}

	// Remove hash
	if (options.stripHash) {
		urlObj.hash = '';
	}

	// Remove duplicate slashes if not preceded by a protocol
	if (urlObj.pathname) {
		// TODO: Use the following instead when targeting Node.js 10
		// `urlObj.pathname = urlObj.pathname.replace(/(?<!https?:)\/{2,}/g, '/');`
		urlObj.pathname = urlObj.pathname.replace(/((?!:).|^)\/{2,}/g, (_, p1) => {
			if (/^(?!\/)/g.test(p1)) {
				return `${p1}/`;
			}

			return '/';
		});
	}

	// Decode URI octets
	if (urlObj.pathname) {
		urlObj.pathname = decodeURI(urlObj.pathname);
	}

	// Remove directory index
	if (options.removeDirectoryIndex === true) {
		options.removeDirectoryIndex = [/^index\.[a-z]+$/];
	}

	if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
		let pathComponents = urlObj.pathname.split('/');
		const lastComponent = pathComponents[pathComponents.length - 1];

		if (testParameter(lastComponent, options.removeDirectoryIndex)) {
			pathComponents = pathComponents.slice(0, pathComponents.length - 1);
			urlObj.pathname = pathComponents.slice(1).join('/') + '/';
		}
	}

	if (urlObj.hostname) {
		// Remove trailing dot
		urlObj.hostname = urlObj.hostname.replace(/\.$/, '');

		// Remove `www.`
		if (options.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z.]{2,5})$/.test(urlObj.hostname)) {
			// Each label should be max 63 at length (min: 2).
			// The extension should be max 5 at length (min: 2).
			// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
			urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
		}
	}

	// Remove query unwanted parameters
	if (Array.isArray(options.removeQueryParameters)) {
		for (const key of [...urlObj.searchParams.keys()]) {
			if (testParameter(key, options.removeQueryParameters)) {
				urlObj.searchParams.delete(key);
			}
		}
	}

	// Sort query parameters
	if (options.sortQueryParameters) {
		urlObj.searchParams.sort();
	}

	if (options.removeTrailingSlash) {
		urlObj.pathname = urlObj.pathname.replace(/\/$/, '');
	}

	// Take advantage of many of the Node `url` normalizations
	urlString = urlObj.toString();

	// Remove ending `/`
	if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '') {
		urlString = urlString.replace(/\/$/, '');
	}

	// Restore relative protocol, if applicable
	if (hasRelativeProtocol && !options.normalizeProtocol) {
		urlString = urlString.replace(/^http:\/\//, '//');
	}

	// Remove http/https
	if (options.stripProtocol) {
		urlString = urlString.replace(/^(?:https?:)?\/\//, '');
	}

	return urlString;
};

module.exports = normalizeUrl;
// TODO: Remove this for the next major release
module.exports.default = normalizeUrl;


/***/ }),
/* 739 */
/***/ ((module) => {

"use strict";

// rfc7231 6.1
const statusCodeCacheableByDefault = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501];

// This implementation does not understand partial responses (206)
const understoodStatuses = [200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501];

const hopByHopHeaders = {
    'date': true, // included, because we add Age update Date
    'connection':true, 'keep-alive':true, 'proxy-authenticate':true, 'proxy-authorization':true, 'te':true, 'trailer':true, 'transfer-encoding':true, 'upgrade':true
};
const excludedFromRevalidationUpdate = {
    // Since the old body is reused, it doesn't make sense to change properties of the body
    'content-length': true, 'content-encoding': true, 'transfer-encoding': true,
    'content-range': true,
};

function parseCacheControl(header) {
    const cc = {};
    if (!header) return cc;

    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
    const parts = header.trim().split(/\s*,\s*/); // TODO: lame parsing
    for(const part of parts) {
        const [k,v] = part.split(/\s*=\s*/, 2);
        cc[k] = (v === undefined) ? true : v.replace(/^"|"$/g, ''); // TODO: lame unquoting
    }

    return cc;
}

function formatCacheControl(cc) {
    let parts = [];
    for(const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + '=' + v);
    }
    if (!parts.length) {
        return undefined;
    }
    return parts.join(', ');
}

module.exports = class CachePolicy {
    constructor(req, res, {shared, cacheHeuristic, immutableMinTimeToLive, ignoreCargoCult, trustServerDate, _fromObject} = {}) {
        if (_fromObject) {
            this._fromObject(_fromObject);
            return;
        }

        if (!res || !res.headers) {
            throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);

        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._trustServerDate = undefined !== trustServerDate ? trustServerDate : true;
        this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE
        this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24*3600*1000;

        this._status = 'status' in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers['cache-control']);
        this._method = 'method' in req ? req.method : 'GET';
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used
        this._reqcc = parseCacheControl(req.headers['cache-control']);

        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
        // so there's no point stricly adhering to the blindly copy&pasted directives.
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
            delete this._rescc['pre-check'];
            delete this._rescc['post-check'];
            delete this._rescc['no-cache'];
            delete this._rescc['no-store'];
            delete this._rescc['must-revalidate'];
            this._resHeaders = Object.assign({}, this._resHeaders, {'cache-control': formatCacheControl(this._rescc)});
            delete this._resHeaders.expires;
            delete this._resHeaders.pragma;
        }

        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
        // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
        if (!res.headers['cache-control'] && /no-cache/.test(res.headers.pragma)) {
            this._rescc['no-cache'] = true;
        }
    }

    now() {
        return Date.now();
    }

    storable() {
        // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
        return !!(!this._reqcc['no-store'] &&
            // A cache MUST NOT store a response to any request, unless:
            // The request method is understood by the cache and defined as being cacheable, and
            ('GET' === this._method || 'HEAD' === this._method || ('POST' === this._method && this._hasExplicitExpiration())) &&
            // the response status code is understood by the cache, and
            understoodStatuses.indexOf(this._status) !== -1 &&
            // the "no-store" cache directive does not appear in request or response header fields, and
            !this._rescc['no-store'] &&
            // the "private" response directive does not appear in the response, if the cache is shared, and
            (!this._isShared || !this._rescc.private) &&
            // the Authorization header field does not appear in the request, if the cache is shared,
            (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) &&
            // the response either:
            (
                // contains an Expires header field, or
                this._resHeaders.expires ||
                // contains a max-age response directive, or
                // contains a s-maxage response directive and the cache is shared, or
                // contains a public response directive.
                this._rescc.public || this._rescc['max-age'] || this._rescc['s-maxage'] ||
                // has a status code that is defined as cacheable by default
                statusCodeCacheableByDefault.indexOf(this._status) !== -1
            ));
    }

    _hasExplicitExpiration() {
        // 4.2.1 Calculating Freshness Lifetime
        return (this._isShared && this._rescc['s-maxage']) ||
            this._rescc['max-age'] ||
            this._resHeaders.expires;
    }

    _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
            throw Error("Request headers missing");
        }
    }

    satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);

        // When presented with a request, a cache MUST NOT reuse a stored response, unless:
        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
        // unless the stored response is successfully validated (Section 4.3), and
        const requestCC = parseCacheControl(req.headers['cache-control']);
        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {
            return false;
        }

        if (requestCC['max-age'] && this.age() > requestCC['max-age']) {
            return false;
        }

        if (requestCC['min-fresh'] && this.timeToLive() < 1000*requestCC['min-fresh']) {
            return false;
        }

        // the stored response is either:
        // fresh, or allowed to be served stale
        if (this.stale()) {
            const allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());
            if (!allowsStale) {
                return false;
            }
        }

        return this._requestMatches(req, false);
    }

    _requestMatches(req, allowHeadMethod) {
        // The presented effective request URI and that of the stored response match, and
        return (!this._url || this._url === req.url) &&
            (this._host === req.headers.host) &&
            // the request method associated with the stored response allows it to be used for the presented request, and
            (!req.method || this._method === req.method || (allowHeadMethod && 'HEAD' === req.method)) &&
            // selecting header fields nominated by the stored response (if any) match those presented, and
            this._varyMatches(req);
    }

    _allowsStoringAuthenticated() {
        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
        return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];
    }

    _varyMatches(req) {
        if (!this._resHeaders.vary) {
            return true;
        }

        // A Vary header field-value of "*" always fails to match
        if (this._resHeaders.vary === '*') {
            return false;
        }

        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for(const name of fields) {
            if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
    }

    _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for(const name in inHeaders) {
            if (hopByHopHeaders[name]) continue;
            headers[name] = inHeaders[name];
        }
        // 9.1.  Connection
        if (inHeaders.connection) {
            const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
            for(const name of tokens) {
                delete headers[name];
            }
        }
        if (headers.warning) {
            const warnings = headers.warning.split(/,/).filter(warning => {
                return !/^\s*1[0-9][0-9]/.test(warning);
            });
            if (!warnings.length) {
                delete headers.warning;
            } else {
                headers.warning = warnings.join(',').trim();
            }
        }
        return headers;
    }

    responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();

        // A cache SHOULD generate 113 warning if it heuristically chose a freshness
        // lifetime greater than 24 hours and the response's age is greater than 24 hours.
        if (age > 3600*24 && !this._hasExplicitExpiration() && this.maxAge() > 3600*24) {
            headers.warning = (headers.warning ? `${headers.warning}, ` : '') + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
    }

    /**
     * Value of the Date response header or current time if Date was demed invalid
     * @return timestamp
     */
    date() {
        if (this._trustServerDate) {
            return this._serverDate();
        }
        return this._responseTime;
    }

    _serverDate() {
        const dateValue = Date.parse(this._resHeaders.date)
        if (isFinite(dateValue)) {
            const maxClockDrift = 8*3600*1000;
            const clockDrift = Math.abs(this._responseTime - dateValue);
            if (clockDrift < maxClockDrift) {
                return dateValue;
            }
        }
        return this._responseTime;
    }

    /**
     * Value of the Age header, in seconds, updated for the current time.
     * May be fractional.
     *
     * @return Number
     */
    age() {
        let age = Math.max(0, (this._responseTime - this.date())/1000);
        if (this._resHeaders.age) {
            let ageValue = this._ageValue();
            if (ageValue > age) age = ageValue;
        }

        const residentTime = (this.now() - this._responseTime)/1000;
        return age + residentTime;
    }

    _ageValue() {
        const ageValue = parseInt(this._resHeaders.age);
        return isFinite(ageValue) ? ageValue : 0;
    }

    /**
     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
     *
     * For an up-to-date value, see `timeToLive()`.
     *
     * @return Number
     */
    maxAge() {
        if (!this.storable() || this._rescc['no-cache']) {
            return 0;
        }

        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
        // so this implementation requires explicit opt-in via public header
        if (this._isShared && (this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable)) {
            return 0;
        }

        if (this._resHeaders.vary === '*') {
            return 0;
        }

        if (this._isShared) {
            if (this._rescc['proxy-revalidate']) {
                return 0;
            }
            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
            if (this._rescc['s-maxage']) {
                return parseInt(this._rescc['s-maxage'], 10);
            }
        }

        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
        if (this._rescc['max-age']) {
            return parseInt(this._rescc['max-age'], 10);
        }

        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;

        const dateValue = this._serverDate();
        if (this._resHeaders.expires) {
            const expires = Date.parse(this._resHeaders.expires);
            // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
            if (Number.isNaN(expires) || expires < dateValue) {
                return 0;
            }
            return Math.max(defaultMinTtl, (expires - dateValue)/1000);
        }

        if (this._resHeaders['last-modified']) {
            const lastModified = Date.parse(this._resHeaders['last-modified']);
            if (isFinite(lastModified) && dateValue > lastModified) {
                return Math.max(defaultMinTtl, (dateValue - lastModified)/1000 * this._cacheHeuristic);
            }
        }

        return defaultMinTtl;
    }

    timeToLive() {
        return Math.max(0, this.maxAge() - this.age())*1000;
    }

    stale() {
        return this.maxAge() <= this.age();
    }

    static fromObject(obj) {
        return new this(undefined, undefined, {_fromObject:obj});
    }

    _fromObject(obj) {
        if (this._responseTime) throw Error("Reinitialized");
        if (!obj || obj.v !== 1) throw Error("Invalid serialization");

        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24*3600*1000;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
    }

    toObject() {
        return {
            v:1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc,
        };
    }

    /**
     * Headers for sending to the origin server to revalidate stale response.
     * Allows server to return 304 to allow reuse of the previous response.
     *
     * Hop by hop headers are always stripped.
     * Revalidation headers may be added or removed, depending on request.
     */
    revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);

        // This implementation does not understand range requests
        delete headers['if-range'];

        if (!this._requestMatches(incomingReq, true) || !this.storable()) { // revalidation allowed via HEAD
            // not for the same resource, or wasn't allowed to be cached anyway
            delete headers['if-none-match'];
            delete headers['if-modified-since'];
            return headers;
        }

        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
        if (this._resHeaders.etag) {
            headers['if-none-match'] = headers['if-none-match'] ? `${headers['if-none-match']}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }

        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
        const forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || (this._method && this._method != 'GET');

        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */
        if (forbidsWeakValidators) {
            delete headers['if-modified-since'];

            if (headers['if-none-match']) {
                const etags = headers['if-none-match'].split(/,/).filter(etag => {
                    return !/^\s*W\//.test(etag);
                });
                if (!etags.length) {
                    delete headers['if-none-match'];
                } else {
                    headers['if-none-match'] = etags.join(',').trim();
                }
            }
        } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {
            headers['if-modified-since'] = this._resHeaders['last-modified'];
        }

        return headers;
    }

    /**
     * Creates new CachePolicy with information combined from the previews response,
     * and the new revalidation response.
     *
     * Returns {policy, modified} where modified is a boolean indicating
     * whether the response body has been modified, and old cached body can't be used.
     *
     * @return {Object} {policy: CachePolicy, modified: Boolean}
     */
    revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (!response || !response.headers) {
            throw Error("Response headers missing");
        }

        // These aren't going to be supported exactly, since one CachePolicy object
        // doesn't know about all the other cached objects.
        let matches = false;
        if (response.status !== undefined && response.status != 304) {
            matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
            // "All of the stored responses with the same strong validator are selected.
            // If none of the stored responses contain the same strong validator,
            // then the cache MUST NOT use the new response to update any stored responses."
            matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//,'') === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
            // "If the new response contains a weak validator and that validator corresponds
            // to one of the cache's stored responses,
            // then the most recent of those matching stored responses is selected for update."
            matches = this._resHeaders.etag.replace(/^\s*W\//,'') === response.headers.etag.replace(/^\s*W\//,'');
        } else if (this._resHeaders['last-modified']) {
            matches = this._resHeaders['last-modified'] === response.headers['last-modified'];
        } else {
            // If the new response does not include any form of validator (such as in the case where
            // a client generates an If-Modified-Since request from a source other than the Last-Modified
            // response header field), and there is only one stored response, and that stored response also
            // lacks a validator, then that stored response is selected for update.
            if (!this._resHeaders.etag && !this._resHeaders['last-modified'] &&
                !response.headers.etag && !response.headers['last-modified']) {
                matches = true;
            }
        }

        if (!matches) {
            return {
                policy: new this.constructor(request, response),
                // Client receiving 304 without body, even if it's invalid/mismatched has no option
                // but to reuse a cached body. We don't have a good way to tell clients to do
                // error recovery in such case.
                modified: response.status != 304,
                matches: false,
            }
        }

        // use other header fields provided in the 304 (Not Modified) response to replace all instances
        // of the corresponding header fields in the stored response.
        const headers = {};
        for(const k in this._resHeaders) {
            headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }

        const newResponse = Object.assign({}, response, {
            status: this._status,
            method: this._method,
            headers,
        });
        return {
            policy: new this.constructor(request, newResponse, {shared: this._isShared, cacheHeuristic: this._cacheHeuristic, immutableMinTimeToLive: this._immutableMinTtl, trustServerDate: this._trustServerDate}),
            modified: false,
            matches: true,
        };
    }
};


/***/ }),
/* 740 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Readable = __webpack_require__(110).Readable;
const lowercaseKeys = __webpack_require__(741);

class Response extends Readable {
	constructor(statusCode, headers, body, url) {
		if (typeof statusCode !== 'number') {
			throw new TypeError('Argument `statusCode` should be a number');
		}
		if (typeof headers !== 'object') {
			throw new TypeError('Argument `headers` should be an object');
		}
		if (!(body instanceof Buffer)) {
			throw new TypeError('Argument `body` should be a buffer');
		}
		if (typeof url !== 'string') {
			throw new TypeError('Argument `url` should be a string');
		}

		super();
		this.statusCode = statusCode;
		this.headers = lowercaseKeys(headers);
		this.body = body;
		this.url = url;
	}

	_read() {
		this.push(this.body);
		this.push(null);
	}
}

module.exports = Response;


/***/ }),
/* 741 */
/***/ ((module) => {

"use strict";

module.exports = object => {
	const result = {};

	for (const [key, value] of Object.entries(object)) {
		result[key.toLowerCase()] = value;
	}

	return result;
};


/***/ }),
/* 742 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const PassThrough = __webpack_require__(110).PassThrough;
const mimicResponse = __webpack_require__(743);

const cloneResponse = response => {
	if (!(response && response.pipe)) {
		throw new TypeError('Parameter `response` must be a response stream.');
	}

	const clone = new PassThrough();
	mimicResponse(response, clone);

	return response.pipe(clone);
};

module.exports = cloneResponse;


/***/ }),
/* 743 */
/***/ ((module) => {

"use strict";


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProps = [
	'destroy',
	'setTimeout',
	'socket',
	'headers',
	'trailers',
	'rawHeaders',
	'statusCode',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'rawTrailers',
	'statusMessage'
];

module.exports = (fromStream, toStream) => {
	const fromProps = new Set(Object.keys(fromStream).concat(knownProps));

	for (const prop of fromProps) {
		// Don't overwrite existing properties
		if (prop in toStream) {
			continue;
		}

		toStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];
	}
};


/***/ }),
/* 744 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(170);
const JSONB = __webpack_require__(745);

const loadStore = opts => {
	const adapters = {
		redis: '@keyv/redis',
		mongodb: '@keyv/mongo',
		mongo: '@keyv/mongo',
		sqlite: '@keyv/sqlite',
		postgresql: '@keyv/postgres',
		postgres: '@keyv/postgres',
		mysql: '@keyv/mysql'
	};
	if (opts.adapter || opts.uri) {
		const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
		return new (__webpack_require__(746)(adapters[adapter]))(opts);
	}

	return new Map();
};

class Keyv extends EventEmitter {
	constructor(uri, opts) {
		super();
		this.opts = Object.assign(
			{
				namespace: 'keyv',
				serialize: JSONB.stringify,
				deserialize: JSONB.parse
			},
			(typeof uri === 'string') ? { uri } : uri,
			opts
		);

		if (!this.opts.store) {
			const adapterOpts = Object.assign({}, this.opts);
			this.opts.store = loadStore(adapterOpts);
		}

		if (typeof this.opts.store.on === 'function') {
			this.opts.store.on('error', err => this.emit('error', err));
		}

		this.opts.store.namespace = this.opts.namespace;
	}

	_getKeyPrefix(key) {
		return `${this.opts.namespace}:${key}`;
	}

	get(key, opts) {
		key = this._getKeyPrefix(key);
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.get(key))
			.then(data => {
				return (typeof data === 'string') ? this.opts.deserialize(data) : data;
			})
			.then(data => {
				if (data === undefined) {
					return undefined;
				}

				if (typeof data.expires === 'number' && Date.now() > data.expires) {
					this.delete(key);
					return undefined;
				}

				return (opts && opts.raw) ? data : data.value;
			});
	}

	set(key, value, ttl) {
		key = this._getKeyPrefix(key);
		if (typeof ttl === 'undefined') {
			ttl = this.opts.ttl;
		}

		if (ttl === 0) {
			ttl = undefined;
		}

		const { store } = this.opts;

		return Promise.resolve()
			.then(() => {
				const expires = (typeof ttl === 'number') ? (Date.now() + ttl) : null;
				value = { value, expires };
				return this.opts.serialize(value);
			})
			.then(value => store.set(key, value, ttl))
			.then(() => true);
	}

	delete(key) {
		key = this._getKeyPrefix(key);
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.delete(key));
	}

	clear() {
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.clear());
	}
}

module.exports = Keyv;


/***/ }),
/* 745 */
/***/ ((__unused_webpack_module, exports) => {

//TODO: handle reviver/dehydrate function like normal
//and handle indentation, like normal.
//if anyone needs this... please send pull request.

exports.stringify = function stringify (o) {
  if('undefined' == typeof o) return o

  if(o && Buffer.isBuffer(o))
    return JSON.stringify(':base64:' + o.toString('base64'))

  if(o && o.toJSON)
    o =  o.toJSON()

  if(o && 'object' === typeof o) {
    var s = ''
    var array = Array.isArray(o)
    s = array ? '[' : '{'
    var first = true

    for(var k in o) {
      var ignore = 'function' == typeof o[k] || (!array && 'undefined' === typeof o[k])
      if(Object.hasOwnProperty.call(o, k) && !ignore) {
        if(!first)
          s += ','
        first = false
        if (array) {
          if(o[k] == undefined)
            s += 'null'
          else
            s += stringify(o[k])
        } else if (o[k] !== void(0)) {
          s += stringify(k) + ':' + stringify(o[k])
        }
      }
    }

    s += array ? ']' : '}'

    return s
  } else if ('string' === typeof o) {
    return JSON.stringify(/^:/.test(o) ? ':' + o : o)
  } else if ('undefined' === typeof o) {
    return 'null';
  } else
    return JSON.stringify(o)
}

exports.parse = function (s) {
  return JSON.parse(s, function (key, value) {
    if('string' === typeof value) {
      if(/^:base64:/.test(value))
        return Buffer.from(value.substring(8), 'base64')
      else
        return /^:/.test(value) ? value.substring(1) : value 
    }
    return value
  })
}


/***/ }),
/* 746 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => [];
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 746;
module.exports = webpackEmptyContext;

/***/ }),
/* 747 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http2 = __webpack_require__(748);
const agent = __webpack_require__(749);
const ClientRequest = __webpack_require__(751);
const IncomingMessage = __webpack_require__(752);
const auto = __webpack_require__(757);

const request = (url, options, callback) => {
	return new ClientRequest(url, options, callback);
};

const get = (url, options, callback) => {
	const req = new ClientRequest(url, options, callback);
	req.end();

	return req;
};

module.exports = {
	...http2,
	ClientRequest,
	IncomingMessage,
	...agent,
	request,
	get,
	auto
};


/***/ }),
/* 748 */
/***/ ((module) => {

"use strict";
module.exports = require("http2");

/***/ }),
/* 749 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const EventEmitter = __webpack_require__(170);
const tls = __webpack_require__(279);
const http2 = __webpack_require__(748);
const QuickLRU = __webpack_require__(750);

const kCurrentStreamsCount = Symbol('currentStreamsCount');
const kRequest = Symbol('request');
const kOriginSet = Symbol('cachedOriginSet');

const nameKeys = [
	// `http2.connect()` options
	'maxDeflateDynamicTableSize',
	'maxSessionMemory',
	'maxHeaderListPairs',
	'maxOutstandingPings',
	'maxReservedRemoteStreams',
	'maxSendHeaderBlockLength',
	'paddingStrategy',

	// `tls.connect()` options
	'localAddress',
	'path',
	'rejectUnauthorized',
	'minDHSize',

	// `tls.createSecureContext()` options
	'ca',
	'cert',
	'clientCertEngine',
	'ciphers',
	'key',
	'pfx',
	'servername',
	'minVersion',
	'maxVersion',
	'secureProtocol',
	'crl',
	'honorCipherOrder',
	'ecdhCurve',
	'dhparam',
	'secureOptions',
	'sessionIdContext'
];

const removeSession = (where, name, session) => {
	if (name in where) {
		const index = where[name].indexOf(session);

		if (index !== -1) {
			where[name].splice(index, 1);

			if (where[name].length === 0) {
				delete where[name];
			}

			return true;
		}
	}

	return false;
};

const addSession = (where, name, session) => {
	if (name in where) {
		where[name].push(session);
	} else {
		where[name] = [session];
	}
};

const getSessions = (where, name, normalizedOrigin) => {
	if (!(name in where)) {
		return [];
	}

	return where[name].filter(session => {
		return !session.closed && !session.destroyed && session[kOriginSet].includes(normalizedOrigin);
	});
};

// See https://tools.ietf.org/html/rfc8336
const closeCoveredSessions = (where, name, session) => {
	if (!(name in where)) {
		return;
	}

	// Clients SHOULD NOT emit new requests on any connection whose Origin
	// Set is a proper subset of another connection's Origin Set, and they
	// SHOULD close it once all outstanding requests are satisfied.
	for (const coveredSession of where[name]) {
		if (
			// The set is a proper subset when its length is less than the other set.
			coveredSession[kOriginSet].length < session[kOriginSet].length &&

			// And the other set includes all elements of the subset.
			coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&

			// Makes sure that the session can handle all requests from the covered session.
			// TODO: can the session become uncovered when a stream is closed after checking this condition?
			coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
		) {
			// This allows pending requests to finish and prevents making new requests.
			coveredSession.close();
		}
	}
};

// This is basically inverted `closeCoveredSessions(...)`.
const closeSessionIfCovered = (where, name, coveredSession) => {
	if (!(name in where)) {
		return;
	}

	for (const session of where[name]) {
		if (
			coveredSession[kOriginSet].length < session[kOriginSet].length &&
			coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&
			coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
		) {
			coveredSession.close();
		}
	}
};

class Agent extends EventEmitter {
	constructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 1, maxCachedTlsSessions = 100} = {}) {
		super();

		// A session is considered busy when its current streams count
		// is equal to or greater than the `maxConcurrentStreams` value.
		this.busySessions = {};

		// A session is considered free when its current streams count
		// is less than the `maxConcurrentStreams` value.
		this.freeSessions = {};

		// The queue for creating new sessions. It looks like this:
		// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION
		//
		// The entry function has `listeners`, `completed` and `destroyed` properties.
		// `listeners` is an array of objects containing `resolve` and `reject` functions.
		// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.
		// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.
		this.queue = {};

		// Each session will use this timeout value.
		this.timeout = timeout;

		// Max sessions per origin.
		this.maxSessions = maxSessions;

		// Max free sessions per origin.
		// TODO: decreasing `maxFreeSessions` should close some sessions
		// TODO: should `maxFreeSessions` be related only to sessions with 0 pending streams?
		this.maxFreeSessions = maxFreeSessions;

		// We don't support push streams by default.
		this.settings = {
			enablePush: false
		};

		// Reusing TLS sessions increases performance.
		this.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});
	}

	static normalizeOrigin(url, servername) {
		if (typeof url === 'string') {
			url = new URL(url);
		}

		if (servername && url.hostname !== servername) {
			url.hostname = servername;
		}

		return url.origin;
	}

	normalizeOptions(options) {
		let normalized = '';

		if (options) {
			for (const key of nameKeys) {
				if (options[key]) {
					normalized += `:${options[key]}`;
				}
			}
		}

		return normalized;
	}

	_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
		if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
			return;
		}

		// We need the busy sessions length to check if a session can be created.
		const busyLength = getSessions(this.busySessions, normalizedOptions, normalizedOrigin).length;
		const item = this.queue[normalizedOptions][normalizedOrigin];

		// The entry function can be run only once.
		if (busyLength < this.maxSessions && !item.completed) {
			item.completed = true;

			item();
		}
	}

	_closeCoveredSessions(normalizedOptions, session) {
		closeCoveredSessions(this.freeSessions, normalizedOptions, session);
		closeCoveredSessions(this.busySessions, normalizedOptions, session);
	}

	getSession(origin, options, listeners) {
		return new Promise((resolve, reject) => {
			if (Array.isArray(listeners)) {
				listeners = [...listeners];

				// Resolve the current promise ASAP, we're just moving the listeners.
				// They will be executed at a different time.
				resolve();
			} else {
				listeners = [{resolve, reject}];
			}

			const normalizedOptions = this.normalizeOptions(options);
			const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);

			if (normalizedOrigin === undefined) {
				for (const {reject} of listeners) {
					reject(new TypeError('The `origin` argument needs to be a string or an URL object'));
				}

				return;
			}

			if (normalizedOptions in this.freeSessions) {
				// Look for all available free sessions.
				const freeSessions = getSessions(this.freeSessions, normalizedOptions, normalizedOrigin);

				if (freeSessions.length !== 0) {
					// Use session which has the biggest stream capacity in order to use the smallest number of sessions possible.
					const session = freeSessions.reduce((previousSession, nextSession) => {
						if (
							nextSession.remoteSettings.maxConcurrentStreams >= previousSession.remoteSettings.maxConcurrentStreams &&
							nextSession[kCurrentStreamsCount] > previousSession[kCurrentStreamsCount]
						) {
							return nextSession;
						}

						return previousSession;
					});

					for (const {resolve} of listeners) {
						// TODO: The session can get busy here
						resolve(session);
					}

					return;
				}
			}

			if (normalizedOptions in this.queue) {
				if (normalizedOrigin in this.queue[normalizedOptions]) {
					// There's already an item in the queue, just attach ourselves to it.
					this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);

					return;
				}
			} else {
				this.queue[normalizedOptions] = {};
			}

			// The entry must be removed from the queue IMMEDIATELY when:
			// 1. the session connects successfully,
			// 2. an error occurs.
			const removeFromQueue = () => {
				// Our entry can be replaced. We cannot remove the new one.
				if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
					delete this.queue[normalizedOptions][normalizedOrigin];

					if (Object.keys(this.queue[normalizedOptions]).length === 0) {
						delete this.queue[normalizedOptions];
					}
				}
			};

			// The main logic is here
			const entry = () => {
				const name = `${normalizedOrigin}:${normalizedOptions}`;
				let receivedSettings = false;
				let servername;

				try {
					const tlsSessionCache = this.tlsSessionCache.get(name);

					const session = http2.connect(origin, {
						createConnection: this.createConnection,
						settings: this.settings,
						session: tlsSessionCache ? tlsSessionCache.session : undefined,
						...options
					});
					session[kCurrentStreamsCount] = 0;

					// Tries to free the session.
					const freeSession = () => {
						// Fetch the smallest amount of free sessions of any origin we have.
						const freeSessionsCount = session[kOriginSet].reduce((accumulator, origin) => {
							return Math.min(accumulator, getSessions(this.freeSessions, normalizedOptions, origin).length);
						}, Infinity);

						// Check the limit.
						if (freeSessionsCount < this.maxFreeSessions) {
							addSession(this.freeSessions, normalizedOptions, session);

							return true;
						}

						return false;
					};

					const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;

					session.socket.once('session', tlsSession => {
						// We need to cache the servername due to a bug in OpenSSL.
						setImmediate(() => {
							this.tlsSessionCache.set(name, {
								session: tlsSession,
								servername
							});
						});
					});

					// OpenSSL bug workaround.
					// See https://github.com/nodejs/node/issues/28985
					session.socket.once('secureConnect', () => {
						servername = session.socket.servername;

						if (servername === false && typeof tlsSessionCache !== 'undefined' && typeof tlsSessionCache.servername !== 'undefined') {
							session.socket.servername = tlsSessionCache.servername;
						}
					});

					session.once('error', error => {
						// `receivedSettings` is true when the session has successfully connected.
						if (!receivedSettings) {
							for (const {reject} of listeners) {
								reject(error);
							}
						}

						// The connection got broken, purge the cache.
						this.tlsSessionCache.delete(name);
					});

					session.setTimeout(this.timeout, () => {
						// Terminates all streams owned by this session.
						session.destroy();
					});

					session.once('close', () => {
						if (!receivedSettings) {
							// Broken connection
							const error = new Error('Session closed without receiving a SETTINGS frame');

							for (const {reject} of listeners) {
								reject(error);
							}
						}

						removeFromQueue();

						// This cannot be moved to the stream logic,
						// because there may be a session that hadn't made a single request.
						removeSession(this.freeSessions, normalizedOptions, session);

						// There may be another session awaiting.
						this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
					});

					// Iterates over the queue and processes listeners.
					const processListeners = () => {
						if (!(normalizedOptions in this.queue)) {
							return;
						}

						for (const origin of session[kOriginSet]) {
							if (origin in this.queue[normalizedOptions]) {
								const {listeners} = this.queue[normalizedOptions][origin];

								// Prevents session overloading.
								while (listeners.length !== 0 && isFree()) {
									// We assume `resolve(...)` calls `request(...)` *directly*,
									// otherwise the session will get overloaded.
									listeners.shift().resolve(session);
								}

								if (this.queue[normalizedOptions][origin].listeners.length === 0) {
									delete this.queue[normalizedOptions][origin];

									if (Object.keys(this.queue[normalizedOptions]).length === 0) {
										delete this.queue[normalizedOptions];
										break;
									}
								}

								// We're no longer free, no point in continuing.
								if (!isFree()) {
									break;
								}
							}
						}
					};

					// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.
					session.once('origin', () => {
						session[kOriginSet] = session.originSet;

						if (!isFree()) {
							// The session is full.
							return;
						}

						// Close covered sessions (if possible).
						this._closeCoveredSessions(normalizedOptions, session);

						processListeners();

						// `session.remoteSettings.maxConcurrentStreams` might get increased
						session.on('remoteSettings', () => {
							this._closeCoveredSessions(normalizedOptions, session);
						});
					});

					session.once('remoteSettings', () => {
						// The Agent could have been destroyed already.
						if (entry.destroyed) {
							const error = new Error('Agent has been destroyed');

							for (const listener of listeners) {
								listener.reject(error);
							}

							session.destroy();
							return;
						}

						session[kOriginSet] = session.originSet;
						this.emit('session', session);

						if (freeSession()) {
							// Process listeners, we're free.
							processListeners();
						} else if (this.maxFreeSessions === 0) {
							processListeners();

							// We're closing ASAP, when all possible requests have been made for this event loop tick.
							setImmediate(() => {
								session.close();
							});
						} else {
							// Too late, another free session took these listeners.
							session.close();
						}

						removeFromQueue();

						// Check if we haven't managed to execute all listeners.
						if (listeners.length !== 0) {
							// Request for a new session with predefined listeners.
							this.getSession(normalizedOrigin, options, listeners);
							listeners.length = 0;
						}

						receivedSettings = true;

						// `session.remoteSettings.maxConcurrentStreams` might get increased
						session.on('remoteSettings', () => {
							// Check if we're eligible to become a free session
							if (isFree() && removeSession(this.busySessions, normalizedOptions, session)) {
								// Check for free seats
								if (freeSession()) {
									processListeners();
								} else {
									// Assume it's still a busy session
									addSession(this.busySessions, normalizedOptions, session);
								}
							}
						});
					});

					// Shim `session.request()` in order to catch all streams
					session[kRequest] = session.request;
					session.request = headers => {
						const stream = session[kRequest](headers, {
							endStream: false
						});

						// The process won't exit until the session is closed.
						session.ref();

						++session[kCurrentStreamsCount];

						// Check if we became busy
						if (!isFree() && removeSession(this.freeSessions, normalizedOptions, session)) {
							addSession(this.busySessions, normalizedOptions, session);
						}

						stream.once('close', () => {
							--session[kCurrentStreamsCount];

							if (isFree()) {
								if (session[kCurrentStreamsCount] === 0) {
									// All requests are finished, the process may exit now.
									session.unref();
								}

								// Check if we are no longer busy and the session is not broken.
								if (removeSession(this.busySessions, normalizedOptions, session) && !session.destroyed && !session.closed) {
									// Check the sessions count of this authority and compare it to `maxSessionsCount`.
									if (freeSession()) {
										this._closeCoveredSessions(normalizedOptions, session);
										processListeners();
									} else {
										session.close();
									}
								}
							}

							if (!session.destroyed && !session.closed) {
								closeSessionIfCovered(this.freeSessions, normalizedOptions, session);
							}
						});

						return stream;
					};
				} catch (error) {
					for (const listener of listeners) {
						listener.reject(error);
					}

					removeFromQueue();
				}
			};

			entry.listeners = listeners;
			entry.completed = false;
			entry.destroyed = false;

			this.queue[normalizedOptions][normalizedOrigin] = entry;
			this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
		});
	}

	request(origin, options, headers) {
		return new Promise((resolve, reject) => {
			this.getSession(origin, options, [{
				reject,
				resolve: session => {
					resolve(session.request(headers));
				}
			}]);
		});
	}

	createConnection(origin, options) {
		return Agent.connect(origin, options);
	}

	static connect(origin, options) {
		options.ALPNProtocols = ['h2'];

		const port = origin.port || 443;
		const host = origin.hostname || origin.host;

		if (typeof options.servername === 'undefined') {
			options.servername = host;
		}

		return tls.connect(port, host, options);
	}

	closeFreeSessions() {
		for (const freeSessions of Object.values(this.freeSessions)) {
			for (const session of freeSessions) {
				if (session[kCurrentStreamsCount] === 0) {
					session.close();
				}
			}
		}
	}

	destroy(reason) {
		for (const busySessions of Object.values(this.busySessions)) {
			for (const session of busySessions) {
				session.destroy(reason);
			}
		}

		for (const freeSessions of Object.values(this.freeSessions)) {
			for (const session of freeSessions) {
				session.destroy(reason);
			}
		}

		for (const entriesOfAuthority of Object.values(this.queue)) {
			for (const entry of Object.values(entriesOfAuthority)) {
				entry.destroyed = true;
			}
		}

		// New requests should NOT attach to destroyed sessions
		this.queue = {};
	}
}

module.exports = {
	Agent,
	globalAgent: new Agent()
};


/***/ }),
/* 750 */
/***/ ((module) => {

"use strict";


class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.onEviction = options.onEviction;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;

			if (typeof this.onEviction === 'function') {
				for (const [key, value] of this.oldCache.entries()) {
					this.onEviction(key, value);
				}
			}

			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return Math.min(this._size + oldCacheSize, this.maxSize);
	}
}

module.exports = QuickLRU;


/***/ }),
/* 751 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http2 = __webpack_require__(748);
const {Writable} = __webpack_require__(110);
const {Agent, globalAgent} = __webpack_require__(749);
const IncomingMessage = __webpack_require__(752);
const urlToOptions = __webpack_require__(753);
const proxyEvents = __webpack_require__(754);
const isRequestPseudoHeader = __webpack_require__(755);
const {
	ERR_INVALID_ARG_TYPE,
	ERR_INVALID_PROTOCOL,
	ERR_HTTP_HEADERS_SENT,
	ERR_INVALID_HTTP_TOKEN,
	ERR_HTTP_INVALID_HEADER_VALUE,
	ERR_INVALID_CHAR
} = __webpack_require__(756);

const {
	HTTP2_HEADER_STATUS,
	HTTP2_HEADER_METHOD,
	HTTP2_HEADER_PATH,
	HTTP2_METHOD_CONNECT
} = http2.constants;

const kHeaders = Symbol('headers');
const kOrigin = Symbol('origin');
const kSession = Symbol('session');
const kOptions = Symbol('options');
const kFlushedHeaders = Symbol('flushedHeaders');
const kJobs = Symbol('jobs');

const isValidHttpToken = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
const isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;

class ClientRequest extends Writable {
	constructor(input, options, callback) {
		super({
			autoDestroy: false
		});

		const hasInput = typeof input === 'string' || input instanceof URL;
		if (hasInput) {
			input = urlToOptions(input instanceof URL ? input : new URL(input));
		}

		if (typeof options === 'function' || options === undefined) {
			// (options, callback)
			callback = options;
			options = hasInput ? input : {...input};
		} else {
			// (input, options, callback)
			options = {...input, ...options};
		}

		if (options.h2session) {
			this[kSession] = options.h2session;
		} else if (options.agent === false) {
			this.agent = new Agent({maxFreeSessions: 0});
		} else if (typeof options.agent === 'undefined' || options.agent === null) {
			if (typeof options.createConnection === 'function') {
				// This is a workaround - we don't have to create the session on our own.
				this.agent = new Agent({maxFreeSessions: 0});
				this.agent.createConnection = options.createConnection;
			} else {
				this.agent = globalAgent;
			}
		} else if (typeof options.agent.request === 'function') {
			this.agent = options.agent;
		} else {
			throw new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);
		}

		if (!options.port) {
			options.port = options.defaultPort || (this.agent && this.agent.defaultPort) || 443;
		}

		options.host = options.hostname || options.host || 'localhost';

		if (options.protocol && options.protocol !== 'https:') {
			throw new ERR_INVALID_PROTOCOL(options.protocol, 'https:');
		}

		const {timeout} = options;
		options.timeout = undefined;

		this[kHeaders] = Object.create(null);
		this[kJobs] = [];

		this.socket = null;
		this.connection = null;

		this.method = options.method;
		this.path = options.path;

		this.res = null;
		this.aborted = false;
		this.reusedSocket = false;

		if (options.headers) {
			for (const [header, value] of Object.entries(options.headers)) {
				this.setHeader(header, value);
			}
		}

		if (options.auth && !('authorization' in this[kHeaders])) {
			this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');
		}

		options.session = options.tlsSession;
		options.path = options.socketPath;

		this[kOptions] = options;

		// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.
		// What about IPv6? Square brackets?
		if (options.port === 443) {
			options.origin = `https://${options.host}`;

			if (!(':authority' in this[kHeaders])) {
				this[kHeaders][':authority'] = options.host;
			}
		} else {
			options.origin = `https://${options.host}:${options.port}`;

			if (!(':authority' in this[kHeaders])) {
				this[kHeaders][':authority'] = `${options.host}:${options.port}`;
			}
		}

		this[kOrigin] = options;

		if (timeout) {
			this.setTimeout(timeout);
		}

		if (callback) {
			this.once('response', callback);
		}

		this[kFlushedHeaders] = false;
	}

	get method() {
		return this[kHeaders][HTTP2_HEADER_METHOD];
	}

	set method(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
		}
	}

	get path() {
		return this[kHeaders][HTTP2_HEADER_PATH];
	}

	set path(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_PATH] = value;
		}
	}

	_write(chunk, encoding, callback) {
		this.flushHeaders();

		const callWrite = () => this._request.write(chunk, encoding, callback);
		if (this._request) {
			callWrite();
		} else {
			this[kJobs].push(callWrite);
		}
	}

	_final(callback) {
		if (this.destroyed) {
			return;
		}

		this.flushHeaders();

		const callEnd = () => this._request.end(callback);
		if (this._request) {
			callEnd();
		} else {
			this[kJobs].push(callEnd);
		}
	}

	abort() {
		if (this.res && this.res.complete) {
			return;
		}

		if (!this.aborted) {
			process.nextTick(() => this.emit('abort'));
		}

		this.aborted = true;

		this.destroy();
	}

	_destroy(error, callback) {
		if (this.res) {
			this.res._dump();
		}

		if (this._request) {
			this._request.destroy();
		}

		callback(error);
	}

	async flushHeaders() {
		if (this[kFlushedHeaders] || this.destroyed) {
			return;
		}

		this[kFlushedHeaders] = true;

		const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;

		// The real magic is here
		const onStream = stream => {
			this._request = stream;

			if (this.destroyed) {
				stream.destroy();
				return;
			}

			// Forwards `timeout`, `continue`, `close` and `error` events to this instance.
			if (!isConnectMethod) {
				proxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);
			}

			// This event tells we are ready to listen for the data.
			stream.once('response', (headers, flags, rawHeaders) => {
				// If we were to emit raw request stream, it would be as fast as the native approach.
				// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).
				const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);
				this.res = response;

				response.req = this;
				response.statusCode = headers[HTTP2_HEADER_STATUS];
				response.headers = headers;
				response.rawHeaders = rawHeaders;

				response.once('end', () => {
					if (this.aborted) {
						response.aborted = true;
						response.emit('aborted');
					} else {
						response.complete = true;

						// Has no effect, just be consistent with the Node.js behavior
						response.socket = null;
						response.connection = null;
					}
				});

				if (isConnectMethod) {
					response.upgrade = true;

					// The HTTP1 API says the socket is detached here,
					// but we can't do that so we pass the original HTTP2 request.
					if (this.emit('connect', response, stream, Buffer.alloc(0))) {
						this.emit('close');
					} else {
						// No listeners attached, destroy the original request.
						stream.destroy();
					}
				} else {
					// Forwards data
					stream.on('data', chunk => {
						if (!response._dumped && !response.push(chunk)) {
							stream.pause();
						}
					});

					stream.once('end', () => {
						response.push(null);
					});

					if (!this.emit('response', response)) {
						// No listeners attached, dump the response.
						response._dump();
					}
				}
			});

			// Emits `information` event
			stream.once('headers', headers => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]}));

			stream.once('trailers', (trailers, flags, rawTrailers) => {
				const {res} = this;

				// Assigns trailers to the response object.
				res.trailers = trailers;
				res.rawTrailers = rawTrailers;
			});

			const {socket} = stream.session;
			this.socket = socket;
			this.connection = socket;

			for (const job of this[kJobs]) {
				job();
			}

			this.emit('socket', this.socket);
		};

		// Makes a HTTP2 request
		if (this[kSession]) {
			try {
				onStream(this[kSession].request(this[kHeaders], {
					endStream: false
				}));
			} catch (error) {
				this.emit('error', error);
			}
		} else {
			this.reusedSocket = true;

			try {
				onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
			} catch (error) {
				this.emit('error', error);
			}
		}
	}

	getHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		return this[kHeaders][name.toLowerCase()];
	}

	get headersSent() {
		return this[kFlushedHeaders];
	}

	removeHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('remove');
		}

		delete this[kHeaders][name.toLowerCase()];
	}

	setHeader(name, value) {
		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('set');
		}

		if (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {
			throw new ERR_INVALID_HTTP_TOKEN('Header name', name);
		}

		if (typeof value === 'undefined') {
			throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
		}

		if (isInvalidHeaderValue.test(value)) {
			throw new ERR_INVALID_CHAR('header content', name);
		}

		this[kHeaders][name.toLowerCase()] = value;
	}

	setNoDelay() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setSocketKeepAlive() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setTimeout(ms, callback) {
		const applyTimeout = () => this._request.setTimeout(ms, callback);

		if (this._request) {
			applyTimeout();
		} else {
			this[kJobs].push(applyTimeout);
		}

		return this;
	}

	get maxHeadersCount() {
		if (!this.destroyed && this._request) {
			return this._request.session.localSettings.maxHeaderListSize;
		}

		return undefined;
	}

	set maxHeadersCount(_value) {
		// Updating HTTP2 settings would affect all requests, do nothing.
	}
}

module.exports = ClientRequest;


/***/ }),
/* 752 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {Readable} = __webpack_require__(110);

class IncomingMessage extends Readable {
	constructor(socket, highWaterMark) {
		super({
			highWaterMark,
			autoDestroy: false
		});

		this.statusCode = null;
		this.statusMessage = '';
		this.httpVersion = '2.0';
		this.httpVersionMajor = 2;
		this.httpVersionMinor = 0;
		this.headers = {};
		this.trailers = {};
		this.req = null;

		this.aborted = false;
		this.complete = false;
		this.upgrade = null;

		this.rawHeaders = [];
		this.rawTrailers = [];

		this.socket = socket;
		this.connection = socket;

		this._dumped = false;
	}

	_destroy(error) {
		this.req._request.destroy(error);
	}

	setTimeout(ms, callback) {
		this.req.setTimeout(ms, callback);
		return this;
	}

	_dump() {
		if (!this._dumped) {
			this._dumped = true;

			this.removeAllListeners('data');
			this.resume();
		}
	}

	_read() {
		if (this.req) {
			this.req._request.resume();
		}
	}
}

module.exports = IncomingMessage;


/***/ }),
/* 753 */
/***/ ((module) => {

"use strict";

/* istanbul ignore file: https://github.com/nodejs/node/blob/a91293d4d9ab403046ab5eb022332e4e3d249bd3/lib/internal/url.js#L1257 */

module.exports = url => {
	const options = {
		protocol: url.protocol,
		hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
		host: url.host,
		hash: url.hash,
		search: url.search,
		pathname: url.pathname,
		href: url.href,
		path: `${url.pathname || ''}${url.search || ''}`
	};

	if (typeof url.port === 'string' && url.port.length !== 0) {
		options.port = Number(url.port);
	}

	if (url.username || url.password) {
		options.auth = `${url.username || ''}:${url.password || ''}`;
	}

	return options;
};


/***/ }),
/* 754 */
/***/ ((module) => {

"use strict";


module.exports = (from, to, events) => {
	for (const event of events) {
		from.on(event, (...args) => to.emit(event, ...args));
	}
};


/***/ }),
/* 755 */
/***/ ((module) => {

"use strict";


module.exports = header => {
	switch (header) {
		case ':method':
		case ':scheme':
		case ':authority':
		case ':path':
			return true;
		default:
			return false;
	}
};


/***/ }),
/* 756 */
/***/ ((module) => {

"use strict";

/* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */

const makeError = (Base, key, getMessage) => {
	module.exports[key] = class NodeError extends Base {
		constructor(...args) {
			super(typeof getMessage === 'string' ? getMessage : getMessage(args));
			this.name = `${super.name} [${key}]`;
			this.code = key;
		}
	};
};

makeError(TypeError, 'ERR_INVALID_ARG_TYPE', args => {
	const type = args[0].includes('.') ? 'property' : 'argument';

	let valid = args[1];
	const isManyTypes = Array.isArray(valid);

	if (isManyTypes) {
		valid = `${valid.slice(0, -1).join(', ')} or ${valid.slice(-1)}`;
	}

	return `The "${args[0]}" ${type} must be ${isManyTypes ? 'one of' : 'of'} type ${valid}. Received ${typeof args[2]}`;
});

makeError(TypeError, 'ERR_INVALID_PROTOCOL', args => {
	return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
});

makeError(Error, 'ERR_HTTP_HEADERS_SENT', args => {
	return `Cannot ${args[0]} headers after they are sent to the client`;
});

makeError(TypeError, 'ERR_INVALID_HTTP_TOKEN', args => {
	return `${args[0]} must be a valid HTTP token [${args[1]}]`;
});

makeError(TypeError, 'ERR_HTTP_INVALID_HEADER_VALUE', args => {
	return `Invalid value "${args[0]} for header "${args[1]}"`;
});

makeError(TypeError, 'ERR_INVALID_CHAR', args => {
	return `Invalid character in ${args[0]} [${args[1]}]`;
});


/***/ }),
/* 757 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const http = __webpack_require__(275);
const https = __webpack_require__(274);
const resolveALPN = __webpack_require__(758);
const QuickLRU = __webpack_require__(750);
const Http2ClientRequest = __webpack_require__(751);
const calculateServerName = __webpack_require__(759);
const urlToOptions = __webpack_require__(753);

const cache = new QuickLRU({maxSize: 100});
const queue = new Map();

const installSocket = (agent, socket, options) => {
	socket._httpMessage = {shouldKeepAlive: true};

	const onFree = () => {
		agent.emit('free', socket, options);
	};

	socket.on('free', onFree);

	const onClose = () => {
		agent.removeSocket(socket, options);
	};

	socket.on('close', onClose);

	const onRemove = () => {
		agent.removeSocket(socket, options);
		socket.off('close', onClose);
		socket.off('free', onFree);
		socket.off('agentRemove', onRemove);
	};

	socket.on('agentRemove', onRemove);

	agent.emit('free', socket, options);
};

const resolveProtocol = async options => {
	const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;

	if (!cache.has(name)) {
		if (queue.has(name)) {
			const result = await queue.get(name);
			return result.alpnProtocol;
		}

		const {path, agent} = options;
		options.path = options.socketPath;

		const resultPromise = resolveALPN(options);
		queue.set(name, resultPromise);

		try {
			const {socket, alpnProtocol} = await resultPromise;
			cache.set(name, alpnProtocol);

			options.path = path;

			if (alpnProtocol === 'h2') {
				// https://github.com/nodejs/node/issues/33343
				socket.destroy();
			} else {
				const {globalAgent} = https;
				const defaultCreateConnection = https.Agent.prototype.createConnection;

				if (agent) {
					if (agent.createConnection === defaultCreateConnection) {
						installSocket(agent, socket, options);
					} else {
						socket.destroy();
					}
				} else if (globalAgent.createConnection === defaultCreateConnection) {
					installSocket(globalAgent, socket, options);
				} else {
					socket.destroy();
				}
			}

			queue.delete(name);

			return alpnProtocol;
		} catch (error) {
			queue.delete(name);

			throw error;
		}
	}

	return cache.get(name);
};

module.exports = async (input, options, callback) => {
	if (typeof input === 'string' || input instanceof URL) {
		input = urlToOptions(new URL(input));
	}

	if (typeof options === 'function') {
		callback = options;
		options = undefined;
	}

	options = {
		ALPNProtocols: ['h2', 'http/1.1'],
		protocol: 'https:',
		...input,
		...options,
		resolveSocket: true
	};

	const isHttps = options.protocol === 'https:';
	const agents = options.agent;

	options.host = options.hostname || options.host || 'localhost';
	options.session = options.tlsSession;
	options.servername = options.servername || calculateServerName(options);
	options.port = options.port || (isHttps ? 443 : 80);
	options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;

	if (agents) {
		if (agents.addRequest) {
			throw new Error('The `options.agent` object can contain only `http`, `https` or `http2` properties');
		}

		options.agent = agents[isHttps ? 'https' : 'http'];
	}

	if (isHttps) {
		const protocol = await resolveProtocol(options);

		if (protocol === 'h2') {
			if (agents) {
				options.agent = agents.http2;
			}

			return new Http2ClientRequest(options, callback);
		}
	}

	return http.request(options, callback);
};

module.exports.protocolCache = cache;


/***/ }),
/* 758 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const tls = __webpack_require__(279);

module.exports = (options = {}) => new Promise((resolve, reject) => {
	const socket = tls.connect(options, () => {
		if (options.resolveSocket) {
			socket.off('error', reject);
			resolve({alpnProtocol: socket.alpnProtocol, socket});
		} else {
			socket.destroy();
			resolve({alpnProtocol: socket.alpnProtocol});
		}
	});

	socket.on('error', reject);
});


/***/ }),
/* 759 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const net = __webpack_require__(278);
/* istanbul ignore file: https://github.com/nodejs/node/blob/v13.0.1/lib/_http_agent.js */

module.exports = options => {
	let servername = options.host;
	const hostHeader = options.headers && options.headers.host;

	if (hostHeader) {
		if (hostHeader.startsWith('[')) {
			const index = hostHeader.indexOf(']');
			if (index === -1) {
				servername = hostHeader;
			} else {
				servername = hostHeader.slice(1, -1);
			}
		} else {
			servername = hostHeader.split(':', 1)[0];
		}
	}

	if (net.isIP(servername)) {
		return '';
	}

	return servername;
};


/***/ }),
/* 760 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs_1 = __webpack_require__(6);
const util_1 = __webpack_require__(115);
const is_1 = __webpack_require__(720);
const is_form_data_1 = __webpack_require__(761);
const statAsync = util_1.promisify(fs_1.stat);
exports.default = async (body, headers) => {
    if (headers && 'content-length' in headers) {
        return Number(headers['content-length']);
    }
    if (!body) {
        return 0;
    }
    if (is_1.default.string(body)) {
        return Buffer.byteLength(body);
    }
    if (is_1.default.buffer(body)) {
        return body.length;
    }
    if (is_form_data_1.default(body)) {
        return util_1.promisify(body.getLength.bind(body))();
    }
    if (body instanceof fs_1.ReadStream) {
        const { size } = await statAsync(body.path);
        return size;
    }
    return undefined;
};


/***/ }),
/* 761 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __webpack_require__(720);
exports.default = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);


/***/ }),
/* 762 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function default_1(from, to, events) {
    const fns = {};
    for (const event of events) {
        fns[event] = (...args) => {
            to.emit(event, ...args);
        };
        from.on(event, fns[event]);
    }
    return () => {
        for (const event of events) {
            from.off(event, fns[event]);
        }
    };
}
exports.default = default_1;


/***/ }),
/* 763 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const net = __webpack_require__(278);
const unhandle_1 = __webpack_require__(764);
const reentry = Symbol('reentry');
const noop = () => { };
class TimeoutError extends Error {
    constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
        this.name = 'TimeoutError';
        this.code = 'ETIMEDOUT';
    }
}
exports.TimeoutError = TimeoutError;
exports.default = (request, delays, options) => {
    if (reentry in request) {
        return noop;
    }
    request[reentry] = true;
    const cancelers = [];
    const { once, unhandleAll } = unhandle_1.default();
    const addTimeout = (delay, callback, event) => {
        var _a;
        const timeout = setTimeout(callback, delay, delay, event);
        (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);
        const cancel = () => {
            clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
    };
    const { host, hostname } = options;
    const timeoutHandler = (delay, event) => {
        request.destroy(new TimeoutError(delay, event));
    };
    const cancelTimeouts = () => {
        for (const cancel of cancelers) {
            cancel();
        }
        unhandleAll();
    };
    request.once('error', error => {
        cancelTimeouts();
        // Save original behavior
        /* istanbul ignore next */
        if (request.listenerCount('error') === 0) {
            throw error;
        }
    });
    request.once('close', cancelTimeouts);
    once(request, 'response', (response) => {
        once(response, 'end', cancelTimeouts);
    });
    if (typeof delays.request !== 'undefined') {
        addTimeout(delays.request, timeoutHandler, 'request');
    }
    if (typeof delays.socket !== 'undefined') {
        const socketTimeoutHandler = () => {
            timeoutHandler(delays.socket, 'socket');
        };
        request.setTimeout(delays.socket, socketTimeoutHandler);
        // `request.setTimeout(0)` causes a memory leak.
        // We can just remove the listener and forget about the timer - it's unreffed.
        // See https://github.com/sindresorhus/got/issues/690
        cancelers.push(() => {
            request.removeListener('timeout', socketTimeoutHandler);
        });
    }
    once(request, 'socket', (socket) => {
        var _a;
        const { socketPath } = request;
        /* istanbul ignore next: hard to test */
        if (socket.connecting) {
            const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);
            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {
                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
                once(socket, 'lookup', cancelTimeout);
            }
            if (typeof delays.connect !== 'undefined') {
                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');
                if (hasPath) {
                    once(socket, 'connect', timeConnect());
                }
                else {
                    once(socket, 'lookup', (error) => {
                        if (error === null) {
                            once(socket, 'connect', timeConnect());
                        }
                    });
                }
            }
            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {
                once(socket, 'connect', () => {
                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
                    once(socket, 'secureConnect', cancelTimeout);
                });
            }
        }
        if (typeof delays.send !== 'undefined') {
            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');
            /* istanbul ignore next: hard to test */
            if (socket.connecting) {
                once(socket, 'connect', () => {
                    once(request, 'upload-complete', timeRequest());
                });
            }
            else {
                once(request, 'upload-complete', timeRequest());
            }
        }
    });
    if (typeof delays.response !== 'undefined') {
        once(request, 'upload-complete', () => {
            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
            once(request, 'response', cancelTimeout);
        });
    }
    return cancelTimeouts;
};


/***/ }),
/* 764 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// When attaching listeners, it's very easy to forget about them.
// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.
exports.default = () => {
    const handlers = [];
    return {
        once(origin, event, fn) {
            origin.once(event, fn);
            handlers.push({ origin, event, fn });
        },
        unhandleAll() {
            for (const handler of handlers) {
                const { origin, event, fn } = handler;
                origin.removeListener(event, fn);
            }
            handlers.length = 0;
        }
    };
};


/***/ }),
/* 765 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __webpack_require__(720);
exports.default = (url) => {
    // Cast to URL
    url = url;
    const options = {
        protocol: url.protocol,
        hostname: is_1.default.string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ''}${url.search || ''}`
    };
    if (is_1.default.string(url.port) && url.port.length !== 0) {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${url.username || ''}:${url.password || ''}`;
    }
    return options;
};


/***/ }),
/* 766 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* istanbul ignore file: deprecated */
const url_1 = __webpack_require__(281);
const keys = [
    'protocol',
    'host',
    'hostname',
    'port',
    'pathname',
    'search'
];
exports.default = (origin, options) => {
    var _a, _b;
    if (options.path) {
        if (options.pathname) {
            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');
        }
        if (options.search) {
            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');
        }
        if (options.searchParams) {
            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');
        }
    }
    if (options.search && options.searchParams) {
        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');
    }
    if (!origin) {
        if (!options.protocol) {
            throw new TypeError('No URL protocol specified');
        }
        origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ''}`;
    }
    const url = new url_1.URL(origin);
    if (options.path) {
        const searchIndex = options.path.indexOf('?');
        if (searchIndex === -1) {
            options.pathname = options.path;
        }
        else {
            options.pathname = options.path.slice(0, searchIndex);
            options.search = options.path.slice(searchIndex + 1);
        }
        delete options.path;
    }
    for (const key of keys) {
        if (options[key]) {
            url[key] = options[key].toString();
        }
    }
    return url;
};


/***/ }),
/* 767 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class WeakableMap {
    constructor() {
        this.weakMap = new WeakMap();
        this.map = new Map();
    }
    set(key, value) {
        if (typeof key === 'object') {
            this.weakMap.set(key, value);
        }
        else {
            this.map.set(key, value);
        }
    }
    get(key) {
        if (typeof key === 'object') {
            return this.weakMap.get(key);
        }
        return this.map.get(key);
    }
    has(key) {
        if (typeof key === 'object') {
            return this.weakMap.has(key);
        }
        return this.map.has(key);
    }
}
exports.default = WeakableMap;


/***/ }),
/* 768 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __webpack_require__(720);
const types_1 = __webpack_require__(728);
const core_1 = __webpack_require__(729);
if (!core_1.knownHookEvents.includes('beforeRetry')) {
    core_1.knownHookEvents.push('beforeRetry', 'afterResponse');
}
exports.knownBodyTypes = ['json', 'buffer', 'text'];
// @ts-ignore The error is: Not all code paths return a value.
exports.parseBody = (response, responseType, encoding) => {
    const { rawBody } = response;
    try {
        if (responseType === 'text') {
            return rawBody.toString(encoding);
        }
        if (responseType === 'json') {
            return rawBody.length === 0 ? '' : JSON.parse(rawBody.toString());
        }
        if (responseType === 'buffer') {
            return Buffer.from(rawBody);
        }
        throw new types_1.ParseError({
            message: `Unknown body type '${responseType}'`,
            name: 'Error'
        }, response);
    }
    catch (error) {
        throw new types_1.ParseError(error, response);
    }
};
class PromisableRequest extends core_1.default {
    static normalizeArguments(url, nonNormalizedOptions, defaults) {
        const options = super.normalizeArguments(url, nonNormalizedOptions, defaults);
        if (is_1.default.null_(options.encoding)) {
            throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');
        }
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);
        // `options.retry`
        const { retry } = options;
        if (defaults) {
            options.retry = { ...defaults.retry };
        }
        else {
            options.retry = {
                calculateDelay: retryObject => retryObject.computedValue,
                limit: 0,
                methods: [],
                statusCodes: [],
                errorCodes: [],
                maxRetryAfter: undefined
            };
        }
        if (is_1.default.object(retry)) {
            options.retry = {
                ...options.retry,
                ...retry
            };
            options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];
            options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
            options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
        }
        else if (is_1.default.number(retry)) {
            options.retry.limit = retry;
        }
        if (is_1.default.undefined(options.retry.maxRetryAfter)) {
            options.retry.maxRetryAfter = Math.min(...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));
        }
        // `options.pagination`
        if (is_1.default.object(options.pagination)) {
            if (defaults) {
                options.pagination = {
                    ...defaults.pagination,
                    ...options.pagination
                };
            }
            const { pagination } = options;
            if (!is_1.default.function_(pagination.transform)) {
                throw new Error('`options.pagination.transform` must be implemented');
            }
            if (!is_1.default.function_(pagination.shouldContinue)) {
                throw new Error('`options.pagination.shouldContinue` must be implemented');
            }
            if (!is_1.default.function_(pagination.filter)) {
                throw new TypeError('`options.pagination.filter` must be implemented');
            }
            if (!is_1.default.function_(pagination.paginate)) {
                throw new Error('`options.pagination.paginate` must be implemented');
            }
        }
        // JSON mode
        if (options.responseType === 'json' && options.headers.accept === undefined) {
            options.headers.accept = 'application/json';
        }
        return options;
    }
    static mergeOptions(...sources) {
        let mergedOptions;
        for (const source of sources) {
            mergedOptions = PromisableRequest.normalizeArguments(undefined, source, mergedOptions);
        }
        return mergedOptions;
    }
    async _beforeError(error) {
        if (!(error instanceof core_1.RequestError)) {
            error = new core_1.RequestError(error.message, error, this);
        }
        // Let the promise decide whether to abort or not
        // It is also responsible for the `beforeError` hook
        this.emit('error', error);
    }
}
exports.default = PromisableRequest;


/***/ }),
/* 769 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __webpack_require__(728);
function createRejection(error, ...beforeErrorGroups) {
    const promise = (async () => {
        if (error instanceof types_1.RequestError) {
            try {
                for (const hooks of beforeErrorGroups) {
                    if (hooks) {
                        for (const hook of hooks) {
                            // eslint-disable-next-line no-await-in-loop
                            error = await hook(error);
                        }
                    }
                }
            }
            catch (error_) {
                error = error_;
            }
        }
        throw error;
    })();
    const returnPromise = () => promise;
    promise.json = returnPromise;
    promise.text = returnPromise;
    promise.buffer = returnPromise;
    promise.on = returnPromise;
    return promise;
}
exports.default = createRejection;


/***/ }),
/* 770 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __webpack_require__(720);
function deepFreeze(object) {
    for (const value of Object.values(object)) {
        if (is_1.default.plainObject(value) || is_1.default.array(value)) {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}
exports.default = deepFreeze;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			if(mode & 2 && typeof value == 'object' && value) {
/******/ 				for(const key in value) def[key] = () => value[key];
/******/ 			}
/******/ 			def['default'] = () => value;
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })()
;